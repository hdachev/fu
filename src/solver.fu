import helpers;
import parser;
import scope;
import context;
import types;


//

let OPTI_autoshadow         = true;

let USE_nontriv_autocopy    = true;
let USE_retval_narrowing    = false;
let USE_ref_to_mutref       = false;

let SELF_TEST               = true;



///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Solver.

pub fn solve(
    implicit ctx: Context,
    implicit ref module: Module,
    parse: Node): SolverOutput
{
    mut _here:          TokenIdx;
    mut _scope:         Scope;
    mut _root_scope:    ScopeMemo;

    mut _ss_items:      ScopeSkip[];
    mut _ss_imports:    ScopeSkip[];

    struct CurrentFn
    {
        using out:      SolvedNode;
        return_idx:     ScopeMemo; // <- truth from here
        parent_idx:     i32;
        locals_used?:   i32[];

        ret_expect?:    Type;
        ret_actual?:    Type;
        ret_count?:     i32;

        returns?:       Target[];
        tries?:         i32;
    };

    mut _current_fn:    CurrentFn;


    //

    mut SLOW_resolve:   i32;
    mut resolve_done:   i32;


    // TODO we shouldn't need this stuff
    //  under the new depth-first + immediately-repeat-on-dirty design.

    struct Mangles
    {
        mangle0: string;
        mangle00: string;
        args00: SolvedNode[];
        overloadIdx: Target;
        extra_items: ScopeItem[];
    };

    struct OpenTemplate
    {
        spec: Target;
        using mangles?: Mangles;
    };

    mut _open_templates: OpenTemplate[];
    mut _current_struct: Target;

    type TypeParams = Map(string, Type);


    //

    let t_string = createArray(t_byte);


    //

    fn _Scope_import__forceCopy(modid: i32): void
    {
        _scope.items ~= ctx.modules[modid].out.solve.scope.items;
    }

    fn Scope_import(modid: i32): void
    {
        mut found = false;
        _scope.imports.each(_ss_imports, |import|
        {
            if (import == modid)
            {
                found = true;
                // break;  // <- TODO
                // return; // <- actually
            }
        });

        if (found)
            return;

        modid || fail("Attempting to import modid-0.");
        _scope.imports ~= modid;
        _Scope_import__forceCopy(modid);
    }

    fn GET(target: Target): Overload
    {
        if (target.modid == module.modid)
            return _scope.overloads[target.index - 1];

        return ctx.modules[target.modid]
            .out.solve.scope.overloads[target.index - 1];
    }

    fn GET_mut(target: Target)
    {
        target.index > 0 && target.modid == MODID || assert();
        return _scope.overloads[target.index - 1];
    }

    fn GET_local(index: i32): Overload
    {
        return GET(Target(modid: module.modid, :index));
    }


    //

    fn fail(mut reason: string = ""): never
    {
        let here = _here._token;

        if (!reason)
            reason = "Unexpected `" ~ here.value ~ "`.";

        let fname = _here._fname;
        let l0 = here.line;
        let c0 = here.col;

        let addr = "@" ~ l0 ~ ":" ~ c0;

        return throw(fname ~ " " ~ addr ~ ":\n\t" ~ reason);
    }


    //

    fn Lifetime_DISABLE_BORROW_CHECKER(): Lifetime =
        Lifetime();

    fn Lifetime_FN_unorderedPrep(): Lifetime =
        Lifetime();

    fn Lifetime_fromNative(sig: [Node], args: [SolvedNode]): Lifetime
    {
        sig.len + FN_ARGS_BACK == args.len || fail("sig.len != args.len");

        let ret = sig[sig.len + FN_RET_BACK];
        mut mutref = ret.kind == "call" && ret.items.len == 1 && ret.value == "&mut";

        mut res: Lifetime;
        for (;;)
        {
            for (mut i = 0; i < args.len; i++)
            {
                let inArg = sig[i];
                let annot = inArg.items[LET_TYPE];
                if (annot.items.len == 1 && ((annot.kind == "call"
                    && (!mutref && annot.value == "&" || annot.value == "&mut"))
                     || !mutref && annot.kind == "arrlit"))
                {
                    res && fail("Ambiguous __native lifetime.");

                    let arg = args[i];
                    let o = GET(arg.target);
                    res = o.type.lifetime || fail("Missing arg lifetime.");
                }
            }

            // Try again without the mutref,
            //  currently we have a bunch of drama related to case-patterns,
            //   the mutref annots actually come in the branches, not the arg annots.
            if (!mutref || res.uni0n)
                break;

            mutref = false;
        }

        let only = res.uni0n.only;
        only < 0 || fail("Non-single-arg __native lifetime.");

        return res;
    }

    fn Lifetime_test(lifetime: Lifetime, current_fn: Target): Lifetime
    {
        if (SELF_TEST)
        {
            mut _last = 0x80000000.i32;

            let debug_2 = current_fn && GET(current_fn);
            if (debug_2) {}

            for (mut i = 0; i < lifetime.uni0n.len; i++)
            {
                let packed = lifetime.uni0n[i];
                {
                    packed > _last || fail("Lifetime_test: not a sorted set");
                    _last = packed;
                }

                if (packed >= 0)
                {
                    fn fnd(index: i32)
                        GET(Target(:module.modid, :index));

                    i == lifetime.uni0n.len - 1 || fail("Lifetime_test: local not last");

                    let local = packed && fnd(packed);
                    let local_of = local.local_of; // zero for globals
                    if (local_of)
                    {
                        mut frame = current_fn.index;
                        while (local_of != frame)
                        {
                            local_of <= frame || fail("Lifetime_test: `" ~ local.name ~ "` is not a local: `"
                                ~ fnd(local_of).name ~ "` does not contain "
                                ~ (frame    ? "`" ~ fnd(frame).name ~ "`"
                                            : "global scope")
                                ~ (current_fn.index != frame ? ", testing from `" ~ fnd(current_fn.index).name ~ "`." : "."));

                            frame || fail("Lifetime_test: climbed up to root");
                            frame = fnd(frame).local_of;
                        }
                    }
                }
            }
        }

        return lifetime;
    }

    fn Lifetime_fromBinding(target: Target, kind: string, type: Type): Lifetime
    {
        target.modid == module.modid || fail("not from this module");

        // Globals?
        if (kind == "global")
            return Lifetime_static();

        // Alias?
        if (kind == "ref")
            return Lifetime_test(
                type.is_ref && type.lifetime || fail("ref: bad ref/lifetime"),
                _current_fn.target);

        // Argument?
        let parametric  = kind == "arg" && type.is_ref;
        let index       = target.index;
        let packed      = parametric ? -1 - index : index;

        return Lifetime_test(
            Lifetime(uni0n: [ packed ]),
            _current_fn.target);
    }

    fn Lifetime_replaceArgsAtCallsite(overload: Overload, argNodes: [SolvedNode]): Lifetime
    {
        let returned    = overload.type.lifetime.uni0n;
        let items       = overload.solved.items;

        // Nothing to do if empty/non-arg.
        if !(returned.if_first < 0)
            return Lifetime(uni0n: returned);

        let head = items[0].target.index;
        let tail = items[items.len + FN_ARGS_BACK - 1].target.index;

        mut keep:       Lifetime;
        mut replace:    Lifetime;

        mut offset = items.len + FN_ARGS_BACK;

        for (mut i = 0; i < returned.len; i++)
        {
            let packed  = returned[i];
            let index   = -1 - packed;

            // We're only filtering here, no need to run the full thing.
            if (index < head || index > tail) {
                keep.uni0n ~= packed;
                continue;
            }

            // Full union here, otherwise we risk messing things up.
            while (offset--)
            {
                let here = items[offset].target.index;
                if (here == index)
                {
                    let argNode = argNodes[offset];

                    // Abort on first temporary.
                    // TODO FIX this is not correct - we cant skip over anything,
                    //  and temp lifetimes need to be extended.
                    if (!argNode.type.is_ref || argNode.type.is_ref2temp)
                        return Lifetime_temporary();

                    // This is fine.
                    let argLt   = argNode.type.lifetime || fail("refarg without lifetime");
                    replace     = Lifetime_union(replace, argLt);
                    break;
                }

                here > index || fail("nope, going backwards");
            }
        }

        return Lifetime_test(
            Lifetime_union(keep, replace),
            _current_fn.target);
    }

    fn Lifetime_killedByReturnOf(lifetime: Lifetime, target: Target)
    {
        // Any local will suffice.
        for (mut i = 0; i < lifetime.uni0n.len; i++)
        {
            let item = lifetime.uni0n[i];
            if (item >= target.index)
                return true;
        }

        return false;
    }


    //

    fn Binding(id: string, mut type: Type, mut flags!: i32, kind: string)
    {
        mut name = id;

        // Unique identifiers.
        if (_root_scope)
        {
            mut any     = 0;
            mut same    = 0;

            _scope.items.each(_ss_items, |item|
            {
                if (item.id == id)
                {
                    any++;
                    let o = GET(item.target);
                    if (o.kind == "arg" || o.kind == "ref" || o.kind == "var")
                        same++;
                }
            },
            start: _root_scope.items_len);

            if (same)
                name ~= "_" ~ same;

            // LEAKY TEMPLATES, part 1:
            //  All locals are F_SHADOW - this is a usability thing really,
            //   otherwise you'd simply have to `shadow` everything manually.
            //
            // Actually turning this on for everything -
            //  it might optimize scope lookups all over the place.
            //
            if (OPTI_autoshadow)
                if (kind != "global" && !any) // && _current_fn.flags & F_INLINE
                    flags |= F_SHADOW;
        }

        //
        let local_of = !(flags & F_FIELD) && _current_fn.target.index;
        if (local_of)
        {
            kind == "var" || kind == "arg" || kind == "ref" || fail("Nope, getting it wrong.");
            flags |= F_LOCAL;
        }

        // Reserve the slot.
        let target = Scope_create(_scope, :kind, :name, :flags, :local_of);
        Scope_set(_scope, :id, :target);

        // Setup the lifetime for references to this binding.
        ref overload = GET_mut(target);
        {
            let lifetime = Lifetime_fromBinding(target, kind, type);

            // Throw away argument lifetime, union below will fix it up.
            if (flags & F_ARG)
                type.lifetime = Lifetime_DISABLE_BORROW_CHECKER();

            overload.type = flags & F_MUT
                ? add_mutref(type, lifetime)
                : add_ref   (type, lifetime);
        }

        return target;
    }

    fn createTemplate(node: Node): Template
    {
        return Template(
            node,
            imports:   !_current_fn && _scope.imports,
            scope_memo: _current_fn && Scope_snap(_scope),
            ss_items:   _current_fn && _ss_items,
            ss_imports: _current_fn && _ss_imports);
    }

    fn TemplateDecl(node: Node, local_of: i32): Target
    {
        let id      = node.value;
        let items   = node.items;

        mut min     = 0;
        let max     = node.kind == "fn" ? items.len + FN_ARGS_BACK
                    : fail("TemplateDecl: non-fn node.");

        mut args: Argument[];
        for (mut i = 0; i < max; i++)
        {
            let arg = items[i];
            arg.kind == "let" || fail();
            let name = arg.value || fail();
            args.push(Argument(:name));

            if (!arg.items[LET_INIT])
                min++;
        }

        //
        let template = createTemplate(node);

        return Scope_add(
            _scope,
            kind: "template", :id, Type,
            :min, :max, :args, :template,
            :node.flags, :local_of);
    }

    fn FnDecl_init(target: Target, kind: string, id: string, template: Template)
    {
        ref overload = GET_mut(target);

        overload.name = id;
        overload.kind = kind;
        overload.template = template;

        Scope_set(_scope, :id, :target);
    }

    fn FnDecl_update(solved: SolvedNode, locals_used: i32[], ret_actual: Type)
    {
        let items = solved.items;

        mut min = 0;
        let max = items.len + FN_ARGS_BACK;
        mut args: Argument[];
        for (mut i = 0; i < max; i++)
        {
            let argNode = items[i];
            argNode.kind == "let" || fail();

            let isImplicit = !!(argNode.flags & F_IMPLICIT);
            let arg = Argument(
                type:       argNode.type  || fail(),
                name:       argNode.value || fail(),
                default:    !isImplicit && argNode.items[LET_INIT],
                flags:      argNode.flags);

            if (!arg.default && !isImplicit)
                min++;

            args.push(arg);
        }

        // Unconditionally replacing the stuff.
        ref overload    = GET_mut(solved.target);

        let retval0     = overload.type;
        let args_len0   = overload.args.len;
        let closure0    = overload.closes_over.len;

        overload.type   = ret_actual || fail("FnDecl_update: no return type.");
        overload.min    = min;
        overload.max    = max;
        overload.args   = args;
        overload.flags  = solved.flags;

        overload.solved = solved;

        // See which one of the locals we've used are not our own.
        {
            mut closes_over: i32[];

            for (mut i = 0; i < locals_used.len; i++)
            {
                let o = GET_local(locals_used[i]);
                if (o.local_of != solved.target.index)
                    closes_over ~= locals_used[i];
            }

            overload.closes_over = closes_over;
        }

        // Test.
        Lifetime_test(ret_actual.lifetime, solved.target);

        // TODO FIX starting the diff with just number of arguments,
        //  which is fine for implicit cycling,
        //   then we gotta move on to bigger and better things.
        if (args_len0 != overload.args.len          ||
            closure0  != overload.closes_over.len   ||
            !(retval0 == overload.type))
        {
            invalidateUsers(overload);
        }

        // We dont need this yet.
        // checkRecursions(overload, solved.target.index);
    }

    fn invalidateUsers(overload: Overload): void
    {
        let parent_idx = overload.local_of;
        for (mut i = 0; i < overload.used_by.len; i++)
            makeDirty(overload.used_by[i], :parent_idx, becauseOf: overload);
    }

    fn makeDirty(index: i32, parent_idx: i32, becauseOf!: Overload): void
    {
        index || fail(
            "makeDirty: climbed up to global scope.");

        let userIdx = Target(modid: module.modid, :index);

        ref user = GET_mut(userIdx);
        if !(user.status & SS_DIRTY)
        {
            let their_parent = user.local_of;
            index >= parent_idx || fail(
                "makeDirty: climbed too far up.");

            if (user.status & SS_FINALIZED)
            {
                if (their_parent)
                    return makeDirty(their_parent, :parent_idx, :becauseOf);

                fail("Overload finalized, cannot make dirty: `" ~ user.name ~ "`, because of `" ~ becauseOf.name ~ "`.");
            }

            user.status |= SS_DIRTY;
            SLOW_resolve++;
        }
    }

    fn tryCreateDefinit(type: Type): SolvedNode
    {
        // Cannot definit mutrefs.
        if (type.is_mutref)
            return SolvedNode();

        return createDefinit(type);
    }

    fn createDefinit(mut type: Type): SolvedNode
    {
        let token = _here || fail();

        if (type.is_ref)
            type.lifetime = Lifetime_static();

        if (type.quals & q_integral)
            return SolvedNode(
                kind: "int", :token, :type,
                value: "0");

        if (type.quals & q_floating_pt)
            return SolvedNode(
                kind: "real", :token, :type,
                value: "0");

        return SolvedNode(
            kind: "definit", :token, :type);
    }

    fn solveDefinit(type: Type): SolvedNode
    {
        if (!type)
            return fail(
                "Cannot solve definit, no inferred type.");

        return tryCreateDefinit(type)
            || fail("Cannot definit: " ~ serializeType(type));
    }

    fn solveTypeAssert(node: Node): SolvedNode
    {
        let left   = node.items[0];
        let right  = node.items[1];

        // left -> right.
        let expect = evalTypeAnnot(right).type;
        let actual = solveNode(left, expect);

        checkAssignable(host: expect, actual.type,
            "Type assertion failed");

        return actual;
    }


    //

    fn Partial(id: string, viaIdx: Target, overloadIdx: Target)
    {
        let via      = GET(viaIdx);
        let overload = GET(overloadIdx);

        mut kind = "p-unshift";
        mut min = overload.min - 1;
        mut max = overload.max - 1;
        min >= 0 && max >= min || fail();

        mut args = overload.args.slice(1);
        mut flags = 0;

        // Everything that's not a local/namespace/static/constant
        //  needs a value through which to activate.
        if (via.kind != "var" &&
            via.kind != "global" &&
            via.kind != "arg" &&
            via.kind != "ref")
        {
            kind = "p-wrap";
            min++;
            max++;

            flags |= F_PUB;

            mut arg = Argument(
                type: via.args[0].type,
                name: "using");

            args.unshift(arg);
        }

        return Scope_add(
            _scope,
            :kind, :id, :overload.type, :flags,
            :min, :max, :args,
            partial: Partial(viaIdx, overloadIdx));
    }


    // We need a smarter way of doing this.

    fn scope_using(viaIdx: Target)
    {
        let via     = GET(viaIdx);
        let actual  = via.type || fail();

        fn visit(item: ScopeItem)
        {
            // Skip over operators.
            if (!item.id.hasIdentifierChars)
                return;

            let overloadIdx = item.target;
            let overload = GET(overloadIdx);

            // Needs at least one argument,
            //  and does not support defaulted args.
            if (overload.min < 1 || overload.max != overload.min)
                return;

            // Skip over defctors -
            //  we really only want this for fields & properties,
            //   but there's no way to tell a property from a fn,
            //    this at least is easy to disambiguate.
            if (overload.kind == "type")
                return;

            // See if we fit.
            let expect = overload.args[0] || fail("scope_using: bad head arg.");
            if (!isAssignableAsArgument(expect.type, actual))
                return;

            //
            Partial(item.id, viaIdx, overloadIdx);
        }

        // Visit stuff currently in scope.
        _scope.items.each(_ss_items, fn visit);

        // Also bring in stuff from the module of origin.
        let extra_modid = actual.modid;
        if (!_scope.imports.has(extra_modid))
        {
            let items = ctx.modules[extra_modid].out.solve.scope.items;
            for (mut i = 0; i < items.len; i++)
                visit(items[i]);
        }

        // Struct members.
        if (actual.isStruct)
        {
            let items = lookupStruct(actual).items;
            for (mut i = 0; i < items.len; i++)
                visit(items[i]);
        }
    }


    //

    fn getNamedArgReorder(
        ref result: i32[],
        names: string[],
        host_args: Argument[]): bool
    {
        result.clear();

        //
        mut used   = 0;
        mut offset = 0;
        for (mut i = 0; i < host_args.len; i++)
        {
            mut idx = names.find(host_args[i].name);
            if (idx < 0)
            {
                for (shadow mut i = offset; i < names.len; i++)
                {
                    offset++;
                    if (!names[i])
                    {
                        idx = i;
                        break;
                    }
                }
            }
            else
            {
                used++;
            }

            result.push(idx);
        }

        // Fail if some name ended up unused.
        //  TODO FIX THIS MESS
        if (used != names.len)
        {
            for (mut i = 0; i < names.len; i++)
                if (!names[i])
                    used++;

            if (used != names.len)
                return false;
        }

        // Drop trailing misses.
        while (result && result[result.len - 1] < 0)
            result.pop();

        // Return nothing if not needed.
        for (mut i = 0; i < result.len; i++)
            if (result[i] != i)
                return true;

        result.clear();
        return true;
    }

    fn tryMatch__mutargs(
        scope: Scope, scope_skip: ScopeSkip[],
        mut id: string, ref args: SolvedNode[],
        flags?!: i32, retType?!: Type, target?!: Target): Target
    {
        mut matchIdx: Target;

        let arity = args.len;

        // Prep labelled args for remap.
        mut names: string[];
        if (flags & F_NAMED_ARGS)
        {
            mut some = false;

            for (mut i = 0; i < arity; i++)
            {
                let arg = args[i];
                names.push(arg.kind == "label"
                    ? { some = true; arg.value } || fail()
                    : "");
            }

            some || fail();
        }

        mut reorder: i32[];
        mut args_mangled: string;

        //
        let extra_modid = flags & F_ACCESS && args.if_first.type.modid;
        let extra_items = extra_modid
                        && !_scope.imports.has(extra_modid)
                        && ctx.modules[extra_modid].out.solve.scope.items;

        //
        let unary_arg_t = arity == 1 && args[0].type;
        let field_items = flags & F_ACCESS && unary_arg_t.isStruct && lookupStruct(unary_arg_t).items;

        //
        mut alternate_ids: string[];

        for (;;)
        {
            mut scope_iterator: i32;
            mut overloadIdx: Target;

            NEXT: while (overloadIdx =
                scope.items.search(id, scope_iterator,
                    :scope_skip, :target,
                    :extra_items, :field_items))
            {
                TEST_AGAIN: while (true)
                {
                    let overload = GET(overloadIdx);

                    ////////////////////////////////////////////
                    // Conversions / typename aliases.
                    let isType = overload.kind == "type";
                    let isZeroInit = isType && !arity;
                    if (arity && isType && !target)
                    {
                        let alt = overload.type.canon;
                        if (alt != id) // e.g. i32
                            alternate_ids.push(alt);
                    }
                    ////////////////////////////////////////////

                    //
                    if (overload.min > arity || overload.max < arity)
                        if (!isZeroInit)
                            continue :NEXT;

                    // Match by return.
                    if (retType && !isAssignable(retType, overload.type || fail()))
                        continue :NEXT;

                    // Match by argnames.
                    if (names && !getNamedArgReorder(reorder, names, overload.args))
                        continue :NEXT;

                    mut temp: string;
                    shadow ref args_mangled =
                        reorder ? temp : args_mangled;

                    // Specialize.
                    if (overload.kind == "template")
                    {
                        let specIdx = trySpecialize(
                            :overloadIdx, :args, :reorder,
                            :args_mangled ||= mangleArguments(args, reorder));

                        if (!specIdx)
                            continue :NEXT;

                        // Repeat arity checks and such.
                        overloadIdx = specIdx;
                        continue :TEST_AGAIN;
                    }

                    fn disambig()
                    {
                        if (matchIdx)
                        {
                            fn GETfn(idx: i32) GET(Target(modid: module.modid, index: idx));

                            fn fnName(idx: i32) idx
                                ? "`" ~ GETfn(idx).name ~ "`"
                                : "global scope";

                            let inner = GET(matchIdx)   .local_of;      // first to match is innermost scope
                            let outer = GET(overloadIdx).local_of;      // what we're currently looking is upscope
                            let callsite = _current_fn.target.index;    // as seen from where we currently are

                            if (SELF_TEST)
                            {
                                mut _c = callsite;
                                while (_c > inner) _c = GETfn(_c).local_of;
                                _c == inner || fail(
                                    "BUG! Leaking `" ~ id ~ "` between functions [inner/callsite]: "
                                        ~ inner.fnName ~ " is seen from " ~ callsite.fnName);

                                mut _i = inner;
                                while (_i > outer) _i = GETfn(_i).local_of;
                                _i == outer || fail(
                                    "BUG! Leaking `" ~ id ~ "` between functions [inner/outer]: "
                                        ~ inner.fnName ~ " and " ~ outer.fnName
                                        ~ " as seen from " ~ callsite.fnName);
                            }

                            fail("Ambiguous callsite, matches multiple items in scope: `" ~ id
                                ~ "` from " ~ inner.fnName ~ " and " ~ outer.fnName
                                ~ ", as seen from " ~ callsite.fnName ~ ".");
                        }
                    }

                    if (args)
                    {
                        // Type check args.
                        let host_args = overload.args;

                        let N = reorder ? reorder.len
                                        : args.len;

                        /////////////////
                        // Literal fixup.
                        let undo_literal_fixup = args;
                        //        /LITFIX
                        /////////////////

                        for (mut i = 0; i < N; i++)
                        {
                            let host_arg = host_args[i];

                            let callsiteIndex = reorder ? reorder[i]
                                                        : i;
                            if (callsiteIndex < 0)
                            {
                                // Argument may not be defaulted -
                                //  we might be supplying defaults via names
                                //   before we've actually exhausted
                                //    all the non-defaulted stuff.
                                if (!host_arg.default && !(host_arg.flags & F_IMPLICIT))
                                    continue :NEXT;

                                continue;
                            }

                            // Explicit argname requirements.
                            else if (host_arg.flags & F_MUSTNAME)
                            {
                                if (names.len <= callsiteIndex || !names[callsiteIndex])
                                    continue :NEXT;
                            }

                            let expect = host_arg.type;
                            let actual = args[callsiteIndex].type;

                            mut ok = isAssignableAsArgument(expect, actual);

                            /////////////////
                            // Literal fixup.
                            if (!ok && considerRetyping(expect, actual))
                            {
                                ref arg = args[callsiteIndex];
                                if (arg.kind == "label")
                                {
                                    // SEGV fix -
                                    //  how do we deal with this in general?
                                    //   might as well discontinue copy assignment
                                    //    in favor of cpy->mov.
                                    let inner = arg.items.only;
                                    arg = inner;
                                }

                                let retype  = tryRetyping(arg, expect);
                                    ok      = isAssignableAsArgument(expect, retype);

                                if (ok)
                                    arg.type = retype;
                            }
                            //        /LITFIX
                            /////////////////

                            if (!ok)
                            {
                                args = undo_literal_fixup;
                                continue :NEXT;
                            }
                        }

                        // Forbid ambiguity.
                        disambig();

                        // Do reorder.
                        if (reorder)
                        {
                            // TODO:
                            // I shouldn't need this pass, just swaps must do.
                            mut new_args: SolvedNode[];
                            new_args.resize(reorder.len);

                            for (mut i = 0; i < reorder.len; i++)
                            {
                                let idx = reorder[i];
                                if (idx >= 0)
                                    new_args[i] = args[idx];
                            }

                            args = new_args;
                        }
                    }

                    // Forbid ambiguity.
                    else
                    {
                        disambig();
                    }

                    // Done!
                    matchIdx = overloadIdx;

                    // Arity 0 auto-shadows.
                    if (overload.flags & F_SHADOW)
                        break :NEXT;

                    // Done here.
                    break :TEST_AGAIN;
                }
            }

            //////////////////////////////////
            // Conversions / typename aliases.
            if (!alternate_ids)
                break;

            id = alternate_ids.last;
            alternate_ids.pop();
            //////////////////////////////////
        }

        if (matchIdx)
        {
            let matched = GET(matchIdx);

            let isZeroInit = matched.kind == "type" && !arity;
            if (!isZeroInit)
            {
                // Mutate call args last thing.
                let host_args = matched.args;
                if (host_args.len > args.len)
                    args.resize(host_args.len);

                // Defaults & implicit argument injection.
                for (mut i = 0; i < args.len; i++)
                {
                    if (!args[i])
                    {
                        let host_arg = host_args[i];
                        args[i] = host_arg.default || bindImplicitArg(
                            :host_arg.name,
                            :host_arg.type,

                            becauseOf: matchIdx);
                    }
                }
            }
        }

        return matchIdx;
    }


    //

    fn considerRetyping(expect: Type, actual: Type): bool
    {
        return expect.quals & actual.quals & q_arithmetic != 0;
    }

    fn couldRetype(node: SolvedNode): bool
    {
        return node.kind == "int"
            || node.kind == "real";
    }

    fn tryRetyping(node: SolvedNode, expect: Type): Type
    {
        return node.kind == "int"  ? solveInt(node.value, expect)
             : node.kind == "real" ? solveNum(node.value, expect)
             : [];
    }


    //

    fn match__mutargs(
        scope: Scope, scope_skip: ScopeSkip[],
        id: string, ref args: SolvedNode[],
        flags: i32, target: Target): Target
    {
        let ret = tryMatch__mutargs(scope, scope_skip, :id, :args, :flags, :target);
        if (ret)
            return ret;

        let debug = tryMatch__mutargs(scope, scope_skip, :id, :args, :flags, :target);
        if (debug)
            return debug;

        return scope.NICERR_mismatch(:id, :args, :scope_skip);
    }

    fn NICERR_mismatch(
        scope: Scope, scope_skip: ScopeSkip[],
        id: string, args: SolvedNode[]): never
    {
        // TODO instead of this -
        //  run tryMatch__mutargs again with an error output attached,
        //   this way we don't need the second pass for debugging,
        //    we can #bake alla jblow the if (explain) parts,
        //     and we can rid ourselves of Scope_lookup altogether.

        // We should do everything possible to be helpful here,
        //  do whatever you need, this is compile-fail path.
        let overloads = DEPREC_lookup(scope, id, scope_skip);

        mut min = 0x7fffffff.i32;
        mut max = 0;
        for (mut i = 0; i < overloads.len; i++)
        {
            let o = GET(overloads[i]);
            if (min > o.min) min = o.min;
            if (max < o.max) max = o.max;
        }

        fn expectedArgs(shadow targets: Target[]): string
        {
            mut result = "";

            for (mut i = 0; i < targets.len; i++)
            {
                if (result)
                    result ~= "\n\t\t";
                else if (targets.len > 1)
                    result ~= ", available overloads:\n\t\t";
                else
                    result ~= ", expects: ";

                let overload = GET(targets[i]);

                result ~= overload.name ~ "(";

                for (shadow mut i = 0; i < overload.args.len; i++)
                {
                    let arg = overload.args[i];
                    if (i)
                        result ~= ", ";

                    result ~=  arg.name
                            ~ (arg.flags & F_MUSTNAME ? "!" : "")
                            ~ (arg.default ? "?: " : ": ")
                            ~ (arg.type ? humanizeType(arg.type) : "$");
                }

                result ~= ")";
            }

            return result || ".";
        }

        fn actualArgs(shadow args: SolvedNode[]): string
        {
            mut result = "\nActual: (";

            for (mut i = 0; i < args.len; i++)
            {
                let arg = args[i];
                if (i)
                    result ~= ",";

                result ~= "\n\t";
                if (arg.kind == "label")
                    result ~= arg.value ~ ": ";

                result ~= humanizeType(arg.type);
            }

            return result ~ ").";
        }

        return overloads
                ? args.len < min ? fail("`" ~ id ~ "` expects at least " ~ min ~ " arguments, " ~ args.len ~ " provided" ~ expectedArgs(overloads))
                : args.len > max ? fail("`" ~ id ~ "` expects at most " ~ max ~ " arguments, " ~ args.len ~ " provided" ~ expectedArgs(overloads))
                : fail("`" ~ id ~ "` bad args" ~ expectedArgs(overloads) ~ actualArgs(args))
             : fail("`" ~ id ~ "` is not defined in this scope.");
    }


    //

    fn solveNode(node: Node, type: Type = []): SolvedNode
    {
        let k = node.kind;

        if (k == "root")        return solveRoot(node);
        if (k == "block")       return solveBlock(node, :type);
        if (k == "label")       return solveLabel(node, :type);

        if (k == "let")         return solveLet(node);
        if (k == "call")        return solveCall(node);
        if (k == "arrlit")      return solveArrayLiteral(node, type);

        if (k == "if")          return solveIf(node, type);
        if (k == "or")          return solveOr(node, type);
        if (k == "!")           return solveNot(node);
        if (k == "and")         return solveAnd(node, type);

        if (k == "return")      return solveReturn(node);
        if (k == "loop")        return solveLoop(node);
        if (k == "break")       return solveJump(node);
        if (k == "continue")    return solveJump(node);

        if (k == "int")         return solveInt(node, type);
        if (k == "real")        return solveNum(node, type);
        if (k == "str")         return solveStr(node);
        if (k == "char")        return solveChar(node);
        if (k == "empty")       return createEmpty();

        if (k == "definit")     return solveDefinit(type);

        if (k == "catch")       return solveCatch(node);
        if (k == "import")      return solveImport(node);
        if (k == "defer")       return solveDefer(node);
        if (k == "try")         return solveTryCatch(node);

        if (k == "typeassert")  return solveTypeAssert(node);
        if (k == "typeparam")   return solveTypeParam(node);
        if (k == "addroffn")    return solveAddrOfFn(node);

        if (k == "fn")          return solveFnExpr(node);
        if (k == "struct")      return solveStructExpr(node);

        // Exotics
        if (k == "forfieldsof") return solveForFieldsOf(node);

        //
        return fail("TODO: " ~ k);
    }

    fn unorderedClassify(kind: string): i32
    {
        if (kind == "fn")       return 1;
        if (kind == "struct")   return 10;
        if (kind == "typedef")  return 10;

        return 0;
    }

    fn unorderedPrep_A(node: Node): SolvedNode
    {
        let k = node.kind;
        if (k == "fn")          return uPrepFn_A(node);
        if (k == "struct")      return uPrepStruct(node);
        if (k == "typedef")     return solveTypedef(node);

        return fail("TODO: " ~ k);
    }

    fn unorderedPrep_B(node: Node, into: Target)
    {
        let k = node.kind;
        if (k == "fn")
            uPrepFn_B(into);
    }

    fn unorderedSolve(node: Node, into: Target)
    {
        into || fail("unorderedSolve without prep");

        let k = node.kind;
        if (k == "fn")          return uSolveFn(node, :into);
        if (k == "struct")      return uSolveStruct(node, :into);

        return fail("TODO: " ~ k);
    }


    //

    fn solveRoot(node: Node): SolvedNode
    {
        return solved(node, t_void,
            solveNodes(node.items, t_void,
                TEMP_open_templates: true));
    }

    fn solveBlock(node: Node, type?: Type): SolvedNode
    {
        ////////////////////////////////
        let scope0 = Scope_snap(_scope);
        defer Scope_pop(_scope, scope0);

        let open_templates0 = _open_templates.len;
        ////////////////////////////////

        let label = node.value && Scope_addLabel(node.value);

        let expr = !!(node.items.if_last.flags & F_NODISCARD);
        if (expr && label)
            fail("TODO labelled expression blocks.");

        let items = solveNodes(
            node.items,
            type_all:       t_void,
            type_last:      type,
            use_type_last:  expr,
            TEMP_open_templates: true,
            TEMP_template_scope: scope0,
            deadcode_on_never:   true);

        // Control flow.
        shadow let type = expr && items.len || items.if_last.type.is_never && !(label && GET(label).status & SS_HAS_BREAK)
            ? items.last.type
            : t_void;

        ////////////////////////////////
        if (SELF_TEST)
        {
            for (mut i = open_templates0; i < _open_templates.len; i++)
            {
                let ot = _open_templates[i];
                let o = GET(ot.overloadIdx || ot.spec);
                if (o.template.scope_memo > scope0)
                    fail("Exiting the scope of an open template: `" ~ o.name ~ "`.");
            }
        }
        ////////////////////////////////

        return solved(:node, :type, :items);
    }


    //

    fn solveInt(v: string, type: Type): Type
    {
        shadow let parse = intlit::Intlit(v);
        parse.error && fail(parse.error);

        if (type)
        {
            fn want(t: Type)
                type.canon == t.canon;

            if (!parse.unsigned)
            {
                if (want(t_f32) && parse.minsize_f <= 32) return t_f32;
                if (want(t_f64) && parse.minsize_f <= 64) return t_f64;

                if (want(t_i32) && parse.minsize_i <= 32) return t_i32;
                if (want(t_i64) && parse.minsize_i <= 64) return t_i64;
                if (want(t_i16) && parse.minsize_i <= 16) return t_i16;
                if (want(t_i8 ) && parse.minsize_i <= 8 ) return t_i8 ;
            }

            if (!parse.signed)
            {
                if (want(t_u32) && parse.minsize_u <= 32) return t_u32;
                if (want(t_u64) && parse.minsize_u <= 64) return t_u64;
                if (want(t_u16) && parse.minsize_u <= 16) return t_u16;
                if (want(t_u8 ) && parse.minsize_u <= 8 ) return t_u8 ;
            }
        }

        if (parse.unsigned)
        {
            if (parse.minsize_u <= 32) return t_u32;
            if (parse.minsize_u <= 64) return t_u64;
        }
        else
        {
            if (parse.minsize_i <= 32) return t_i32;
            if (parse.minsize_i <= 64) return t_i64;
        }

        return fail("Bad int literal.");
    }

    fn solveNum(v: string, type: Type): Type
    {
        // TODO `f` suffix
        if (v) {}

        if (type.canon == t_f32.canon) return t_f32;

        return t_f64;
    }


    //

    fn solveInt(node: Node, type: Type): SolvedNode
        solved(node,
             solveInt(node.value, type));

    fn solveNum(node: Node, type: Type): SolvedNode
        solved(node,
             solveNum(node.value, type));


    //

    fn solveChar(node: Node): SolvedNode
    {
        return solved(node, t_byte);
    }

    fn solveStr(node: Node): SolvedNode
    {
        if (!node.value)
            return createDefinit(
                add_ref(t_string, Lifetime_temporary));

        return solved(node, t_string);
    }

    fn createEmpty(kind = "empty", type = t_void, target?: Target): SolvedNode
    {
        return SolvedNode(
            :kind, :type, :target,
            token: _here || fail());
    }


    //

    fn createTypeParam(value: string): Node
    {
        return Node(kind: "typeparam",
            :value, token: _here || fail());
    }


    //

    fn uPrepFn_A(node: Node): SolvedNode
    {
        return __solveFn(node, solve: false);
    }

    fn uPrepFn_B(target: Target)
    {
        ref template = GET_mut(target).template;
        if (template.scope_memo)
            template.scope_memo = Scope_snap(_scope);
    }

    fn uSolveFn(node: Node, into: Target): SolvedNode
    {
        return __solveFn(node, solve: true, :into);
    }

    fn solveFnExpr(node: Node): SolvedNode
    {
        return __solveFn(node, solve: true, into: uPrepFn_A(node).target);
    }

    fn __solveFn(
        n_fn: Node, solve!: bool, spec?!: bool, into?: Target,
        mangles?: Mangles): SolvedNode
    {
        let parent_idx = _current_fn.target.index;

        // Template early exit.
        if (spec)
        {
            // Now we try to prep these too.
            // solve || fail();
        }
        else if (n_fn.flags & F_TEMPLATE)
        {
            let tDecl = solve
                ? into || fail()
                : TemplateDecl(n_fn, local_of: parent_idx);

            return createEmpty(
                target: tDecl,
                type: addroffn::X_addrofTarget(tDecl));
        }

        // Prep reject.
        let return_idx = Scope_snap(_scope);
        let target = into || Scope_create(_scope, local_of: parent_idx);

        mut out = CurrentFn(
            :return_idx, :parent_idx, solved(n_fn,
                :target, type: addroffn::X_addrofTarget(target)));

        let inItems = n_fn.items;
        out.items.resize(inItems.len);

        // Propagate "inlined"-ness to non-templates within templates,
        //  see the `traverse` testcase.
        if (_current_fn.flags & F_TEMPLATE)
            out.flags |= F_TEMPLATE;

        // Populate scope.
        _scope.items ~= mangles.extra_items;

        //////////////////////////
        mut native = false;
        mut n_body: Node;

        mut didInit = false;

        fn initScope()
        {
            if (didInit)
                return;

            didInit = true;

            // TODO FIX currently we only hash template names.
            mut name = n_fn.value || fail("TODO anonymous fns");
            if (spec && !native)
            {
                let sig = mangleArguments(out.items[0, out.items.len + FN_ARGS_BACK]);
                if (sig)
                {
                    let hash = tea::hash62(sig, chars: 4) || fail();
                    name ~= "_" ~ hash;
                }
            }

            //
            let kind = native ? "__native" : "fn";
            let template = createTemplate(node: native ? n_body : n_fn);

            FnDecl_init(:target, :kind, id: name, :template);
        }

        fn updateScope()
        {
            FnDecl_update(out.out, :out.locals_used, :out.ret_actual);
        }

        // Go!
        {
            let root_scope0 = _root_scope;
            if (!root_scope0)
                _root_scope = return_idx;

            SWAP(_current_fn, out);

            defer {
                SWAP(_current_fn, out);
                Scope_pop(_scope, return_idx);
                _root_scope = root_scope0;
            }

            /////////////////////////////////
            ref outItems = _current_fn.items;

            // Arg decls.
            for (mut i = 0; i < inItems.len + FN_ARGS_BACK; i++)
            {
                fn tryGetArgSpecType(id: string): Type
                {
                    mut param = "$" ~ id;
                    for (shadow mut i = 0; i < mangles.extra_items.len; i++)
                    {
                        let m = mangles.extra_items[i];
                        if (m.id == param)
                        {
                            let o = GET(m.target);
                            o.kind == "type" && o.max == 0 || fail(
                                "tryGetArgSpecType: Not a typeparam: `"
                                    ~ o.kind ~ ":" ~ param ~ "(" ~ o.max ~ ")`.");

                            return o.type;
                        }
                    }

                    return Type;
                }

                let n_arg       = inItems[i];
                let specType    = spec && tryGetArgSpecType(n_arg.value);
                outItems[i]     = solveLet(n_arg, :specType);
            }

            /////////////////////////////////////////////////////
            let n_ret   = inItems[inItems.len + FN_RET_BACK];
                n_body  = inItems[inItems.len + FN_BODY_BACK];

            // Builtin?
            n_body || fail("solveFn: no body.");
            if (n_body.kind == "call" && n_body.value == "__native")
                native = true;

            // Return type annot.
            _current_fn.ret_expect = n_ret && evalTypeAnnot(n_ret).type;

            // Seed return value.
            {
                _current_fn.ret_actual = n_ret
                    ? _current_fn.ret_expect || fail("falsy ret_expect: " ~ n_fn.value)
                    : t_never;

                if (_current_fn.ret_actual.lifetime)
                    _current_fn.ret_actual.lifetime = native
                        ? Lifetime_fromNative(inItems, _current_fn.items[0, _current_fn.items.len + FN_ARGS_BACK])
                        : Lifetime_FN_unorderedPrep();
                //
                else if (_current_fn.ret_actual.is_ref)
                    fail("fn.ret_actual is a ref without a lifetime.");
            }

            // Only if actually solving the fn, the fn body.
            if (solve)
            {
                if (!into && mangles)
                {
                    // Re-enable recursion.
                    {
                        SWAP(_current_fn, out);
                        initScope();
                        updateScope();
                        SWAP(_current_fn, out);
                    }

                    // setSpecs & co.
                    let preexisting = __afterPrep_dedupeMangle(mangles, target);
                    if (preexisting)
                        return createEmpty(target: preexisting);
                }

                if (!native)
                {
                    _current_fn.ret_actual = Type();
                    let s_body = solveNode(n_body);
                    finalizeReturns(s_body.type);

                    // MUT DURING SOLVE,
                    //  implicit args splice in
                    outItems[outItems.len + FN_BODY_BACK] = s_body || fail("falsy body");
                }
            }

            // Sighashes include return value.
            outItems[outItems.len + FN_RET_BACK] =
                createEmpty(type: _current_fn.ret_actual);
        }
        //////////////////////////

        // What now?
        if (!into)
            initScope();

        updateScope();

        // This is where we open up
        if (!solve)
            return out.out;

        _open_templates.push(OpenTemplate(spec: target, :mangles));
        return createFnDef(out.out);
    }

    fn createFnDef(fn: SolvedNode): SolvedNode
    {
        return SolvedNode(
            kind:   "fndef",
            type:   fn.type,
            target: fn.target,
            token:  fn.token);
    }


    //

    fn mangleArguments(args: [$T]): string
    {
        mut mangle = "";
        for (mut i = 0; i < args.len; i++)
        {
            if (i)
                mangle ~= ",";

            mangle ~= serializeType(args[i].type);
        }

        return mangle;
    }

    fn mangleArguments(args: [SolvedNode], reorder: [i32]): string
    {
        if (!reorder)
            return mangleArguments(args);
        else
            reorder.len >= args.len || fail(
                "mangleArguments: `reorder.len < args.len`,"
                    ~ " then `!reorder` checks become ambiguous.");

        mut mangle = "";
        mut commas = 0;

        for (mut i = 0; i < reorder.len; i++)
        {
            while (commas > 0)
            {
                mangle ~= ",";
                commas--;
            }

            let callsiteIndex = reorder[i];
            if (callsiteIndex >= 0 && callsiteIndex < args.len)
                mangle ~= serializeType(args[callsiteIndex].type);

            commas++;
        }

        return mangle;
    }


    //

    fn is_SPECFAIL(target: Target): bool
    {
        return target.modid == -1;
    }

    fn setSpec(mangle: string, target: Target, nx?: bool)
    {
        ref t = module.out.specs[mangle] ||= Target;

        fn id(shadow target)
            target.modid != -1  ? `"` ~ GET(target).name ~ `"`
                                : "SPEC_FAIL";

        !t && nx || t.is_SPECFAIL && !nx || fail(
            "About to screw up royally, replacing spec: "
                ~ t.index ~ " with " ~ target.index
                    ~ ", mangle: " ~ mangle ~ ", that's: "
                    ~ t.id ~ " becoming " ~ target.id);

        t = target;
    }

    fn trySpecialize(
        overloadIdx: Target, args: SolvedNode[], reorder: [i32],
        args_mangled: string)
            : Target
    {
        // TODO memoize the whole mangle.
        let mangle = overloadIdx.modid ~ "#" ~ overloadIdx.index ~ " " ~ args_mangled;
        let spec = module.out.specs[mangle] || doTrySpecialize(:overloadIdx, :args, :mangle, :reorder);

        return !spec.is_SPECFAIL && spec;
    }


    //

    fn ScopeSkip_push(ref scope_skip: ScopeSkip[], start: i32, end: i32)
    {
        start <= end || fail("ScopeSkip_push: bad args.");
        if (end == start)
            return;

        let last = scope_skip.if_last;
        last.end <= start || fail("ScopeSkip_push: last.end > start.");

        scope_skip ~= ScopeSkip(:start, :end);
    }

    fn doTrySpecialize(
        overloadIdx: Target, mut args: SolvedNode[],
        mut mangle: string, into?: Target, reorder?: [i32])
            : Target
    {
        mut ok = true;

        // Reorder with gaps.
        if (reorder)
        {
            mut reordered: SolvedNode[];
            for (mut i = 0; i < reorder.len; i++)
            {
                let callsiteIndex = reorder[i];
                reordered.push(
                    callsiteIndex >= 0 && callsiteIndex < args.len
                        && args[callsiteIndex]);
            }

            args = reordered;
        }

        //
        let args00 = args;
        let mangle00 = mangle;
        let SPECFAIL = Target(modid: -1, index: 0);

        if (!into) setSpec(mangle, SPECFAIL, nx: true);

        ////////////////////////////////
        mut current_fn0: CurrentFn;

        SWAP(_current_fn, current_fn0);
        let scope0 = Scope_snap(_scope);
        let ss_items0   = _ss_items;
        let ss_imports0 = _ss_imports;

        defer {
            SWAP(_current_fn, current_fn0);
            Scope_pop(_scope, scope0);
            _ss_items   = ss_items0;
            _ss_imports = ss_imports0;
        }
        ////////////////////////////////

        //
        mut typeParams: TypeParams;

        //
        let overload = GET(overloadIdx);
        let template = overload.template;

        {
            mut parent_idx = overload.local_of;

            // If we're taking a closure as an argument,
            //  we're becoming a closure ourselves of whatever that closure is closing over -
            //   so that e.g. lifetime reasoning can have an easier time etc.
            //
            // TODO all of these must form up a common shadowing group -
            //  So nothing by the same name should come in from outer scope,
            //   and yet none of these things shadow each other.
            //
            for (mut i = 0; i < args.len; i++)
            {
                let arg_t = args[i].type;
                if (addroffn::type_isAddrOfFn(arg_t))
                {
                    let targets = addroffn::unpackAddrOfFn(arg_t.canon);
                    for (shadow mut i = 0; i < targets.len; i++)
                    {
                        let target = targets[i];
                        if (target.modid == module.modid)
                        {
                            let local_of = GET(target).local_of;
                            if (parent_idx < local_of)
                                parent_idx = local_of;
                        }
                    }
                }
            }

            //
            if (parent_idx)
                _current_fn.target = Target(
                    :module.modid, index: parent_idx);
        }

        //
        if (_root_scope)
        {
            let start = template.scope_memo || _root_scope;

            _ss_items   = template.ss_items;
            _ss_imports = template.ss_imports;

            ScopeSkip_push(_ss_items,   start: start.items_len,   end: scope0.items_len);
            ScopeSkip_push(_ss_imports, start: start.imports_len, end: scope0.imports_len);
        }

        // We'll need the original imports in scope
        //  in order to solve type params & pattern match below.
        Scope_snap(_scope) == scope0 || fail(
            "doTrySpec: scope write before imports unpack.");

        for (mut i = 0; i < template.imports.len; i++)
            Scope_import(template.imports[i]);

        let expect_scopelen = Scope_snap(_scope);
        defer Scope_snap(_scope) == expect_scopelen || fail(
            "doTrySpec: scope write after imports unpack.");

        //
        let kind    = template.node.kind;
        let items   = template.node.items;
        let numArgs = kind == "fn" ? items.len + FN_ARGS_BACK
                    : fail("TODO numArgs for template:" ~ kind);

        /////////////////
        // Literal fixup.
        mut retypeIndices: i32[];
        mut remangle = false;

        // First off, solve type params.
        for (   mut pass_retype  = 0;
                    pass_retype == 0 || pass_retype == 1 && retypeIndices;
                    pass_retype++)
        {
        //        /LITFIX
        /////////////////

            for (mut i = 0; i < numArgs; i++)
            {
                if (pass_retype)
                {
                    // TODO fix, .try_shift instead.
                    if (!retypeIndices.has(i))
                        continue;
                }

                let inValue = args.len > i && args[i];
                mut inType  = inValue.type;

                let argNode = items[i] || fail();
                let annot   = argNode.items[LET_TYPE];

                /////////////////
                // Literal fixup.
                if (couldRetype(inValue))
                {
                    let paramType =
                        annot.kind == "typeparam"
                            ? typeParams[annot.value] ||= Type
                            : annot.kind == "call" && !annot.items
                                && Scope_lookupType(annot);

                    // Ignore literals if possible.
                    if (paramType)
                    {
                        let retype = tryRetyping(inValue, paramType);
                        if (retype && retype.canon != inType.canon)
                        {
                            inType   = args[i].type = retype;
                            remangle = true;
                        }
                    }

                    // Defer for second pass.
                    else if (!pass_retype)
                    {
                        retypeIndices.push(i);
                        continue;
                    }
                }
                //        /LITFIX
                /////////////////

                argNode.kind == "let"  || fail();

                if (inType)
                {
                    let argName = argNode.value || fail();

                    // Same pattern - grabs a mutref.
                    ref argName_typeParam =
                        typeParams[argName] ||= Type;

                    // Values vs refs.
                    //  TODO actually this is rather stupid, isn't it,
                    //   what if it were all just refs and we did the copy internally,
                    //    only if necessary, and as late as possible.
                    if (argNode.flags & F_MUT)
                        inType = clear_refs(inType);
                    else
                        inType = add_ref(inType, Lifetime_temporary);

                    //
                    argName_typeParam && fail(
                        "Type param name collision with argument: `" ~ argName ~ "`.")
                            = inType;

                    // Type check.
                    if (annot)
                    {
                        let argOk = inType && trySolveTypeParams(
                            annot, inType, typeParams);

                        ok = ok && argOk;
                        if (!ok && !remangle)
                            break;
                    }
                }
            }
        }

        /////////////////
        // Literal fixup.
        if (remangle)
        {
            // TODO FIX
            let start   = mangle.find(' ') + 1 || fail();
                mangle  = mangle.slice(0, start) ~ mangleArguments(args);

            if (mangle00 != mangle)
            {
                let preexisting = module.out.specs[mangle] || Target();
                if (preexisting)
                {
                    setSpec(mangle00, preexisting);
                    return preexisting;
                }

                if (!into) setSpec(mangle, SPECFAIL, nx: true);
            }
        }
        //        /LITFIX
        /////////////////

        // Match pattern arm here.
        if (!ok)
            return SPECFAIL;

        mut n_fn = template.node;
        {
            // Pattern matching.
            let body = items[items.len + FN_BODY_BACK] || fail();
            if (body.kind == "pattern")
            {
                let undo = typeParams;
                let branches = body.items;

                mut did_match = false;
                for (mut i = 0; i < branches.len; i++)
                {
                    // Fails cond if any?
                    let cond = branches[i].items[0];
                    if (cond && !evalTypePattern(cond, typeParams))
                    {
                        typeParams = undo;
                        continue;
                    }

                    // Pass.
                    let cons = branches[i].items;
                    ref sig = n_fn.items;
                    {
                        let n_ret = cons[cons.len + FN_RET_BACK];
                        if (n_ret) sig[sig.len + FN_RET_BACK] = n_ret;

                        let n_body = cons[cons.len + FN_BODY_BACK];
                        sig[sig.len + FN_BODY_BACK] = n_body || fail("doTrySpec: no case/body.");
                    }

                    did_match = true;
                    break;
                }

                // All branches mismatch?
                //  Can't return, faking RAII here.
                if (!did_match)
                    return SPECFAIL;
            }
        }

        // We shouldn't have written anything new into scope.
        let extra_items = typeParams.intoScopeItems();

        //
        kind == "fn" || fail("__solveFn spec:true is not expected to fail.");

        let mangles = Mangles(:mangle00, mangle0: mangle, :overloadIdx, :args00, :extra_items);

        return __solveFn(:n_fn, solve: true, spec: true, :into, :mangles).target;
    }

    fn __afterPrep_dedupeMangle(using mangles: Mangles, prep: Target): Target
    {
        let start   = mangle0.find(' ') + 1 || fail();
        let mangle  = mangle0.slice(0, start)
                    ~ mangleArguments(GET(prep).args);

        mut preexisting: Target;
        if (mangle0 != mangle)
        {
            preexisting = module.out.specs[mangle] || Target();
            setSpec(mangle0, preexisting || prep);
        }

        let nx = mangle00 != mangle;
        if (nx && mangle00 != mangle0)
            setSpec(mangle00, preexisting || prep);

        if (preexisting)
            return preexisting;

        setSpec(mangle, prep, :nx);
        return Target();
    }


    //

    fn intoScopeItems(typeParams: TypeParams): ScopeItem[]
    {
        mut res: ScopeItem[];

        typeParams.pairs(|id, type|
        {
            let name = "$" ~ id;
            let target = Scope_Typedef(_scope,
                id: "", // dont Scope_add
                name: "$" ~ id, :type, flags: 0);

            res ~= ScopeItem(name, :target);
        });

        return res;
    }


    //

    fn uPrepStruct(node: Node): SolvedNode
    {
        return __solveStruct(solve: false, :node);
    }

    fn uSolveStruct(node: Node, into: Target): SolvedNode
    {
        return __solveStruct(solve: true, :node, :into);
    }

    fn solveStructExpr(node: Node): SolvedNode
    {
        return __solveStruct(solve: true, :node);
    }

    fn __solveStruct(solve!: bool, node: Node, into?!: Target): SolvedNode
    {
        mut out = solved(node, target: into, type: into && GET(into).type);
        ref structType = out.type;

        mut name = node.value;
        let origId = name;
        if (!origId)
            name = _current_fn.value || "Anon";

        fn ensureTypedef()
        {
            if (out.target)
                return;

            let template = createTemplate(:node);

            out.target = Scope_Typedef(_scope, id: origId, :name,
                structType, node.flags, :template);
        }

        // Add the arity-0 type entry.
        if (!(_current_fn.flags & F_TEMPLATE) && !out.target)
        {
            structType = initStruct(:name, :node.flags);
            ensureTypedef();
        }

        if (!solve)
            return out;

        /////////////////////////////////////////////////
        _current_struct && fail("struct-within-struct");
        defer _current_struct = Target();
        _current_struct = out.target;
        /////////////////////////////////////////////////

        // Struct fields only.
        let members = node.items;

        // Struct members, pass 0.
        out.items = members.map(|shadow node|
        {
            node.kind == "let" || fail("solveStructMembers_1: " ~ node.kind);

            node.items[LET_INIT] &&
            node.items[LET_INIT].kind != "definit" &&
                fail("All structs must be zerofilled by default."
                    ~ " Please remove the initializer of struct member `" ~ node.value ~ "`.");

            return solveLetLike_dontTouchScope(node);
        });

        if (!structType)
        {
            let sig     = mangleArguments(out.items);
            let hash    = tea::hash62(sig, chars: 4);
            name       ~= "_" ~ hash;

            structType  = initStruct(:name, :node.flags);
        }

        // (Re)poplate fields.
        {
            ref innerScope = lookupStruct_mut(structType.canon).items;
            if (!innerScope && out.items)
            {
                // Dereferencing a struct does not require it
                //  to have any particular qualities.
                let args = [ Argument(name: "this",
                    type: despeculateStruct(structType)) ];

                innerScope.resize(node.items.len);
                for (mut i = 0; i < innerScope.len; i++)
                {
                    let id = node.items[i].value;
                    let target = Scope_create(
                        _scope, "field", name: id || fail(),
                        min: 1, max: 1, flags: F_PUB, :args);

                    innerScope[i] = ScopeItem(:id, :target);
                }
            }

            // Update field types.
            innerScope.len == out.items.len || fail(
                "solveStructMembers_3: field lens mismatch.");

            for (mut i = 0; i < innerScope.len; i++)
            {
                let item = innerScope[i];
                shadow let node = out.items[i];
                item.id == node.value || fail(
                    "solveStructMembers_4: field id mismatch.");

                ref field = GET_mut(item.target);
                    field.type = node.type;

                if (node.flags & F_USING)
                    scope_using(item.target);
            }
        }

        ensureTypedef();

        // Add a default constructor.
        {
            shadow mut members: SolvedNode[];

            mut commonQuals = -1;

            for (mut i = 0; i < out.items.len; i++)
            {
                let item = out.items[i];
                if (item && item.kind == "let" && (item.flags & F_FIELD))
                {
                    members.push(item);
                    commonQuals &= item.type.quals;
                }
            }

            //
            {
                ref s = lookupStruct_mut(structType.canon);
                    s.target = out.target || fail(
                        "No struct/out.target.");
            }

            let quals0 = structType.quals;
            let quals1 = structType.quals &= commonQuals;

            //
            let max = members.len;
            mut min = 0;
            mut args: Argument[];

            for (mut i = 0; i < members.len; i++)
            {
                let member = members[i];

                let arg = Argument(
                    name:       member.value || fail(),
                    type:       member.type  || fail(),
                    default:    member.items[LET_INIT],
                    flags:      member.flags & F_MUSTNAME);

                if (!arg.default)
                    min++;

                args.push(arg);
            }

            if (max && !min) min++;

            ref overload    = GET_mut(out.target);
            overload.min    = min;
            overload.max    = max;
            overload.args   = args;
            overload.type   = structType;

            if (quals0 != quals1 && out.target)
                invalidateUsers(overload);
        }

        // So we can type x = struct { what };
        out.type = structType;

        if (out.target)
        {
            ref o = GET_mut(out.target);
                o.solved = out;

            checkRecursions(o, out.target.index);

            _open_templates.push(OpenTemplate(spec: out.target));
        }

        return out;
    }

    fn checkRecursions(ref o: Overload, startIndex: i32): void
    {
        if (!o.used_by || o.status & SS_REC_CHECKED)
            return;

        o.status |= SS_REC_CHECKED;

        //
        mut seen: bitset::BitSet;

        fn visit(overload: Overload): bool
        {
            let u = overload.used_by;
            for (mut i = 0; i < u.len; i++)
            {
                let index = u[i];
                if (!seen.bitset::add_once(index))
                    continue;

                if (index == startIndex)
                    return true;

                let t = Target(:module.modid, :index);
                if (visit(GET(t)))
                    return true;
            }

            return false;
        }

        if (visit(o))
            o.status |= SS_RECURSIVE;
    }


    //////////////////////////////////////////////////////////
    //
    // Note - as soon as we re-assign the return value,
    //  we want to re-iterate all the return statements,
    //   because that can change our copy/move decision.

    fn superType(reason: string, a: Type, b: Type)
    {
        return type_trySuper(a, b) || fail(reason
            ~ " No common supertype: `"
            ~ serializeType(a) ~ "` <-> `" ~ serializeType(b) ~ "`.");
    }

    fn reportReturnType(type: Type)
    {
        // Check annot.
        if (_current_fn.ret_expect)
            checkAssignable(host: _current_fn.ret_expect, type,
                "Expression not assignable to return annotation");

        // Check multiple returns.
        if (_current_fn.ret_actual)
            _current_fn.ret_actual = superType("[return]", _current_fn.ret_actual, type);
        else
            _current_fn.ret_actual = type || fail();

        // Counter.
        _current_fn.ret_count++;
    }

    fn stashReturn(solved: SolvedNode): Target
    {
        let target = Scope_create(_scope, "return",
            local_of: _current_fn.target.index || fail(), :solved);

        _current_fn.returns ~= target;

        return target;
    }

    fn finalizeReturns(bodyType: Type)
    {
        // Not a single return statement = return void.
        _current_fn.ret_actual ||= _current_fn.ret_count
            ? fail("falsy ret_actual when ret_count != 0.")
            : t_void;

        // TODO FIX
        //  Disable return value narrowing,
        //   we're getting some aliasing somewhere that breaks the compiler's back.
        if (!USE_retval_narrowing && _current_fn.ret_expect)
        {
            let lt0                 = _current_fn.ret_actual.lifetime;
            _current_fn.ret_actual  = _current_fn.ret_expect;

            if (_current_fn.ret_actual.is_ref)
                _current_fn.ret_actual.lifetime = lt0 || fail("expected ref, got no lt0");
        }

        // cpy/move.
        if (!_current_fn.ret_actual.is_ref)
        {
            for (mut i = 0; i < _current_fn.returns.len; i++)
            {
                ref ret = GET_mut(_current_fn.returns[i]);
                maybeCopyOrMove(ret.solved, _current_fn.ret_actual);
            }
        }

        // See if we're missing the final return statement.
        //  Two cases of interest:
        //
        // [1] If this is a non-void/non-never returning function,
        //      then you've forgotten the final return stmt of your fn.
        //
        // [2] If this is a never returning function,
        //      then this means that the function actually returns void.
        //
        if (!bodyType.is_never) // Refers to the type of the return stmt -
        {                       //  it is always never, everything after it is unreach.
            isAssignable(host: t_void, _current_fn.ret_actual) || fail(
                "Non-void returning fn missing a final return.");

            _current_fn.ret_actual = t_void;
        }
    }

    fn solveReturn(node: Node): SolvedNode
    {
        if (!node.items)
        {
            reportReturnType(t_void);
            return solved(node, t_never);
        }


        // We'll detach the return expression for further fiddling elsewhere.

        mut expr = solveNode(
            node.items.only,
            type: _current_fn.ret_actual || _current_fn.ret_expect);

        //////////////////////////////////////////////////////
        //                                                  //
        // TODO LIFETIMES   this doesn't work               //
        //                  for deeply referential types.   //
                                                            //
        if (expr.type.lifetime.Lifetime_killedByReturnOf(_current_fn.target) &&
            expr.type.is_ref)                               //
        {                                                   //
            let nrvo = expr.kind == "call"                  //
                    && expr.items.len == 0                  //
                    && expr.target.GET.kind == "var";       //
                                                            //
            expr = createMove(expr, nrvo);                  //
        }                                                   //
                                                            //
        //////////////////////////////////////////////////////

        reportReturnType(expr.type);
        return solved(node, t_never, target: stashReturn(expr));
    }


    //////////////////////////////////////////////////////////

    fn checkAssignable(
        host: Type, guest: Type, err: string,
        id?: string, sep?: string)
    {
        isAssignable(
            :host   || fail("Bad host type."),
            :guest  || fail("Bad guest type."))
                    || fail(err ~ (id && " `" ~ id ~ "`") ~ ": "
                                ~ host .humanizeType() ~ (sep || " <- ")
                                ~ guest.humanizeType());
    }


    // Loops.

    fn LabelID(id: string) "L " ~ id;

    fn Scope_addLabel(id: string): Target
    {
        return Scope_add(
            _scope, "label", id: LabelID(id),
            type: Type, flags: F_SHADOW,
            local_of: _current_fn.target.index);
    }

    fn Scope_lookupLabel(mut id: string): &mut Overload
    {
        id = LabelID(id);

        mut scope_iterator: i32;
        mut overloadIdx: Target;

        while (overloadIdx = _scope.items.search(
            id, scope_iterator, scope_skip: _ss_items))
        {
            ref maybe = GET_mut(overloadIdx);
            if (maybe.kind == "label")
                return maybe;
        }

        return fail("No label `" ~ id ~ "` in scope.");
    }

    fn solveLabel(node: Node, type: Type): SolvedNode
    {
        let target = node.flags & F_STATEMENT
            && Scope_addLabel(node.value);

        //
        let expr = solveNode(node.items.only, :type);
        return solved(node, [ expr ], :expr.type, :target);
    }

    fn solveLoop(node: Node): SolvedNode
    {
        ////////////////////////////////
        let scope0 = Scope_snap(_scope);
        defer Scope_pop(_scope, scope0);
        ////////////////////////////////

        let label       = Scope_addLabel(node.value);

        let n_init      = node.items[0];
        let n_pre_cond  = node.items[1];
        let n_post      = node.items[2];
        let n_body      = node.items[3];
        let n_post_cond = node.items[4];

        let init        = n_init      && solveNode(n_init,      t_void);
        let pre_cond    = n_pre_cond  && solveNode(n_pre_cond,  t_bool);
        let post        = n_post      && solveNode(n_post,      t_void);
        let body        = n_body      && solveNode(n_body,      t_void);
        let post_cond   = n_post_cond && solveNode(n_post_cond, t_bool);

        // Control flow.
        let type        = !pre_cond && !post_cond && !(GET(label).status & SS_HAS_BREAK)
                            ? t_never
                            : t_void;

        return solved(node, type,
            [ init, pre_cond, post, body, post_cond ]);
    }

    fn solveJump(node: Node): SolvedNode
    {
        // Jump kind.
        ref label = Scope_lookupLabel(node.value);
        if (node.kind == "break")
            label.status |= SS_HAS_BREAK;
        else if (node.kind == "continue")
            label.status |= SS_HAS_CONTINUE;
        else
            fail("TODO jump kind: `" ~ node.kind ~ "`.");

        // Control flow.
        return solved(node, t_never);
    }


    // Exotic loops.

    fn solveForFieldsOf(node: Node): SolvedNode
    {
        fn astReplace(shadow node: Node, mutate): Node
        {
            fn walk(shadow ref node: Node)
            {
                for (mut i = 0; i < node.items.len; i++)
                    walk(node.items[i]);

                mutate(node);
            }

            shadow mut node = node;
            walk(node);
            return node;
        }

        let placeholder     = node.value;
        let body_template   = node.items[1];
        let fields_of       = evalTypeAnnot(node.items[0]).type;
        fields_of.isStruct || fail("[for fieldname]: This is not a struct: `" ~ serializeType(fields_of) ~ "`.");

        let fields          = lookupStruct(fields_of).items;

        mut items_ast: Node[];
        for (mut i = 0; i < fields.len; i++)
        {
            let field = fields[i];
            if (GET(field.target).kind == "field")
            {
                items_ast ~= astReplace(body_template, |ref item: Node|
                {
                    if (item.value == placeholder)
                    {
                        if (item.items.len == 1 && item.kind == "call")
                        {
                            // TODO field access syntax disables any kind of scope lookup but fields,
                            //  otherwise we risk miscellaneous stuff randomly breaking templates for no good reason.
                            //
                            // if (item.flags & F_ACCESS)
                            //     item.flags |= F_NOSCOPE;
                            //
                            item.value = field.id;
                        }
                        else if (item.kind == "str")
                        {
                            // String literals, potentially useful for serialization.
                            item.value = field.id;
                        }
                    }
                });
            }
        }

        // Control flow & deadcode elim.
        //  TODO break & continue.
        let items = solveNodes(items_ast, deadcode_on_never: true);
        let type  = items.last.type.is_never ? t_never : t_void;

        return createBlock(node.token, type, items);
    }


    //

    fn solveLetLike_dontTouchScope(node: Node, specType?!: Type): SolvedNode
    {
        let n_annot     = node.items[LET_TYPE];
        let n_init      = node.items[LET_INIT];

        mut annot       = n_annot && evalTypeAnnot(n_annot);

        // Annot override during template specialization.
        if (specType)
            annot.type = specType;

        if (annot.type && node.flags & F_REF)
            annot.type  = add_mutref(annot.type, Lifetime_temporary);

        mut init        = n_init && solveNode(n_init, annot.type);

        annot.type || init.type || fail(
            "Variable declarations without type annotations must be initialized.");

        if (annot.type && init.type)
        {
            if (node.flags & F_ARG)
            {
                // Is this correct here?
                //  Since we do fnarg defaults on the callsite,
                //   they're always referable.
                if (annot.type.is_ref && !init.type.is_ref)
                    init.type = add_ref(init.type, Lifetime_temporary);
            }

            if (specType)
            {
                // Kinda arbitrary -
                //  if init expr doesn't resolve to a mutref,
                //   infer we want no mutref under any circumstance,
                //    this should help herd the specs a little.
                if (specType.is_mutref && !init.type.is_mutref)
                    annot.type = clear_mutref(annot.type);

                // Drop defaults that don't match current spec types,
                //  this will effectively make the args non-defaulted.
                if (!isAssignable(host: annot.type, init.type))
                    init = SolvedNode();
            }               // ^
                            // |
            if (init.type)  // | Might be dropped here.
            {
                checkAssignable(host: annot.type, init.type,
                    "Type annotation does not match init expression",
                        node.value, "=");

                annot.type.lifetime = init.type.lifetime;
            }
        }

        let killref = init.type.is_ref2temp();

        if (node.flags & F_REF)
        {
            init.type.is_mutref || !init && node.flags & F_ARG || fail(
                "`ref` variables must be initialized to a mutable reference: `" ~ node.value ~ "`.");
            killref && fail(
                "`ref` varibles cannot bind to temporaries.");
        }

        //
        let t_let   = annot.type
                        ? node.flags & F_ARG && !(node.flags & F_MUT)
                            ? add_ref(annot.type, Lifetime_temporary)
                            : annot.type
                    : init.type.is_mutref || node.flags & F_MUT || killref
                        ? node.flags & F_REF && !killref
                            ? init.type
                            : USE_ref_to_mutref && !(node.flags & F_MUT) && !killref
                                ? clear_mutref(init.type)
                                : clear_refs(init.type)
                        : node.flags & F_ARG && !(node.flags & F_MUT)
                            ? add_ref(init.type, Lifetime_temporary)
                            : init.type;

        if (init)
            maybeCopyOrMove(init, t_let);

        //
        mut out = solved(node, t_let, [annot || init, init]);

        let global = !_current_fn && !(node.flags & F_FIELD);
        if (global)
        {
            if (out.flags & F_MUT || out.type.is_mutref)
                fail("Mutable statics are not currently allowed.");

            out.kind = "global";
        }

        return out;
    }

    fn solveTypedef(node: Node): SolvedNode
    {
        let annot = evalTypeAnnot(node.items.only);
        Scope_Typedef(_scope, node.value, annot.type, node.flags);
        return createEmpty();
    }

    fn solveLet(node: Node, specType?!: Type): SolvedNode
    {
        mut out         = solveLetLike_dontTouchScope(node, :specType);
        let global      = out.kind == "global";

        let kind = global               ? "global"
                 : node.flags & F_ARG   ? "arg"
                 : out.type.is_ref      ? "ref"
                                        : "var";

        let id = out.value;

        !out.type.is_ref || out.type.lifetime || fail("ref without lifetime");

        //
        if (!addroffn::X_unpackAddrOfFnBinding(_scope.items, id, out.type))
        {
            let target = out.target = Binding(:id, :kind, :node.flags, :out.type);

            if (global)
                GET_mut(target).solved = out;

            if (out.flags & F_USING)
                scope_using(target);
        }

        return out;
    }

    fn solveCatch(node: Node): SolvedNode
    {
        node.items.len == 3 || fail();

        _current_fn.tries++;
        let var_ok = solveNode(node.items[0]);
        _current_fn.tries--;

        ////////////////////////////////
        let scope0 = Scope_snap(_scope);
        defer Scope_pop(_scope, scope0);
        ////////////////////////////////

        let var_err = solveNode(node.items[1]);
        let catch   = solveNode(node.items[2]);

        let type = var_ok.type;
        catch.type.is_never || fail(
            "[let catch]: catch clause must exit local scope.");

        var_err.kind == "let" && isAssignableAsArgument(
            var_err.type, t_string) || fail(
                "catch: exceptions are strings,"
                    ~ " consider dropping the annotation.");

        return solved(node, type,
            [ var_ok, var_err, catch ]);
    }

    fn solveTryCatch(node: Node): SolvedNode
    {
        node.items.len == 3 || fail();

        /////////////////////////////////
        let scope0  = Scope_snap(_scope);
        /////////////////////////////////

        _current_fn.tries++;
        let try     = solveNode(node.items[0]);
        _current_fn.tries--;

        ///////////////////////////////////////
        Scope_pop(_scope, scope0);
        shadow let scope0 = Scope_snap(_scope);
        ///////////////////////////////////////

        let err     = solveNode(node.items[1]);
        let catch   = solveNode(node.items[2]);

        //////////////////////////
        Scope_pop(_scope, scope0);
        //////////////////////////

        err.kind == "let" && isAssignableAsArgument(
            host: err.type, t_string) || fail(
                "catch: exceptions are strings,"
                    ~ " consider dropping the annotation.");

        let type    = try.type.is_never && catch.type.is_never
                        ? t_never
                        : t_void;

        return solved(node, type, [ try, err, catch ]);
    }

    fn findModule(fuzimport: string): &Module
    {
        let fname = resolveFile_x(fuzimport);

        let modules = ctx.modules;
        for (mut i = 1; i < modules.len; i++)
        {
            let m = modules[i];
            if (m.fname == fname)
                return m;
        }

        fail("Cannot locate: " ~ fname);
    }

    fn solveImport(node: Node): SolvedNode
    {
        let m = findModule(fuzimport: node.value);
        Scope_import(m.modid);

        //
        return createEmpty();
    }

    fn solveDefer(node: Node): SolvedNode
    {
        let item = solveNode(node.items.only);
        return solved(node, t_void, [ item ]);
    }


    //

    fn Scope_lookupType(mut id: string, flags: i32 = 0): Type
    {
        mut scope_iterator: i32;
        mut overloadIdx: Target;

        let qualified = flags & F_QUALIFIED;
        let scope = qualified
            ? dequalify_andGetScope(id)
            : _scope;

        while (overloadIdx =
            scope.items.search(id, scope_iterator,
                scope_skip: !qualified && _ss_items))
        {
            let maybe = GET(overloadIdx);
            if (maybe.kind == "type")
                return maybe.type || fail();
        }

        return fail("No type `" ~ id ~ "` in scope.");
    }

    fn Scope_lookupType(annot: Node): Type
    {
        return Scope_lookupType(annot.value, :annot.flags);
    }


    //

    fn evalTypeParam(id: string, typeParams?: TypeParams): Type
    {
        return typeParams[id] || Scope_lookupType(
                    "$" ~ (id || fail("Falsy type param id.")))
                              || fail("No type param `$" ~ id ~ "` in scope.");
    }

    fn solveTypeParam(node: Node): SolvedNode
    {
        return solved(node, evalTypeParam(node.value));
    }

    fn solveAddrOfFn(node: Node): SolvedNode
    {
        let id = node.value;

        mut shadow = false;
        mut result: Target[];

        // Visit local scope.
        fn visitScope(items: [ScopeItem])
        {
            mut scope_iterator: i32;
            mut target: Target;
            while (!shadow && (target = items.search(
                :id, :scope_iterator, scope_skip: _ss_items)))
            {
                // Can't shadow here -
                //  shadowing works per signature,
                //   we can't just shadow everything by the same name in scope.
                result.push(target);
            }
        }

        visitScope(_scope.items);

        // TODO FIX:
        //  emit a regular lambda instead.
        if (node.flags & F_ACCESS)
        {
            // Iterate all visible types, this is slow.
            //  Alternatively we could just unwrap all of these things in
            //   module root scope but that'd slow everything else down.
            fn visitTypes(shadow module: Module)
                module.out.types.each(
                    |struct| visitScope(struct.items));

            // From this module ...
            visitTypes(module);

            // ... and all visible imports.
            _scope.imports.each(_ss_imports,
                |import| visitTypes(ctx.modules[import]));
        }

        //
        result || fail("No `fn " ~ id ~ "` in scope.");

        let type = Type(ValueType(quals: 0, modid: 0, canon: addroffn::packAddrOfFn(result)));
        return createEmpty(:type);
    }


    //

    fn evalTypeAnnot(node: Node, typeParams?: TypeParams): SolvedNode
    {
        fn T(i: i32 = 0) evalTypeAnnot(node.items[i], typeParams).type;

        if (node.kind == "call")
        {
            let items = node.items;
            if (items.len == 1)
            {
                if (node.value == "&")
                    return solved(node, add_ref(T, Lifetime_temporary));

                if (node.value == "&mut")
                    return solved(node, add_mutref(T, Lifetime_temporary));

                if (node.value == "[]")
                    return solved(node, createArray(T));
            }
            else if (items.len == 2)
            {
                if (node.value == "Map")
                    return solved(node, createMap(T(0), T(1)));
            }

            // TODO FIX kinda crappy
            // Watch out for noreturn.
            ////////////////////////////
                    _current_fn.tries++;
            defer   _current_fn.tries--;
            ////////////////////////////

            return solveCall(node);
        }
        else if (node.kind == "typeparam")
        {
            return solved(node, evalTypeParam(node.value, typeParams));
        }
        else if (node.kind == "arrlit" && node.items.len == 1)
        {
            // Slice.
            return solved(node, createSlice(T, Lifetime_temporary));
        }

        return fail("TODO evalTypeAnnot");
    }

    fn trySolveTypeParams(
        node: Node, mut type: Type, ref typeParams: TypeParams): bool
    {
        if (node.kind == "call")
        {
            let items = node.items;
            if (items.len)
            {
                if (items.len == 1)
                {
                    mut t   = node.value == "&"    ? tryClear_ref(type)
                            : node.value == "&mut" ? tryClear_mutref(type)
                            : node.value == "[]"   ? tryClear_array(type)
                            : fail("TODO trySolveTypeParams unary call");

                    if (!t)
                        return false;

                    return trySolveTypeParams(
                        items[0] || fail(), t, typeParams);
                }
                else if (items.len == 2)
                {
                    if (node.value == "Map")
                    {
                        let kv = tryClear_map(type);
                        if (!kv)
                            return false;

                        return trySolveTypeParams(items[0] || fail(), kv.key  , typeParams)
                            && trySolveTypeParams(items[1] || fail(), kv.value, typeParams);
                    }
                }
            }
            else
            {
                return isAssignable(
                    Scope_lookupType(node),
                        type);
            }
        }
        else if (node.kind == "typeparam")
        {
            let id = node.value || fail();

            // What is happening here?
            // This is crazy, no?
            ref _param = (typeParams[id] ||= Type);
            if (_param)
            {
                let inter = type_trySuper(_param, type);
                if (!inter)
                    return false;

                type = inter;
            }

            // TODO not here:
            //  we want to clear everything non-canonical from
            //   type params AFTER we solve & match the args,
            //    during the matching it shouldn't be necessary.
            //
            // After the match we need this to e.g. lift `non_zero`
            //  from integral results, etc.
            //
            _param = clear_refs(type);

            return true;
        }
        else if (node.kind == "arrlit" && node.items.len == 1)
        {
            // Slice.
            let t = tryClear_sliceable(type);
            return t && trySolveTypeParams(
                node.items[0] || fail(), t, typeParams);
        }

        return fail("TODO trySolveTypeParams fallthrough");
    }

    fn evalTypePattern(node: Node, ref typeParams: Map(string, Type)): bool
    {
        if (node.kind == "and")
        {
            for (mut i = 0; i < node.items.len; i++)
                if (!evalTypePattern(node.items[i], typeParams))
                    return false;

            return true;
        }
        else if (node.kind == "or")
        {
            for (mut i = 0; i < node.items.len; i++)
                if (evalTypePattern(node.items[i], typeParams))
                    return true;

            return false;
        }
        else if (node.kind == "typeassert")
        {
            let left  = node.items[0] || fail();
            let right = node.items[1] || fail();

            // We'll have to figure out the type tag nonsense at some point.
            //  Perhaps when we have an `any` type,
            //   we could subtype it with the desired quals.
            if (left.kind  == "typeparam" && right.kind == "typetag")
                return type_has(
                    evalTypeParam(left.value, typeParams),
                    right.value || fail("Falsy type tag."));
            else
            {
                let actual = evalTypeAnnot(left, typeParams).type;

                return trySolveTypeParams(
                    type: actual, node: right,
                        :typeParams);
            }
        }

        return fail("TODO evalTypePattern fallthrough: "
                    ~ node.kind ~ "(" ~ node.items.len ~ ")");
    }


    //

    fn createRead(id: string): Node
    {
        return Node(
            kind:   "call",
            value:  id,
            token:  (_here || fail()));
    }

    fn dequalify_andGetScope(ref id: string): &Scope
    {
        let split = id.find('\t');
            split >= 0 || fail();

        let fname = id.slice(0, split);
            id    = id.slice(split + 1);

        let other = findModule(fuzimport: fname);
        if (other.modid != module.modid)
            return other.out.solve.scope;

        return _scope;
    }

    fn solveCall(node: Node, target?!: Target): SolvedNode
    {
        mut id = node.value;
        if (!id) target || fail();

        // Qualified?
        let qualified = node.flags & F_QUALIFIED;
        let scope = qualified
            ? dequalify_andGetScope(id)
            : _scope;

        mut args = solveNodes(node.items, deadcode_on_never: true);

        // Dead code elim.
        if (args.if_last.type.is_never)
            return createBlock(node.token, t_never, args);

        //
        mut callTargIdx = match__mutargs(
            scope, !qualified && _ss_items,
            id, args, node.flags, :target);

        mut callTarg = GET(callTargIdx);

        // `using` codegen.
        while (callTarg.partial)
        {
            let unshift     = callTarg.kind == "p-unshift";

            let partial     = callTarg.partial  || fail();
            let viaIdx      = partial.via       || fail();
            callTargIdx     = partial.target    || fail();

            let via         = GET(viaIdx);
            callTarg        = GET(callTargIdx);

            // There's two things we can do here -
            //  -   either we're injecting an implicitly used local,
            //          e.g. the this pointer, or another `using` variable,
            //  -   or we're wrapping the head argument
            //          with another derefence or method call or whatever.

            // And that's all there is to `using`.
            mut innerArgs: SolvedNode[];
            if (!unshift)
                innerArgs = [ args[0] || fail() ];

            let argNode     = CallerNode(
                createRead("__partial"),
                via.type || fail(),
                viaIdx,
                innerArgs);

            //
            if (unshift)
                args.unshift(argNode);
            else
                args[0] = argNode;
        }

        //
        return CallerNode(
            node,
            callTarg.type || fail(),
            callTargIdx,
            args);
    }


    // I feel this should be a fncall instead of this here.
    //  It's varargs - so is it a template or what?

    fn solveArrayLiteral(node: Node, type: Type): SolvedNode
    {
        mut itemType = type && tryClear_array(type);

        // Default constructor calls.
        if (!itemType && type.isStruct)
            return solveCall(node,
                target: lookupStruct(type).target);

        // Nope, it's an array literal.
        mut items   = solveNodes(node.items, itemType);
        mut startAt = 0;

        if (!itemType && items.len)
        {
            let head = items[startAt++] || fail();
            itemType = clear_refs(head.type);
        }

        if (!itemType)
            return fail("Cannot infer empty arraylit.");

        for (mut i = startAt; i < items.len; i++)
        {
            itemType = type_trySuper(
                itemType, (items[i] || fail()).type);

            itemType || fail(
                "[array literal] No common supertype.");
        }

        //
        if (itemType.is_ref || itemType.lifetime)
            fail("Array items cannot be refs.");

        for (mut i = 0; i < items.len; i++)
            maybeCopyOrMove(items[i], itemType);

        return solved(node, createArray(itemType), items);
    }


    //

    fn createLet(target: Target, flags: i32 = 0): SolvedNode
    {
        let overload = GET(target);

        return SolvedNode(
            kind: "let", :flags, token: _here || fail(),
            value: overload.name, :overload.type, :target);
    }

    fn injectImplicitArg(id: string, type: Type, becauseOf!: Target): Target
    {
        _current_fn.items || fail(
            "No implicit `" ~ id ~ "` in scope, needed to call `" ~ GET(becauseOf).name ~ "`.");

        // Reuse existing or add new argnode.
        for (mut i = 0; i < _current_fn.items.len + FN_ARGS_BACK; i++)
        {
            let arg = _current_fn.items[i];
            if (arg.value == id)
            {
                checkAssignable(host: type, arg.type,
                    "Implicit arg collision", id);

                return arg.target || fail();
            }
        }

        // We'll be adding a new thing here.
        let newArgIdx   = _current_fn.items.len + FN_ARGS_BACK;

        /////////////////////////////////////////////////////
        // TODO obtain or persist this in the original scope.
        let scope0      = Scope_snap(_scope);
        let ret         = Binding(id, type, flags: F_IMPLICIT | F_ARG, kind: "arg");
        Scope_pop(_scope, scope0);
        /////////////////////////////////////////////////////

        let newArgNode  = createLet(ret, F_IMPLICIT);
        _current_fn.items.insert(newArgIdx, newArgNode);

        return ret;
    }

    fn bindImplicitArg(name: string, type: Type, becauseOf!: Target): SolvedNode
    {
        let id = name;
        mut args: SolvedNode[];

        let target = tryMatch__mutargs(_scope, _ss_items, :id, :args, retType: type)
            || injectImplicitArg(:id, :type, :becauseOf)
            || fail();

        let o = GET(target);
        o.flags & F_IMPLICIT || fail(
            "Matching a non-implicit item in scope: `" ~ name ~ "`, binds to call to `" ~ GET(becauseOf).name ~ "`.");

        return CallerNode(
            createRead("__implicit"), :o.type, :target);
    }


    //

    fn solveIf(node: Node, mut type: Type): SolvedNode
    {
        let cond    = solveNode(node.items[0], t_bool);

        // Dead code elim.
        if (cond.type.is_never)
            return cond;

        let n_cons  = node.items[1];
        let n_alt   = node.items[2];
        mut cons    = n_cons && solveNode(n_cons, type);
        mut alt     = n_alt  && solveNode(n_alt, !cons.type.is_never && cons.type || type);

        if (cons.type && alt.type)
        {
            if (!type.is_void)
            {
                type = type_trySuper(cons.type, alt.type) || fail(
                    "[if] No common supertype: `" ~ serializeType(cons.type) ~ " : " ~ serializeType(alt.type) ~ "`.");

                type.is_ref || !type.lifetime || fail("[if] stray lifetime");
                maybeCopyOrMove(cons, type);
                maybeCopyOrMove(alt,  type);
            }

            // Control flow.
            if (cons.type.is_never && alt.type.is_never)
                type = t_never;
        }
        else
        {
            type = t_void;
        }

        return solved(node, type || fail(), [ cond, cons, alt ]);
    }


    //////////////////////////////////////////////////
    // Logic                  .                     //
    //////////////////////////////////////////////////

    fn solveNot(node: Node): SolvedNode
    {
        return solved(
            node, t_bool,
                [ solveNode(node.items[0], t_bool) ]);
    }

    fn solveOr(node: Node, mut type: Type): SolvedNode
    {
        mut items = solveNodes(node.items, type, deadcode_on_never: true);
        if (items.len < 2)
            return items.only;

        // Statement mode.
        if (type.is_void)
            type = t_bool;

        // Unless this is an explicit bool context:
        if (!type.is_bool)
        {
            mut sumType: Type;
            mut hasNever = false;

            // Sum types, ignoring never.
            for (mut i = items.len; i --> 0; )
            {
                let item = items[i];
                if (item.type.is_never)
                {
                    hasNever = true;
                    continue;
                }

                // a && b || never: b can be mutref!
                let andLast = hasNever && item.kind == "and" && item.items && item.items[item.items.len - 1];
                let itemType = andLast && !andLast.type.is_never
                    ? andLast.type
                    : item.type;

                if (sumType)
                {
                    sumType = type_trySuper(sumType, itemType);
                    if (!sumType)
                        break;
                }
                else
                {
                    sumType = itemType;
                }
            }

            if (sumType)
            {
                // If we do have an intersection,
                //  and if the sum type is not a reference,
                //   some shit may need copying here.
                for (mut i = 0; i < items.len; i++)
                    maybeCopyOrMove(
                        items[i], sumType);

                type = sumType;
            }
            else
            {
                type = t_bool;
            }
        }

        return solved(node, type, items);
    }

    fn solveAnd(node: Node, mut type: Type): SolvedNode
    {
        let items = solveNodes(node.items, type, deadcode_on_never: true);
        if (items.len < 2)
            return items.only;

        // Statement mode.
        if (type.is_void)
            type = t_bool;

        // Unless this is an explicit bool context:
        if (!type.is_bool)
        {
            mut sumType: Type;

            // Last item type wins -
            //  unless it's never, which we can safely ignore.
            for (mut i = items.len; i --> 0; )
            {
                let item = items[i];
                if (item.type.is_never)
                    continue;

                if (sumType)
                {
                    sumType = type_trySuper(sumType, item.type);
                    if (!sumType)
                        break;
                }
                else
                {
                    type    = item.type;
                    sumType = item.type;
                }
            }

            if (sumType)
            {
                // All the types sum up -
                //  so this is an ok way to get a mutref:
                //   e.g. `mut &x = mut_expectFalsy && throw("someone already set this");`
                type = sumType;
            }
            else
            {
                // Nope, that didn't work.
                //  We can generate falsy values and refs,
                //   but not mutrefs - can't allocate
                //    a static mut and expect it to remain falsy.
                type = clear_mutref(type);
            }
        }

        // Because values remain values and refs remain refs,
        //  there's no copying/moving involved in an && chain.
        return solved(node, type, items);
    }


    //

    fn solved(
        node: Node, type: Type, items: SolvedNode[] = [], target = Target)
            : SolvedNode
    {
        return SolvedNode(
            kind:  node.kind ,
            flags: node.flags,
            value: node.value,
            token: node.token,

            :items, :type, :target);
    }

    fn createBlock(token: TokenIdx, type: Type, items: SolvedNode[]): SolvedNode
    {
        return SolvedNode(kind: "block", :type, :items, :token);
    }

    fn CallerNode(
        node: Node, mut type: Type, target: Target, mut args: SolvedNode[] = [])
            : SolvedNode
    {
        let overload = GET(target);

        // TODO FIX
        //  Ensures we notice noreturn fns.
        //   Implicit return void is caught in finalizeReturns on exit.
        if (!_current_fn.tries && !_current_fn.ret_count && overload.type.is_never && _current_fn)
            reportReturnType(t_never);

        // HACK -
        //  TBD how we make this stuff work in real life.
        //   OR alternatively, do this for arrays too.
        if (overload.kind == "field")
        {
            let head = args.len == 1 && args[0] || fail();
            let headType = head.type || fail();

            type = add_refs(from: headType, to: type);
        }

        // Tag copies and moves.
        else if (args)
        {
            let host_args = overload.args || fail("CallerNode: no host args.");
            for (mut i = 0; i < args.len; i++)
                maybeCopyOrMove(
                    args[i] || fail(), host_args[i].type,
                    isArgument: true);

            type.lifetime = Lifetime_replaceArgsAtCallsite(overload, args);
        }

        // Track deps.
        if (target.modid == module.modid)
        {
            // Tracking call graph & type annotations.
            if (overload.kind == "fn" || overload.kind == "type")
            {
                ref t = GET_mut(target);

                if (_current_struct)
                    GET_mut(target).used_by.set::add(
                        _current_struct.index);
                else
                    t.used_by.set::add(
                        _current_fn.target.index);
            }

            // Robust closure tracking.
            if (_current_fn)
            {
                let o = GET(target);
                if (o.flags & F_LOCAL)
                    _current_fn.locals_used.set::add(target.index);

                _current_fn.locals_used.set::add(o.closes_over);
            }
        }

        //
        mut out = solved(node, type, args);
        out.target = target;
        return out;
    }

    fn maybeCopyOrMove(ref node: SolvedNode, slot: Type,
        isArgument = false): void
    {
        // Clear mutrefs unless needed.
        if !(slot.is_mutref)
            node.type = clear_mutref(node.type);

        // No copy needed when the slot is a reference.
        if (slot.is_ref)
        {
            // Except if we're talking a fnarg,
            //  in which case we're better off binding a temporary,
            //   else we risk cache missing on the useless global defval.
            if (node.kind == "definit" && isArgument)
                node.type = clear_refs(node.type);

            return;
        }

        // Also, no copy needed when the expression is a value.
        if (!node.type.is_ref)
            return;

        // Definits can just as well emit values.
        if (node.kind == "definit")
        {
            node.type = clear_refs(node.type);
            return;
        }

        if !(slot.quals & q_rx_copy)
            fail("Needs an explicit STEAL or CLONE.");

        if (!USE_nontriv_autocopy && !(node.type.quals & q_trivial))
            fail("Non-trivial implicit copy.");

        // Here we go.
        node = createCopy(node);
    }

    fn createCopy(node: SolvedNode): SolvedNode
        SolvedNode(
            kind:   "copy",
            items:  [ node ],
            token:  node.token,
            type:   clear_refs(node.type));

    fn createMove(node: SolvedNode, nrvo = false): SolvedNode
        SolvedNode(
            kind:   nrvo ? "nrvo" : "move",
            items:  [ node ],
            token:  node.token,
            type:   clear_refs(node.type));


    //

    fn solveNodes(
        nodes: Node[],
        type_all?: Type, type_last?!: Type,
        use_type_last?!: bool,
        TEMP_open_templates?!: bool,
        TEMP_template_scope?!: ScopeMemo,
        deadcode_on_never?: bool): SolvedNode[]
    {
        mut result: SolvedNode[];

        ////////////////////////////////////////////////////////
        let here0   = _here;
        defer _here = here0;
        ////////////////////////////////////////////////////////

        result.resize(nodes.len);

        let open_templates0 = _open_templates.len;

        ////////////////////////////
        mut resolve0 = SLOW_resolve;

        fn resolve_ALL()
        {
            if (!TEMP_open_templates)
                return;

            mut some = SLOW_resolve != resolve0
                    && SLOW_resolve != resolve_done;

            while (some)
            {
                some = false;

                ////////////////////////
                resolve0 = SLOW_resolve;
                ////////////////////////

                for (shadow mut i = open_templates0; i < _open_templates.len; i++)
                {
                    let r = _open_templates[i];
                    if (!resolveIfNeeded(r))
                        continue;

                    some = SLOW_resolve != resolve0
                        && SLOW_resolve != resolve_done;
                }
            }

            // Also freeze templates.
            freezeTemplates(TEMP_template_scope, :open_templates0);
        }

        //
        for (mut i = 0; i < nodes.len; i++)
        {
            let node = nodes[i];
            if (!node)
                continue;

            // Regular solve.
            mut unorderedClass = unorderedClassify(node.kind);
            if (!unorderedClass)
            {
                _here       = node.token || _here;

                ref solved  =
                result[i]   = solveNode(:node, type:
                    i == nodes.len - 1 && use_type_last
                        ? type_last : type_all);

                // Dead code elim.
                if (deadcode_on_never && solved.type.is_never)
                {
                    result.shrink(i + 1);
                    break;
                }

                continue;
            }

            // Unordered solve -
            //  batches multiple potentially recursive declarations,
            //   so we can expose them all in scope prior to solving types.

            // This allows us to have groups of mutually recursive types & functions,
            //  without risking stuff depending on constants & variables
            //   introduced halfway through.
            let i0 = i;
            mut i1 = nodes.len;

            // First pass, expose stuff in scope
            //  without doing type checking when possible.
            for (shadow mut i = i0; i < nodes.len; i++)
            {
                shadow let node = nodes[i] || fail("solveNodes, prep-a: falsy node");
                if (unorderedClassify(node.kind) != unorderedClass)
                {
                    i1 = i;
                    break;
                }

                _here = node.token || _here;
                result[i] = unorderedPrep_A(node);
            }

            // Later we'll continue from group end.
            i1 > i0 || fail();
            i = i1 - 1; // <- loop++

            // Second prep pass, limit access to scope
            //  of all newly generated entries to what we have right now.
            for (shadow mut i = i0; i < i1; i++)
            {
                shadow let node = nodes[i] || fail("solveNodes, prep-b: falsy node");
                _here = node.token || _here;
                unorderedPrep_B(:node, result[i].target);
            }

            // TODO REMOVE, solve all.
            for (shadow mut i = i0; i < i1; i++)
            {
                shadow let node = nodes[i] || fail("solveNodes, solve: falsy node");
                _here = node.token || _here;
                let into = result[i].target;
                result[i] = into && unorderedSolve(:node, :into);
            }

            // Exhaust the resolve queue here, unless this is the last iter ...
            if (i != nodes.len - 1)
                resolve_ALL();
        }

        // ... which we resolve here.
        resolve_ALL();

        return result;
    }

    fn freezeTemplates(scope0: ScopeMemo, open_templates0!: i32)
    {
        for (mut i = _open_templates.len; i --> open_templates0; )
        {
            let ot = _open_templates[i];
            if (scope0)
            {
                let p = GET(ot.overloadIdx || ot.spec);
                if !(p.template.scope_memo > scope0)
                    continue;
            }

            ref o = GET_mut(ot.spec);
            {
                o.status & SS_DIRTY && fail(
                    "freezeTemplates: attempting to freeze a dirty template.");

                o.status |= SS_FINALIZED;
                _open_templates.splice(i, 1);
            }
        }
    }

    fn resolveIfNeeded(ot: OpenTemplate): bool
    {
        let overload = GET(ot.spec);
        if !(overload.status & SS_DIRTY)
            return false;

        GET_mut(ot.spec).status &= ~SS_DIRTY;
        resolve_done++;

        //////////////////
        let here0 = _here;
        _here = overload.template.node.token;
        //////////////////

        if (ot.overloadIdx)
            doTrySpecialize(
                // TODO figure out how to collapse this in the bottom branch
                //  we shouldn't need to resolve the signature.
                //   so this is both risky and wasteful.
                :ot.overloadIdx, ot.args00, ot.mangle00, into: ot.spec);
        else
            unorderedSolve(
                overload.template.node,
                into: overload.solved.target);

        //////////////
        _here = here0;
        //////////////

        return true;
    }


    // SOLVE END

    // Import prelude / inject builtins.
    if (module.modid)
    {
        // Ensure can't reimport self.
        _scope.imports ~= module.modid;

        // Load prelude.
        _Scope_import__forceCopy(0);
    }
    else
    {
        // Pre-populate prelude with primitive types and such.
        _scope = listGlobals();
    }

    // Solve.
    {
        let root = solveNode(parse);

        _current_fn && fail("non-empty _current_fn.");
        SLOW_resolve == resolve_done || fail("Some overload was left dirty.");
        _open_templates && fail("Some template was left open.");

        // Run the thing.
        return SolverOutput(:root,
            scope: Scope_exports(_scope, :module.modid),
            :SLOW_resolve);
    }
}
