
let OPTOKENS = "{}[]()!?~@#$%^&*/-+<=>,.;:|";

let MBOPS =
[
    "++", "--",
    "**",
    "<<", "<<<", ">>", ">>>",
    "===", "==", "!=", "!==", "<=", ">=",
    "=>", "->", "<=>", "|>", "<|",
    "??",
    "..", "...", "::",
    "&&", "||", "[]",
    "+=", "-=", "*=", "**=", "/=", "%=",
    "&=", "|=", "^=", "<<=", ">>=", "~=",
    "&&=", "||=",
    ".=",
];

pub struct Token
{
    kind:   string;
    value:  string;

    idx0:   i32;
    idx1:   i32;
    line:   i32;
    col:    i32;
};

pub struct LexerOutput
{
    fname:  string;
    tokens: Token[];
};

pub fn lex(src: string, fname: string): LexerOutput
{
    let end     = src.len;
    mut line    = 1;
    mut lidx    = -1;
    mut idx     = 0;

    mut tokens: Token[];

    fn token(kind: string, value: string, idx0: i32, idx1: i32)
    {
        let col = idx0 - lidx;

        tokens.push(
            Token( :kind, :value, :idx0, :idx1, :line, :col ));
    }

    // Start token, so that no legit token has index 0.
    token(
        "sof", "sof",
        idx, idx);

    fn err_str(kind: string, idx0: i32, reason: string)
    {
        // exit to nearest whitespace
        while (idx < end && src[idx] > ' ')
            idx++;

        let col = idx0 - lidx;
        let value = src.slice(idx0, idx);

        throw("LEX ERROR: " ~ fname ~ "@" ~ line ~ ":" ~ col
            ~ ":\n\t" ~ reason
            ~ "\n\t" ~ kind ~ ": `" ~ value ~ "`");
    }

    fn err(kind: string, idx0: i32, reason: i32)
    {
        err_str(kind, idx0, "`" ~ src[reason] ~ "`");
    }

    fn unescapeStr(esc: string, idx0: i32, idx1: i32): string
    {
        mut out = "";

        let n = idx1 - 1;
        for (mut i = idx0 + 1; i < n; i++)
        {
            let c = esc[i];
            if (c == '\\')
            {
                let c1 = esc[++i];

                if      (c1 == '\\') out ~= '\\';

                else if (c1 ==  'n') out ~= '\n';
                else if (c1 ==  'r') out ~= '\r';
                else if (c1 ==  't') out ~= '\t';
                else if (c1 ==  'f') out ~= '\f';
                else if (c1 ==  'v') out ~= '\v';

                else if (c1 ==  '0') out ~= '\0';
                else if (c1 ==  'a') out ~= '\a';
                else if (c1 ==  'b') out ~= '\b';
                else if (c1 ==  'e') out ~= '\e';

                else                out ~= c1;
            }
            else
            {
                out ~= c;
            }
        }

        return out;
    }

    while (idx < end)
    {
        let idx0 = idx;
        let c = src[idx++];

        // whitespace
        if (c <= ' ')
        {
            if (c == '\n')
            {
                line++;
                lidx = idx - 1;
            }
        }

        // identifiers & keywords
        else if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z' || c == '_')
        {
            while (idx < end)
            {
                shadow let c = src[idx++];
                if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z' || c == '_' || c >= '0' && c <= '9')
                {
                    //
                }
                else
                {
                    idx--;
                    break;
                }
            }

            let idx1 = idx;

            token(
                "id", src.slice(idx0, idx1),
                idx0, idx1);
        }

        // numeric literals
        else if (c >= '0' && c <= '9')
        {
            mut hex = false;
            mut dot = false;
            mut exp = false;

            mut ob = false;
            mut max = '9';

            if (c == '0')
            {
                shadow let c = idx < end && src[idx];
                if (c == 'x' || c == 'X')
                {
                    hex = true;
                    idx++;
                }
                else if (c == 'o' || c == 'O')
                {
                    ob = true;
                    max = '7';
                    idx++;
                }
                else if (c == 'b' || c == 'B')
                {
                    ob = true;
                    max = '1';
                    idx++;
                }
                else if (c >= '0' && c <= '9')
                {
                    err_str("real", idx0,
                        "Leading `0` in numeric literal,"
                            ~ " perhaps you meant `0x`, `0b` or `0o`.");
                }
            }

            while (idx < end)
            {
                shadow let c = src[idx++];
                if (c >= '0' && c <= max
                      || hex && (c >= 'a' && c <= 'f'
                             || (c >= 'A' && c <= 'F')))
                {
                    // Looks good.
                }
                else if (ob)
                {
                    idx--;
                    break;
                }
                else if (c == '.')
                {
                    // Don't munch dots unless followed by a digit -
                    //  So you can"t do 1.e1 but that"s the same as 1e1 or 1.0e1.

                    shadow let c = idx < end && src[idx];
                    if !(c >= '0' && c <= '9'
                           || hex && (c >= 'a' && c <= 'f'
                                  || (c >= 'A' && c <= 'F')))
                    {
                        idx--;
                        break;
                    }

                    if (dot || exp)
                    {
                        err("real", idx0, idx - 1);
                        break;
                    }

                    dot = true;
                }
                else if (hex ? c == 'p' || c == 'P'
                             : c == 'e' || c == 'E')
                {
                    if (exp)
                    {
                        err("real", idx0, idx - 1);
                        break;
                    }

                    if (idx < end && (src[idx] == '-' || src[idx] == '+'))
                        idx++;

                    exp = true;
                }
                else
                {
                    idx--;
                    break;
                }
            }

            let trail = src[idx - 1];
            if (!(trail >= '0' && trail <= '9') &&
                !(hex && (trail >= 'a' && trail <= 'f'
                       || trail >= 'A' && trail <= 'F')))
            {
                err("real", idx0, idx - 1);
            }
            else
            {
                let idx1 = idx;
                let str = src.slice(idx0, idx1);

                if (hex && dot && !exp)
                {
                    err_str("real", idx0,
                        "The exponent is never optional"
                            ~ " for hexadecimal floating-point literals.");
                }
                else
                {
                    token(
                        dot || exp ? "real" : "int",
                        helpers::ascii_lower(str),
                        idx0, idx1);
                }
            }
        }

        // string literals
        else if (c == '\'' || c == '"' || c == '`')
        {
            mut esc = false;
            mut ok  = false;

            while (idx < end)
            {
                let c1 = src[idx++];
                if (c1 == c)
                {
                    ok = true;
                    break;
                }
                else if (c1 == '\\')
                {
                    esc = true;
                    idx++;
                }
                else if (c1 == '\n')
                {
                    line++;
                    lidx = idx - 1;
                }
            }

            if (!ok)
            {
                err_str("str", idx0, "Unterminated string literal.");
            }
            else
            {
                let idx1 = idx;
                let str  = esc  ? unescapeStr(src, idx0, idx1)
                                : src.slice(idx0 + 1, idx1 - 1);

                let char = c == '\'';
                let kind = char ? "char" : "str";

                if (char && str.len != 1)
                {
                    err_str("char", idx0,
                        "Char literal len != 1: " ~ str.len);
                }
                else
                {
                    token(
                        kind, str,
                        idx0, idx1);
                }
            }
        }

        // comments
        else if (c == '/' && idx < end && src[idx] == '/')
        {
            idx++;
            while (idx < end)
            {
                let c1 = src[idx++];
                if (c1 == '\n')
                {
                    line++;
                    lidx = idx - 1;
                    break;
                }
            }
        }

        // multiline comments
        else if (c == '/' && idx < end && src[idx] == '*')
        {
            idx++;
            while (idx < end)
            {
                shadow let c = src[idx++];
                if (c == '\n')
                {
                    line++;
                    lidx = idx - 1;
                }
                else if (c == '*' && idx < end && src[idx] == '/')
                {
                    idx++;
                    break;
                }
            }
        }

        // operators
        else if (OPTOKENS.has(c))
        {
            mut candidate: string = [ c ];

            while (idx < end)
            {
                shadow let c = src[idx++];
                if (OPTOKENS.has(c))
                {
                    let c1 = candidate ~ c;
                    if (MBOPS.has(c1))
                    {
                        candidate = c1;
                        continue;
                    }
                }

                idx--;
                break;
            }

            token(
                "op", candidate,
                idx0, idx);
        }

        // dunno
        else
        {
            err("?", idx0, idx0);
        }
    }

    // end of file token
    line++;
    lidx = idx + 0;

    token(
        "eof", "eof",
        idx, idx);

    // err, data
    return LexerOutput( :fname, :tokens );
}
