
enum kind
{

    // -- -- -- -- Lexeme:
    // LexerOnly:
    sof
    err
    eof

    id
    op
    // /LexerOnly

    // AffineExpression:
    // -- LinearExpression:
    // -- -- ValueExpression:
    // -- -- -- Literal:
    int
    real
    char
    str
    bool
    // -- -- -- -- /Lexeme
    // -- -- -- /Literal

    copy
    move
    arrlit
    definit

    empty
    // -- -- /ValueExpression

    not
    call
    argid
    // -- /LinearExpression

    root
    block

    // -- ControlFlow:
    if
    or
    and
    // /AffineExpression

    loop

    jump
    __far_jump

    defer
    try
    // -- /ControlFlow

    let
    letdef

    typecast
    typeassert
    typeparam

    unwrap
    pragma

    // ParseOnly_JumpKind:
    break
    return
    continue
    // /ParseOnly_JumpKind

    // ParseOnly_Placeholder:
    import
    addroffn
    forfieldsof
    // /ParseOnly_Placeholder

    // TypeDecl:
    struct
    union

    primitive
    flags
    enum
    // /TypeDecl

    members

    fndef
    fn

    fnbranch
    pattern

    typeunion
    typetag


    // Solver: extra node kinds.

    __relaxed
    __convert
    __preceding_ref_arg


    // Scope: overload types.

    __no_kind_yet
    __tombstone
    type
    var
    field
    enumv
    template
    __native
    inline
}
