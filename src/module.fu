

//

pub nocopy struct Context
{
    modules: Module[];

    // FS facts.
    files: map::Map(string, string);
    fuzzy: map::Map(string, string);
};

pub struct Module
{
    modid:      i32;
    fname:      string;

    in?:        ModuleInputs;
    out?:       ModuleOutputs;
    stats?:     ModuleStats;
};

pub struct ModuleInputs
{
    src:        string;
    lex:        LexerOutput;
    parse:      ParserOutput;
};

pub struct ModuleOutputs
{
    deps:       i32[];
    types:      Struct[];
    solve:      SolverOutput;
    cpp:        CodegenOutput;

    // Static init depth.
    init_prio:  i32;
};

pub struct ModuleStats
{
    lex:        stat::ModuleStat;
    parse:      stat::ModuleStat;
    solve:      stat::ModuleStat;
    codegen:    stat::ModuleStat;
};


//

pub struct Struct
{
    name:       string;

    target?:    Target;
    items?:     ScopeItem[];
    imports?:   i32[];
    converts?:  Target[];

    flat_cnt?:  i32;
    all_triv?:  bool;
};


//

pub struct LexerOutput
{
    tokens:     Token[];
};

pub struct ParserOutput
{
    root:       Node;
    fuzimports: string[];
    warnings:   string[];
}

pub struct SolverOutput
{
    root:       SolvedNode;
    scope:      Scope;

    // Important solver events for testing.
    notes:      i32;
};

pub struct CodegenOutput
{
    using src:  string;
};


//

pub struct Token
{
    true kind:  string;
    value:      string;

    idx0:       i32;
    idx1:       i32;
    line:       i32;
    col:        i32;
};


//

pub struct Node
{
    true kind:  string;
    flags?:     i32;
    value:      string;
    items?:     Node[];
    token:      TokenIdx;
};

pub struct TokenIdx
{
    modid:      i32;
    tokidx:     i32;
};


//

pub struct Target
{
    modid:      i32;
    index:      i32;
}

pub struct SolvedNode
{
    signedidx!: i32;
}

pub struct RWRanges
{
    reads0:     i32;
    reads1:     i32;
    writes0:    i32;
    writes1:    i32;
}

pub struct SolvedNodeData
{
    true kind:  string; // TODO enum, will save so many string copies

    helpers:    i32;    // TODO not here: I had room for it, but honestly this is not the best place for this.
    flags:      i32;    //  Ideally both should go, flags is a very leaky thing on solved AST.

    value:      string;
    items:      SolvedNode[];
    token:      TokenIdx;

    using type: Type;
    target:     Target;

    using rwr?: RWRanges;
}


//

pub struct ScopeItem
{
    true id:    string;
    modid:      i32;
    packed:     u32;
};

pub nocopy struct Scope
{
    overloads:  Overload[];
    extended:   Extended[];

    items:      ScopeItem[];
    implicits:  ScopeItem[];
    imports:    i32[];
    privates:   i32[];
    usings:     Target[];
    converts:   Target[];

    pub_items:  i32;
    pub_cnvrts: i32;
};


//

pub struct Template
{
    true node:  Node;
    imports:    i32[];

    scope_memo: ScopeMemo;
    scope_skip: ScopeSkipMemos;
};

pub struct ScopeMemo
{
    items_len:      i32;
    implicits_len:  i32;
    imports_len:    i32;
    privates_len:   i32;
    usings_len:     i32;
    converts_len:   i32;
    helpers_len:    i32;
};

pub struct ScopeSkipMemos
{
    // TODO FIX should not be exported,
    //  this is due to templates but exported templates dont skip

    items:      ScopeSkip[];
    implicits:  ScopeSkip[];
    imports:    ScopeSkip[];
    privates:   ScopeSkip[];
    usings:     ScopeSkip[];
    converts:   ScopeSkip[];
    helpers:    ScopeSkip[];
};

pub struct ScopeSkip
{
    // TODO FIX should not be exported,
    //  this is due to templates but exported templates dont skip

    start:  i32;
    end:    i32;
};


//

pub struct Partial
{
    via:        Target;
    target:     Target;
};

pub struct Argument
{
    name?:          string;
    autocall?:      string;

    using type?:    Type;
    default?:       SolvedNode;
    flags?:         i32;
    local?:         i32;

    // subset_at_risk: bitset::BitSet;
    risk_free?:     bitset::BitSet;
};

pub struct Overload
{
    true kind:      string;
    name:           string;
    type:           Type;

    flags:          i32;

    // Solver state.
    status?:        u32;

    solved:         SolvedNode;
};

pub struct Extended
{
    // For locals, if non-zero, index of enclosing fn, obviously same modid.
    local_of:       i32;
    revision:       i32;

    // Arity.
    min:            i32;
    max:            i32;
    args:           Argument[];

    // The scopeskips here aren't needed in global scope (e.g. anything imported).
    spec_of?:       Target;
    template:       Template;

    // The new nodelists.
    nodes?:         SolvedNodeData[];
    locals?:        Overload[];

    // These are single-module-solve-only, no need to keep them here.
    extra_items?:   ScopeItem[];
    callers?:       i32[];
};


//

pub struct ValueType
{
    quals:          i32;
    canon:          string;
};

pub struct Type
{
    using vtype:    ValueType;
    lifetime?:      Lifetime; // Excluding this from the truth check feels dangerous
};

pub struct Lifetime { uni0n!: Region[]; };

pub struct Region { index!: i32; };
