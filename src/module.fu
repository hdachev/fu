

//

nocopy struct Context
{
    modules:    Module[];
    dep_order:  i32[];

    // FS facts.
    files:      typeof( map::Map(string, string) );
    fuzzy:      typeof( map::Map(string, string) );
};

struct Module
{
    modid:      i32;
    fname:      string;

    in?:        ModuleInputs;
    order?:     ModuleOrder;
    out?:       ModuleOutputs;
    stats?:     ModuleStats;
};

struct ModuleInputs
{
    src:        string;
    lex:        LexerOutput;
    parse:      ParserOutput;
};

struct ModuleOrder
{
    dep_depth:  i32;
};

struct ModuleOutputs
{
    types:      Struct[];
    solve:      SolverOutput;
    cpp:        CodegenOutput;
};

struct ModuleStats
{
    lex:        stat::ModuleStat;
    parse:      stat::ModuleStat;
    solve:      stat::ModuleStat;
    codegen:    stat::ModuleStat;
};


//

struct Struct
{
    ::kind;
    name:       string;

    target?:    Target;
    items?:     ScopeItem[];
    imports?:   i32[];
    converts?:  Target[];

    base?:      string;
    flat_cnt?:  i32;
    all_triv?:  bool;
};


//

struct LexerOutput
{
    tokens:     Token[];
};

struct ParserOutput
{
    root:       Node;
    fuzimports: string[];
    warnings:   string[];
}

struct SolverOutput
{
    root:       SolvedNode;
    scope:      Scope;

    // Important solver events for testing.
    notes:      flags::SolverNotes;
};

struct CodegenOutput
{
    using src:  string;

    // Libraries and such.
    link?:              string[];
    include_dirs?:      string[];
    extra_sources?:     string[];

    // Live exports.
    live?:              i32[];

    //
    defects?:           flags::CGDefects;
};


//

struct LineColChars
{
    line:       i32;
    col:        i32;
    chars:      i32;
};

struct Token
{
    true        ::kind;
    using lcc:  LineColChars;
    value:      string;
};


//

struct Node
{
    true        ::kind;
    asserts?:   flags::DeclAsserts;
    syntax?:    flags::ParseSyntax;

    flags?:     flags::Flags;
    value:      string;
    items?:     Node[];
    token:      TokenIdx;
};

struct TokenIdx
{
    modid:      i32;
    tokidx:     i32;
};


//

struct Target
{
    modid:      i32;
    index:      i32;
}

struct Local
{
    // modid: -this.fn, this is a fn-local.
    index:      i32;
}

struct RWRanges
{
    reads0:     i32;
    reads1:     i32;
    writes0:    i32;
    writes1:    i32;
}

struct Helpers
{
    index:      i32;
};

struct SolvedNode
{
    true            ::kind;

    helpers:        Helpers; // TODO not here: I had room for it, but honestly this is not the best place for this.
    flags:          flags::Flags;
    _loop_start?:   i32;

    value:          string;
    items:          SolvedNode[];
    token:          TokenIdx;

    using type:     Type;
    target:         Target;

    using rwr?:     RWRanges;
}


//

struct ScopeItem
{
    true id:        string;
    modid:          i32;
    packed:         u32;
};

nocopy struct Scope
{
    overloads:      Overload[];
    extended:       Extended[];

    items:          ScopeItem[];
    implicits:      ScopeItem[];
    imports:        i32[];
    privates:       i32[];
    usings:         Target[];
    converts:       Target[];

    pub_items:      i32;
    pub_cnvrts:     i32;
};


//

struct Template
{
    true node:      Node;
    imports:        i32[];
};


//

struct Argument
{
    name?:          string;
    autocall?:      string;

    using type?:    Type;
    default?:       SolvedNode;
    flags?:         flags::Flags;
    local?:         i32;

    // Arguments at risk -
    //  This is the borrow checker's global component.
    //
    // Soft vs hard risk:
    //
    //  - soft risk means it's ok if args alias,
    //     unless writes to the other argument
    //      invalidate this argument's binding.
    //
    soft_risk?:     bitset::BitSet;
    //
    //  - hard risk means it's never ok for these args to alias,
    //     which means we're relying on a derived expr from this arg
    //      after writing to the other argument.
    //
    //  - hard risk is symmetric,
    //     no point in flagging it on both args.
    //
    //  - the old risk-free stuff would only flag the item on the higher arg,
    //     but i'm starting to think that we should only set the flags on the
    //      arguments that get written to and invalidate the others,
    //       this means that we only need to flag the mutrefs.
    //
    hard_risk?:     bitset::BitSet;
};

struct Overload
{
    true            ::kind;

    flags:          flags::Flags;
    status?:        flags::SolverStatus;

    name:           string;

    type:           Type;

    solved:         SolvedNode;
};

struct Extended
{
    // For locals, if non-zero, index of enclosing fn, obviously same modid.
    local_of:       i32;
    revision:       u32;

    // Arity.
    min:            i32;
    max:            i32;
    args:           Argument[];

    // The scopeskips here aren't needed in global scope (e.g. anything imported).
    spec_of?:       Target;
    true template:  Template;

    // The new nodelists.
    locals?:        Overload[];

    // Previously we appended a fns signature hash to its name,
    //  now we'll do this in the codegen.
    //
    // But this could also be used for some kind of content addressed code thing,
    //  TBD where we can take this, deduplicate identical functions or something.
    //
    sighash?:       string;

    //
    fx_mask?:       effects::FxMask;
};


//

struct ValueType
{
    quals:          i32;
    canon:          string;
};

struct Type
{
    using vtype:    ValueType;
    lifetime?:      Lifetime; // Excluding this from the truth check feels dangerous
    vfacts?:        VFacts;
};

struct Lifetime { using uni0n!: Region[]; };

struct Region { index!: i32; };


// Instead of this we'd have a string listing qualities,
//  known value ranges, etc, but this should be enough to get the basics set it.

flags VFacts
{
    AlwaysTrue
    AlwaysFalse
    COWUnique
};
