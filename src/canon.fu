import helpers;


// TODO FIX Approximating unions & intersections.

pub fn canon_tryIntersect(a: string, b: string)
{
    if (a.len < b.len)
        return canon_tryIntersect(b, a);

    return isCanonAssignable(host: a, b) && a;
}

pub fn canon_trySuper(a: string, b: string)
{
    if (a.len > b.len)
        return canon_trySuper(b, a);

    return isCanonAssignable(host: a, b) && a;
}


// This is like string.find,
//  but skips over parenthesized groups,
//   however deeply nested. We use it to scan for '|' and ':' below.

fn scan(str: [byte], sep: byte,
    ref offset: i32,
    ref isLast: bool): bool
{
    mut isDeep = false;
    mut depth = 0;

    :SCAN
    {
        for (; offset < str.len; offset++)
        {
            let c = str[offset];
            if (c == '(') {
                depth++;
                isDeep = true;
            }
            else if (c == ')') {
                depth--;
            }
            else if (c == sep && !depth) {
                break :SCAN;
            }
        }

        isLast = true;
    }

    return isDeep;
}


// This parses (a|b|c) patterns,
//  invoking visit with each a, b and c subpattern.

pub fn eachSubPattern(pattern: [byte], visit)
{
    mut offset  = 0;
    for (;;)
    {
        let mi      = pattern.parseMi(:offset);
        let start   = offset;

        mut isLastSubPattern: bool;
        lax let isDeep = pattern.scan('|',
            :offset, isLastSubPattern);

        visit(pattern[start : offset], :mi,
            isDeep?: isDeep, isLast?: isLastSubPattern);

        if (isLastSubPattern)
            break;

        offset++;
    }
}

pub fn tryGetPattern(canon: [byte])
{
    return canon.ends(with: ')') // Same as below
        && canon[canon.find('(') + 1 : canon.len - 1];
}

pub fn isCanonAssignable(host: [byte], guest: [byte])
{
    let guestHasPatterns = guest.ends(with: ')');

    // Early exit #1:
    //  If guest is not generic, we match by canon.
    //
    if (!guestHasPatterns)
        return host == guest;

    let g0 = guest.find('(') + 1;
    let g1 = guest.len - 1;

    // Early exit #2:
    //  If host is not generic, we gotta match by canon.
    //   This can result from adding generic labels to non-generic types,
    //    should work just fine.
    //
    let hostHasPatterns = host.ends(with: ')');
    if (!hostHasPatterns)
        return host == guest[0 : g0];

    let h0 = host.find('(') + 1;
    let h1 = host.len - 1;

    // Early exit #3:
    //  If base types mismatch, we abort immediately.
    //
    if (host[0] != guest[0])
        return false;

    // For each host subpattern,
    //  ensure there's at least one matching guest subpattern.
    //
    eachSubPattern(host[h0 : h1]): |shadow host, isDeep!hostDeep, mi!hostTemplateId|
    {
        // TODO replace this with continue :NEXT_HOST_PAIR -
        //  currently continues don't appear to work for nested lambdas,
        //   see `for_fn` failcase.
        //
        :HOST_PAIR_OK
        {
            eachSubPattern(guest[g0 : g1]): |shadow guest, isDeep!guestDeep, mi!guestTemplateId|
            {
                // Both need to be specs of the same template.
                if (guestTemplateId != hostTemplateId)
                    continue;

                // We can speed this up if there are no nested patterns ...
                if (!hostDeep && !guestDeep)
                {
                    // ... in which case spec-args must be exactly the same.
                    if (host == guest)
                        break :HOST_PAIR_OK;
                }

                // Else we gotta canon-compare each spec-arg pair individually.
                else if (hostDeep && guestDeep)
                {
                    shadow mut h1 = 0;
                    shadow mut g1 = 0;

                    // We split-zip the two spec-arg sequences here.
                    for (;;)
                    {
                        // First spec-args begins on a : after the template-id,
                        //  that's why we increment this on the first loop iter.
                        h1++;
                        g1++;

                        shadow let h0 = h1;
                        shadow let g0 = g1;

                        mut isLastHostPair:  bool;
                        mut isLastGuestPair: bool;

                        host .scan(':', h1, isLastHostPair);
                        guest.scan(':', g1, isLastGuestPair);

                        // The two spec-arg-sets must be equal-length.
                        if (isLastHostPair != isLastGuestPair)
                            break;

                        let hostItem  = host [h0 : h1];
                        let guestItem = guest[g0 : g1];
                        if (isCanonAssignable(hostItem, guestItem))
                            break :HOST_PAIR_OK;
                    }
                }
            }

            // Unless you break :HOST_PAIR_OK -
            return false;
        }
    }

    // All host pairs matched.
    return true;
}
