import helpers;

fn isCanonAssignable(host: [byte], guest: [byte])
{
    let guestHasPatterns = guest.ends(with: ')');

    // Early exit #1:
    //  If guest is not generic, we match by canon.
    //
    if (!guestHasPatterns)
        return host == guest;

    let g0 = guest.find('(') + 1;
    let g1 = guest.len - 1;

    // Early exit #2:
    //  If host is not generic, we gotta match by canon.
    //   This can result from adding generic labels to non-generic types,
    //    should work just fine.
    //
    let hostHasPatterns = host.ends(with: ')');
    if (!hostHasPatterns)
        return host == guest[0 : g0];

    let h0 = host.find('(') + 1;
    let h1 = host.len - 1;

    // Early exit #3:
    //  If base types mismatch, we abort immediately.
    //
    if (host[0] != guest[0])
        return false;


    // This is like string.find,
    //  but skips over parenthesized groups,
    //   however deeply nested. We use it to scan for '|' and ':' below.

    fn scan(str: [byte], sep: byte,
        ref offset: i32,
        ref isLast: bool): bool
    {
        mut isDeep = false;
        mut depth = 0;

        :SCAN
        {
            for (; offset < str.len; offset++)
            {
                let c = str[offset];
                if (c == '(') {
                    depth++;
                    isDeep = true;
                }
                else if (c == ')') {
                    depth--;
                }
                else if (c == sep && !depth) {
                    break :SCAN;
                }
            }

            isLast = true;
        }

        return isDeep;
    }


    // This parses (a|b|c) patterns,
    //  invoking visit with each a, b and c subpattern.

    fn eachSubPattern(pattern: [byte], visit)
    {
        mut offset  = 0;
        for (;;)
        {
            let start = offset;

            mut isLastSubPattern: bool;
            mut isDeep: bool = pattern.scan('|',
                :offset, isLastSubPattern);

            visit(pattern[start : offset], :isDeep);

            if (isLastSubPattern)
                break;

            offset++;
        }
    }


    // For each host subpattern,
    //  ensure there's at least one matching guest subpattern.

    eachSubPattern(host[h0 : h1]): |shadow host, isDeep!hostDeep|
    {
        shadow mut h1 = 0;
        let hostTemplateId = parseMi(host, offset: h1);

        // TODO replace this with continue :NEXT_HOST_PAIR -
        //  currently continues don't appear to work for nested lambdas,
        //   see `for_fn` failcase.
        //
        :HOST_PAIR_OK
        {
            eachSubPattern(guest[g0 : g1]): |shadow guest, isDeep!guestDeep|
            {
                shadow mut g1 = 0;
                let guestTemplateId = parseMi(guest, offset: g1);

                // Both need to be specs of the same template.
                if (guestTemplateId != hostTemplateId)
                    continue;

                // We can speed this up if there are no nested patterns ...
                if (!hostDeep && !guestDeep)
                {
                    // ... in which case spec-args must be exactly the same.
                    if (host == guest)
                        break :HOST_PAIR_OK;
                }

                // Else we gotta canon-compare each spec-arg pair individually.
                else if (hostDeep && guestDeep)
                {
                    // We split-zip the two spec-arg sequences here.
                    for (;;)
                    {
                        // First spec-args begins on a : after the template-id,
                        //  that's why we increment this on the first loop iter.
                        h1++;
                        g1++;

                        shadow let h0 = h1;
                        shadow let g0 = g1;

                        mut isLastHostPair:  bool;
                        mut isLastGuestPair: bool;

                        host .scan(':', h1, isLastHostPair);
                        guest.scan(':', g1, isLastGuestPair);

                        // The two spec-arg-sets must be equal-length.
                        if (isLastHostPair != isLastGuestPair)
                            break;

                        let hostItem  = host [h0 : h1];
                        let guestItem = guest[g0 : g1];
                        if (isCanonAssignable(hostItem, guestItem))
                            break :HOST_PAIR_OK;
                    }
                }
            }

            // Unless you break :HOST_PAIR_OK -
            return false;
        }
    }

    // All host pairs matched.
    return true;
}
