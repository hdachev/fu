import ansi;
import helpers;
import module;
import fail;
import flags;


//

let use_AUTOPUB     = true;


// Operator precedence table.

struct Precedence {
    formal:         int;
    whitesp_lint?:  int;
    tokidx?:        int;
}

let P_RESET         = Precedence(1000);
let P_PREFIX_UNARY  = Precedence(1   );

let PREFIX          = [ "++", "+", "--", "-", "!", "~", "?", "*", "&", "-%" ];
let POSTFIX         = [ "++", "--", "[]", "[..]" ];

fn setupOperators()
{
    struct BINOP {
        PRECEDENCE:     flat::Map(string, i32);
        RIGHT_TO_LEFT:  bool[];
    };

    mut out: BINOP;

    mut precedence  = P_PREFIX_UNARY.formal;
    mut rightToLeft = false;

    fn binop(ops: string[])
    {
        precedence++;

        precedence < 64 || throw(
            "Assertion failed: precedence < 64");

        out .RIGHT_TO_LEFT
            .ensure(exists: precedence) = rightToLeft;

        for (mut i = 0; i < ops.len; i++)
            out.PRECEDENCE.set(ops[i], precedence);
    }

    // TODO not so simple,
    //  must be stronger than unary - and +,
    //   or alternatively also fail lint.
    //
    // See: https://stackoverflow.com/questions/47068812/javascript-exponentiation-unary-operator-design-decision
    //
    // rightToLeft = true;
    // binop([ "**" ]);

    rightToLeft = false;
    binop([ "*", "/", "%",      "*%"       ]);
    binop([ "+",  "-",          "+%", "-%" ]);
    binop([ "<<", ">>" ]);
    binop([ "&" ]); // Notice this is not js/c precedence, it's just never usefu]l.
    binop([ "^" ]); // We're doing the rust thing her]e.
    binop([ "|" ]);
    binop([ "~" ]); // concat operator - same prec as in lua, as weak as possible
    binop([ "<=>", "<>" ]);
    binop([ "=>", "->" ]); // see c# as, is and js in, instanceof
    binop([ "<", "<=", ">", ">=", "<=>" ]);
    binop([ "==", "!=" ]);
    binop([ "&&" ]);
    binop([ "||" ]);

    rightToLeft = true;
    binop([ "?",
            "=", "+=", "-=", "**=", "*=", "/=", "%=", "<<=", ">>=", "&=", "^=", "|=",
            "||=", "&&=", ".=", "~=", ":=",

            "+%=", "-%=", "*%=" ]);

    // F# has weird precedence here, why?
    binop([ "<|" ]);

    rightToLeft = false;
    binop([ "|>" ]);

    //
    return out;
}

let BINOP       = setupOperators();


// Descent modes.

let M_LINT_UNARY_PRECEDENCE = 1 << 0;
let M_LINT_ENSURE_INDENT    = 1 << 1;
let M_LAMBDA_STMT_OK        = 1 << 2;


//

using enum Fixity {
    Infix
    Prefix
    Postfix
};

struct ArgsParse {
    flags:          Flags;
    sliceSyntax:    bool;
}

struct ParserState {
    _idx:           int;
    _loc:           int;
    _col0:          int;
    _precedence:    Precedence;

    _fnDepth:       int;
    _templateDepth: int;

    _autopub:       bool;

    // TODO FIX So the $T thing backfired -
    //  when you have an if (a -> $T) in the middle of some fn,
    //   if you rename the $T in the fn sig,
    //    it starts introducing a new unused type param AND DOES NOTHING.
    //
    // It's not neat, so we'll have to go for introducing type params explicitly so these things are unambiguous.
    //  In the meantime, we forbid the introduction of new type params halfway through a function.
    //
    // The upside is this frees up the dollar sigil.
    //
    _TODO_FIX_dollarOk:     bool;

    _numDollars:            int;
    _expectedTypeParams:    flat::Set(string);
    _upstreamTypeParams:    flat::Set(string);

    //
    imports:        Import[];
    warnings:       string[];
}


//

pub fn parse(
    modid!: i32,
    fname!: string, src!: string, tokens!: Token[],
    implicit options!: options::Options): ParserOutput
{
    using mut _ps: ParserState;

    _autopub = true;


    //

    fn registerImport(mut pattern: string, id?: string)
    {
        mut index = imports.len;
        :ADD {
            if (id)
                (pattern ~= '\t') ~= id;

            for (mut i = 0; i < imports.len; i++)
                if (imports[i].pattern == pattern) {
                    index = i;
                    break :ADD;
                }

            imports ~= Import(:pattern,
                token: TokenIdx(:modid, tokidx: _loc));
        }

        // What we leave in the AST is a serialized modid + import-index,
        //  and the id to look up, if any, imports dont have it, qualified calls do.
        mut marker = "";
        marker.appendVarint(modid.u32);
        marker.appendVarint(index.u32);
        marker ~= id;

        return marker;
    }


    //

    fn fail(token: TokenIdx, mut reason?: string)
    {
        if (token.modid == modid) _loc = _idx = token.tokidx;
        return fail(:reason);
    }

    fn fail(mut reason?: string)
    {
        let token = tokens[_idx];
        if (!reason)
            reason = "Unexpected `" ~ token.value ~ "`.";

        return FAIL(:fname, :src, :token, :reason);
    }

    fn fail_compose(mut reason: string)
    {
        let loc  = tokens[_loc];
        let here = tokens[_idx];

        if (!reason)
            reason = "Unexpected `" ~ here.value ~ "`.";

        let l0 = loc.line;
        let c0 = loc.col;

        let l1 = here.line;
        let c1 = here.col;

        let addr = l1 == l0
            ? "@" ~ l1 ~ ":" ~ c1
            : "@" ~ l0 ~ ":" ~ c0 ~ ".." ~ l1 ~ ":" ~ c1;

        return fname ~ " " ~ addr ~ ":\n\t" ~ reason;
    }

    fn warn(reason: string)
    {
        if (warnings.len == options.maxwarn)
            return fail(reason);

        warnings ~= fail_compose(reason);
    }

    fn warn(idx: i32, reason)
    {
        let idx0    = _idx;
        _idx        = idx;
        warn(reason);
        _idx        = idx0;
    }

    fn make(
        kind:       Kind,
        items?:     Node[],
        flags?:     Flags,
        value?:     string,
        asserts?:   DeclAsserts,
        syntax?:    ParseSyntax,
        token?:     TokenIdx)
    {
        return Node(
            :kind, :value, :items,
            :flags, :asserts, :syntax,
            token: token || TokenIdx(:modid, _loc));
    };


    //

    fn consume(kind: Kind, value?: string): Token
    {
        let token = tokens[_idx];
        if (token.kind == kind && (!value || token.value == value))
        {
            _idx++;
            return token;
        }

        return fail("Expected " ~ kind.str.qKW
            ~ (value && kind == token.kind && " " ~ value.qID)
            ~ "\n\t     got " ~ token.kind.str.qKW
            ~ (value && kind == token.kind && " " ~ token.value.qID));
    }


    //

    fn tryConsume(kind: Kind): Token
    {
        let token = tokens[_idx];
        if (token.kind == kind)
        {
            _idx++;
            return token;
        }

        return [];
    }

    fn tryConsume(kind: Kind, value: byte[..]): Token
    {
        let token = tokens[_idx];
        if (token.kind == kind && token.value == value)
        {
            _idx++;
            return token;
        }

        return [];
    }

    fn tryConsume(kind: Kind, value: byte[..], peek!): Token
    {
        let token = tokens[_idx];
        if (token.kind == kind && token.value == value
                               && tokens[_idx + 1].peek())
        {
            _idx++;
            return token;
        }

        return [];
    }


    //

    fn parseRoot(): Node
    {
        consume("sof", "");

        _loc = _idx;

        mut out = make("root",
            parseBlockLike("eof", ""));

        // STEP BACK FROM EOF //
        _idx--;               //
        ////////////////////////

        // Autopub.
        if (use_AUTOPUB && _autopub) for (mut i = 0; i < out.items.len; i++)
        {
            ref item = out.items[i];

            let k = item.kind;
            if (k == "fn" || k == "let" || k == "struct" || k == "union" || k == "enum" || k == "flags" || k == "primitive")
                set_PUB(item.flags, "Module has no pubs, pubbing everything.");
        }

        return out;
    }

    fn parseCompilerPragma(): Node
    {
        let value = consume("id").value;

        // Codegen passthrough for direct c++ hacks.
        mut items: Node[];
        if (value != "break")
        {
            consume("op", "(");
            parseCallArgs(")", items);
        }

        return make("pragma", :value, :items,
            syntax: softSemi() && PS_DISCARD_IF_BLOCK_TAIL);
    }


    //

    fn parseBlock(): Node
    {
        return createBlock(
            parseBlockLike("op", "}"));
    }

    fn createBlock(mut items: Node[], label?: string): Node
    {
        if (items.if_last.syntax & (PS_DISCARD_IF_BLOCK_TAIL | PS_ALWAYS_DISCARD))
            items ~= make("empty", :items.last.token);

        return make("block", :items, value: label);
    }


    //

    fn softComma(endop: string)
    {
        let peek = tokens[_idx];
        if (peek.kind == "op")
        {
            if (peek.value == ",") {
                _idx++;
                return;
            }

            if (peek.value == endop)
                return;
        }

        // Experimental,
        //  optional commas around string literals -
        //   but not when two literals are adjacent.
        //
        if ((peek.kind == "str") != (tokens[_idx - 1].kind == "str"))
            return;

        warn("Missing comma before " ~ peek.value.qBAD ~ ".");
    }

    fn softSemi()
    {
        let peek = tokens[_idx];
        if (peek.kind == "op")
        {
            if (peek.value == ";") {
                _idx++;
                return true;
            }

            if (peek.value == "}" || peek.value == ")")
                return false;
        }

        // Experimental:
        //  allow optional semis when
        //   whitespace is completely unambiguous.
        //
        else if (peek.col == _col0)
            return false;
        else if (peek.kind == "eof")
            return false;

        warn("Missing semicollon before " ~ peek.value.qBAD ~ ".");
        return false;
    }


    //

    fn parseAnnotatedType(asserts: DeclAsserts = A_NODISCARD): Node
    {
        let kw = consume("id").value;
        if (kw == "struct")
            return parseStructDecl("struct", :asserts);

        if (kw == "enum")
            return parsePrimDecl("enum", :asserts);
        if (kw == "flags")
            return parsePrimDecl("flags", :asserts);
        if (kw == "primitive")
            return parsePrimDecl("primitive", :asserts);

        _idx--;
        fail();
    }

    fn parseAnnotatedStruct(asserts: DeclAsserts): Node
    {
        consume("id", "struct");

        return parseStructDecl("struct", :asserts);
    }

    fn parseStructDecl(kind: Kind, flags!?: Flags, asserts!?: DeclAsserts): Node
    {
        let name = tryConsume("id").value;

        // struct Hello(args) shorthand, see below.
        mut args: Node[];
        let argFlags = name
            && tryConsume("op", "(")
            && parseArgsDecl(args, "op", ")");

        //
        consume("op", "{");
        mut items = parseBlockLike("op", "}", struct: true);

        :F_PREDICATE
        {
            // Unless user tagged somethign as F_PREDICATE explicitly ...
            items.each: |item|
                if (item.kind == "let")
                    if (item.flags & F_PREDICATE)
                        break :F_PREDICATE;

            //  ... then every field is a predicate.
            items.each: |ref item|
                if (item.kind == "let")
                    item.flags |= F_PREDICATE;
        }

        // Items: [ Base type (primitives), items (structs, enums & unions) ]
        mut struct = make(:kind, [ [], make("members", items) ], :flags, :asserts, name);
        if (!args)
            return struct;

        // struct Hello(args) { ... } shorthand:
        //  rewrites into fn Hello(args) struct { ... }
        //
        struct.value = "";

        return make("fn",
            items: args ~ Node() ~ struct,
            flags: argFlags,
            value: name);
    }

    fn parseStructItem(): Node
    {
        // Subset of fields we're gonna be using for conversion to bool -
        //  for example, a dynamic array's `size`, or a Node's `kind` here.
        let isPredicate = tryConsume("id", "true");

        mut member = parseLet(xqmark: true);
        softSemi();

        if (isPredicate)
            member.flags |= F_PREDICATE;

        return member;
    }


    //

    fn parsePrimDecl(kind: Kind, asserts?: DeclAsserts): Node
    {
        let name    = tryConsume("id").value;
        let annot   = tryPopTypeAnnot();
        mut items   = tryConsume("op", "{") && parseBlockLike("op", "}", enum: true);

        if (kind != "enum" && kind != "flags")
            annot || fail("primitive".qKW ~ " declarations require a base type annotation.");

        return make(
            :kind, value: name, :asserts,
                [ annot, items && make("members", items) ]);
    }

    fn parseEnumItem(): Node
    {
        let id      = consume("id").value;
        let init    = tryParseLetInit();
        softSemi();

        return createLet(:id, :init);
    }


    //

    fn parseBlockLike(
        endKind: Kind, endVal: string,
        struct! = false,
        enum! = false): Node[]
    {
        let tok0    = _idx && tokens[_idx - 1];
        let line0   = tok0.line;

        let col00   = _col0;
        let col01   = tok0.col == col00 ? col00 : -1;

        mut colNN   = -1;
        mut lineNN  = line0;

        mut items: Node[];
        for (;;)
        {
            let idx0  = _idx;
            let token = tokens[_idx];

            // Ignore excess semicolons, e.g. struct{}; etc.
            if (token.kind == "op" && token.value == ";")
            {
                _idx++;
                continue;
            }

            if (token.kind == endKind && token.value == endVal)
            {
                // Done.
                _col0 = col00;
                _idx++;

                // Style-check, makes for more helpful errors.
                let line1 = token.line;
                let col1  = token.col;

                let col1_min = _col0;
                let col1_max = col01 < 0
                    ? colNN < 0 ? _col0 : colNN - 1
                    : col01;

                line1 == line0 || (col1 >= col1_min && col1 <= col1_max) || warn(
                    "Inconsistent indent at closing `" ~ token.value ~ "`: expected "
                        ~ (col1_min - 1)
                        ~ (col1_max > col1_min ? " up to " ~ (col1_max - 1) : "")
                        ~ ", got " ~ (col1 - 1)
                        ~ ". Block starts on line " ~ line0 ~ ".");

                break;
            }

            //
            _col0 = token.col;
            _col0 > col00 || warn(
                "Inconsistent indent at `" ~ token.value ~ "`: expected more than " ~ col00
                    ~ ", got " ~ _col0 ~ ". Block starts on line " ~ line0 ~ ".");

            // Consistent indentation within blocks.
            colNN < 0 || colNN == _col0 || token.line == lineNN || warn(
                "Inconsistent indent at `" ~ token.value ~ "`: expected exactly " ~ colNN
                    ~ ", got " ~ _col0 ~ ". Previous statement starts on line " ~ lineNN ~ ".");

            if (colNN < 0)
                colNN = _col0;

            lineNN = token.line;

            //
            let expr    = struct    ? parseStructItem()
                        : enum      ? parseEnumItem()
                                    : parseDeferOrStatement();

            // Maybe we should get rid of this.
            expr.kind != "call"
                || expr.flags & (F_CALL_HAS_ARGPARENS | F_OPERATOR)
                || expr.items.len > 1
                || tokens[_idx].value == endVal
                || warn(idx: idx0, "Orphaned call without parentheses, add () to imply a useful side effect.");

            items.push(expr);
        }

        return items;
    }

    fn parseSubStatement()
    {
        let peek = tokens[_idx];

        // Whitespace warn, unless block.
        if (peek.kind != "op" || peek.value != "{")
            peek.col > _col0 || warn(
                "Misleading indent at " ~ peek.value.qBAD ~ ": expected more than " ~ _col0
                    ~ ", got " ~ peek.col ~ ".");

        return parseStatement();
    }


    // Watch out, we want to not allow pubs & shadows together.

    fn set_SHADOW(ref flags: Flags)
    {
        flags & F_PUB && fail(
            "Cannot " ~ "shadow".qBAD ~ " a " ~ "pub".qKW);

        _fnDepth || fail(
            "Shadowing is currently only supported inside functions.");

        flags |= F_SHADOW;
    }

    fn set_PUB(ref flags: Flags, extra?: string, autopub_ok!?: bool)
    {
        flags & F_SHADOW && fail(
            "Cannot " ~ "pub".qBAD ~ " a " ~ "shadow".qKW ~
                (extra ? ": " ~ extra : "."));

        flags |= F_PUB;

        if (!autopub_ok)
            _autopub = false;
    }

    fn parsePub(): Node
    {
        _fnDepth && fail("Cannot " ~ "pub".qBAD ~ " from within a " ~ "fn".qKW ~ ".");

        mut out = parseStatement();
        set_PUB(out.flags, autopub_ok: out.kind == "import");

        return out;
    }

    fn parseShadow(): Node
    {
        mut idx0 = _idx;

        mut out = parseStatement();
        out.flags & F_PUB && fail("Cannot " ~ "shadow".qBAD ~ " a " ~ "pub".qKW ~ ".");

        swap(idx0, _idx);
        out.flags.set_SHADOW();
        swap(idx0, _idx);

        return out;
    }

    fn parseUsing(): Node
    {
        mut out = parseStatement();
        if (out.kind == "fn")
        {
            // This should probably move within the solver.
            mut explicitMin = 0;
            mut explicitMax = 0;

            for (mut i = 0; i < out.items.len + FN_ARGS_BACK; i++)
            {
                let arg = out.items[i];
                if (arg.flags & F_IMPLICIT)
                    continue;

                explicitMax++;
                if (!arg.items[LET_INIT] && explicitMin++)
                    fail(:arg.token, "Conversion functions cannot have more than one non-defaulted explicit argument.");
            }

            if (explicitMin)
                out.flags |= F_CONVERSION;
            else if (!explicitMax)
                out.flags |= F_USING;
            else
                fail(:out.token, "Conversion functions cannot have all their explicit arguments defaulted.");

            //
            for (mut i = 0; i < out.items.len - 2; i++) {
                let arg = out.items[i];
                if (!arg.items[LET_TYPE] && !arg.value.has('.'))
                    fail(:arg.token, "Conversion functions need type annotations on their arguments to know when to kick in.");
            }
        }
        else if (out.kind == "let")
            out.flags |= F_USING;
        else if (out.kind == "enum" || out.kind == "flags" || out.kind == "primitive")
            out.flags |= F_USING;
        else
            fail("using".qBAD ~ " cannot be used here.");

        if (out.flags & F_OPERATOR)
            fail("using".qBAD ~ " cannot be used on operator functions.");

        return out;
    }

    fn parseLax(): Node
    {
        mut out = parseStatement();
        out.kind == "let" || out.kind == "fn" || fail(
            "lax".qBAD ~ " cannot be used here.");

        out.flags |= F_LAX;
        return out;
    }


    //

    fn parseStatement(): Node
    {
        ///////////////////////////////////////////////
        let loc0 = _loc;
        defer _loc = loc0;
        let token = tokens[_loc = _idx++] || fail();
        ///////////////////////////////////////////////

        //
        if (token.kind == "op")
        {
            let v = token.value;

            if (v == "{")           return parseBlock();
            if (v == ":")           return parseLabelledStatement();
        }
        else if (token.kind == "id")
        {
            let v = token.value;
            let peek = tokens[_idx];

            if (_fnDepth)
            {
                if (v == "if")          return parseIf();
                if (v == "for")         return parseFor();
                if (v == "while")       return parseWhile();
                if (v == "do")          return parseDoWhile();

                if (v == "return")      return parseJump("return");
                if (v == "break")       return parseJump("break");
                if (v == "continue")    return parseJump("continue");

                if (v == "try")         return parseTryCatch();
            }

            if (peek.kind == "op" && peek.value == "{")
            {
                if (v == "unwrap")      return parseUnwrap();
            }

            if (v == "fn" && (peek.kind == "id" || !_fnDepth))
            {
                                        return parseFnDecl();
            }

            if (peek.kind == "id")
            {
                if (v == "struct")      return parseStructDecl("struct");
                if (v == "union")       return parseStructDecl("union");

                if (v == "pub")         return parsePub();
                if (v == "shadow")      return parseShadow();
                if (v == "using")       return parseUsing();
                if (v == "lax")         return parseLax();

                if (v == "import")      return parseImport();

                if (v == "pragma")      return parseCompilerPragma();

                if (v == "inline")      return parseInlineDecl();
                if (v == "noinline")    return parseNoInlineDecl();
                if (v == "infix")       return parseOperatorDecl(Infix);
                if (v == "prefix")      return parseOperatorDecl(Prefix);
                if (v == "postfix")     return parseOperatorDecl(Postfix);

                if (v == "primitive")   return parsePrimDecl("primitive");
                if (v == "flags")       return parsePrimDecl("flags");
                if (v == "enum")        return parsePrimDecl("enum");

                if (v == "pure")        return parseAnnotatedFn(asserts: A_PURE);
                if (v == "purectx")     return parseAnnotatedFn(asserts: A_PURE_CTX);
                if (v == "purefx")      return parseAnnotatedFn(asserts: A_PURE_FX);

                if (v == "novec")       return parseAnnotatedFn(asserts: A_NOVEC);
                if (v == "noflow")      return parseAnnotatedFn(asserts: A_NOFLOW);

                if (v == "nothrow")     return parseAnnotatedFn(asserts: A_NOTHROW);
                if (v == "nocrash")     return parseAnnotatedFn(asserts: A_NOCRASH);
                if (v == "noio")        return parseAnnotatedFn(asserts: A_NOIO);
                if (v == "fast")        return parseAnnotatedFn(asserts: A_FAST);

                if (v == "nocopy")      return parseAnnotatedStruct(A_NOCOPY);
                if (v == "trivial")     return parseAnnotatedStruct(A_TRIVIAL);
                if (v == "nodiscard")   return parseAnnotatedType(A_NODISCARD);

                if (v == "extern")      return parseAnnotatedFn(F_EXTERN);
                if (v == "hotswap")     return parseAnnotatedFn(F_HOTSWAP);
                if (v == "test")        return parseTestcase();
            }
        }

        ////////////
        _idx--;
        ////////////

        return parseLetOrExpressionStatement();
    }

    fn parseLetOrExpressionStatement(): Node
    {
        let token = tokens[_idx++];
        if (token.kind == "id" && tokens[_idx].kind == "id")
        {
            let v = token.value;

            if (v == "let")
            {
                return parseLetStmt();
            }

            if (v == "mut" || v == "ref" ||
                v == "val" || v == "const" ||
                v == "implicit" || v == "type")
            {
                _idx--;
                return parseLetStmt();
            }
        }

        ////////////
        _idx--;
        ////////////

        // No expression statements outside of fns for now.
        if (!_fnDepth)
            fail();

        // Expression statement, followed by a semi.
        return parseExpressionStatement();
    }

    fn parseDeferOrStatement()
    {
        ///////////////////////////////////////////////
        let loc0 = _loc;
        defer _loc = loc0;
        let peek = tokens[_loc = _idx] || fail();
        ///////////////////////////////////////////////

        if (peek.kind == "id")
        {
            let v = peek.value;
            if (v == "defer")
                return { _idx++; parseDefer() };
        }

        return parseStatement();
    }

    fn parseImport(): Node
    {
        mut path = tryConsume("id").value;
        if (path)
        {
            while (tryConsume("op", "::"))
                path ~= "/" ~ consume("id").value;
        }
        else
        {
            path = consume("str").value;
        }

        softSemi();

        return make("import", value: registerImport(path));
    }

    fn parseLabelledStatement(): Node
    {
        let label = consume("id").value;

        mut stmt = parseStatement();
        if (stmt.kind == "loop" || stmt.kind == "block")
        {
            stmt.value && fail("Label " ~ label.qID ~ ": statement already labeled as " ~ stmt.value.qID ~ ".");
            stmt.value = label;
            return stmt;
        }

        return createBlock([ stmt ], :label);
    }

    fn parseUnwrap(): Node
    {
        mut stmt = parseStatement();
        stmt.kind == "block" || fail("Unwrap only works for blocks, this is a " ~ stmt.kind.str.qKW ~ ".");
        stmt.items ~= make("unwrap");
        return stmt;
    }

    fn parseExpressionStatement(): Node
    {
        mut expr = parseExpression(P_RESET);
        expr.tryColonPipeline(stmt: true);

        if (softSemi())
            expr.syntax |= PS_DISCARD_IF_BLOCK_TAIL;

        return expr;
    }

    fn tryColonPipeline(ref expr: Node, stmt!: bool)
    {
        // Pipeline left expriment.
        if (tryConsume("op", ":"))
        {
            if !(expr.kind == "call")
                fail("Cannot pipeline: expression is not a call.");

            let right = parseExpression(P_RESET, mode: stmt && M_LAMBDA_STMT_OK);
            expr = pipelineLeft(expr, right);

            if (stmt)
            {
                // HACK! TODO FIX semicollon ambiguity here.
                let prev = _idx && tokens[_idx - 1];
                if (prev.kind == "op" && prev.value == ";")
                    _idx--;
            }
        }
    }


    // Fn decorator order -
    //  fn keyword comes last to disambiguate operators from anonymous functions,
    //   which makes the parse a bit problematic but whatever.

    fn parseAnnotatedFn(mut flags?: Flags, mut asserts?: DeclAsserts): Node
    {
        let _idx0 = _idx;
        mut stmt = parseStatement();

        if (stmt.kind != "fn" || stmt.flags & F_LAMBDA)
        {
            _idx = _idx0 && _idx0 - 1;
            fail("Invalid annotation: not a " ~ "fn".qKW ~ " declaration.");
        }

        stmt.flags      |= flags;
        stmt.asserts    |= asserts;
        return stmt;
    }

    fn parseNoInlineDecl(): Node
    {
        return parseInlineDecl(F: [], asserts: A_NOINLINE);
    }

    fn parseInlineDecl(mut flags?: Flags, F = F_INLINE, mut asserts?: DeclAsserts): Node
    {
        flags |= F;

        let v = consume("id").value;
        if (v == "infix")   return parseOperatorDecl(:flags, Infix);
        if (v == "prefix")  return parseOperatorDecl(:flags, Prefix);
        if (v == "postfix") return parseOperatorDecl(:flags, Postfix);
        _idx--;

        return parseFixityDecl(:flags, :asserts);
    }

    fn parseOperatorDecl(fixity: Fixity, flags?: Flags)
    {
        fixity || fail("Falsy fixity.");
        return parseFixityDecl(flags, :fixity);
    }

    fn parseFixityDecl(flags: Flags, fixity?: Fixity, asserts?: DeclAsserts, expr?: bool): Node
    {
        consume("id", "fn");
        return parseFnDecl(flags, :fixity, :asserts, :expr);
    }


    //

    fn parseLambda(noClosingPipe!?: bool, leadingDot!?: bool, mode!?: i32): Node
    {
        if (noClosingPipe && _precedence.formal > P_RESET.formal && _precedence.formal < P_PREFIX_UNARY.formal)
            warn("Unparenthesized `|| lambda` within a binary expression.");

        let name = "_";

        // TODO FIX: re: F_LAX, otherwise we get complaints for no effects/returns void,
        //  also there's no way to add the annotation manually, feels sloppy though.
        let flags = F_LAX | F_LAMBDA;

        return parseFnDecl_cont(endv: !noClosingPipe && "|",
            expr: !(mode & M_LAMBDA_STMT_OK),
                :flags, :name, :leadingDot);
    }

    fn parseFnDecl(mut flags?: Flags, fixity?: Fixity, asserts?: DeclAsserts, expr!?: bool): Node
    {
        let loc0    = _loc;
        _loc        = _idx;
        defer _loc  = loc0;

        // fn hello(), fn +()
        mut name = tryConsume("id").value;
        if (!name)
        {
            name = consume("op").value;

            if (fixity == Postfix)
            {
                if !(POSTFIX.has(name))
                    fail("No such postfix operator: " ~ name.qBAD ~ ".");

                if (PREFIX.has(name))
                    name = "postfix" ~ name;
            }
            else if (fixity == Infix)
            {
                BINOP.PRECEDENCE.has(name) || fail("No such infix operator: " ~ name.qBAD ~ ".");
            }
            else if (fixity == Prefix)
            {
                PREFIX.has(name) || fail("No such prefix operator: " ~ name.qBAD ~ ".");
            }

            flags |= F_OPERATOR;
        }
        else if (flags & F_OPERATOR || fixity)
        {
            fail("Not an operator: " ~ name.qBAD ~ ".");
        }

        /////////////////////////
        mut expectedTypedParams0 = _expectedTypeParams.steal();
        defer swap(expectedTypedParams0, _expectedTypeParams);

        tryParseTypeParamsDecl();
        /////////////////////////

        //
        let endv = tryConsume("op", "(") && ")";
        if (!endv)
        {
            if (expr)
                return createAddrOfFn(:name, :flags);

            consume("op", "=");
        }

        return parseFnDecl_cont(:flags, :asserts, :name, :expr, :endv);
    }

    fn tryParseTypeParamsDecl()
    {
        if (tryConsume("op", "!")

            // TODO FIX, removing the bangs,
            //  we're now going for a syntax alla:
            //
            // fn what<T>(a: T, b: T)
            //
            //  ... with an inline version alla:
            //
            // fn what(a: <T>, b: T)
            //
            //  ... in an attempt to make everything look consistent
            //       and avoid repetition where it feels natural:
            //
            // struct Map<K, V>(type K, type V)
            //
            //  ... is just too moronic, which motivates the inline syntax:
            //
            // struct Map(type <K>, type <V>)
            //
            //  ... which feels less stupid, but more consistent than:
            //
            // struct Map(type K, type V)
            //
            //  ... where type K & V magically become type params
            //       without any visible declaration.
            //
            || tryConsume("op", "<") && { _idx--; true })
        {
            fn parseAndAdd()
            {
                let id = consume("id").value;
                if (_upstreamTypeParams.has(id) || !_expectedTypeParams.add(id))
                    fail("Duplicate type parameter: " ~ id.qBAD ~ ".");
            }

            if (tryConsume("op", "<"))
            {
                mut first = true;
                for (;;)
                {
                    if (tryConsume("op", ">"))
                        break;

                    if (!first)
                        consume("op", ",");

                    first = false;
                    parseAndAdd();
                }
            }
            else
            {
                parseAndAdd();
            }
        }
    }

    fn createAddrOfFn(name!: string, flags!: Flags): Node
    {
        return make(kind: "addroffn", :flags, value: name);
    }

    fn parseFnDecl_cont(
        name!: string, mut flags!?: Flags, asserts?: DeclAsserts,
        expr!?: bool, leadingDot!?: bool, endv! = ")"): Node
    {
        shadow let expr = expr || leadingDot;

        // Opening parens!
        mut items: Node[];

        ////////////////////////////////
        _fnDepth++;
        let numDollars0         = _numDollars;

        defer {
            _fnDepth--;
            _numDollars         = numDollars0;
        }
        ////////////////////////////////

        if (leadingDot)
        {
            flags |= parseLeadingDot(items, :name);
        }
        else
        {
            flags |= endv && parseArgsDecl(
                items, "op", :endv,
                initPrecedence: endv == "|"
                    ? P_PREFIX_UNARY
                    : P_RESET);

            // Return type annot.
            mut type = tryPopTypeAnnot(allowLegacyRefs: true);
            let retIdx = items.len;
            items.push(type);

            // Body or pattern (case/case).
            parseFnBodyOrPattern(:flags, items, :expr);

            // Ensure main: i32, kinda lame doing it here.
            if (name == "main" && _fnDepth == 1)
            {
                if (!type)
                    items[retIdx] = type = createRead("i32");
                else if (type.kind != "call" || type.value != "i32" || type.items.len)
                    fail("fn main() must return i32.");

                set_PUB(flags);
                flags |= F_EXTERN;
            }

            // TODO FIX testsuite should definitely not be F_PUB
            //  ideally shouldn't even go onto scope or anything,
            //   doing right now to ensure they reach cg.
            //
            if (flags & F_TESTCASE)
            {
                set_PUB(flags);
                flags |= F_EXTERN;
            }
        }

        // TODO FIX gotta rethink how we do jumps & labels,
        //  starting to think that we should only have jumps
        //   with explicit labels in the AST,
        //    which means we'd have to resolve them while parsing.
        //
        // TODO FIX another problem with lambdas,
        //  they can end up as private fns within some module,
        //   but if they're only called from a public inline fn,
        //    they won't get emitted - no fndef node in the original module.
        //
        // TODO FIX adding F_TEMPLATE to all nested fns within templates -
        //  helps make everything lazy which helps with mut/const-generics,
        //   alla visit(item, ?:fn remove), etc.
        //
        if (flags & F_LAMBDA || _templateDepth)
            flags |= F_TEMPLATE;

        return make("fn", :items, :flags, :asserts, name,
            syntax: !expr && PS_NOT_AN_EXPRESSION);
    }

    fn parseLeadingDot(
        ref out_push_arg_and_body: Node[], name!: string): Flags
    {
        // A single argument, named after the lambda.
        let singleArg = createLet(
            id: name,
            flags: F_TEMPLATE | F_SHADOW | F_REF);

        // We back off one token, so we can re-parse the leading dot.
        let singleExpression = parseExpression(
            p1: _precedence,
            parseHead: { _idx--; createRead(id: name) });

        //
        out_push_arg_and_body.push(singleArg);
        out_push_arg_and_body.push(/*retval annot*/ []);
        out_push_arg_and_body.push(singleExpression);

        return F_TEMPLATE;
    }

    fn parseFnBodyOrPattern(
        ref flags: Flags, ref out_push_body: Node[], expr!: bool)
    {
        mut body: Node;

        //
        mut TODO_FIX_didInitArgTypeParams = false;
        mut withArgTypeParams: flat::Set(string);

        //
        if (!expr && tryConsume("id", "case"))
        {
            // TODO FIX otherwise solver doesn't handle the pattern
            flags |= F_TEMPLATE;

            mut branches: Node[];

            fn parseBranch(noCond?: bool)
            {
                if (!noCond)
                {
                    if (!TODO_FIX_didInitArgTypeParams)
                    {
                        TODO_FIX_didInitArgTypeParams   = true;
                        withArgTypeParams               = _expectedTypeParams;

                        for (mut i = out_push_body.len - 1; i --> 0; )
                        {
                            let arg         = out_push_body[i];
                            let argName     = arg.kind == "let" && (
                                arg.flags & F_COMPOUND_ID
                                    ? cleanID(arg.value)
                                    :         arg.value);

                            if (argName && argName != "_")
                                withArgTypeParams.add(argName);
                        }
                    }

                    swap(_expectedTypeParams, withArgTypeParams);
                }

                _TODO_FIX_dollarOk = true;
                let cond = !noCond && parseUnaryExpression();
                _TODO_FIX_dollarOk = false;

                if (!noCond)
                    swap(_expectedTypeParams, withArgTypeParams);

                let type = tryPopTypeAnnot(allowLegacyRefs: true);
                let cons = parseFnBodyBranch(:flags);

                branches.push(
                    make("fnbranch", [ cond, type, cons ]));
            }

            // Parse cases.
            do parseBranch();
            while (tryConsume("id", "case"));

            // Trailing else.
            if (tryConsume("id", "default"))
                parseBranch(noCond: true);

            //
            body = make("pattern", branches);
        }
        else
        {
            body = parseFnBodyBranch(:flags, :expr);
        }

        //
        out_push_body.push(body);
    }

    fn parseFnBodyBranch(ref flags: Flags, expr!?: bool): Node
    {
        ////////////////////////////////////////////////////////////////
        mut upstreamTypeParams0 =
            _upstreamTypeParams.union(_expectedTypeParams);

        swap(_upstreamTypeParams, upstreamTypeParams0);
        mut expectedTypeParams0 = steal(_expectedTypeParams);

        let templateDepth0 = _templateDepth;

        defer {
            swap(_upstreamTypeParams, upstreamTypeParams0);
            swap(_expectedTypeParams, expectedTypeParams0);
            defer _templateDepth = templateDepth0;
        }

        if (flags & F_TEMPLATE)
            _templateDepth++;

        ////////////////////////////////////////////////////////////////

        // Allow a leading `=` before body.
        //  We'll transition to this thing fulltime
        //   in the presence of type annots.
        tryConsume("op", "=");

        //
        mut body = expr
            ? parseExpression(_precedence)
            : parseStatement();

        if (body.syntax & PS_ALWAYS_DISCARD)
            body = createBlock([ body ]);

        //
        return body;
    }

    fn parseTestcase()
    {
        return parseFnDecl(flags: F_TESTCASE);
    }

    fn tryPopTypeAnnot(allowTypeUnions! = false, allowLegacyRefs! = false): Node
    {
        return tryConsume("op", ":")
            && parseTypeAnnot(:allowTypeUnions, :allowLegacyRefs);
    }

    fn parseTypeAnnot(allowTypeUnions! = false, allowLegacyRefs! = false): Node
    {
        mut hasLegacyRef    = false;
        mut hasLegacyMutRef = false;

        if (allowLegacyRefs)
        {
            hasLegacyRef    = !!tryConsume("op", "&");
            hasLegacyMutRef = hasLegacyRef && !!tryConsume("id", "mut");
        }

        //
        mut res = parseUnaryExpression();

        // EXPERIMENTAL type union syntax, i'm not loving it
        while (allowTypeUnions && tryConsume("id", "or"))
        {
            if (res.kind != "typeunion")
                res = make("typeunion", [ res ]);

            res.items ~= parseUnaryExpression();
        }

        if (hasLegacyRef)
            res = createCall(hasLegacyMutRef ? "&mut" : "&", F_OPERATOR, [ res ]);

        return res;
    }

    fn parseArgsDecl(
        ref outArgs: Node[],
        endk: Kind, endv: string,
        initPrecedence! = P_RESET): Flags
    {
        mut first = true;
        mut outFlags: Flags;

        mut implicit: Node[];
        mut firstDefaulted = -1;

        for (;;)
        {
            if (tryConsume(endk, endv))
                break;

            if (!first)
                consume("op", ",");

            first = false;

            let isInline = !!tryConsume("id", "inline");
            let numDollars0 = _numDollars;

            mut insertAt = -1;
            mut arg = parseLet(
                anonIndex: outArgs.len,
                xqmark: true,
                allowTypeUnions: true,
                allowTypeParams: true,
                :initPrecedence);

            let NEW = _numDollars > numDollars0;
            if (NEW || arg.items[LET_TYPE].kind == "typeunion")
                arg.flags |= F_TEMPLATE;

            if (isInline)
            {
                arg.flags |= F_INLINE;
                outFlags  |= F_INLINE;
            }

            let annot   = arg.items[LET_TYPE];
            let init    = arg.items[LET_INIT];
            if (init)
            {
                if (arg.flags & F_IMPLICIT)
                    fail("TODO default implicit arguments");

                if (firstDefaulted < 0)
                    firstDefaulted = outArgs.len;

                if (init.kind == "definit" && !annot ||
                    arg.flags & F_TYPENAME)
                {
                    arg.flags |= F_TEMPLATE;
                }
            }
            else if (firstDefaulted >= 0)
            {
                if !(arg.flags & F_MUSTNAME)
                    fail("Non-optional arguments without a bang! cannot follow optional arguments.");

                insertAt = firstDefaulted;
                firstDefaulted++;
            }
            else if (!annot)
            {
                arg.flags |= F_TEMPLATE;
            }

            outFlags |= arg.flags & F_TEMPLATE;

            if (arg.flags & F_IMPLICIT)
                implicit.push(arg);
            else if (insertAt >= 0)
                outArgs.insert(insertAt, arg);
            else
                outArgs.push(arg);
        }

        // Ensures implicit arguments always come last.
        if (implicit)
            for (mut i = 0; i < implicit.len; i++)
                outArgs.push(implicit[i]);

        return outFlags;
    }

    fn parseLetStmt(): Node
    {
        mut ret = parseLet();

        // TODO FIX we're now adding a "let expression",
        //  which is (a := b) that can be nested wherever,
        //   but for the time being we'll support if (let a = b) for backwards compat,
        //    so the presence of this semi is what's gonna drive discards for now here.
        //
        if (softSemi())
            ret.syntax |= PS_ALWAYS_DISCARD;

        // EXPERIMENTAL free implicit ref syntax -
        //  rewrites:   implicit ref hello: Hello;
        //  into:       inline fn hello(implicit shadow ref hello: Hello) hello;
        //
        if (!(~ret.flags & (F_IMPLICIT | F_REF))    // if implicit ref,
                &&  ret.items[LET_TYPE]             //  with type annot,
                && !ret.items[LET_INIT])            //   without an initializer -
        {
            let name    = ret.value;
            let flags   = ret.flags & (F_SHADOW | F_LAX);

            ret.flags  |= F_SHADOW;                 // disambig arg with fn, same name

            return make("fn", value: name, :flags | F_INLINE,
                items: [ ret, Node(), createRead(name) ]);
        }

        //
        return ret;
    }

    fn parseLet(
        xqmark! = false,
        anonIndex! = 0,
        allowTypeUnions! = false,
        allowTypeParams! = false,
        initPrecedence! = P_RESET): Node
    {
        mut flags: Flags;

        {
            inline fn peek(token: Token)
                token.kind == "id" ||

                    // TODO FIX this is not amazing,
                    //  ideally you'd get some kind of warning
                    //   when the variable name is on the keyword list here.
                    //
                    // Without this the .autocall shorthand fails
                    //  when there's an e.g. ref prefix,
                    //   it gets interpreted as the variable name.
                    //
                    xqmark && token.kind == "op"

                                               // TODO FIX see type <T> below
                        && (token.value == "." || token.value == "<");

            if (tryConsume("id", "using"    , :fn peek)) flags |= F_USING;
            if (tryConsume("id", "implicit" , :fn peek)) flags |= F_IMPLICIT;
            if (tryConsume("id", "lax"      , :fn peek)) flags |= F_LAX;
            if (tryConsume("id", "shadow"   , :fn peek)) flags.set_SHADOW();

            if (tryConsume("id", "type"     , :fn peek)) flags |= F_TYPENAME;
            else
            {
                // FWD COMPAT
                if      (tryConsume("id", "mut"      , :fn peek)) flags |= F_MUT;
                else if (tryConsume("id", "const"    , :fn peek)) flags |= F_CONST;

                // FWD COMPAT
                if      (tryConsume("id", "ref"      , :fn peek)) flags |= F_REF;
                else if (tryConsume("id", "val"      , :fn peek)) flags |= F_VAL;
            }
        }
        //
        // Standalone `mut` - default to value semantics,
        //  this is a local variable.
        if (flags & F_MUT && !(flags & F_REF))
            flags |= F_VAL;
        //
        // Standalone `const` - default to reference semantics,
        //  locks the value in place rust-like.
        if (flags & F_CONST && !(flags & F_VAL))
            flags |= F_REF;
        //
        // If neither is set, we'll leave this up to the solver to infer.
        //  Most lets will have value semantics,
        //   except in cases of ambiguity where we'll explain what's going on,
        //    and ask the programmer to explicitly use `val` or `ref`.

        // ----
        // Autocall shorthand -
        //
        //  fn what(.id: X)    same as (id.id: X)
        let sh_autocall = xqmark && tryConsume("op", ".");

        //
        let loc0    = _loc;
        _loc        = _idx;
        defer _loc  = loc0;

        //
        mut id =
            // TODO FIX forward compat for type <T> //////////////////////
            flags & F_TYPENAME && tryConsume("op", "<")                 //
                ? { let v = consume("id").value; consume("op", ">"); v }//
            // TODO FIX forward compat for type <T> //////////////////////
                : consume("id").value;

        if (id == "_")
        {
            if (anonIndex)
                id = "_ " ~ anonIndex;

            flags |= F_LAX;
        }

        // Argument autocalls.
        if (sh_autocall)
        {
            flags |= F_COMPOUND_ID;
            id    ~= "." ~ id;
        }
        else if (xqmark && tryConsume("op", "."))
        {
            flags |= F_COMPOUND_ID;
            id    ~= "." ~ consume("id").value;

            while (tryConsume("op", "::"))
                id ~= "\t" ~ consume("id").value;
        }

        // Varargs & rest params.
        if (xqmark && tryConsume("op", "[]"))
            flags |= F_REST_ARG;

        // Explicit external arg name.
        if (xqmark && tryConsume("op", "!"))
        {
            flags |= F_MUSTNAME;

            // Alternate internal arg name.
            let inner_id =
                // TODO FIX forward compat for type <T> //////////////////////
                flags & F_TYPENAME && tryConsume("op", "<")                 //
                    ? { let v = consume("id").value; consume("op", ">"); v }//
                // TODO FIX forward compat for type <T> //////////////////////
                    : tryConsume("id").value;

            if (inner_id)
            {
                flags |= F_COMPOUND_ID;
                id    ~= "!" ~ inner_id;
            }
        }

        //
        mut optional    = xqmark && tryConsume("op", "?");

        _TODO_FIX_dollarOk = allowTypeParams;

        mut type        =
            xqmark && !optional && (optional = tryConsume("op", "?:"))
                ? parseTypeAnnot(:allowTypeUnions)
                : tryPopTypeAnnot(:allowTypeUnions);

        _TODO_FIX_dollarOk = false;

        let init        = optional
            ? createDefinit()
            : tryParseLetInit(precedence: initPrecedence);

        return createLet(id, :flags, :type, :init);
    }

    fn tryParseLetInit(precedence! = P_RESET)
    {
        return tryConsume("op", "=") && parseExpression(precedence);
    }

    fn createLet(id: string, type!?: Node, init!?: Node, flags!?: Flags): Node
    {
        return make("let", [ type, init ], :flags, id);
    }

    fn parseExpression !ParseHead(
        p1: Precedence,
        parseHead: ParseHead = fn parseExpressionHead,
        mode!?: i32): Node
    {
        //////////////////////////////
        let p0 = _precedence;
        let loc00 = _loc;
        _precedence = p1;
        _loc = _idx;
        //////////////////////////////

        // Whitespace lint -
        //  Expression tails cannot continue at or above current statement indent.
        let col00 = _col0;

        tokens[_idx].col >= _col0 + (mode & M_LINT_ENSURE_INDENT ? 1 : 0) || warn(
            "Ambiguous indent at `" ~ tokens[_idx].value
                ~ "`: expected more than " ~ _col0 ~ ", got " ~ tokens[_idx].col);

        //
        mut head = parseHead(mode?: mode);

        // TODO FIX This is gnarly - e.g. "statement-mode" lambda,
        //  we don't want to continue parsing an expression after the semi.
        //
        if !(head.syntax & PS_NOT_AN_EXPRESSION)
        {
            //////////////////////////////////////////////
            // Lint, this looks crazy but its fine really,
            //  powers the -1.abs error.
            shadow let mode =
                mode & M_LINT_UNARY_PRECEDENCE
                    && (head.kind == "int" || head.kind == "real")
                        ? mode
                        : mode &~ M_LINT_UNARY_PRECEDENCE;
            //////////////////////////////////////////////

            mut loc0 = _loc = _idx;
            mut out: Node;
            while (out = tryParseExpressionTail(:head, :mode))
            {
                // Whitespace lint.
                {
                    let t1 = tokens[_loc = loc0];
                    t1.col > col00 || warn(
                        "Ambiguous indent at `" ~ t1.value
                            ~ "`: expected more than " ~ col00
                            ~ ", got " ~ t1.col);
                }

                //
                loc0 = _loc = _idx;
                head = out;
            };
        }

        //////////////////////////////
        _precedence = p0;
        _loc = loc00;
        //////////////////////////////

        return head;
    }

    fn whitespaceDiff(prev: Token, next: Token)
    {
        if (prev.line < next.line)
            return 10;

        return max(0, min(1, next.col - prev.col - prev.chars));
    }

    fn tryParseBinary(left: Node, op: Token, p1: i32): Node
    {
        let miss = p1 > _precedence.formal || p1 == _precedence.formal && !BINOP.RIGHT_TO_LEFT[p1];

        // Whitespace lint -
        let whitesp_lint = max(
            whitespaceDiff(tokens.if(exists: _idx - 1), op),
            whitespaceDiff(op, tokens.if(exists: _idx + 1)));

        if (_precedence.tokidx)
        {
            let whitespace_diff = whitesp_lint - _precedence.whitesp_lint;
            let multiline       = whitespace_diff.abs > 1;

            if ((miss ? whitespace_diff < 0 : whitespace_diff > 0)
                    && p1 != _precedence.formal

                    && (!multiline || {
                            // To further cut down on false positives,
                            //  consider indentation - if the tighter operator is indented further in,
                            //   then the intent reads well.
                            //
                            let indent_diff = op.col - tokens[_precedence.tokidx].col;
                            miss ? indent_diff >= 0 : indent_diff <= 0
                        })

                    // Trying to make this as permissive as possible,
                    //  I don't think we want this for assignments & ternaries.
                    && !BINOP.RIGHT_TO_LEFT[p1]
                    && !BINOP.RIGHT_TO_LEFT[_precedence.formal])
            {
                if (miss)
                    _idx = _precedence.tokidx;

                warn("Misleading whitespace: misrepresents operator precedence."
                    ~ "\n\n\tPlease parenthesize this expression to disambiguate"
                    ~ (multiline
                        ? ","   ~ "\n\t\tindent the stronger operator further to the right,"
                                ~ "\n\t\tor put the weaker operator on a new line."
                        : "."));
            }
        }

        //
        if (miss)
            return [];

        shadow let p1 = Precedence(formal: p1, whitesp_lint, tokidx: _idx);

        // consume
        _idx++;

        shadow let op = op.value;

        mut mid: Node;
        if (op == "?")
        {
            mid = parseExpression(P_RESET);
            consume("op", ":");
        }

        let right = op == "->" || op == "=>"
            ? parseTypeAnnot(allowLegacyRefs: true)
            : parseExpression(p1);

        if (mid)
            return createIf(left, mid, right);

        // We'll treat these two differently,
        //  no operator overloading for those guys.
        if (op == "||") return createOr (left, right);
        if (op == "&&") return createAnd(left, right);

        if (left.kind == "and" || left.kind == "or")
            left.syntax & PS_PARENS || warn(
                "Unparenthesized `" ~ left.kind ~ "` on the left side of an `" ~ op ~ "`.");

        // Experimental sugar,
        //  pipeline operator basics.
        if (op == "|>") return pipelineRight(left, right);
        if (op == "<|") return pipelineLeft (left, right);
        if (op == ":=") return letShorthand (left, right);

        //
        if (op == "->") return typeCheck(left, right);
        if (op == "=>") return typeCast(left, right);

        //
        return createCall(
            op, F_OPERATOR, [ left, right ]);
    }

    fn typeCheck(actual: Node, expect: Node): Node
    {
        // Returns true if actual assigns to expect.
        return make("typeassert", [ actual, expect ]);
    }

    fn typeCast(actual: Node, expect: Node): Node
    {
        // Asserts type of expression.
        //  We might decide to use this as the type-cast operator.
        return make("typecast", [ actual, expect ]);
    }

    fn pipelineRight(left: Node, mut right: Node): Node
    {
        if (right.kind != "call")
            return fail("Cannot pipeline: not a call expr.");

        if (right.flags & F_CALL_HAS_DOT)
            right.items.insert(1, left);
        else
            right.items.unshift(left);

        return right;
    }

    fn pipelineLeft(mut left: Node, right: Node): Node
    {
        if (left.kind != "call")
            return fail("Cannot pipeline: not a call expr.");

        left.items.push(right);
        left.flags |= F_CALL_HAS_ARGPARENS; // non-orphan-looking
        return left;
    }

    fn letShorthand(left: Node, right: Node): Node
    {
        if (left.kind != "call" || left.flags || left.items)
            return fail("Invalid let shorthand - left side not an identifier.");

        return createLet(id: left.value, init: right);
    }

    fn tryParseExpressionTail(head: Node, mode!?: i32): Node
    {
        // Consume.
        let token = tokens[_idx++];
        if (token.kind == "op")
        {
            let v = token.value;

            fn lint()
                mode & M_LINT_UNARY_PRECEDENCE && warn(
                    "Here the unary -/+ separates from the numeric literal,"
                        ~ " and wraps around the whole expression."
                        ~ " Please parenthesize explicitly to make this obvious.");

            if (v == ";") return { _idx--; Node() };
            if (v == ".") return { lint(); parseAccessExpression(head) };
            if (v == "(") return { lint(); parseCallExpression(head) };
            if (v == "[") return { lint(); parseIndexExpression(head) };

            let p1 = BINOP.PRECEDENCE.get(v);
            if (p1)
                return { _idx--; tryParseBinary(head, token, p1) };

            if (POSTFIX.has(v))
                return createCall(
                    v == "++" || v == "--" ? "postfix" ~ v : v,
                        F_OPERATOR, [ head ]);

            if (v == "::")
                return parseQualifierChain(head);
        }

        // Backtrack.
        return { _idx--; Node() };
    }

    fn parseExpressionHead(mode: i32): Node
    {
        //////////////////////////////
        let token = tokens[_idx++];
        //////////////////////////////

        {
            let k = token.kind;
            let v = token.value;

            // Literals.
            if (k == "int" || k == "real" || k == "str" || k == "char")
                return createLeaf(k, v);

            // Identifier expression.
            if (k == "id")
            {
                let peek = tokens[_idx];
                if (peek.kind == "id")
                {
                    if (v == "fn" || v == "infix" || v == "prefix" || v == "postfix")
                    {
                        _idx++;
                        let fixity = v == "infix"   ? Infix
                                   : v == "prefix"  ? Prefix
                                   : v == "postfix" ? Postfix
                                   : { _idx--; [] };

                        return parseFnDecl(expr: true, :fixity);
                    }
                }

                if (peek.kind == "op" && peek.value == "{")
                {
                    if (v == "struct")      return parseStructDecl("struct");
                    if (v == "union")       return parseStructDecl("union");
                }

                if (_TODO_FIX_dollarOk)
                    if (_expectedTypeParams.has(v))
                        return createTypeParam(v);

                // any-HACK-2: introduce a new ... 'anonymous' type param,
                //  this also allows you to later eval the type annotation back
                //   into whatever was matched from typeParams.
                //
                if (v == "_")
                    return createAnonymousTypeParam();

                return createRead(v);
            }

            // Operators.
            if (k == "op")
            {
                if (v ==  "(") return parseParens();
                if (v ==  "{") return parseBlock();
                if (v ==  "[") return parseArrayLiteral();
                if (v ==  "$") return parseTypeParam();

                if (v ==  "|") return parseLambda(:mode);
                if (v == "||") return parseLambda(noClosingPipe: true, :mode);
                if (v ==  ".") return parseLambda(noClosingPipe: true, leadingDot: true);

                if (v == "[]") return createDefinit();

                if (v == "::")
                {
                    let id = consume("id").value;
                    _idx--;
                    return parseQualifierChain(createRead(id));
                }

                if (v == "<" && _TODO_FIX_dollarOk)
                    return parseTypeParam(">");

                return parsePrefix(v);
            }
        }

        ///////
        _idx--;
        ///////

        return fail();
    }

    fn createDefinit(): Node
    {
        return make("definit");
    }

    fn parseParens(): Node
    {
        mut out = parseExpression(P_RESET);
        out.syntax |= PS_PARENS;

        consume("op", ")");
        return out;
    }

    fn parseTypeParam(endv: string): Node
    {
        _TODO_FIX_dollarOk || fail();

        let value = consume("id").value;
        if (_upstreamTypeParams.has(value) || !_expectedTypeParams.add(value))
            fail("A type parameter " ~ value.qID ~ " is already defined.");

        consume("op", endv);

        _numDollars++;
        return make("typeparam", :value);
    }

    fn parseTypeParam(): Node
    {
        let value = "$" ~ consume("id").value;

        return createTypeParam(value);
    }

    fn createAnonymousTypeParam(): Node
    {
        return createTypeParam("_ " ~ _idx);
    }

    fn createTypeParam(value: string): Node
    {
        let isDollar = value.starts(with: '$');

        if (!_TODO_FIX_dollarOk && isDollar || _upstreamTypeParams.has(value))
            return createRead(value);

        if (_TODO_FIX_dollarOk && isDollar)
            _expectedTypeParams.add(value);

        _numDollars++;
        return make("typeparam", :value);
    }

    fn parsePrefix(mut op: string): Node
    {
        PREFIX.has(op) || { _idx--; fail() };

        let mode = op == "-" || op == "+"
            ? M_LINT_UNARY_PRECEDENCE
            : 0;

        return createPrefix(
            op, parseUnaryExpression(:mode));
    }

    fn parseUnaryExpression(mode!?: i32): Node
    {
        return parseExpression(P_PREFIX_UNARY, :mode);
    }

    fn createPrefix(op: string, mut expr: Node): Node
    {
        // Moving `-` and `+` into unary literals.
        if ((op == "+" || op == "-") &&
            (expr.kind == "int" || expr.kind == "real"))
        {
            let sign = expr.value[0];
            if (sign == '+' || sign == '-')
                expr.value[0] = sign == op.only ? '+' : '-';
            else
                expr.value = op ~ expr.value;

            return expr;
        }

        if (op == "!")
            return make("not", items: [ expr ]);

        return createCall(op, F_OPERATOR, [ expr ]);
    }

    fn parseAccessExpression(expr: Node): Node
    {
        _loc = _idx;

        mut id = tryConsume("id");
        if (!id)
        {
            consume("op", "::");
            id = consume("id");
            _idx -= 2;
        }

        return createCall(
            id.value,
            F_CALL_HAS_DOT, [ expr ]);
    }


    // This is some hacky business -
    //  might actually perform well though -
    //   path[\t]id so we can cheap-slice the path.

    fn parseQualifierChain(mut expr: Node): Node
    {
        if (expr.kind != "addroffn")
        {
            if (expr.kind != "call"
                || expr.items.len > 1
                || expr.flags & ~F_CALL_HAS_DOT)
            {
                _idx--;
                fail();
            }
        }

        expr.flags |= F_COMPOUND_ID;

        mut path = expr.value;
        for (;;)
        {
            let id = consume("id").value;
            if (!tryConsume("op", "::"))
            {
                // HACK .is::primtive & co /////////////////
                if (path == "is" && expr.items.len == 1)
                {
                    let left    = expr.items.only;
                    let right   = createTypeTag(id);
                    return typeCheck(left, right);
                }
                ////////////////////////////////////////////

                expr.value = registerImport(path, id);

                return expr;
            }

            path ~= "/" ~ id;
        }
    }

    fn createTypeTag(value: string): Node
    {
        return make("typetag", :value);
    }


    //

    fn parseCallArgs(
        endop: string, ref out_args: Node[],
        sliceSyntax!?: bool): ArgsParse
    {
        mut flags: Flags;
        mut sliceSyntax_used: bool;

        //////////////////
        let col00 = _col0;
        //////////////////

        for (;;)
        {
            mut name = "";

            // Comma juggle.
            :COMMA
            {
                if (sliceSyntax && !sliceSyntax_used)
                {
                    let peek = tokens[_idx];
                    if (peek.kind == "op" && peek.value == "..")
                    {
                        if (out_args)
                        {
                            ref last = out_args.last;
                            if (last.kind == "argid")
                                fail();

                            last = createArgID("start", last);
                            flags |= F_CALL_HAS_NAMED_ARGS;
                        }

                        _idx++;
                        sliceSyntax_used = true;

                        // This should allow fun stuff like:
                        //  hello[start .. , step: 2], etc.
                        //
                        shadow let peek = tokens[_idx];
                        if (peek.kind == "op" && peek.value == ",")
                            _idx++;
                        else
                            name = "end";

                        break :COMMA;
                    }
                }

                if (out_args)
                    softComma(:endop);
            }

            // Trailing comma -
            //  array literals, fncalls, etc.
            if (tryConsume("op", endop))
                break;

            // Named arguments.
            mut autoName = false;
            mut optional = false;

            let tok0 = tokens[_idx];

            // Whitespace lint.
            _col0 = tok0.line > tokens[_idx - 1].line
                  ? tok0.col.max(col00)
                  : col00;

            if (name)
            {
                // Already set to "end" above.
            }
            else if (tok0.kind == "op" && tok0.value == "?:")
            {
                autoName = true;
                optional = true;
                _idx += 1;
            }
            else if (tok0.kind == "op" && tok0.value == ":")
            {
                autoName = true;
                _idx += 1;
            }
            else if (tok0.kind == "id")
            {
                let tok1 = tokens[_idx + 1];
                if (tok1.kind == "op")
                {
                    if (tok1.value == ":" || (optional = tok1.value == "?:"))
                    {
                        name = tok0.value;
                        _idx += 2;
                    }
                }
            }

            mut expr = parseExpression(P_RESET);
            expr.tryColonPipeline(stmt: false);

            if (autoName)
                name = getAutoName(expr);

            if (name)
            {
                flags |= F_CALL_HAS_NAMED_ARGS;

                // TODO FIX auto-name lambdas & co if possible, better debug.
                if (expr.kind == "fn" && expr.value == "_")
                    expr.value = name;
            }

            out_args.push(
                name    ? createArgID(name, expr, flags: optional && F_ARGID_IS_OPTIONAL)
                        : expr);
        }

        //////////////
        _col0 = col00;
        //////////////

        return ArgsParse(:flags, sliceSyntax: sliceSyntax_used);
    }

    fn getAutoName(expr: Node): string
    {
        if (expr.value.hasIdentifierChars)
            if (expr.kind == "call" || expr.kind == "typeparam" || expr.kind == "addroffn")
                return expr.value;

        if (expr.items)
        {
            // _  ? NAME :  _
            //      NAME || _       same as NAME ? NAME : _
            // _ && NAME            same as _    ? NAME : 0

            let i = expr.kind == "and" && expr.items.len - 1
                  ? expr.kind == "if"  && 1
                  : 0;

            return getAutoName(expr.items[i]);
        }

        return fail("Cannot :autoname this expression.");
    }

    fn createArgID(id: string, expr: Node, flags?: Flags): Node
    {
        return make("argid", [ expr ], :flags, id);
    }

    fn parseCallExpression(expr: Node): Node
    {
        mut args: Node[];

        ////////////////////////////////
        let numDollars0 = _numDollars;
        ////////////////////////////////

        mut argFlags = parseCallArgs(")", args).flags;

        ////////////////////////////////
        if (_numDollars > numDollars0)
            argFlags |= F_TEMPLATE;
        ////////////////////////////////

        mut flags = expr.flags | argFlags;

        :CallByName
        {
            if (expr.syntax & PS_PARENS)
                break :CallByName;

            // Uniform call syntax.
            if (expr.kind == "call" &&
                    flags & (F_CALL_HAS_DOT | F_CALL_HAS_ARGPARENS)
                          == F_CALL_HAS_DOT)
            {
                let head = expr.items.len == 1 && expr.items[0]
                    || throw("Malformed property access expression.");

                args.unshift(head);

                // Fallthrough.
            }
            else if (expr.kind == "call" &&
                !(flags & (F_CALL_HAS_DOT | F_CALL_HAS_ARGPARENS)))
            {
                // Fallthrough.
            }
            else if (expr.kind == "typeparam")
            {
                // Fallthrough.
            }
            else
            {
                break :CallByName;
            }

            return createCall(
                expr.value || fail(),
                :flags | F_CALL_HAS_ARGPARENS,
                args);
        }

        // Call-by-expression.

        // Stuff like (a)() will currently hit this,
        //  ideally we'd start supporting this at some point.
        //
        return make("call_indir", expr ~ args, flags: argFlags);
    }

    fn createCall(id: string, flags: Flags, args?: Node[], syntax?: ParseSyntax): Node
    {
        return make("call", args, :flags, :syntax, id);
    }

    fn parseArrayLiteral(): Node
    {
        mut args: Node[];
        let argFlags = parseCallArgs("]", args).flags;

        return createArrayLiteral(argFlags, args);
    }

    fn createArrayLiteral(argFlags: Flags, items: Node[]): Node
    {
        return make("arrlit", items, argFlags);
    }

    fn parseIndexExpression(expr: Node): Node
    {
        mut args: Node[];
        let argsParse = parseCallArgs("]", args, sliceSyntax: true);

        args.unshift(expr);

        return createCall(
            argsParse.sliceSyntax ? "[..]" : "[]",
            argsParse.flags | F_OPERATOR,
            args);
    }

    fn createLeaf(kind: Kind, value: string): Node
    {
        return make(kind, :value);
    }

    fn createRead(id: string, flags?: Flags): Node
    {
        if (id == "true" || id == "false")
            return make("bool", value: id);

        return createCall(id || fail(), :flags);
    }


    //

    fn parseJump(kind: Kind/*"break"|"continue"|"return"*/): Node
    {
        _fnDepth > 0 || { _idx--; fail() };

        let label = tryConsume("op", ":") && consume("id").value;

        mut expr: Node;
        if (!tryConsume("op", ";"))
        {
            expr = parseExpression(P_RESET, mode: M_LINT_ENSURE_INDENT);
            softSemi();
        }

        return make(kind, value: label, expr && [ expr ]);
    }

    fn parseDefer(): Node
    {
        let value = tryConsume("op", ":")
                && (tryConsume("id", "err") || consume("id", "ok")).value;

        _fnDepth > 0 || { _idx--; fail() };
        return make("defer", :value, [ parseStatement() ],

            // TODO FIX remove this, solver fails to handle a bunch of things,
            //  shouldn't rely on a friendly parse for things to work.
            syntax: PS_ALWAYS_DISCARD);
    }

    fn parseTryCatch(): Node
    {
        _fnDepth > 0 || { _idx--; fail() };

        let try = parseStatement();

        consume("id", "catch");
        consume("op", "(");

        let err = parseCatchErrvar();

        consume("op", ")");

        let catch = parseStatement();

        return make("try", [ try, err, catch ]);
    }

    fn parseCatchErrvar(): Node
    {
        let id = consume("id").value;
        return createLet(:id, type: createRead("string"));
    }


    //

    fn parseIfCond(): Node
    {
        // A little bit of syntactic sugar -
        //  TBD if this is good or not, i'm 50/50.
        //   At least it's unambiguous.
        let not = tryConsume("op", "!");

        consume("op", "(");
        let cond = parseLetOrExpressionStatement();
        consume("op", ")");

        if (not)
            return createPrefix("!", cond);

        return cond;
    }

    fn parseIf(): Node
    {
        // Indentation lint for `else`s:
        //  This catches problems such as | if (a) for (b) if (c) smth
        //                                | else ...       <- will go to inner if instead of outer as indentation suggests was intended.
        let token =             tokens[_idx - 1];
        let prev  = _idx > 1 && tokens[_idx - 2];

        shadow let token = prev.kind == "id" && prev.value == "else" ? prev : token;

        let cond = parseIfCond();
        let cons = parseSubStatement();

        let else = tryConsume("id", "else");
        if (else)
        {
            else.line == token.line || else.col == token.col || warn(
                "Inconsistent indent at `else`: expected " ~ token.col
                    ~ ", got " ~ else.col
                    ~ ". `if` starts on line " ~ token.line ~ ".");

            let alt = parseStatement();
            return createIf(cond, cons, alt, syntax: PS_ALWAYS_DISCARD);
        }

        return createAnd(cond, cons, syntax: PS_ALWAYS_DISCARD);
    }


    //

    fn createIf(cond: Node, cons: Node, alt: Node, syntax?: ParseSyntax): Node
    {
        return make("if", [ cond, cons, alt ], :syntax);
    }

    fn createOr(left: Node, right: Node, syntax?: ParseSyntax): Node
    {
        return flattenIfSame("or", left, right, :syntax);
    }

    fn createAnd(left: Node, right: Node, syntax?: ParseSyntax): Node
    {
        return flattenIfSame("and", left, right, :syntax);
    }

    fn flattenIfSame(kind: Kind, left: Node, right: Node, syntax?: ParseSyntax): Node
    {
        let k_left  =  left.kind;
        let k_right = right.kind;

        let items =
            k_left == kind && k_right == kind
                ? left.items ~ right.items
                : k_left == kind
                    ? left.items ~ right
                    : k_right == kind
                        ? left ~ right.items
                        : [ left, right ];

        return make(kind, items, :syntax);
    }


    //

    fn parseFor(): Node
    {
        consume("op", "(");

        // First of the crazies.
        if (tryConsume("id", "fieldname"))
        {
            let placeholder = consume("id").value;
            consume("op", ":");
            let type = parseTypeAnnot();
            consume("op", ")");
            let body = parseSubStatement();

            return make("forfieldsof",
                value: placeholder,
                items: [ type, body ]);
        }

        //
        let init = !tryConsume("op", ";") && parseStatement();
        if (init && init.kind != "let")
            fail("`for` expects a `let` statement, got a `" ~ init.kind ~ "`.");

        let pre_cond = !tryConsume("op", ";") && parseLetOrExpressionStatement();

        let token   = tokens[_idx];
        let post    = !(token.kind == "op" && token.value == ")")
            ? parseParens()
            : consume("op", ")") && [];

        let pre     = tryParseLoopPreheader();
        let body    = parseStatement();

        return createLoop(:init, :pre_cond, :pre, :post, :body);
    }

    fn tryParseLoopPreheader()
    {
        let peek = tokens[_idx];
        if (peek.kind == "id" && peek.value == "on")
        {
            shadow let peek = tokens[_idx + 1];
            if (peek.kind == "id" && peek.value == "enter")
            {
                _idx += 2;
                let ret = parseStatement();
                consume("id", "then");
                return ret;
            }
        }

        return [];
    }

    fn parseWhile(): Node
    {
        let pre_cond = parseIfCond();
        let body = parseSubStatement();

        return createLoop(:pre_cond, :body);
    }

    fn parseDoWhile(): Node
    {
        let body = parseSubStatement();
        consume("id", "while");
        consume("op", "(");
        let post_cond = parseLetOrExpressionStatement();
        consume("op", ")");
        softSemi();

        return createLoop(:body, :post_cond);
    }

    fn createLoop(init!?: Node, pre_cond!?: Node, pre!?: Node, body!?: Node, post!?: Node, post_cond!?: Node): Node
    {
        return make("loop",
            [ init, pre_cond, pre, body, post, post_cond ],
            syntax: PS_ALWAYS_DISCARD);
    }

    // -------------------------------
    // Good to go.

    // Check EOF.
    tokens[tokens.len - 1].kind == "eof" || fail(
        "Missing `eof` token.");

    // PARSE END

    //
    let root = parseRoot();

    return ParserOutput(
        :root, :imports, :warnings);
}
