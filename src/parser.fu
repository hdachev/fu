import ansi;
import helpers;
import module;
import fail;
import flags;


//

let use_AUTOPUB     = true;


// Operator precedence table.

let P_RESET           = 1000;
let P_PREFIX_UNARY    = 1   ;

let PREFIX:  string[] = [ "++", "+", "--", "-", "!", "~", "?", "*", "&", "&mut" ];
let POSTFIX: string[] = [ "++", "--", "[]" ];

fn setupOperators()
{
    struct BINOP {
        PRECEDENCE:     map::Map(string, i32);
        RIGHT_TO_LEFT:  bool[];
    };

    mut out: BINOP;

    mut precedence  = P_PREFIX_UNARY;
    mut rightToLeft = false;

    fn binop(ops: string[])
    {
        precedence++;

        precedence < 64 || throw(
            "Assertion failed: precedence < 64");

        out .RIGHT_TO_LEFT
            .grow_if_oob(precedence) = rightToLeft;

        for (mut i = 0; i < ops.len; i++)
            out.PRECEDENCE.map::set(ops[i], precedence);
    }

    // TODO not so simple,
    //  must be stronger than unary - and +,
    //   or alternatively also fail lint.
    //
    // See: https://stackoverflow.com/questions/47068812/javascript-exponentiation-unary-operator-design-decision
    //
    // rightToLeft = true;
    // binop([ "**" ]);

    rightToLeft = false;
    binop([ "*", "/", "%" ]);
    binop([ "+", "-" ]);
    binop([ "<<", ">>" ]);
    binop([ "&" ]); // Notice this is not js/c precedence, it's just never usefu]l.
    binop([ "^" ]); // We're doing the rust thing her]e.
    binop([ "|" ]);
    binop([ "~" ]); // concat operator - same prec as in lua, as weak as possible
    binop([ "<=>", "<>" ]);
    binop([ "=>", "->" ]); // see c# as, is and js in, instanceof
    binop([ "<", "<=", ">", ">=", "<=>" ]);
    binop([ "==", "!=" ]);
    binop([ "&&" ]);
    binop([ "||" ]);

    rightToLeft = true;
    binop([ "?",
            "=", "+=", "-=", "**=", "*=", "/=", "%=", "<<=", ">>=", "&=", "^=", "|=",
            "||=", "&&=", ".=", "~=" ]);

    // F# has weird precedence here, why?
    binop([ "<|" ]);

    rightToLeft = false;
    binop([ "|>" ]);

    //
    return out;
}

let BINOP     = setupOperators();


// Descent modes.

let M_LINT_UNARY_PRECEDENCE = 1 << 0;
let M_LINT_ENSURE_INDENT    = 1 << 1;
let M_LAMBDA_STMT_OK        = 1 << 2;


//

pub fn parse(
    modid!: i32,
    fname!: string, src!: string, tokens!: Token[],
    implicit options!: options::Options): ParserOutput
{
    mut _idx        = 0;
    mut _loc        = 0;
    mut _col0       = 0;
    mut _precedence = P_RESET;
    mut _fnDepth    = 0;

    mut _dollarAuto = 0;
    mut _dollars    : string[];

    mut _anonFns    = 0;

    mut _hasPUB     = false;


    // TODO FIX So the $T thing backfired -
    //  when you have an if (a -> $T) in the middle of some fn,
    //   if you rename the $T in the fn sig,
    //    it starts introducing a new unused type param AND DOES NOTHING.
    //
    // It's not neat, so we'll have to go for introducing type params explicitly so these things are unambiguous.
    //  In the meantime, we forbid the introduction of new type params halfway through a function.
    //
    // The upside is this frees up the dollar sigil.

    mut _TODO_FIX_dollarOk  = false;


    //

    mut fuzimports: string[];
    mut warnings:   string[];

    fn registerImport(mut value: string): string
    {
        if (!value.path::ext)
            value ~= ".fu";

        // Exact relative or fuzzy?
        let dir = path::dirname(fname);
        value   = value.starts(with: ".")
                ? path::join(dir, value)
                : dir ~ '\v' ~ value;

        if (!fuzimports.has(value))
            fuzimports.push(value);

        return value;
    }


    //

    fn fail(mut reason: string = "")
    {
        let token = tokens[_idx];
        if (!reason)
            reason = "Unexpected `" ~ token.value ~ "`.";

        return FAIL(:fname, :src, :token, :reason);
    }

    fn fail_compose(mut reason: string)
    {
        let loc  = tokens[_loc];
        let here = tokens[_idx];

        if (!reason)
            reason = "Unexpected `" ~ here.value ~ "`.";

        let l0 = loc.line;
        let c0 = loc.col;

        let l1 = here.line;
        let c1 = here.col;

        let addr = l1 == l0
            ? "@" ~ l1 ~ ":" ~ c1
            : "@" ~ l0 ~ ":" ~ c0 ~ ".." ~ l1 ~ ":" ~ c1;

        return fname ~ " " ~ addr ~ ":\n\t" ~ reason;
    }

    fn warn(reason: string)
    {
        if (warnings.len == options.maxwarn)
            return fail(reason);

        warnings ~= fail_compose(reason);
    }

    fn make(
        ::kind,
        items?: Node[],
        flags?: i32,
        value?: string,
        asserts?: DeclAsserts)
    {
        return Node(
            :kind, :flags, :asserts, :value, :items,
                token: TokenIdx(:modid, _loc) );
    };

    fn miss() Node();


    //

    fn consume(::kind, value?: [byte], err?: string): Token
    {
        let token = tokens[_idx];
        if (token.kind == kind && (!value || token.value == value))
        {
            _idx++;
            return token;
        }

        return fail((err || "Expected") ~
            " `" ~ (value || kind) ~ "`, got `" ~ token.value ~ "`.");
    }

    fn tryConsume(::kind, value?: [byte]): Token
    {
        let token = tokens[_idx];
        if (token.kind == kind && (!value || token.value == value))
        {
            _idx++;
            return token;
        }

        return [];
    }


    //

    fn parseRoot(): Node
    {
        consume("sof", "sof");

        _loc = _idx;

        mut out = make("root",
            parseBlockLike("eof", "eof"));

        // Autopub.
        if (use_AUTOPUB && !_hasPUB) for (mut i = 0; i < out.items.len; i++)
        {
            ref item = out.items[i];

            let k = item.kind;
            if (k == "fn" || k == "let" || k == "typedef" || k == "struct" || k == "enum" || k == "flags" || k == "primitive")
                if !(item.flags & F_SHADOW)
                    set_PUB(item.flags);
        }

        return out;
    }

    fn parseCompilerPragma(): Node
    {
        let value = consume("id").value;

        // Codegen passthrough for direct c++ hacks.
        if (value != "break")
        {
            mut items: Node[];
            consume("op", "(");
            parseCallArgs(")", items);

            return make("pragma", :value, :items);
        }

        //
        let ret = make("pragma", :value);
        softSemi();
        return ret;
    }


    //

    fn parseBlock(): Node
    {
        return createBlock(
            parseBlockLike("op", "}"));
    }

    fn createBlock(items: Node[], label?: string): Node
    {
        return make("block", :items, value: label);
    }


    //

    fn softComma(endop: string)
    {
        let peek = tokens[_idx];
        if (peek.kind == "op")
        {
            if (peek.value == ",") {
                _idx++;
                return;
            }

            if (peek.value == endop)
                return;
        }

        // Experimental,
        //  optional commas around string literals -
        //   but not when two literals are adjacent.
        //
        if ((peek.kind == "str") != (tokens[_idx - 1].kind == "str"))
            return;

        warn("Missing comma before `" ~ peek.value ~ "`.");
    }

    fn softSemi()
    {
        let peek = tokens[_idx];
        if (peek.kind == "op")
        {
            if (peek.value == ";") {
                _idx++;
                return;
            }

            if (peek.value == "}" || peek.value == ")")
                return;
        }

        // Experimental:
        //  allow optional semis when
        //   whitespace is completely unambiguous.
        //
        else if (peek.col == _col0)
        {
            return;
        }

        warn("Missing semicollon before `" ~ peek.value ~ "`.");
    }

    fn parseTypedef(): Node
    {
        let name = consume("id").value;
        consume("op", "=");
        let annot = parseTypeAnnot();
        softSemi();

        return make("typedef", value: name, items: [ annot ]);
    }


    //

    fn parseNoCopy(): Node
    {
        consume("id", "struct");

        return parseStructDecl(flags: F_NOCOPY, asserts: A_NOCOPY);
    }

    fn parseStructDecl(flags!?: i32, asserts!?: DeclAsserts): Node
    {
        let name = tryConsume("id").value;

        consume("op", "{");
        mut items = parseBlockLike("op", "}", struct: true);

        :F_PREDICATE
        {
            // Unless user tagged somethign as F_PREDICATE explicitly ...
            items.each: |item|
                if (item.kind == "let")
                    if (item.flags & F_PREDICATE)
                        break :F_PREDICATE;

            //  ... then every field is a predicate.
            items.each: |item|
                if (item.kind == "let")
                    item.flags |= F_PREDICATE;
        }

        // Items: [ Base type (primitives), items (structs, enums & unions) ]
        return make("struct", [ [], make("members", items) ], :flags, :asserts, name);
    }

    fn parseStructItem(): Node
    {
        // Subset of fields we're gonna be using for conversion to bool -
        //  for example, a dynamic array's `size`, or a Node's `kind` here.
        let isPredicate = tryConsume("id", "true");

        mut member = parseLet(xqmark: true);
        softSemi();

        if (isPredicate)
            member.flags |= F_PREDICATE;

        return member;
    }


    //

    fn parsePrimDecl(::kind): Node
    {
        let name    = tryConsume("id").value;
        let annot   = tryPopTypeAnnot();
        mut items   = tryConsume("op", "{") && parseBlockLike("op", "}", enum: true);

        if (kind != "enum" && kind != "flags")
            annot || fail("`primitive` declarations require a base type annotation.");

        return make(
            :kind, value: name,
                [ annot, items && make("members", items) ]);
    }

    fn parseEnumItem(): Node
    {
        let id      = consume("id").value;
        let init    = tryParseLetInit();
        softSemi();

        return createLet(:id, flags: 0, [], :init);
    }


    //

    fn parseBlockLike(
        endKind: ::kind, endVal: string,
        struct! = false,
        enum! = false): Node[]
    {
        let line0   = _idx && tokens[_idx - 1].line;
        let col00   = _col0;

        mut colNN   = -1;
        mut lineNN  = line0;

        mut items: Node[] = [];
        for (;;)
        {
            let token = tokens[_idx];

            // Ignore excess semicolons, e.g. struct{}; etc.
            if (token.kind == "op" && token.value == ";")
            {
                _idx++;
                continue;
            }

            if (token.kind == endKind && token.value == endVal)
            {
                // Done.
                _col0 = col00;
                _idx++;

                // Style-check, makes for more helpful errors.
                let line1 = token.line;
                let col1  = token.col;

                line1 == line0 || col1 == _col0 || warn(
                    "Inconsistent indent at closing `" ~ token.value ~ "`: expected " ~ (_col0 - 1)
                        ~ ", got " ~ (col1 - 1)
                        ~ ". Block starts on line " ~ line0 ~ ".");

                break;
            }

            //
            _col0 = token.col;
            _col0 > col00 || warn(
                "Inconsistent indent at `" ~ token.value ~ "`: expected more than " ~ col00
                    ~ ", got " ~ _col0 ~ ". Block starts on line " ~ line0 ~ ".");

            // Consistent indentation within blocks.
            colNN < 0 || colNN == _col0 || token.line == lineNN || warn(
                "Inconsistent indent at `" ~ token.value ~ "`: expected exactly " ~ colNN
                    ~ ", got " ~ _col0 ~ ". Previous statement starts on line " ~ lineNN ~ ".");

            if (colNN < 0)
                colNN = _col0;

            lineNN = token.line;

            //
            let expr    = struct    ? parseStructItem()
                        : enum      ? parseEnumItem()
                                    : parseStatementOrDefer();

            // Maybe we should get rid of this.
            expr.kind != "call"
                || ((expr.flags & (F_ID | F_ACCESS)) == 0)
                || expr.items.len > 1
                || tokens[_idx].value == endVal
                || warn("Orphan pure-looking expression.");

            items.push(expr);
        }

        return items;
    }


    // Watch out, we want to not allow pubs & shadows together.

    fn set_PUB(ref flags: i32)
    {
        flags |= F_PUB;
        flags & F_SHADOW && fail("Cannot pub a shadow.");

        _hasPUB = true;
    }

    fn parsePub(): Node
    {
        _fnDepth && fail("Cannot pub from within a fn.");
        mut out = parseStatement();
        set_PUB(out.flags);
        return out;
    }

    fn parseShadow(): Node
    {
        mut out = parseStatement();
        out.flags |= F_SHADOW;
        out.flags & F_PUB && fail("Cannot shadow a pub.");
        return out;
    }


    //

    fn parseStatement(): Node
    {
        ///////////////////////////////////////////////
        let loc0 = _loc;
        defer _loc = loc0;
        let token = tokens[_loc = _idx++] || fail();
        ///////////////////////////////////////////////

        //
        if (token.kind == "op")
        {
            let v = token.value;

            if (v == "{")           return parseBlock();
            if (v == ":")           return parseLabelledStatement();
        }
        else if (token.kind == "id")
        {
            let v = token.value;
            let peek = tokens[_idx];

            if (_fnDepth)
            {
                if (v == "if")          return parseIf();
                if (v == "for")         return parseFor();
                if (v == "while")       return parseWhile();
                if (v == "do")          return parseDoWhile();

                if (v == "return")      return parseJump("return");
                if (v == "break")       return parseJump("break");
                if (v == "continue")    return parseJump("continue");

                if (v == "try")         return parseTryCatch();
            }

            if (peek.kind == "op")
            {
                if (peek.value == "{" && v == "struct")
                    return parseStructDecl();
            }

            if (v == "fn" && (peek.kind == "id" || !_fnDepth))
            {
                                        return parseFnDecl();
            }

            if (peek.kind == "id")
            {
                if (v == "struct")      return parseStructDecl();
                if (v == "type")        return parseTypedef();

                if (v == "pub")         return parsePub();
                if (v == "shadow")      return parseShadow();
                if (v == "using")       return parseConversionDecl();

                if (v == "nocopy")      return parseNoCopy();
                if (v == "import")      return parseImport();

                if (v == "pragma")      return parseCompilerPragma();

                if (v == "inline")      return parseInlineDecl();
                if (v == "infix")       return parseFixityDecl(F_INFIX);
                if (v == "prefix")      return parseFixityDecl(F_PREFIX);
                if (v == "postfix")     return parseFixityDecl(F_POSTFIX);

                if (v == "primitive")   return parsePrimDecl("primitive");
                if (v == "flags")       return parsePrimDecl("flags");
                if (v == "enum")        return parsePrimDecl("enum");

                if (v == "pure")        return parseExoticDecl(asserts: A_PURE);
                if (v == "purectx")     return parseExoticDecl(asserts: A_PURE_CTX);
                if (v == "novec")       return parseExoticDecl(asserts: A_NOVEC);
                if (v == "noflow")      return parseExoticDecl(asserts: A_NOFLOW);
                if (v == "extern")      return parseExoticDecl(F_EXTERN);
                if (v == "hotswap")     return parseExoticDecl(F_HOTSWAP);

                // SKETCH EFFECTS //////////////////////////////////////////////
                if (v == "effect")      return parseStructDecl(flags: F_EFFECT);
                // SKETCH EFFECTS //////////////////////////////////////////////
            }
        }

        ////////////
        _idx--;
        ////////////

        return parseLetOrExpressionStatement();
    }

    fn parseLetOrExpressionStatement(): Node
    {
        let token = tokens[_idx++];
        if (token.kind == "id" && tokens[_idx].kind == "id")
        {
            let v = token.value;
            if (v == "let")         return parseLetStmt();
            if (v == "lax")         return { _idx--; parseLetStmt() };
            if (v == "mut")         return { _idx--; parseLetStmt() };
            if (v == "ref")         return { _idx--; parseLetStmt() };
        }

        ////////////
        _idx--;
        ////////////

        // No expression statements outside of fns for now.
        if (!_fnDepth)
            fail();

        // Expression statement, followed by a semi.
        return parseExpressionStatement();
    }

    fn parseStatementOrDefer()
    {
        let peek = tokens[_idx];

        if (peek.kind == "id")
        {
            let v = peek.value;
            if (v == "defer")
                return { _idx++; parseDefer() };
        }

        return parseStatement();
    }

    fn parseImport(): Node
    {
        mut value = tryConsume("id").value;
        if (value)
        {
            while (tryConsume("op", "::"))
                value ~= "/" ~ consume("id").value;
        }
        else
        {
            value = consume("str").value;
        }

        softSemi();
        value = registerImport(value);
        return make("import", :value);
    }

    fn parseLabelledStatement(): Node
    {
        let label = consume("id").value;

        mut stmt = parseStatement();
        if (stmt.kind == "loop" || stmt.kind == "block")
        {
            stmt.value && fail("Label `" ~ label ~ "`: statement already labeled as `" ~ stmt.value ~ "`.");
            stmt.value = label;
            return stmt;
        }

        return createBlock([ stmt ], :label);
    }

    fn parseExpressionStatement(): Node
    {
        let expr = parseExpression(P_RESET);

        // Pipeline left expriment.
        if (tryConsume("op", ":"))
        {
            if !(expr.kind == "call")
                fail("Cannot pipeline: expression is not a call.");

            let right = parseExpression(P_RESET, mode: M_LAMBDA_STMT_OK);
            return pipelineLeft(expr, right);
        }

        //
        softSemi();
        return expr;
    }


    // Fn decorator order -
    //  fn keyword comes last to disambiguate operators from anonymous functions,
    //   which makes the parse a bit problematic but whatever.

    fn parseConversionDecl(): Node
    {
        let flags = F_CONVERSION;

        let v = consume("id").value;
        if (v == "inline") return parseInlineDecl(flags);
        _idx--;

        return parseFixityDecl(flags);
    }

    fn parseExoticDecl(mut flags?: i32, mut asserts?: DeclAsserts): Node
    {
        for (;;)
        {
            let v = consume("id").value;

            fn add(flag: i32)
            {
                flags  & flag && fail("Duplicate qualifier: " ~ v.qKW);
                flags |= flag;
            }

            fn add(assert?: DeclAsserts)
            {
                asserts  & assert && fail("Dulicate assertion: " ~ v.qKW);
                asserts |= assert;
            }

            if      (v == "pure")       add(A_PURE);
            else if (v == "purectx")    add(A_PURE_CTX);
            else if (v == "novec")      add(A_NOVEC);
            else if (v == "noflow")     add(A_NOFLOW);
            else if (v == "extern")     add(F_EXTERN);
            else if (v == "hotswap")    add(F_HOTSWAP);

            else if (v == "fn")
                return { _idx--; parseInlineDecl(F: flags, :asserts) };
            else
                fail("Unknown qualifier: " ~ v.qKW);
        }
    }

    fn parseInlineDecl(mut flags?: i32, F = F_INLINE, mut asserts?: DeclAsserts): Node
    {
        flags |= F;

        let v = consume("id").value;
        if (v == "infix")   return parseFixityDecl(flags | F_INFIX);
        if (v == "prefix")  return parseFixityDecl(flags | F_PREFIX);
        if (v == "postfix") return parseFixityDecl(flags | F_POSTFIX);
        _idx--;

        return parseFixityDecl(:flags, :asserts);
    }

    fn parseFixityDecl(flags: i32, asserts?: DeclAsserts, expr?: bool): Node
    {
        if (flags & F_CONVERSION)
            flags & (F_INFIX | F_PREFIX | F_POSTFIX) &&
                fail("`implicit` functions can't be operators.");

        consume("id", "fn");
        return parseFnDecl(flags, :asserts, :expr);
    }


    //

    fn parseLambda(noArgs_noClosingPipe!?: bool, mode!?: i32): Node
    {
        if (noArgs_noClosingPipe && _precedence > P_RESET && _precedence < P_PREFIX_UNARY)
            warn("Unparenthesized `|| lambda` within a binary expression.");

        let name = "l_" ~ modid ~ "_" ~ _anonFns++;

        return parseFnDecl_cont(endv: !noArgs_noClosingPipe && "|",
            flags: F_INLINE | F_LAMBDA, expr: !(mode & M_LAMBDA_STMT_OK), :name);
    }

    fn parseFnDecl(mut flags?: i32, asserts?: DeclAsserts, expr!?: bool): Node
    {
        // fn hello(), fn +()
        mut name = tryConsume("id").value;
        if (!name)
        {
            let postfix = flags & F_POSTFIX;
            name = consume("op").value;

            if (postfix)
            {
                name == "++" || name == "--"
                    || fail("No such postfix operator: `" ~ name ~ "`.");

                name = "postfix" ~ name;
            }
            else if (flags & F_INFIX)
            {
                BINOP.PRECEDENCE.map::has(name) || fail("No such infix operator: `" ~ name ~ "`.");
            }
            else if (flags & F_PREFIX)
            {
                PREFIX.has(name) || fail("No such prefix operator: `" ~ name ~ "`.");
            }

            flags &= ~(F_INFIX | F_PREFIX);
            flags |= F_OPERATOR;
        }
        else if (flags & (F_INFIX | F_PREFIX | F_POSTFIX))
        {
            fail("Not an operator: `" ~ name ~ "`.");
        }

        //
        let endv = tryConsume("op", "(") && ")";
        if (!endv)
        {
            if (expr)
                return createAddrOfFn(:name, :flags);

            consume("op", "=");
        }

        return parseFnDecl_cont(:flags, :asserts, :name, :expr, :endv);
    }

    fn createAddrOfFn(name!: string, flags!: i32): Node
    {
        return make(kind: "addroffn", :flags, value: name);
    }

    fn parseFnDecl_cont(name!: string, mut flags!?: i32, asserts?: DeclAsserts, expr!?: bool, endv! = ")"): Node
    {
        // Opening parens!
        mut items: Node[];

        ////////////////////////////////
        _fnDepth++;
        let dollars0 = _dollars.len;
        let dollarsOk0 = _TODO_FIX_dollarOk;

        defer {
            _fnDepth--;
            _dollars.shrink(dollars0);
            _TODO_FIX_dollarOk = dollarsOk0;
        }
        ////////////////////////////////

        flags |= endv && parseArgsDecl(items, "op", :endv);

        // Return type annot.
        mut type = tryPopTypeAnnot();
        let retIdx = items.len;
        items.push(type);

        // Body or pattern (case/case).
        flags |= parseFnBodyOrPattern(items, :expr);

        // Ensure main: i32, kinda lame doing it here.
        if (name == "main" && _fnDepth == 1)
        {
            if (!type)
                items[retIdx] = type = createRead("i32");
            else if (type.kind != "call" || type.value != "i32" || type.items.len)
                fail("fn main() must return i32.");

            set_PUB(flags);
            flags |= F_EXTERN;
        }

        //
        if (_dollars.len > dollars0)
            flags |= F_TEMPLATE;

        return make("fn", :items, :flags, :asserts, name);
    }

    fn parseFnBodyOrPattern(
        ref out_push_body: Node[], expr!: bool): i32
    {
        //
        mut flags = 0;
        mut body: Node;

        //
        if (!expr && tryConsume("id", "case"))
        {
            mut branches: Node[] = [];

            fn parseBranch(noCond?: bool)
            {
                _TODO_FIX_dollarOk = true;
                let cond = !noCond && parseUnaryExpression();
                _TODO_FIX_dollarOk = false;

                let type = tryPopTypeAnnot();
                let cons = parseFnBodyBranch();

                branches.push(
                    make("fnbranch", [ cond, type, cons ]));
            }

            // Parse cases.
            do parseBranch();
            while (tryConsume("id", "case"));

            // Trailing else.
            if (tryConsume("id", "default"))
                parseBranch(noCond: true);

            //
            body = make("pattern", branches);
        }
        else
        {
            body = parseFnBodyBranch(:expr);
        }

        //
        out_push_body.push(body);
        return flags;
    }

    fn parseFnBodyBranch(expr?: bool): Node
    {
        // Allow a leading `=` before body.
        //  We'll transition to this thing fulltime
        //   in the presence of type annots.
        tryConsume("op", "=");

        //
        mut body = expr
            ? parseExpression(_precedence)
            : parseStatement();

        if (body.kind == "block")
        {
            // Make sure last item doesn't look like a trailing return.
            //  With this we could probably get rid of F_SINGLE_STMT.
            //
            if (body.items && body.items.last.kind != "return")
                body.items ~= make("void");

            return body;
        }

        if (body.kind == "return")
            return createBlock([ body ]);

        if (body.kind == "call" && body.value == "__native")
            return body;

        return createBlock([ createReturn(body, flags: F_SINGLE_STMT) ]);
    }

    fn tryPopTypeAnnot(allowTypeUnions! = false): Node
    {
        return tryConsume("op", ":")
             ? parseTypeAnnot(:allowTypeUnions)
             : miss;
    }

    fn parseTypeAnnot(allowTypeUnions! = false): Node
    {
        mut res = parseUnaryExpression();

        // EXPERIMENTAL type union syntax
        while (allowTypeUnions && tryConsume("id", "or"))
        {
            if (res.kind != "typeunion")
                res = make("typeunion", [ res ]);

            res.items ~= parseUnaryExpression();
        }

        return res;
    }

    fn parseArgsDecl(
        ref outArgs: Node[],
        endk: ::kind, endv: string): i32
    {
        mut first = true;
        mut outFlags = 0;

        mut implicit: Node[];
        mut defaults = false;
        mut firstDefault = -1;

        //////////////
        _dollarAuto++;
        _TODO_FIX_dollarOk = true;
        //////////////

        let dollars0 = _dollars.len;
        for (;;)
        {
            if (tryConsume(endk, endv))
                break;

            if (!first)
                consume("op", ",");

            first = false;

            let isInline = !!tryConsume("id", "inline");

            mut insertAt = -1;
            mut arg = parseLet(xqmark: true, allowTypeUnions: true);
            if (_dollars.len > dollars0 || arg.items[LET_TYPE].kind == "typeunion")
                arg.flags |= F_TEMPLATE;

            if (isInline)
            {
                arg.flags |= F_INLINE;
                outFlags  |= F_INLINE;
            }

            if (arg.items[LET_INIT])
            {
                if (arg.flags & F_IMPLICIT)
                    fail("TODO default implicit arguments");

                defaults        = true;
                firstDefault    = outArgs.len;
            }
            else if (defaults)
            {
                if !(arg.flags & F_MUSTNAME)
                    fail("TODO non-trailing default arguments");

                insertAt    = firstDefault;
                firstDefault++;
            }
            else if (!arg.items[LET_TYPE])
            {
                arg.flags |= F_TEMPLATE;
            }

            arg.flags |= F_ARG;
            outFlags  |= arg.flags & F_TEMPLATE;

            if (arg.flags & F_IMPLICIT)
                implicit.push(arg);
            else if (insertAt > 0)
                outArgs.insert(insertAt, arg);
            else
                outArgs.push(arg);
        }

        //////////////
        _dollarAuto--;
        _TODO_FIX_dollarOk = false;
        //////////////

        // Ensures implicit arguments always come last.
        if (implicit)
            for (mut i = 0; i < implicit.len; i++)
                outArgs.push(implicit[i]);

        return outFlags;
    }

    fn parseLetStmt(): Node
    {
        let ret = parseLet();

        softSemi();
        return ret;
    }

    fn parseLet(xqmark! = false, allowTypeUnions! = false): Node
    {
        mut flags = 0;

        if (tryConsume("id", "using"   ))   flags |= F_USING;
        if (tryConsume("id", "implicit"))   flags |= F_IMPLICIT;
        if (tryConsume("id", "lax"     ))   flags |= F_LAX;
        if (tryConsume("id", "shadow"  ))   flags |= F_SHADOW;
        if (tryConsume("id", "mut"     ))   flags |= F_MUT;
        if (tryConsume("id", "ref"     ))   flags |= F_REF;

        // Experimental shorthand, meant for fn arguments -
        //
        //  fn name(kind: kind::kind, ...)      max verbose
        //  fn name(kind: ::kind, ...)          we already had this
        //  fn name(::kind, ...)                the new thing, shorter
        //
        let sh_import = tryConsume("op", "::");

        //
        mut id = consume("id").value;
        if (id == "_")
            flags |= F_LAX;

        // Explicit external arg name.
        if (xqmark && tryConsume("op", "!"))
        {
            flags |= F_MUSTNAME;

            // Alternate internal arg name.
            let inner_id = tryConsume("id").value;
            if (inner_id)
            {
                flags |= F_COMPOUND_ID;
                id    ~= "!" ~ inner_id;
            }
        }

        // Argument autocalls.
        if (xqmark && tryConsume("op", "."))
        {
            flags |= F_COMPOUND_ID;
            id    ~= "." ~ consume("id").value;

            while (tryConsume("op", "::"))
                id ~= "\t" ~ consume("id").value;
        }

        // Varargs & rest params.
        if (xqmark && tryConsume("op", "[]"))
            flags |= F_REST_ARG;

        //
        let optional    = xqmark && tryConsume("op", "?");

        mut type        = sh_import ? createRead(registerImport(id) ~ '\t' ~ id, flags: F_COMPOUND_ID)
                        : tryPopTypeAnnot(:allowTypeUnions);

        let init        = optional
            ? createDefinit()
            : tryParseLetInit();

        // TODO FIX unify &mut annots with ref-prefixed vars -
        //  initially started by replacing a: &mut annots with refs,
        //   caused a bunch of problems ultimate bottom line is that
        //    the type annot is no longer one thing but two -
        //     the annot node and flags.
        //
        // Trying out the opposite - going for &mut annots only.
        //  To finish this up we can have `let a: &mut _ = b`,
        //   and `ref a = b` would be sugar for that.
        //
        if (flags & F_REF && type)
        {
            if (type.kind != "call" || type.value != "&mut")
            {
                type = createPrefix("&mut", type);
                flags &= ~F_REF;
            }
        }

        return createLet(id, flags, type, init);
    }

    fn tryParseLetInit()
    {
        return tryConsume("op", "=") && parseExpression(P_RESET);
    }

    fn createLet(
        id: string, flags: i32,
        type: Node, init: Node): Node
    {
        return make("let", [ type, init ], flags, id);
    }

    fn parseExpression(p1: i32, mode!?: i32): Node
    {
        //////////////////////////////
        let p0 = _precedence;
        let loc00 = _loc;
        _precedence = p1;
        _loc = _idx;
        //////////////////////////////

        // Whitespace lint -
        //  Expression tails cannot continue at or above current statement indent.
        let col00 = _col0;

        if (mode & M_LINT_ENSURE_INDENT)
            tokens[_idx].col > _col0 || warn(
                "Ambiguous indent at `" ~ tokens[_idx].value
                    ~ "`: expected more than " ~ _col0 ~ ", got " ~ tokens[_idx].col);

        //
        mut head = parseExpressionHead(:mode);
        {
            //////////////////////////////////////////////
            // Lint, this looks crazy but its fine really,
            //  powers the -1.abs error.
            shadow let mode =
                mode & M_LINT_UNARY_PRECEDENCE
                    && (head.kind == "int" || head.kind == "real")
                        ? mode
                        : mode &~ M_LINT_UNARY_PRECEDENCE;
            //////////////////////////////////////////////

            mut loc0 = _loc = _idx;
            mut out: Node;
            while (out = tryParseExpressionTail(:head, :mode))
            {
                // Whitespace lint.
                {
                    let t1 = tokens[_loc = loc0];
                    t1.col > col00 || warn(
                        "Ambiguous indent at `" ~ t1.value
                            ~ "`: expected more than " ~ col00
                            ~ ", got " ~ t1.col);
                }

                //
                loc0 = _loc = _idx;
                head = out;
            };
        }

        //////////////////////////////
        _precedence = p0;
        _loc = loc00;
        //////////////////////////////

        return head;
    }

    fn tryParseBinary(left: Node, op: string, p1: i32): Node
    {
        if (p1 > _precedence || p1 == _precedence && !BINOP.RIGHT_TO_LEFT[p1])
            return miss;

        // consume
        _idx++;

        mut mid: Node;
        if (op == "?")
        {
            mid = parseExpression(P_RESET);
            consume("op", ":");
        }

        let right = parseExpression(p1);
        if (mid)
            return createIf(left, mid, right);

        // We'll treat these two differently,
        //  no operator overloading for those guys.
        if (op == "||") return createOr (left, right);
        if (op == "&&") return createAnd(left, right);

        if (left.kind == "and" || left.kind == "or")
            left.flags & F_PARENS || warn(
                "Unparenthesized `" ~ left.kind ~ "` on the left side of an `" ~ op ~ "`.");

        // Experimental sugar,
        //  pipeline operator basics.
        if (op == "|>") return pipelineRight(left, right);
        if (op == "<|") return pipelineLeft (left, right);

        //
        if (op == "->") return typeCheck(left, right);
        if (op == "=>") return typeCast(left, right);

        //
        return createCall(
            op, F_INFIX | F_OPERATOR, [ left, right ]);
    }

    fn typeCheck(actual: Node, expect: Node): Node
    {
        // Returns true if actual assigns to expect.
        return make("typeassert", [ actual, expect ]);
    }

    fn typeCast(actual: Node, expect: Node): Node
    {
        // Asserts type of expression.
        //  We might decide to use this as the type-cast operator.
        return make("typecast", [ actual, expect ]);
    }

    fn pipelineRight(left: Node, mut right: Node): Node
    {
        if (right.kind != "call")
            return fail("Cannot pipeline: not a call expr.");

        if (right.flags & F_METHOD)
            right.items.insert(1, left);
        else
            right.items.unshift(left);

        return right;
    }

    fn pipelineLeft(mut left: Node, right: Node): Node
    {
        if (left.kind != "call")
            return fail("Cannot pipeline: not a call expr.");

        left.items.push(right);
        left.flags &= ~F_ID; // non-orphan-looking
        return left;
    }

    fn tryParseExpressionTail(head: Node, mode: i32): Node
    {
        // Consume.
        let token = tokens[_idx++];
        if (token.kind == "op")
        {
            let v = token.value;

            fn lint()
                mode & M_LINT_UNARY_PRECEDENCE && warn(
                    "Here the unary -/+ separates from the numeric literal,"
                        ~ " and wraps around the whole expression."
                        ~ " Please parenthesize explicitly to make this obvious.");

            if (v == ";") return { _idx--; miss() };
            if (v == ".") return { lint(); parseAccessExpression(head) };
            if (v == "(") return { lint(); parseCallExpression(head) };
            if (v == "[") return { lint(); parseIndexExpression(head) };

            let p1 = BINOP.PRECEDENCE.map::get(v);
            if (p1)
                return { _idx--; tryParseBinary(head, v, p1) };

            if (POSTFIX.has(v))
                return createCall(
                    v == "++" || v == "--" ? "postfix" ~ v : v,
                        F_POSTFIX | F_OPERATOR, [ head ]);

            if (v == "::")
                return parseQualifierChain(head);
        }

        // Backtrack.
        return { _idx--; miss() };
    }

    fn parseExpressionHead(mode: i32): Node
    {
        //////////////////////////////
        let token = tokens[_idx++];
        //////////////////////////////

        {
            let k = token.kind;
            let v = token.value;

            // Literals.
            if (k == "int" || k == "real" || k == "str" || k == "char")
                return createLeaf(k, v);

            // Identifier expression.
            if (k == "id")
            {
                let peek = tokens[_idx];
                if (peek.kind == "id")
                {
                    if (v == "fn")          return parseFnDecl(expr: true);
                    if (v == "infix")       return parseFixityDecl(F_INFIX, expr: true);
                    if (v == "prefix")      return parseFixityDecl(F_PREFIX, expr: true);
                    if (v == "postfix")     return parseFixityDecl(F_POSTFIX, expr: true);
                }

                return createRead(v);
            }

            // Operators.
            if (k == "op")
            {
                if (v ==  "(") return parseParens();
                if (v ==  "{") return parseBlock();
                if (v ==  "[") return parseArrayLiteral();
                if (v ==  "$") return parseTypeParam();
                if (v ==  "|") return parseLambda(:mode);
                if (v == "||") return parseLambda(noArgs_noClosingPipe: true, :mode);
                if (v == "[]") return createDefinit();

                if (v == "::")
                {
                    let id = consume("id").value;
                    _idx--;
                    return parseQualifierChain(createRead(id));
                }

                if (v == ".")
                {
                    let id = consume("id").value;
                    return createAddrOfFn(name: id, flags: F_ACCESS);
                }

                return parsePrefix(v);
            }
        }

        ///////
        _idx--;
        ///////

        return fail();
    }

    fn createDefinit(): Node
    {
        return make("definit");
    }

    fn parseParens(): Node
    {
        mut out = parseExpression(P_RESET);
        out.flags |= F_PARENS;

        consume("op", ")");
        return out;
    }

    fn parseTypeParam(): Node
    {
        let value = consume("id").value;

        if (!_TODO_FIX_dollarOk)
            return createRead("$" ~ value);

        if (!_dollars.has(value) && _dollarAuto)
            _dollars.push(value);

        return createTypeParam(value);
    }

    fn createTypeParam(value: string): Node
    {
        return make("typeparam", :value);
    }

    fn parsePrefix(mut op: string): Node
    {
        PREFIX.has(op) || { _idx--; fail() };

        if (op == "&" && tryConsume("id", "mut"))
            op = "&mut";

        let mode = op == "-" || op == "+"
            ? M_LINT_UNARY_PRECEDENCE
            : 0;

        return createPrefix(
            op, parseUnaryExpression(:mode));
    }

    fn parseUnaryExpression(mode!: i32 = 0): Node
    {
        return parseExpression(P_PREFIX_UNARY, :mode);
    }

    fn createPrefix(op: string, mut expr: Node): Node
    {
        // Moving `-` and `+` into unary literals.
        if ((op == "+" || op == "-") &&
            (expr.kind == "int" || expr.kind == "real"))
        {
            let sign = expr.value[0];
            if (sign == '+' || sign == '-')
                expr.value[0] = sign == op.only ? '+' : '-';
            else
                expr.value = op ~ expr.value;

            return expr;
        }

        return createCall(op, F_PREFIX | F_OPERATOR, [ expr ]);
    }

    fn parseAccessExpression(expr: Node): Node
    {
        mut id = tryConsume("id");
        if (!id)
        {
            consume("op", "::");
            id = consume("id");
            _idx -= 2;
        }

        return createCall(
            id.value,
            F_ACCESS, [ expr ]);
    }


    // This is some hacky business -
    //  might actually perform well though -
    //   path[\t]id so we can cheap-slice the path.

    fn parseQualifierChain(mut expr: Node): Node
    {
        if (expr.kind != "call" ||
            expr.items && (expr.items.len != 1 || !(expr.flags & F_ACCESS)) ||
            expr.flags & F_COMPOUND_ID)
        {
            _idx--;
            fail();
        }

        expr.flags |= F_COMPOUND_ID;

        mut path = expr.value;
        for (;;)
        {
            let id = consume("id").value;
            if (!tryConsume("op", "::"))
            {
                // HACK .is::primtive & co /////////////////
                if (path == "is" && expr.items.len == 1)
                {
                    let left    = expr.items.only;
                    let right   = createTypeTag(id);
                    return typeCheck(left, right);
                }
                ////////////////////////////////////////////

                path = registerImport(path);
                expr.value = path ~ "\t" ~ id;
                return expr;
            }

            path ~= "/" ~ id;
        }
    }

    fn createTypeTag(value: string): Node
    {
        return make("typetag", :value);
    }


    //

    fn parseCallArgs(
        endop: string, ref out_args: Node[],

        experimental_sliceAnnots!?: bool): i32
    {
        mut flags = 0;

        mut first = true;
        for (;;)
        {
            // EXPERIMENTAL //////////////////////////////////////////
            //  Trying out the [$T;] syntax for slices.             //
            if (experimental_sliceAnnots && tryConsume("op", ";"))  //
            {                                                       //
                consume("op", endop);                               //
                break;                                              //
            }                                                       //
            //////////////////////////////////////////////////////////

            // Comma juggle.
            if (!first)
                softComma(:endop);

            // Trailing comma -
            //  array literals, fncalls, etc.
            if (tryConsume("op", endop))
                break;

            first = false;

            // Named arguments.
            mut name = "";
            mut autoName = false;
            mut optional = false;

            let tok0 = tokens[_idx];
            if (tok0.kind == "op" && tok0.value == ":")
            {
                autoName = true;
                _idx += 1;
            }
            else if (tok0.kind == "id")
            {
                let tok1 = tokens[_idx + 1];
                if (tok1.kind == "op")
                {
                    if (tok1.value == ":")
                    {
                        name = tok0.value;
                        _idx += 2;
                    }
                    else if (tok1.value == "?")
                    {
                        let tok2 = tokens[_idx + 2];
                        if (tok2.kind == "op" && tok2.value == ":")
                        {
                            optional = true;
                            name = tok0.value;
                            _idx += 3;
                        }
                    }
                }
            }

            let expr = parseExpression(P_RESET);
            if (autoName)
                name = getAutoName(expr);
            if (name)
                flags |= F_NAMED_ARGS;

            out_args.push(
                name    ? createArgID(name, expr, flags: optional && F_OPT_ARG)
                        : expr);
        }

        return flags;
    }

    fn getAutoName(expr: Node): string
    {
        if (expr.kind == "call" && expr.value.hasIdentifierChars)
            return expr.value;

        if (expr.items)
        {
            // _  ? NAME :  _
            //      NAME || _       same as NAME ? NAME : _
            // _ && NAME            same as _    ? NAME : 0

            let i = expr.kind == "and" && expr.items.len - 1
                  ? expr.kind == "if"  && 1
                  : 0;

            return getAutoName(expr.items[i]);
        }

        return fail("Can't :autoname this expression.");
    }

    fn createArgID(id: string, expr: Node, flags?: i32): Node
    {
        return make("argid", [ expr ], :flags, id);
    }

    fn parseCallExpression(expr: Node): Node
    {
        mut args: Node[] = [];
        let argFlags = parseCallArgs(")", args);

        // Uniform call syntax.
        if (expr.kind == "call" && (expr.flags & F_ACCESS))
        {
            let head = expr.items
                    && expr.items.len == 1
                    && expr.items[0] || fail();

            args.unshift(head);

            return createCall(
                expr.value || fail(),
                F_METHOD | argFlags | expr.flags &~ F_ACCESS,
                args);
        }

        if (expr.kind == "call" && (expr.flags & F_ID))
            return createCall(
                expr.value || fail(),
                argFlags | expr.flags &~ F_ID,
                args);

        if (expr.kind == "typeparam")
            return createCall(
                "$" ~ (expr.value || fail()), argFlags, args);

        return fail("TODO dynamic call");
    }

    fn parseArrayLiteral(): Node
    {
        mut args: Node[] = [];
        let argFlags = parseCallArgs("]", args,
            experimental_sliceAnnots: true);

        return createArrayLiteral(argFlags, args);
    }

    fn createArrayLiteral(argFlags: i32, items: Node[]): Node
    {
        return make("arrlit", items, argFlags);
    }

    fn parseIndexExpression(expr: Node): Node
    {
        mut args: Node[] = [];
        let argFlags = parseCallArgs("]", args);

        args.unshift(expr);

        return createCall("[]", argFlags | F_OPERATOR, args);
    }

    fn createLeaf(::kind, value: string): Node
    {
        return make(kind, :value);
    }

    fn createCall(id: string, flags: i32, args: Node[] = []): Node
    {
        return make("call", args, flags, id);
    }

    fn createRead(id: string, flags?: i32): Node
    {
        if (id == "true" || id == "false")
            return make("bool", value: id);

        return createCall(id || fail(), F_ID | flags);
    }


    //

    fn parseJump(::kind/*"break"|"continue"|"return"*/): Node
    {
        _fnDepth > 0 || { _idx--; fail() };

        let label = tryConsume("op", ":") && consume("id").value;

        mut expr: Node;
        if (!tryConsume("op", ";"))
        {
            expr = parseExpression(P_RESET, mode: M_LINT_ENSURE_INDENT);
            softSemi();
        }

        return createJump(:kind, :label, :expr);
    }

    fn createReturn(expr: Node, flags!?: i32): Node =
        createJump(kind: "return", :expr, :flags);

    fn createJump(
        kind!: ::kind/*"break"|"continue"|"return"*/,
        label!?: string, expr?: Node, flags!?: i32): Node
    {
        return make(kind, value: label, expr && [ expr ], :flags);
    }

    fn parseDefer(): Node
    {
        let value = tryConsume("op", ":")
                && (tryConsume("id", "err") || consume("id", "ok")).value;

        _fnDepth > 0 || { _idx--; fail() };
        return make("defer", :value, [ parseStatement() ]);
    }

    fn parseTryCatch(): Node
    {
        _fnDepth > 0 || { _idx--; fail() };

        let try = parseStatement();

        consume("id", "catch");
        consume("op", "(");

        let err = parseCatchErrvar();

        consume("op", ")");

        let catch = parseStatement();

        return make("try", [ try, err, catch ]);
    }

    fn parseCatchErrvar(): Node
    {
        let id = consume("id").value;
        return createLet(:id, 0, createRead("string"), Node);
    }


    //

    fn parseIf(): Node
    {
        // Indentation lint for `else`s:
        //  This catches problems such as | if (a) for (b) if (c) smth
        //                                | else ...       <- will go to inner if instead of outer as indentation suggests was intended.
        let token =             tokens[_idx - 1];
        let prev  = _idx > 1 && tokens[_idx - 2];

        shadow let token = prev.kind == "id" && prev.value == "else" ? prev : token;

        // A little bit of syntactic sugar -
        //  TBD if this is good or not, i'm 50/50.
        //   At least it's unambiguous.
        let not = tryConsume("op", "!");

        consume("op", "(");
        mut cond = parseLetOrExpressionStatement();
        consume("op", ")");

        if (not)
            cond = createPrefix("!", cond);

        let cons = parseStatement();

        let else = tryConsume("id", "else");
        if (else)
        {
            else.line == token.line || else.col == token.col || warn(
                "Inconsistent indent at `else`: expected " ~ token.col
                    ~ ", got " ~ else.col
                    ~ ". `if` starts on line " ~ token.line ~ ".");

            let alt = parseStatement();
            return createIf(cond, cons, alt);
        }

        return createAnd(cond, cons);
    }


    //

    fn createIf(cond: Node, cons: Node, alt: Node): Node
    {
        return make("if", [ cond, cons, alt ]);
    }

    fn createOr(left: Node, right: Node): Node
    {
        return flattenIfSame("or", left, right);
    }

    fn createAnd(left: Node, right: Node): Node
    {
        return flattenIfSame("and", left, right);
    }

    fn flattenIfSame(::kind, left: Node, right: Node): Node
    {
        let k_left  =  left.kind;
        let k_right = right.kind;

        let items =
            k_left == kind && k_right == kind
                ? left.items ~ right.items
                : k_left == kind
                    ? left.items ~ right
                    : k_right == kind
                        ? left ~ right.items
                        : [ left, right ];

        return make(kind, items);
    }


    //

    fn parseFor(): Node
    {
        consume("op", "(");

        // First of the crazies.
        if (tryConsume("id", "fieldname"))
        {
            let placeholder = consume("id").value;
            consume("op", ":");
            let type = parseTypeAnnot();
            consume("op", ")");
            let body = parseStatement();

            return make("forfieldsof",
                value: placeholder,
                items: [ type, body ]);
        }

        //
        let init = !tryConsume("op", ";") && parseStatement();
        if (init && init.kind != "let")
            fail("`for` expects a `let` statement, got a `" ~ init.kind ~ "`.");

        let pre_cond = !tryConsume("op", ";") && parseLetOrExpressionStatement();

        let token = tokens[_idx];
        let post = !(token.kind == "op" && token.value == ")")
            ? parseParens()
            : consume("op", ")") && [];

        let body = parseStatement();

        return createLoop(:init, :pre_cond, :post, :body);
    }

    fn parseWhile(): Node
    {
        consume("op", "(");
        let pre_cond = parseLetOrExpressionStatement();
        consume("op", ")");
        let body = parseStatement();

        return createLoop(:pre_cond, :body);
    }

    fn parseDoWhile(): Node
    {
        let body = parseStatement();
        consume("id", "while");
        consume("op", "(");
        let post_cond = parseLetOrExpressionStatement();
        consume("op", ")");
        softSemi();

        return createLoop(:body, :post_cond);
    }

    fn createLoop(init!?: Node, pre_cond!?: Node, body!?: Node, post_cond!?: Node, post!?: Node): Node
    {
        return make("loop", [ init, pre_cond, body, post_cond, post ]);
    }

    // -------------------------------
    // Good to go.

    // Check EOF.
    tokens[tokens.len - 1].kind == "eof" || fail(
        "Missing `eof` token.");

    // PARSE END

    //
    let root = parseRoot();

    return ParserOutput(
        :root, :fuzimports, :warnings);
}
