#import 'helpers';
#import 'compiler';
#import 'tests';

fn cli_handle(argv: string[], cwd = fs_cwd()): i32
{
    mut idx = 0;

    fn next(): string {
        let i = idx++;
        if (i < argv.len)
            return argv[i];

        return '';
    }

    // Router.
    let self    = next();
    let cmd     = next();

    // Exit 0 on no command, else we fail build-checks.
    if (!cmd)
    {
        print('\n\tHello! ', self);
        print(  '\tNothing to do, running a quick self test.\n');

        self_test();
        print('\tEverything checks out.');
        print('\tTry `fu run file.fu`.\n');

        return 0;
    }

    // Go!
    let run = cmd == 'build' ? false
            : cmd == 'run'   ? true
            : throw('Bad command: `' + cmd + '`,' +
                    '\n\tvalid examples are `fu build file.fu`' +
                    '\n\tand `fu run file.fu`.');

    fn abs(path: string)
        path    && path[0] != '-'
                && path_join(cwd, path);

    // A silly option parser.
    let EMIT_CPP = 1 << 0;
    let EMIT_OBJ = 1 << 1;
    let EMIT_BIN = 1 << 2;

    mut dir_src: string;
    mut dir_cpp: string;
    mut dir_obj: string;
    mut bin:     string;

    mut options: i32;

    //
    mut val = next();
    while (val.len > 1 && val[0] == '-') {
        mut opt = val;
        if (opt[1] != '-') {
            opt = opt[1];
            val = '-' + val.slice(2);
            if (val == '-')
                val = next();
        }
        else {
            val = next();
        }

        fn option(short: string, long: string, o: i32, dir: &mut string) {
            if (opt == short || opt == long) {
                options |= o;
                if (opt == long) {
                    dir = abs(val) || throw(
                        'Option ' + long + ' expects a path,' +
                        '\n\tgot `' + val + '`,' +
                        '\n\ttry `' + long + ' rel/or/abs/dir/`.');

                    val = next();
                }

                opt = '';
            }
        }

        option('-', '--src',        0, dir_src);
        option('c', '--cpp', EMIT_CPP, dir_cpp);
        option('o', '--obj', EMIT_OBJ, dir_obj);
        option('b', '--bin', EMIT_BIN,     bin);

        if (opt)
            throw('Unknown option: `' + opt + '`.');
    }

    // Defaulting.
    if (options & EMIT_CPP) {
        if (!dir_src) dir_src = dir_cpp || cwd;
        if (!dir_cpp) dir_cpp = dir_src;
    }

    // Do the work.
    let fname = abs(val) || throw(
        'Missing filename argument, a valid example is:' +
        '\n\t`fu ' + cmd + ' file.fu`.');

    let dir_wrk = DEFAULT_WORKSPACE;

    if (options & EMIT_BIN)
        bin ||= fname.ends(with: '.fu')
                ? fname.slice(0, fname.len - '.fu'.len)
                : fname + '.exe';

    // Go.
    build(:fname, :run, :bin,
        :dir_wrk, :dir_src, :dir_cpp, :dir_obj);

    return 0;
}

fn main(argv: string[])
    cli_handle(argv);


//

fn runTestsAndBuildCompiler()
{
    runTests();

    #import 'hello';
    saySomethingNice();

    cli_handle(
        cwd: PRJDIR,
        [ 'fu', 'run', '--bin', 'bin/fu', '-c', 'src/cli.fu' ]);
}
