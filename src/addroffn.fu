import scope;
import module;
import helpers;


// This is experimental, super dirty shit.
//  This is why we'll keep this away till we figure things out.

pub fn type_isAddrOfFn(type: Type): bool =
    type.canon.starts(with: '@');

pub fn type_isZST(type: Type): bool =
    type.type_isAddrOfFn;

pub fn type_isCTC(type: Type): bool =
    type.type_isZST;

pub fn packAddrOfFn(targets: Target[])
{
    mut res = "@";
    for (mut i = 0; i < targets.len; i++)
    {
        let target = targets[i];
        res.appendMi(:target.modid, :target.index);
    }

    return res;
}

pub fn unpackAddrOfFn(canon: string, fn)
{
    canon[0] == '@' || throw("unpackAddrOfFn: No leading @ in `" ~ canon ~ "`.");

    mut offset = 1;
    while (offset < canon.len)
    {
        let mi = parseMi(offset, canon);
        fn(Target(:mi.modid, :mi.index));
    }
}


//

pub fn X_unpackAddrOfFnBinding(ref out: ScopeItem[], id: string, type: Type, shadows: bool): bool
{
    if (!type.type_isAddrOfFn)
        return false;

    unpackAddrOfFn(type.canon, |target|
        Scope_set(out, :id, :target, :shadows));

    return true;
}

pub fn X_addrofTarget(target: Target)
{
    return Type(ValueType(quals: 0, canon: packAddrOfFn([ target ])));
}
