import scope;
import types;


// This is experimental, super dirty shit.
//  This is why we'll keep this away till we figure things out.

pub fn type_isAddrOfFn(type: Type): bool =
    type.canon.starts(with: "@");

pub fn type_isZST(type: Type): bool =
    type.type_isAddrOfFn;

pub fn type_isCTC(type: Type): bool =
    type.type_isZST;

pub fn packAddrOfFn(targets: Target[])
{
    mut res = "";
    for (mut i = 0; i < targets.len; i++)
    {
        let target = targets[i];
        res ~= "@" ~ target.modid ~ ":" ~ target.index;
    }

    return res;
}

pub fn unpackAddrOfFn(canon: string, fn)
{
    mut i = 0;
    while (i < canon.len)
    {
        canon[i++] == '@' || throw("unpackAddrOfFn: bad canon [1]: `" ~ canon ~ "`.");
        let modid = parse10i32(i, canon);

        canon[i++] == ':' || throw("unpackAddrOfFn: bad canon [2]: `" ~ canon ~ "`.");
        let index = parse10i32(i, canon);

        fn(Target(:modid, :index));
    }
}


//

pub fn X_unpackAddrOfFnBinding(ref out: ScopeItem[], id: string, type: Type, shadows: bool): bool
{
    if (!type.type_isAddrOfFn)
        return false;

    unpackAddrOfFn(type.canon, |target|
        Scope_set(out, :id, :target, :shadows));

    return true;
}

pub fn X_addrofTarget(target: Target)
{
    return Type(ValueType(quals: 0, modid: 0, canon: packAddrOfFn([ target ])));
}
