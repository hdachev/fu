import scope;
import types;


// This is experimental, super dirty shit.
//  This is why we'll keep this away till we figure things out.

pub fn type_isAddrOfFn(type: Type): bool =
    type.canon.starts(with: "@");

pub fn type_isZST(type: Type): bool =
    type.type_isAddrOfFn;

pub fn type_isCTC(type: Type): bool =
    type.type_isZST;

pub fn packAddrOfFn(targets: Target[])
{
    mut res = "";
    for (mut i = 0; i < targets.len; i++)
    {
        let target = targets[i];
        res ~= "@" ~ target.modid ~ ":" ~ target.index;
    }

    return res || "@";
}

pub fn unpackAddrOfFn(canon: string)
{
    mut res: Target[];

    mut i = 0;
    while (i < canon.len)
    {
        canon[i++] == '@' || throw("unpackAddrOfFn: bad canon [1]: `" ~ canon ~ "`.");
        let modid = parse10i32(i, canon);

        canon[i++] == ':' || throw("unpackAddrOfFn: bad canon [2]: `" ~ canon ~ "`.");
        let index = parse10i32(i, canon);

        res.push(Target(:modid, :index));
    }

    return res;
}


//

pub fn X_unpackAddrOfFnBinding(ref out: ScopeItem[], id: string, type: Type): bool
{
    if (!type.type_isAddrOfFn)
        return false;

    let targets = unpackAddrOfFn(type.canon);
    for (mut i = 0; i < targets.len; i++)
        out.push(ScopeItem(:id, target: targets[i]));

    return true;
}

pub fn X_solveAddrOfFn(scope: Scope, scope_skip: ScopeSkip, id: string)
{
    mut targets: Target[];

    mut scope_iterator: i32;
    mut target: Target;
    while (target = scope.search(:id, :scope_iterator, :scope_skip))
        targets.push(target);

    return Type(ValueType(quals: 0, modid: 0, canon: packAddrOfFn(targets)));
}

pub fn X_addrofTarget(target: Target)
{
    return Type(ValueType(quals: 0, modid: 0, canon: packAddrOfFn([ target ])));
}
