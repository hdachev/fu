import module;

fn is_primitive(t: ValueType) {
    let c = t.canon[0];
    return c == 'u' || c == 'i' || c == 'f' || c == 'b' || c == 'c'
                    || c == 'm' || c == 'e';
}

fn is_arithmetic(t: ValueType) {
    let c = t.canon[0];
    return c == 'u' || c == 'i' || c == 'f';
}

fn is_bitfield(t: ValueType) {
    let c = t.canon[0];
    return c == 'u' || c == 'i'
                    || c == 'm';
}

fn is_integral(t: ValueType) {
    let c = t.canon[0];
    return c == 'u' || c == 'i';
}

fn is_unsigned(t: ValueType) {
    let c = t.canon[0];
    return c == 'u';
}

fn is_floating_pt(t: ValueType) {
    let c = t.canon[0];
    return c == 'f';
}

fn is_boolean(t: ValueType) {
    let c = t.canon[0];
    return c == 'b';
}

fn is_enum(t: ValueType) {
    let c = t.canon[0];
    return c == 'e';
}

fn is_flags(t: ValueType) {
    let c = t.canon[0];
    return c == 'm';
}

fn is_sliceable(t: ValueType) {
    let c = t.canon[0];
    return c == '[';
}


//

fn isPassByValue(t: ValueType) {
    return t.is_primitive;
}

fn basePrimPrefixLen(canon: string): int
{
    mut c = canon[0];

    // Let's consider two new category types:
    //  e - for enums, no arithmetics, no bitwise ops
    //  m - for flags, bitwise ops are fine

    // Category.
    c == 'i' || c == 'u'
             || c == 'f'
             || c == 'b' || c == 'c'
             || c == 'e' || c == 'm'
             || throw("basePrimPrefix: bad char0: " ~ canon);

    // Bitcount.
    for (mut offset = 1;; offset++)
    {
        c = offset < canon.len && canon[offset];
        if (c < '0' || c > '9')
            return offset;
    }
}


//

fn serializeType(type: ValueType, debug!: string)
{
    type || throw("COMPILER BUG: serializeType: Falsy type in: " ~ debug);

    mut result: string;

    result.helpers::appendVarint(type.quals.u32);
    result ~= type.canon || throw(
        "COMPILER BUG: serializeType: No type.canon in: " ~ debug);

    return result;
}

fn parseType(str: [byte]): ValueType
{
    mut offset: i32;

    let quals = helpers::parseVarint(offset, str).Quals;

    // TODO FIX SLICES the clone here
    let canon = helpers::clone(str.slice(offset));
    return ValueType(:canon, :quals);
}


//

fn if_sliceable(type: ValueType, hit)
{
    if (type.is_sliceable)
        hit(parseType(type.canon.slice(1, type.canon.len - 1)));
}

fn tryClear_sliceable(type: ValueType)
{
    if_sliceable(type): |vtype|
        return Type(:vtype);

    return [];
}

fn clear_sliceable(type: ValueType)
{
    if_sliceable(type): |vtype|
        return Type(:vtype);

    throw("COMPILER BUG: Not sliceable: " ~ type.canon);
}
