let PRELUDE_SRC = `


// Arithmetics.

prefix fn + !T(a: T) case (T.is::arithmetic): T __native;
prefix fn - !T(a: T) case (T.is::arithmetic): T __native;

infix fn + !T(a: T, b: T) case (T.is::arithmetic): T __native;
infix fn - !T(a: T, b: T) case (T.is::arithmetic): T __native;
infix fn * !T(a: T, b: T) case (T.is::arithmetic): T __native;
infix fn / !T(a: T, b: T) case (T.is::arithmetic): T __native;

infix fn % !T(a: T, b: T)
    case (T.is::integral): T __native;
    case (T.is::floating_point): T __native("<cmath>", "std::fmod");

prefix fn ++ !T(ref a: T) case (T.is::arithmetic): &mut T __native;
prefix fn -- !T(ref a: T) case (T.is::arithmetic): &mut T __native;

postfix fn ++ !T(ref a: T) case (T.is::arithmetic): T __native;
postfix fn -- !T(ref a: T) case (T.is::arithmetic): T __native;

infix fn += !T(ref a: T, b: T) case (T.is::arithmetic): &mut T __native;
infix fn -= !T(ref a: T, b: T) case (T.is::arithmetic): &mut T __native;
infix fn *= !T(ref a: T, b: T) case (T.is::arithmetic): &mut T __native;
infix fn /= !T(ref a: T, b: T) case (T.is::arithmetic): &mut T __native;

infix fn >  !T(a: T, b: T) case (T.is::primitive): bool __native;
infix fn <  !T(a: T, b: T) case (T.is::primitive): bool __native;
infix fn >= !T(a: T, b: T) case (T.is::primitive): bool __native;
infix fn <= !T(a: T, b: T) case (T.is::primitive): bool __native;


// Bitwise.

prefix fn ~ !T(a: T) case (T.is::bitfield): T __native;

infix fn & !T(a: T, b: T) case (T.is::bitfield): T __native;
infix fn | !T(a: T, b: T) case (T.is::bitfield): T __native;
infix fn ^ !T(a: T, b: T) case (T.is::bitfield): T __native;

infix fn &= !T(ref a: T, b: T) case (T.is::bitfield): &mut T __native;
infix fn |= !T(ref a: T, b: T) case (T.is::bitfield): &mut T __native;
infix fn ^= !T(ref a: T, b: T) case (T.is::bitfield): &mut T __native;

infix fn << !T(a: T, b: T) case (T.is::integral): T __native;
infix fn >> !T(a: T, b: T) case (T.is::integral): T __native;

infix fn <<= !T(ref a: T, b: T) case (T.is::integral): &mut T __native;
infix fn >>= !T(ref a: T, b: T) case (T.is::integral): &mut T __native;


// Numeric conversions.

fn   i8 !T(v: T) case (T.is::primitive):   i8 __native("/prim/convert");
fn  i16 !T(v: T) case (T.is::primitive):  i16 __native("/prim/convert");
fn  i32 !T(v: T) case (T.is::primitive):  i32 __native("/prim/convert");
fn  i64 !T(v: T) case (T.is::primitive):  i64 __native("/prim/convert");
fn i128 !T(v: T) case (T.is::primitive): i128 __native("/prim/convert");

fn   u8 !T(v: T) case (T.is::primitive):   u8 __native("/prim/convert");
fn  u16 !T(v: T) case (T.is::primitive):  u16 __native("/prim/convert");
fn  u32 !T(v: T) case (T.is::primitive):  u32 __native("/prim/convert");
fn  u64 !T(v: T) case (T.is::primitive):  u64 __native("/prim/convert");
fn u128 !T(v: T) case (T.is::primitive): u128 __native("/prim/convert");

fn  f32 !T(v: T) case (T.is::primitive): f32 __native("/prim/convert");
fn  f64 !T(v: T) case (T.is::primitive): f64 __native("/prim/convert");

fn byte !T(v: T) case (T.is::primitive): byte __native("/prim/convert");

fn unsigned !T(v: T)
    case (T -> i8)     v.u8;
    case (T -> i16)    v.u16;
    case (T -> i32)    v.u32;
    case (T -> i64)    v.u64;
    case (T -> i128)   v.u128;
    case (T.is::integral && T.is::unsigned) v;

fn signed !T(v: T)
    case (T -> u8)     v.i8;
    case (T -> u16)    v.i16;
    case (T -> u32)    v.i32;
    case (T -> u64)    v.i64;
    case (T -> u128)   v.i128;
    case (T.is::integral && !T.is::unsigned) v;

fn MIN !T(_: T)
    case (T -> i8 )        -128;
    case (T -> i16)        -32768;
    case (T -> i32)        -2147483648;
    case (T -> i64)        -9223372036854775808;
    case (T.is::unsigned)  T(0);

fn MAX !T(_: T)
    case (T -> i8 )        127;
    case (T -> i16)        32767;
    case (T -> i32)        2147483647;
    case (T -> i64)        9223372036854775807;
    case (T.is::unsigned)  T(-1);

type  int   = i32; // These may become separate types
type uint   = u32; //  with a user-selectable size.


// Math.

fn abs !T(v: T) case (T.is::floating_point): T __native("<cmath>", "std::abs");

fn max !T(a: T, b: T)
    case (T.is::floating_point) a >= b || b != b ? a : b;
    case (T.is::arithmetic)     a >= b           ? a : b;

fn min !T(a: T, b: T)
    case (T.is::floating_point) a <= b || b != b ? a : b;
    case (T.is::arithmetic)     a <= b           ? a : b;

fn exp   !T(a: T) case (T.is::floating_point): T __native("<cmath>", "std::exp");
fn exp2  !T(a: T) case (T.is::floating_point): T __native("<cmath>", "std::exp2");
fn log   !T(a: T) case (T.is::floating_point): T __native("<cmath>", "std::log");
fn log10 !T(a: T) case (T.is::floating_point): T __native("<cmath>", "std::log10");
fn log2  !T(a: T) case (T.is::floating_point): T __native("<cmath>", "std::log2");

fn pow   !T(a: T, b: T) case (T.is::floating_point): T __native("<cmath>", "std::pow");
fn sqrt  !T(v: T) case (T.is::floating_point): T __native("<cmath>", "std::sqrt");
fn cbrt  !T(v: T) case (T.is::floating_point): T __native("<cmath>", "std::cbrt");
fn hypot !T(v: T) case (T.is::floating_point): T __native("<cmath>", "std::hypot");

fn ceil  !T(v: T) case (T.is::floating_point): T __native("<cmath>", "std::ceil");
fn floor !T(v: T) case (T.is::floating_point): T __native("<cmath>", "std::floor");
fn trunc !T(v: T) case (T.is::floating_point): T __native("<cmath>", "std::trunc");
fn round !T(v: T) case (T.is::floating_point): T __native("<cmath>", "std::round");

fn sin !T(v: T) case (T.is::floating_point): T __native("<cmath>", "std::sin");
fn cos !T(v: T) case (T.is::floating_point): T __native("<cmath>", "std::cos");
fn tan !T(v: T) case (T.is::floating_point): T __native("<cmath>", "std::tan");

fn asin !T(v: T) case (T.is::floating_point): T __native("<cmath>", "std::asin");
fn acos !T(v: T) case (T.is::floating_point): T __native("<cmath>", "std::acos");
fn atan !T(v: T) case (T.is::floating_point): T __native("<cmath>", "std::atan");

fn atan2 !T(y: T, x: T) case (T.is::floating_point): T __native("<cmath>", "std::atan2");

fn PI():  f64 __native("<math.h>", "M_PI");
fn E():   f64 __native("<math.h>", "M_E");
fn INF(): f64 __native("<math.h>", "INFINITY");
fn NAN(): f64 __native("<math.h>", "NAN");

fn nan    !T(v: T) case (T.is::floating_point): bool __native("<cmath>", "std::isnan");
fn inf    !T(v: T) case (T.is::floating_point): bool __native("<cmath>", "std::isinf");
fn finite !T(v: T) case (T.is::floating_point): bool __native("<cmath>", "std::isfinite");


// Assignment.

infix fn   = !T(ref a: T,    mut b: T): &mut T __native;
infix fn ||= !T(ref a: T, inline b: T): &mut T = a || (a = b);
infix fn &&= !T(ref a: T, inline b: T): &mut T = a && (a = b);

fn swap !T(ref a: T, ref b: T): void __native(
    "hacks/soft_risk",
    "<utility>", "std::swap");



// Arrays.
//
// TODO mutval .=,
//  just like the assignments and splice.

fn typeof !T(lax _: T) = T;

fn [] !T(/*TODO type*/lax _: T) = typeof([] => T[]);

novec fn len !T(a: [T;]): int __native(".size()");

novec fn [] !T(a: [T;], i: int)
    case ($a -> &mut [T;]): &mut T __native(".mutref");
    default               : &    T __native;

novec fn [] !T(a: [T;], start!: int)
    case ($a -> &mut [T;]): &mut [T;] __native("<fu/view.h>", "fu::get_view_mut");
    default               : &    [T;] __native("<fu/view.h>", "fu::get_view");

novec fn [] !T(a: [T;], end!: int)
    case ($a -> &mut [T;]): &mut [T;] __native("<fu/view.h>", "fu::get_view_start0_mut");
    default               : &    [T;] __native("<fu/view.h>", "fu::get_view_start0");

novec fn [] !T(a: [T;], start: int, end: int)
    case ($a -> &mut [T;]): &mut [T;] __native("<fu/view.h>", "fu::get_view_mut");
    default               : &    [T;] __native("<fu/view.h>", "fu::get_view");

fn    push !T(ref a: T[], mut b: T): void __native(".push");
fn unshift !T(ref a: T[], mut b: T): void __native(".unshift");
fn  insert !T(ref a: T[], i: int, mut b: T): void __native(".insert");

fn slice !T(a: [T;], start: int, end: int)
    case ($a -> T[]):  T[] __native("<fu/vec/slice.h>", "fu::slice");
    default         : [T;] __native("<fu/view.h>", "fu::get_view");

fn slice !T(a: [T;], start: int)
    case ($a -> T[]):  T[] __native("<fu/vec/slice.h>", "fu::slice");
    default         : [T;] __native("<fu/view.h>", "fu::get_view");

fn substr !T(a: T[], start: int, end: int): T[] __native("<fu/vec/slice.h>", "fu::substr");

fn splice !T(ref a: T[], start: int, count: int): void  __native(".splice");
fn splice !T(ref a: T[], start: int, count: int, /*TODO FIX*/b: [T]): void  __native(".splice");

fn    pop !T(ref a: T[]): void __native(".pop()");
fn  shift !T(ref a: T[]): void __native(".shift()");

fn  clear !T(ref a: T[]): void __native(".clear()");
fn shrink !T(ref a: T[], len: int): void __native(".shrink");

fn resize !T(ref a: T[], len: int): void __native(".resize");
fn   grow !T(ref a: T[], len: int): void __native(".grow");

fn resize_junk !T(ref a: T[], len: int): void __native(".resize<false>");
fn   grow_junk !T(ref a: T[], len: int): void __native(".grow<false>");


// Sorts, via std::sort - fnptrs.

fn sort !T(ref a: [T;]): void
{
    pragma include("<algorithm>");
    pragma emit(
    \`
        auto* data = \`a\`.data_mut();
        std::sort(data, data + \`a\`.size());
    \`);
}

fn sort !T(ref a: [T;], less/*: fn(a: T, b: T): bool*/): void
{
    noflow fn sort()
    {
        mut l: T;
        mut r: T;
        pragma include("<algorithm>");
        pragma emit(
        \`
            (void) \`l\`;
            (void) \`r\`;
            auto* data = \`a\`.data_mut();
            std::sort(data, data + \`a\`.size(), [&](auto& \`l\`, auto& \`r\`)
            {
        \`);

        mut lt: bool = less(l, r);
        pragma emit(
        \`
                return \`lt\`;
            });
        \`);
    }

    sort();
}


// String likes.

fn find !T(a: [T;], b: [T;], start: int, end: int) case (T.is::primitive): int  __native("<fu/vec/find.h>", "fu::lfind");
fn find !T(a: [T;], b: [T;], start: int)           case (T.is::primitive): int  __native("<fu/vec/find.h>", "fu::lfind");
fn find !T(a: [T;], b: [T;])                       case (T.is::primitive): int  __native("<fu/vec/find.h>", "fu::lfind");

fn has  !T(a: [T;], b: [T;]) case (T.is::primitive): bool __native("<fu/vec/find.h>", "fu::has");


// Find char.

fn starts !T(a: [T;], with: T): bool
{
    return a.len && a[0] == with;
}

fn ends !T(a: [T;], with: T): bool
{
    return a.len && a[a.len - 1] == with;
}

fn starts !T(a: [T;], with: [T;]): bool
{
    return a.len >= with.len
        && a[0, with.len] == with;
}

fn ends !T(a: [T;], with: [T;]): bool
{
    return a.len >= with.len
        && a[a.len - with.len, a.len] == with;
}

fn find !T(a: [T;], b: T, mut start: int): int
{
    start = start > 0 ? start : 0;
    for (mut i = start; i < a.len; i++) // TODO memchr
        if (a[i] == b)
            return i;

    return -1;
}

fn find !T(a: [T;], b: T): int
{
    for (mut i = 0; i < a.len; i++) // TODO memchr
        if (a[i] == b)
            return i;

    return -1;
}

fn has !T(a: [T;], b: T): bool
{
    for (mut i = 0; i < a.len; i++)
        if (a[i] == b)
            return true;

    return false;
}


// Strings.

type string = byte[];

infix fn  >(a: string, b: string): bool __native("<fu/vec/cmp.h>",  ">");
infix fn  <(a: string, b: string): bool __native("<fu/vec/cmp.h>",  "<");
infix fn >=(a: string, b: string): bool __native("<fu/vec/cmp.h>", ">=");
infix fn <=(a: string, b: string): bool __native("<fu/vec/cmp.h>", "<=");


// D-style concats.
//
// TODO FIX these concats hide copies
//  which also means they dont work correctly for nocopy stuff
//
infix fn ~ !T(a: [T;], b: [T;]): T[] __native("<fu/vec/concat.h>",     "+");
infix fn ~ !T(a: [T;], b:  T  ): T[] __native("<fu/vec/concat_one.h>", "+");
infix fn ~ !T(a:  T  , b: [T;]): T[] __native("<fu/vec/concat_one.h>", "+");

infix fn ~= !T(ref a: T[],     b: [T;]): &mut T[] __native("<fu/vec/concat.h>",     "+=");
infix fn ~= !T(ref a: T[], mut b:  T  ): &mut T[] __native("<fu/vec/concat_one.h>", "+=");


// Fun with views.

fn view!<T, U>(a: [T;], of: U)
    case ($a -> &mut [T;] && T.is::trivial && U.is::trivial): &mut [U] __native("<fu/view.h>", "fu::view_of_mut");
    case (                    T.is::trivial && U.is::trivial):      [U] __native("<fu/view.h>", "fu::view_of");

infix fn .= !T(ref a: [T;], b: [T;]) case (T.is::copy): void __native("<fu/vec/view_assign.h>", "fu::view_assign");

// TODO not needed if swap(x, y) alias-ok's its two arguments:
fn swap !T(ref a: [T;], i: int, j: int): void __native("<fu/vec/view_swap.h>", "fu::view_swap");


// Stringifiables.

infix fn ~  !T(    a: [byte], b.str) a ~ b;
infix fn ~  !T(    a.str, b: [byte]) a ~ b;
infix fn ~= !T(ref a: string, b.str) a ~= b;

fn str !T(n: T)
    case (T.is::unsigned       ): string __native("<fu/decstr.h>", "fu::u64dec");
    case (T.is::integral       ): string __native("<fu/decstr.h>", "fu::i64dec");
    case (T -> bool            ): string __native("<fu/decstr.h>", "fu::booldec");
    case (T -> f32             ): string __native("<fu/decstr.h>", "fu::f32dec");
    case (T -> f64             ): string __native("<fu/decstr.h>", "fu::f64dec");
    case (T.is::enum)
{
    for (fieldname i: T)
        if (n == "i")
            return "i";

    return n.i64.str; // TODO FIX use .integer or .arithmetic when we get these
}
    case (T.is::flags)
{
    mut res: string;
    for (fieldname i: T)
        if (n & "i")
            res ~= "i" ~ ", ";

    if (res)
        res.shrink(res.len - 2);

    return res;
}


// Assertions, bugs & fails.
//  TODO i dont actually think we want to have nullary stuff in prelude,
//   so TODO needs to take an arg, same with assert - perhaps a pass-through argument.

fn throw(mut reason: string): never __native("<fu/never.h>", "fu::fail",
    "|Fx_NotDeadCode", "|Fx_DontMoveDown", "|Fx_Throws");

fn assert(): never __native("<fu/never.h>", "fu_ASSERT()",
    "|Fx_NotDeadCode", "|Fx_DontMoveDown", "|Fx_Crashes");


// Printifiables = anything that implements print.

inline fn print(x: string): string = x;
inline fn print(x.str)    : string = x;

fn println(parts.print[]: [string]): void __native("<fu/print.h>", "fu::println",
    "|output");


// String commons.

fn join !T(a: [T[];], sep?: T or [T;] or [])
{
    if (a.len < 2)
        return a.len && a[0];

    let N = typeof(sep) -> [T;] ? sep.len
          : typeof(sep) ->  T   ? 1
                                : 0;

    mut size = a[0].len;
    for (mut i = 1; i < a.len; i++)
        size += N + a[i].len;

    mut res: T[];
    res.grow_junk(size);

    let head = a[0];
    size = head.len;
    res[0, head.len] .= head;
    for (mut i = 1; i < a.len; i++)
    {
        let range = a[i];
        if (typeof(sep) -> [T;])
            res[size, size + N] .= sep;
        else if (typeof(sep) -> T)
            res[size] = sep;

        size += N;
        res[size, size + range.len] .= range;
        size += range.len;
    }

    return res;
}

fn split !T(str: T[] or [T;], sep: T or [T;], each)
{
    mut last = 0;
    mut next = 0;

    let N = typeof(sep) -> [T;] ? sep.len : 1;
    if (N) while ((next = str.find(sep, start: last)) >= 0)
    {
        each(str.slice(last, next), first?: !last, last?: false);
        last = next + N;
    }

    if (last)
        each(str.slice(last), first?: false, last?: true);
    else
        each(str, first?: true, last?: true);
}

fn split !T(str: T[], sep: T or [T;])
{
    mut result: T[][];
    split(str, :sep, |substr| result ~= substr);
    return result;
}


// TODO: .replace() is a faster impl of .split().join().
//  How do we express this so that .split.joins are automatically promoted?
//   This would be generally useful, e.g.
//    .map.maps and .map.filters could use this to skip allocs.

fn replace !T(str: T[], all: T or [T;], with: T or [T;] or [])
{
    mut result: T[];
    split(str, sep: all, |substr, lax first, lax last|
    {
        if (!first)
            typeof(with) -> [] ? with() : result ~= with;
        else if (last)
            return str;

        result ~= substr;
    });

    return result;
}


//

infix fn <> !<T, U>(a: T, b: T)
case (T.is::primitive) = a < b ? -1 : a > b ? +1 : 0;
case (T -> [U;]) {
    mut cmp = a.len <> b.len;
    for (mut i = 0; i < a.len && !cmp; i++)
        cmp = a[i] <> b[i];

    return cmp;
}
default {
    // TODO this would be better if it went through each member doing the trivial work first -
    //  only then going through them again and looking at e.g. array contents etc.
    for (fieldname i: T) {
        let cmp = a.i <> b.i;
        if (cmp)
            return cmp;
    }

    return 0;
}

infix fn == !T(a: T, b: T)
    case (T.is::primitive): bool __native;
    default: bool = !(a <> b);

infix fn != !T(a: T, b: T)
    case (T.is::primitive): bool __native;
    default: bool = !!(a <> b);


//

fn map !T(a: [T;], fn)
{
    mut res: typeof( fn(T, i?: a.len) )[];
    res.grow_junk(a.len);
    for (mut i = 0; i < a.len; i++)
        res[i] = fn(a[i], i?: i);

    return res;
}

fn each !T(a: [T;], fn)
    for (mut i = 0; i < a.len; i++)
        fn(a[i], i?: i);

fn reverse !T(ref a: [T;])
{
    let n1 = a.len - 1;
    let n2 = a.len >> 1;
    for (mut i = 0; i < n2; i++)
        a.swap(i, n1 - i);
}

fn all !T(a: [T;], pred)
{
    a.each: |item, i|
        if !(pred(item, i?: i))
            return false;

    return true;
}

fn some !T(a: [T;], pred)
{
    a.each: |item, i|
        if (pred(item, i?: i))
            return true;

    return false;
}

`;


//

import module;
import context;

pub fn solvePrelude(): Context
{
    let fname   = "prelude";

    // In order to keep the prelude around,
    //  I"m thinking we"ll just prep a ready-to-copy template,
    //   with prelude solved at modid 0.
    let implicit mut ctx: Context;
    let implicit mut module = getModule(fname).helpers::clone();

    let implicit options: options::Options;

    let src     = PRELUDE_SRC;
    let lex     = lexer::lex(:src, :fname);
    let parse   = parser::parse(modid: 0, :fname, :src, :lex.tokens);

    module.in   = ModuleInputs(:src, :lex, :parse);

    setModule(module);
    module.out.solve = solver::solve();
    setModule(module);

    return ctx;
}

pub let CTX_PRELUDE = solvePrelude();
