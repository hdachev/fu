import module;
import context;

let prelude_src = `


// Some lolcode.

fn STEAL (a: &mut $T): $T __native;
fn CLONE (a: &    $T) case ($T -> @copy): $T __native;
fn SWAP  (a: &mut $T, b: &mut $T): void __native("<utility>", "std::swap");

fn println(): void __native;
fn println(a: $A): void __native;
fn println(a: $A, b: $B): void __native;
fn println(a: $A, b: $B, c: $C): void __native;
fn println(a: $A, b: $B, c: $C, d: $D): void __native;
fn println(a: $A, b: $B, c: $C, d: $D, e: $E): void __native;
fn println(a: $A, b: $B, c: $C, d: $D, e: $E, f: $F): void __native;


// Arithmetics.

fn +(a: $T) case ($T -> @arithmetic): $T __native;
fn -(a: $T) case ($T -> @arithmetic): $T __native;

fn +(a: $T, b: $T) case ($T -> @arithmetic): $T __native;
fn -(a: $T, b: $T) case ($T -> @arithmetic): $T __native;
fn *(a: $T, b: $T) case ($T -> @arithmetic): $T __native;
fn /(a: $T, b: $T) case ($T -> @arithmetic): $T __native;

fn %(a: $T, b: $T)
    case ($T -> @integral): $T __native;
    case ($T -> @floating_point): $T __native("<cmath>", "std::fmod");

fn ++(a: &mut $T) case ($T -> @arithmetic): &mut $T __native;
fn --(a: &mut $T) case ($T -> @arithmetic): &mut $T __native;
postfix fn ++(a: &mut $T) case ($T -> @arithmetic): $T __native;
postfix fn --(a: &mut $T) case ($T -> @arithmetic): $T __native;

fn +=(a: &mut $T, b: $T) case ($T -> @arithmetic): &mut $T __native;
fn -=(a: &mut $T, b: $T) case ($T -> @arithmetic): &mut $T __native;
fn *=(a: &mut $T, b: $T) case ($T -> @arithmetic): &mut $T __native;
fn /=(a: &mut $T, b: $T) case ($T -> @arithmetic): &mut $T __native;

fn ==(a: $T, b: $T) case ($T -> @primitive): bool __native;
fn !=(a: $T, b: $T) case ($T -> @primitive): bool __native;

fn > (a: $T, b: $T) case ($T -> @primitive): bool __native;
fn < (a: $T, b: $T) case ($T -> @primitive): bool __native;
fn >=(a: $T, b: $T) case ($T -> @primitive): bool __native;
fn <=(a: $T, b: $T) case ($T -> @primitive): bool __native;


// Bitwise.

fn  ~(a: $T)        case ($T -> @integral): $T __native;
fn  &(a: $T, b: $T) case ($T -> @integral): $T __native;
fn  |(a: $T, b: $T) case ($T -> @integral): $T __native;
fn  ^(a: $T, b: $T) case ($T -> @integral): $T __native;
fn <<(a: $T, b: $T) case ($T -> @integral): $T __native;
fn >>(a: $T, b: $T) case ($T -> @integral): $T __native;

fn  &=(a: &mut $T, b: $T) case ($T -> @integral): &mut $T __native;
fn  |=(a: &mut $T, b: $T) case ($T -> @integral): &mut $T __native;
fn  ^=(a: &mut $T, b: $T) case ($T -> @integral): &mut $T __native;
fn <<=(a: &mut $T, b: $T) case ($T -> @integral): &mut $T __native;
fn >>=(a: &mut $T, b: $T) case ($T -> @integral): &mut $T __native;


// Numeric conversions.

fn  i8(v: $T) case ($T -> @primitive):  i8 __native("<fu/int.h>", "fu::i8");
fn i16(v: $T) case ($T -> @primitive): i16 __native("short");
fn i32(v: $T) case ($T -> @primitive): i32 __native("int");
fn i64(v: $T) case ($T -> @primitive): i64 __native("<cstdint>", "int64_t");

fn  u8(v: $T) case ($T -> @primitive):  u8 __native("<fu/int.h>", "fu::u8");
fn u16(v: $T) case ($T -> @primitive): u16 __native("<cstdint>", "uint16_t");
fn u32(v: $T) case ($T -> @primitive): u32 __native("<cstdint>", "uint32_t");
fn u64(v: $T) case ($T -> @primitive): u64 __native("<cstdint>", "uint64_t");

fn f32(v: $T) case ($T -> @primitive): f32 __native("float");
fn f64(v: $T) case ($T -> @primitive): f64 __native("double");

fn byte(v: $T) case ($T -> @primitive): byte __native("<cstddef>", "fu::byte");


// Math.

fn abs(v: $T) case ($T -> @floating_point): $T __native("<cmath>", "std::abs");
fn max(a: $T, b: $T) case ($T -> @arithmetic): $T __native("<algorithm>", "std::max");
fn min(a: $T, b: $T) case ($T -> @arithmetic): $T __native("<algorithm>", "std::min");

fn exp  (a: $T, b: $T) case ($T -> @floating_point): $T __native("<cmath>", "std::exp");
fn exp2 (a: $T, b: $T) case ($T -> @floating_point): $T __native("<cmath>", "std::exp2");
fn log  (a: $T, b: $T) case ($T -> @floating_point): $T __native("<cmath>", "std::log");
fn log10(a: $T, b: $T) case ($T -> @floating_point): $T __native("<cmath>", "std::log10");
fn log2 (a: $T, b: $T) case ($T -> @floating_point): $T __native("<cmath>", "std::log2");

fn pow  (a: $T, b: $T) case ($T -> @floating_point): $T __native("<cmath>", "std::pow");
fn sqrt (v: $T) case ($T -> @floating_point): $T __native("<cmath>", "std::sqrt");
fn cbrt (v: $T) case ($T -> @floating_point): $T __native("<cmath>", "std::cbrt");
fn hypot(v: $T) case ($T -> @floating_point): $T __native("<cmath>", "std::hypot");

fn ceil (v: $T) case ($T -> @floating_point): $T __native("<cmath>", "std::ceil");
fn floor(v: $T) case ($T -> @floating_point): $T __native("<cmath>", "std::floor");
fn trunc(v: $T) case ($T -> @floating_point): $T __native("<cmath>", "std::trunc");
fn round(v: $T) case ($T -> @floating_point): $T __native("<cmath>", "std::round");

fn sin(v: $T) case ($T -> @floating_point): $T __native("<cmath>", "std::sin");
fn cos(v: $T) case ($T -> @floating_point): $T __native("<cmath>", "std::cos");
fn tan(v: $T) case ($T -> @floating_point): $T __native("<cmath>", "std::tan");

fn asin(v: $T) case ($T -> @floating_point): $T __native("<cmath>", "std::asin");
fn acos(v: $T) case ($T -> @floating_point): $T __native("<cmath>", "std::acos");
fn atan(v: $T) case ($T -> @floating_point): $T __native("<cmath>", "std::atan");

fn atan2(y: $T, x: $T) case ($T -> @floating_point): $T __native("<cmath>", "std::atan2");

fn PI():  f64 __native("<math.h>", "M_PI");
fn E():   f64 __native("<math.h>", "M_E");
fn INF(): f64 __native("<math.h>", "INFINITY");
fn NAN(): f64 __native("<math.h>", "NAN");

fn nan(v: $T) case ($T -> @floating_point): bool __native("<cmath>", "std::isnan");
fn inf(v: $T) case ($T -> @floating_point): bool __native("<cmath>", "std::isinf");
fn finite(v: $T) case ($T -> @floating_point): bool __native("<cmath>", "std::isfinite");


// Logic.

fn !(v: $T): bool __native;
fn true (): bool __native("true");
fn false(): bool __native("false");


// Assignment.

fn   =(a: &mut $T, mut b: $T): &mut $T __native;
fn ||=(a: &mut $T, mut b: $T): &mut $T __native;
fn &&=(a: &mut $T, mut b: $T): void __native;


// Arrays.
//
// TODO mutval push/insert/unshift, just like the assignments above.
// TODO trivial .=

fn len (a: [$T]): i32 __native(".size()");

fn [](a: [$T], i: i32)
    case ($a -> &mut [$T]): &mut $T __native;
    default               : &    $T __native;

fn [](a: [$T], start: i32, end: i32)
    case ($a -> &mut [$T]): &mut [$T] __native("<fu/view.h>", "fu::get_view_mut");
    default               : &    [$T] __native("<fu/view.h>", "fu::get_view");

fn    push(a: &mut $T[], b: $T): void __native(".push");
fn unshift(a: &mut $T[], b: $T): void __native(".unshift");
fn  insert(a: &mut $T[], i: i32, b: $T): void __native(".insert");

fn  slice(a: $T[], start: i32, end: i32): $T[] __native("<fu/vec/slice.h>", "fu::slice");
fn  slice(a: $T[], start: i32): $T[] __native("<fu/vec/slice.h>", "fu::slice");
fn substr(a: $T[], start: i32, end: i32): $T[] __native("<fu/vec/slice.h>", "fu::substr");

fn splice(a: &mut $T[], start: i32, count: i32): void  __native(".splice");
fn splice(a: &mut $T[], start: i32, count: i32, b: [$T]): void  __native(".splice");

fn    pop(a: &mut $T[]): void __native(".pop()");
fn  shift(a: &mut $T[]): void __native(".shift()");

fn  clear(a: &mut $T[]): void __native(".clear()");
fn shrink(a: &mut $T[], len: i32): void __native(".shrink");

fn resize(a: &mut $T[], len: i32): void __native(".resize");
fn   grow(a: &mut $T[], len: i32): void __native(".grow");

fn resize_junk(a: &mut $T[], len: i32): void __native(".resize<false>");
fn   grow_junk(a: &mut $T[], len: i32): void __native(".grow<false>");

fn sort(a: &mut $T[]): void __native("<fu/vec/sort.h>", "fu::sort");


// String likes.

fn ==(a: [$T], b: [$T]) case ($T -> @primitive): bool __native("<fu/vec/cmp.h>", "==");
fn !=(a: [$T], b: [$T]) case ($T -> @primitive): bool __native("<fu/vec/cmp.h>", "!=");

fn starts(a: [$T], with: [$T]) case ($T -> @primitive): bool __native("<fu/vec/find.h>", "fu::lmatch");
fn   ends(a: [$T], with: [$T]) case ($T -> @primitive): bool __native("<fu/vec/find.h>", "fu::rmatch");
fn starts(a: [$T], with:   $T) case ($T -> @primitive): bool __native("<fu/vec/find.h>", "fu::lmatch");
fn   ends(a: [$T], with:   $T) case ($T -> @primitive): bool __native("<fu/vec/find.h>", "fu::rmatch");

fn find(a: [$T], b: [$T], start: i32, end: i32) case ($T -> @primitive): i32  __native("<fu/vec/find.h>", "fu::lfind");
fn find(a: [$T], b: [$T], start: i32)           case ($T -> @primitive): i32  __native("<fu/vec/find.h>", "fu::lfind");
fn find(a: [$T], b: [$T])                       case ($T -> @primitive): i32  __native("<fu/vec/find.h>", "fu::lfind");

fn has (a: [$T], b: [$T]) case ($T -> @primitive): bool __native("<fu/vec/find.h>", "fu::has");

fn find(a: [$T], b: $T, mut start: i32): i32
{
    start = start > 0 ? start : 0;
    for (mut i = start; i < a.len; i++) // TODO memchr
        if (a[i] == b)
            return i;

    return -1;
}

fn find(a: [$T], b: $T): i32
{
    for (mut i = 0; i < a.len; i++) // TODO memchr
        if (a[i] == b)
            return i;

    return -1;
}

fn has(a: [$T], b: $T): bool
{
    for (mut i = 0; i < a.len; i++)
        if (a[i] == b)
            return true;

    return false;
}



// Strings.

type string = byte[];

fn  >(a: string, b: string): bool __native("<fu/vec/cmp.h>",  ">");
fn  <(a: string, b: string): bool __native("<fu/vec/cmp.h>",  "<");
fn >=(a: string, b: string): bool __native("<fu/vec/cmp.h>", ">=");
fn <=(a: string, b: string): bool __native("<fu/vec/cmp.h>", "<=");

// TODO: .replace() is a faster impl of .split().join().
//  How do we express this so that .split.joins are automatically promoted?
//   This would be generally useful, e.g.
//    .map.maps and .map.filters could use this to skip allocs.

fn   split(str: string, sep: string): string[] __native("<fu/vec/split.h>", "fu::split");
fn    join(a: string[], sep: string): string __native("<fu/vec/join.h>", "fu::join");
fn replace(in: string, all: string, with: string): string __native("<fu/vec/replace.h>", "fu::replace");


// D-style concats.

fn ~(a: [$T], b: [$T]): $T[] __native("<fu/vec/concat.h>",     "+");
fn ~(a: [$T], b:  $T ): $T[] __native("<fu/vec/concat_one.h>", "+");
fn ~(a:  $T , b: [$T]): $T[] __native("<fu/vec/concat_one.h>", "+");

fn ~=(a: &mut $T[], b: [$T]): &mut $T[] __native("<fu/vec/concat.h>",     "+=");
fn ~=(a: &mut $T[], b:  $T ): &mut $T[] __native("<fu/vec/concat_one.h>", "+=");

fn ~ (a: string, b: $T)      case ($T -> @arithmetic):      string __native("<fu/vec/concat_str.h>", "+");
fn ~ (a: $T, b: string)      case ($T -> @arithmetic):      string __native("<fu/vec/concat_str.h>", "+");
fn ~=(a: &mut string, b: $T) case ($T -> @arithmetic): &mut string __native("<fu/vec/concat_str.h>", "+=");


// Maps.

fn [](a: &Map($K, $V), b: $K)
    case ($a -> &mut Map($K, $V)): &mut $V __native;
    default                      : &    $V __native;

fn keys  (a: &Map($K, $V)): &$K[] __native(".m_keys");
fn values(a: &Map($K, $V)): &$V[] __native(".m_values");
fn has   (a: Map($K, $V), b: $K): bool __native("<fu/vec/find.h>", "fu::has");


// Fun with views.

fn view(a: [$T], t: $U)
    case ($a -> &mut [$T] && $T -> @trivial && $U -> @trivial): &mut [$U] __native("<fu/view.h>", "fu::view_of_mut");
    case (                   $T -> @trivial && $U -> @trivial):      [$U] __native("<fu/view.h>", "fu::view_of");

fn .=(a: &mut [$T], b: [$T]) case ($T -> @copy): void __native("<fu/view.h>", "fu::view_assign");


// Assertions, bugs & fails.
//  TODO i dont actually think we want to have nullary stuff in prelude,
//   so TODO needs to take an arg, same with assert - perhaps a pass-through argument.

fn throw(reason: string): never __native("<fu/never.h>", "fu::fail");
fn assert(): never __native("<fu/never.h>", "fu_ASSERT()");
fn TODO(): never __native("<fu/never.h>", "fu_TODO()");

`;


//

pub fn solvePrelude(): Context
{
    // In order to keep the prelude around,
    //  I"m thinking we"ll just prep a ready-to-copy template,
    //   with prelude solved at modid 0.
    let implicit mut ctx: Context;
    let implicit mut module = getModule("").helpers::clone();

    let options: options::Options;

    let src     = prelude_src;
    let fname   = "__prelude";
    let lexed   = lexer::lex(:src, :fname);
    let parsed  = parser::parse(0, :fname, :lexed.tokens, :options );

    module.in = ModuleInputs(
        :src, lex: lexed,
        parse: parsed);

    setModule(module);
    module.out.solve = solver::solve(:options);
    setModule(module);

    return ctx;
}

pub let CTX_PRELUDE: Context = solvePrelude();
