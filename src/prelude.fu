import module;
import context;

let prelude_src = `


// Arithmetics.

fn +(a: $T) case ($T.is::arithmetic): $T __native;
fn -(a: $T) case ($T.is::arithmetic): $T __native;

fn +(a: $T, b: $T) case ($T.is::arithmetic): $T __native;
fn -(a: $T, b: $T) case ($T.is::arithmetic): $T __native;
fn *(a: $T, b: $T) case ($T.is::arithmetic): $T __native;
fn /(a: $T, b: $T) case ($T.is::arithmetic): $T __native;

fn %(a: $T, b: $T)
    case ($T.is::integral): $T __native;
    case ($T.is::floating_point): $T __native("<cmath>", "std::fmod");

fn ++(ref a: $T) case ($T.is::arithmetic): &mut $T __native;
fn --(ref a: $T) case ($T.is::arithmetic): &mut $T __native;
postfix fn ++(ref a: $T) case ($T.is::arithmetic): $T __native;
postfix fn --(ref a: $T) case ($T.is::arithmetic): $T __native;

fn +=(ref a: $T, b: $T) case ($T.is::arithmetic): &mut $T __native;
fn -=(ref a: $T, b: $T) case ($T.is::arithmetic): &mut $T __native;
fn *=(ref a: $T, b: $T) case ($T.is::arithmetic): &mut $T __native;
fn /=(ref a: $T, b: $T) case ($T.is::arithmetic): &mut $T __native;

fn ==(a: $T, b: $T) case ($T.is::primitive): bool __native;
fn !=(a: $T, b: $T) case ($T.is::primitive): bool __native;

fn > (a: $T, b: $T) case ($T.is::primitive): bool __native;
fn < (a: $T, b: $T) case ($T.is::primitive): bool __native;
fn >=(a: $T, b: $T) case ($T.is::primitive): bool __native;
fn <=(a: $T, b: $T) case ($T.is::primitive): bool __native;


// Bitwise.

fn ~(a: $T)        case ($T.is::bitfield): $T __native;
fn &(a: $T, b: $T) case ($T.is::bitfield): $T __native;
fn |(a: $T, b: $T) case ($T.is::bitfield): $T __native;
fn ^(a: $T, b: $T) case ($T.is::bitfield): $T __native;

fn &=(ref a: $T, b: $T) case ($T.is::bitfield): &mut $T __native;
fn |=(ref a: $T, b: $T) case ($T.is::bitfield): &mut $T __native;
fn ^=(ref a: $T, b: $T) case ($T.is::bitfield): &mut $T __native;

fn <<(a: $T, b: $T) case ($T.is::integral): $T __native;
fn >>(a: $T, b: $T) case ($T.is::integral): $T __native;

fn <<=(ref a: $T, b: $T) case ($T.is::integral): &mut $T __native;
fn >>=(ref a: $T, b: $T) case ($T.is::integral): &mut $T __native;


// Numeric conversions.

fn  i8(v: $T) case ($T.is::primitive):  i8 __native("/prim/convert");
fn i16(v: $T) case ($T.is::primitive): i16 __native("/prim/convert");
fn i32(v: $T) case ($T.is::primitive): i32 __native("/prim/convert");
fn i64(v: $T) case ($T.is::primitive): i64 __native("/prim/convert");

fn  u8(v: $T) case ($T.is::primitive):  u8 __native("/prim/convert");
fn u16(v: $T) case ($T.is::primitive): u16 __native("/prim/convert");
fn u32(v: $T) case ($T.is::primitive): u32 __native("/prim/convert");
fn u64(v: $T) case ($T.is::primitive): u64 __native("/prim/convert");

fn f32(v: $T) case ($T.is::primitive): f32 __native("/prim/convert");
fn f64(v: $T) case ($T.is::primitive): f64 __native("/prim/convert");

fn byte(v: $T) case ($T.is::primitive): byte __native("/prim/convert");


// Math.

fn abs(v: $T) case ($T.is::floating_point): $T __native("<cmath>", "std::abs");

fn max(a: $T, b: $T)
    case ($T.is::floating_point) a >= b || b != b ? a : b;
    case ($T.is::arithmetic)     a >= b           ? a : b;

fn min(a: $T, b: $T)
    case ($T.is::floating_point) a <= b || b != b ? a : b;
    case ($T.is::arithmetic)     a <= b           ? a : b;

fn exp  (a: $T, b: $T) case ($T.is::floating_point): $T __native("<cmath>", "std::exp");
fn exp2 (a: $T, b: $T) case ($T.is::floating_point): $T __native("<cmath>", "std::exp2");
fn log  (a: $T, b: $T) case ($T.is::floating_point): $T __native("<cmath>", "std::log");
fn log10(a: $T, b: $T) case ($T.is::floating_point): $T __native("<cmath>", "std::log10");
fn log2 (a: $T, b: $T) case ($T.is::floating_point): $T __native("<cmath>", "std::log2");

fn pow  (a: $T, b: $T) case ($T.is::floating_point): $T __native("<cmath>", "std::pow");
fn sqrt (v: $T) case ($T.is::floating_point): $T __native("<cmath>", "std::sqrt");
fn cbrt (v: $T) case ($T.is::floating_point): $T __native("<cmath>", "std::cbrt");
fn hypot(v: $T) case ($T.is::floating_point): $T __native("<cmath>", "std::hypot");

fn ceil (v: $T) case ($T.is::floating_point): $T __native("<cmath>", "std::ceil");
fn floor(v: $T) case ($T.is::floating_point): $T __native("<cmath>", "std::floor");
fn trunc(v: $T) case ($T.is::floating_point): $T __native("<cmath>", "std::trunc");
fn round(v: $T) case ($T.is::floating_point): $T __native("<cmath>", "std::round");

fn sin(v: $T) case ($T.is::floating_point): $T __native("<cmath>", "std::sin");
fn cos(v: $T) case ($T.is::floating_point): $T __native("<cmath>", "std::cos");
fn tan(v: $T) case ($T.is::floating_point): $T __native("<cmath>", "std::tan");

fn asin(v: $T) case ($T.is::floating_point): $T __native("<cmath>", "std::asin");
fn acos(v: $T) case ($T.is::floating_point): $T __native("<cmath>", "std::acos");
fn atan(v: $T) case ($T.is::floating_point): $T __native("<cmath>", "std::atan");

fn atan2(y: $T, x: $T) case ($T.is::floating_point): $T __native("<cmath>", "std::atan2");

fn PI():  f64 __native("<math.h>", "M_PI");
fn E():   f64 __native("<math.h>", "M_E");
fn INF(): f64 __native("<math.h>", "INFINITY");
fn NAN(): f64 __native("<math.h>", "NAN");

fn nan(v: $T) case ($T.is::floating_point): bool __native("<cmath>", "std::isnan");
fn inf(v: $T) case ($T.is::floating_point): bool __native("<cmath>", "std::isinf");
fn finite(v: $T) case ($T.is::floating_point): bool __native("<cmath>", "std::isfinite");


// Int helpers.

type  int   = i32; // These may become separate types
type uint   = u32; //  with a user-selectable size.

fn MIN(_: $T)
    case ($T -> i8 )        -128;
    case ($T -> i16)        -32768;
    case ($T -> i32)        -2147483648;
    case ($T -> i64)        -9223372036854775808;
    case ($T.is::unsigned)  $T(0);

fn MAX(_: $T)
    case ($T -> i8 )        127;
    case ($T -> i16)        32767;
    case ($T -> i32)        2147483647;
    case ($T -> i64)        9223372036854775807;
    case ($T.is::unsigned)  $T(-1);


// Logic.

fn !(v: $T): bool __native;


// Assignment.

fn   =(ref a: $T,    mut b: $T): &mut $T __native;
fn ||=(ref a: $T, inline b: $T): &mut $T = a || (a = b);
fn &&=(ref a: $T, inline b: $T): &mut $T = a && (a = b);

fn swap(ref a: $T, ref b: $T): void __native(
    "hacks/soft_risk",
    "<utility>", "std::swap");



// Arrays.
//
// TODO mutval .=,
//  just like the assignments and splice.

novec fn len (a: [$T;]): int __native(".size()");

novec fn [](a: [$T;], i: int)
    case ($a -> &mut [$T;]): &mut $T __native(".mutref");
    default                : &    $T __native;

novec fn [](a: [$T;], start: int, end: int)
    case ($a -> &mut [$T;]): &mut [$T;] __native("<fu/view.h>", "fu::get_view_mut");
    default                : &    [$T;] __native("<fu/view.h>", "fu::get_view");

fn    push(ref a: $T[], mut b: $T): void __native(".push");
fn unshift(ref a: $T[], mut b: $T): void __native(".unshift");
fn  insert(ref a: $T[], i: int, mut b: $T): void __native(".insert");

fn  slice(a: $T[], start: int, end: int): $T[] __native("<fu/vec/slice.h>", "fu::slice");
fn  slice(a: $T[], start: int): $T[] __native("<fu/vec/slice.h>", "fu::slice");
fn substr(a: $T[], start: int, end: int): $T[] __native("<fu/vec/slice.h>", "fu::substr");

fn splice(ref a: $T[], start: int, count: int): void  __native(".splice");
fn splice(ref a: $T[], start: int, count: int, mut b: $T[]): void  __native(".splice");

fn    pop(ref a: $T[]): void __native(".pop()");
fn  shift(ref a: $T[]): void __native(".shift()");

fn  clear(ref a: $T[]): void __native(".clear()");
fn shrink(ref a: $T[], len: int): void __native(".shrink");

fn resize(ref a: $T[], len: int): void __native(".resize");
fn   grow(ref a: $T[], len: int): void __native(".grow");

fn resize_junk(ref a: $T[], len: int): void __native(".resize<false>");
fn   grow_junk(ref a: $T[], len: int): void __native(".grow<false>");


// Sorts, via std::sort - fnptrs.

fn sort(ref a: [$T;]): void
{
    pragma include("<algorithm>");
    pragma emit(
    "
        auto* data = "a".data_mut();
        std::sort(data, data + "a".size());
    ");
}

fn sort(ref a: [$T;], less/*: fn(a: $T, b: $T): bool*/): void
{
    noflow fn sort()
    {
        mut l: $T;
        mut r: $T;
        pragma include("<algorithm>");
        pragma emit(
        "
            (void) "l";
            (void) "r";
            auto* data = "a".data_mut();
            std::sort(data, data + "a".size(), [&](auto& "l", auto& "r")
            {
        ");

        mut lt: bool = less(l, r);
        pragma emit(
        "
                return "lt";
            });
        ");
    }

    sort();
}


// String likes.

fn ==(a: [$T;], b: [$T;]) case ($T.is::primitive): bool __native("<fu/vec/cmp.h>", "==");
fn !=(a: [$T;], b: [$T;]) case ($T.is::primitive): bool __native("<fu/vec/cmp.h>", "!=");

fn find(a: [$T;], b: [$T;], start: int, end: int) case ($T.is::primitive): int  __native("<fu/vec/find.h>", "fu::lfind");
fn find(a: [$T;], b: [$T;], start: int)           case ($T.is::primitive): int  __native("<fu/vec/find.h>", "fu::lfind");
fn find(a: [$T;], b: [$T;])                       case ($T.is::primitive): int  __native("<fu/vec/find.h>", "fu::lfind");

fn has (a: [$T;], b: [$T;]) case ($T.is::primitive): bool __native("<fu/vec/find.h>", "fu::has");


// Find char.

fn starts(a: [$T;], with: $T): bool
{
    return a.len && a[0] == with;
}

fn ends(a: [$T;], with: $T): bool
{
    return a.len && a[a.len - 1] == with;
}

fn starts(a: [$T;], with: [$T;]): bool
{
    return a.len >= with.len
        && a[0, with.len] == with;
}

fn ends(a: [$T;], with: [$T;]): bool
{
    return a.len >= with.len
        && a[a.len - with.len, a.len] == with;
}

fn find(a: [$T;], b: $T, mut start: int): int
{
    start = start > 0 ? start : 0;
    for (mut i = start; i < a.len; i++) // TODO memchr
        if (a[i] == b)
            return i;

    return -1;
}

fn find(a: [$T;], b: $T): int
{
    for (mut i = 0; i < a.len; i++) // TODO memchr
        if (a[i] == b)
            return i;

    return -1;
}

fn has(a: [$T;], b: $T): bool
{
    for (mut i = 0; i < a.len; i++)
        if (a[i] == b)
            return true;

    return false;
}


// Strings.

type string = byte[];

fn  >(a: string, b: string): bool __native("<fu/vec/cmp.h>",  ">");
fn  <(a: string, b: string): bool __native("<fu/vec/cmp.h>",  "<");
fn >=(a: string, b: string): bool __native("<fu/vec/cmp.h>", ">=");
fn <=(a: string, b: string): bool __native("<fu/vec/cmp.h>", "<=");


// D-style concats.

fn ~(a: [$T;], b: [$T;]): $T[] __native("<fu/vec/concat.h>",     "+");
fn ~(a: [$T;], b:  $T  ): $T[] __native("<fu/vec/concat_one.h>", "+");
fn ~(a:  $T  , b: [$T;]): $T[] __native("<fu/vec/concat_one.h>", "+");

fn ~=(ref a: $T[],     b: [$T;]): &mut $T[] __native("<fu/vec/concat.h>",     "+=");
fn ~=(ref a: $T[], mut b:  $T  ): &mut $T[] __native("<fu/vec/concat_one.h>", "+=");


// Fun with views.

fn view(a: [$T;], t: $U)
    case ($a -> &mut [$T;] && $T.is::trivial && $U.is::trivial): &mut [$U] __native("<fu/view.h>", "fu::view_of_mut");
    case (                    $T.is::trivial && $U.is::trivial):      [$U] __native("<fu/view.h>", "fu::view_of");

fn   .=(ref a: [$T;], b: [$T;]) case ($T.is::copy): void __native("<fu/vec/view_assign.h>", "fu::view_assign");

// TODO not needed if swap(x, y) alias-ok's its two arguments:
fn swap(ref a: [$T;], i: int, j: int): void __native("<fu/vec/view_swap.h>", "fu::view_swap");


// Assertions, bugs & fails.
//  TODO i dont actually think we want to have nullary stuff in prelude,
//   so TODO needs to take an arg, same with assert - perhaps a pass-through argument.

fn throw(mut reason: string): never __native("<fu/never.h>", "fu::fail");
fn assert(): never __native("<fu/never.h>", "fu_ASSERT()");


// Stringifiables.

fn ~ (    a: string, b.str) a ~ b;
fn ~ (    a.str, b: string) a ~ b;
fn ~=(ref a: string, b.str) a ~= b;

fn str(n: $T)
    case ($T.is::unsigned): string __native("<fu/decstr.h>", "fu::u64dec");
    case ($T.is::bitfield): string __native("<fu/decstr.h>", "fu::i64dec");
    case ($T -> bool):      string __native("<fu/decstr.h>", "fu::booldec");
    case ($T.is::floating_point): string __native("<fu/decstr.h>", "fu::f64dec");
    case ($T.is::enum)
{
    for (fieldname i: n)
        if (n == "i")
            return "i";

    return n.i64.str; // TODO FIX use .integer or .arithmetic when we get these
}


// Printifiables = anything that implements print.

inline fn print(x: string): string = x;
inline fn print(x.str)    : string = x;

fn println(parts.print[]: [string]): void __native("<fu/print.h>", "fu::println");


// String commons.

fn join(a: $T[][], lax sep?: $T or [$T;] or [])
{
    if (a.len < 2)
        return a.len && a[0];

    let N = sep -> [$T;] ? sep.len
          : sep ->  $T   ? 1
                         : 0;

    mut size = a[0].len;
    for (mut i = 1; i < a.len; i++)
        size += N + a[i].len;

    mut res: $T[];
    res.grow_junk(size);

    let head = a[0];
    size = head.len;
    res[0, head.len] .= head;
    for (mut i = 1; i < a.len; i++)
    {
        let range = a[i];
        if (sep -> [$T;])
            res[size, size + N] .= sep;
        else if (sep -> $T)
            res[size] = sep;

        size += N;
        res[size, size + range.len] .= range;
        size += range.len;
    }

    return res;
}

fn split(str: $T[], sep: $T or [$T;], each)
{
    mut last = 0;
    mut next = 0;

    let N = sep -> [$T;] ? sep.len : 1;
    if (N) while ((next = str.find(sep, start: last)) >= 0)
    {
        each(str.slice(last, next), first?: !last, last?: false);
        last = next + N;
    }

    if (last)
        each(str.slice(last), first?: false, last?: true);
    else
        each(str, first?: true, last?: true);
}

fn split(str: $T[], sep: $T or [$T;])
{
    mut result: $T[][];
    split(str, :sep, |substr| result ~= substr);
    return result;
}


// TODO: .replace() is a faster impl of .split().join().
//  How do we express this so that .split.joins are automatically promoted?
//   This would be generally useful, e.g.
//    .map.maps and .map.filters could use this to skip allocs.

fn replace(str: $T[], all: $T or [$T;], with: $T or [$T;] or [])
{
    mut result: $T[];
    split(str, sep: all, |substr, first, last|
    {
        if (!first)
            with -> [] ? with() : result ~= with;
        else if (last)
            return str;

        result ~= substr;
    });

    return result;
}


//

fn <>(a: $T, b: $T)
case ($T.is::primitive) = a < b ? -1 : a > b ? +1 : 0;
case ($T -> [$U]) {
    mut cmp = a.len <> b.len;
    for (mut i = 0; i < a.len && !cmp; i++)
        cmp = a[i] <> b[i];

    return cmp;
}
default {
    // TODO this would be better if it went through each member doing the trivial work first -
    //  only then going through them again and looking at e.g. array contents etc.
    for (fieldname i: a) {
        let cmp = a.i <> b.i;
        if (cmp)
            return cmp;
    }

    return 0;
}


`;


//

pub fn solvePrelude(): Context
{
    // In order to keep the prelude around,
    //  I"m thinking we"ll just prep a ready-to-copy template,
    //   with prelude solved at modid 0.
    let implicit mut ctx: Context;
    let implicit mut module = getModule("").helpers::clone();

    let implicit options: options::Options;

    let src     = prelude_src;
    let fname   = "__prelude";
    let lex     = lexer::lex(:src, :fname);
    let parse   = parser::parse(modid: 0, :fname, :src, :lex.tokens);

    module.in   = ModuleInputs(:src, :lex, :parse);

    setModule(module);
    module.out.solve = solver::solve();
    setModule(module);

    return ctx;
}

pub let CTX_PRELUDE: Context = solvePrelude();
