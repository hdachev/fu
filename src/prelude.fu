#import 'lexer';
#import 'parser';
#import 'solver';
#import 'scope';

let prelude_src = `


// Some lolcode.

fn __native(): never never;
fn __native(id: string): never never;
fn __native(id: string, opt: string): never never;

fn STEAL (a: &mut $T): $T __native;
fn CLONE (a: &    $T): $T __native;
fn SWAP  (a: &mut $T, b: &mut $T): void __native;

fn print(a: $A): void __native;
fn print(a: $A, b: $B): void __native;
fn print(a: $A, b: $B, c: $C): void __native;
fn print(a: $A, b: $B, c: $C, d: $D): void __native;
fn print(a: $A, b: $B, c: $C, d: $D, e: $E): void __native;
fn print(a: $A, b: $B, c: $C, d: $D, e: $E, f: $F): void __native;


// Arithmetics.

fn +(a: $T)                 case ($T -> @arithmetic):   $T __native;
fn +(a: $T, b: $T)          case ($T -> @arithmetic):   $T __native;

fn -(a: $T)                 case ($T -> @arithmetic):   $T __native;
fn -(a: $T, b: $T)          case ($T -> @arithmetic):   $T __native;
fn *(a: $T, b: $T)          case ($T -> @arithmetic):   $T __native;

fn /(a: $T, b: $T)
    // case ($T -> @floating_point):                       $T __native;
    // case ($T -> @integral && $b -> @non_zero):          $T __native;
    case ($T -> @arithmetic): $T __native;

fn %(a: $T, b: $T)
    // case ($T -> @floating_point):                       $T __native;
    // case ($T -> @integral && $b -> @non_zero):          $T __native;
    case ($T -> @arithmetic): $T __native;

fn ++(a: &mut $T)           case ($T -> @arithmetic):   $T __native;
fn --(a: &mut $T)           case ($T -> @arithmetic):   $T __native;
fn +=(a: &mut $T, b: $T)    case ($T -> @arithmetic):   &mut $T __native;
fn -=(a: &mut $T, b: $T)    case ($T -> @arithmetic):   &mut $T __native;

fn ==(a: $T, b: $T)         case ($T -> @arithmetic):   bool __native;
fn !=(a: $T, b: $T)         case ($T -> @arithmetic):   bool __native;
fn > (a: $T, b: $T)         case ($T -> @arithmetic):   bool __native;
fn < (a: $T, b: $T)         case ($T -> @arithmetic):   bool __native;
fn >=(a: $T, b: $T)         case ($T -> @arithmetic):   bool __native;
fn <=(a: $T, b: $T)         case ($T -> @arithmetic):   bool __native;


// Bitwise.

fn ~(a: $T)                 case ($T -> @integral):     $T __native;
fn &(a: $T, b: $T)          case ($T -> @integral):     $T __native;
fn |(a: $T, b: $T)          case ($T -> @integral):     $T __native;
fn ^(a: $T, b: $T)          case ($T -> @integral):     $T __native;
fn <<(a: $T, b: $T)         case ($T -> @integral):     $T __native;
fn >>(a: $T, b: $T)         case ($T -> @integral):     $T __native;

fn &=(a: &mut $T, b: $T)    case ($T -> @integral):     &mut $T __native;
fn |=(a: &mut $T, b: $T)    case ($T -> @integral):     &mut $T __native;
fn ^=(a: &mut $T, b: $T)    case ($T -> @integral):     &mut $T __native;


// Logic.

fn true (): bool __native('true');
fn false(): bool __native('false');


// Assignment.

fn   =(a: &mut $T, b: $T): &mut $T __native;
fn ||=(a: &mut $T, b: $T): &mut $T __native;


// Arrays.

fn len (a: $T[]): i32 __native('.size()');
fn find(a: $T[], b: $T): i32 __native('<fu/vec/find.h>', 'fu::lfind');
fn has (a: $T[], b: $T): bool __native('<fu/vec/find.h>', 'fu::has');

fn [](a: $T[], i: i32)
    case ($a -> &mut $T[]): &mut $T __native;
    case ($a -> &    $T[]): &    $T __native;
    case ($a ->      $T[]):      $T __native;

fn    push(a: &mut $T[], b: $T): void __native('.push');
fn unshift(a: &mut $T[], b: $T): void __native('.unshift');
fn  insert(a: &mut $T[], i: i32, b: $T): void __native('.insert');

fn  slice(a: $T[], i0: i32, i1: i32): $T[] __native('<fu/vec/slice.h>', 'fu::slice');
fn  slice(a: $T[], i0: i32): $T[] __native('<fu/vec/slice.h>', 'fu::slice');

fn splice(a: &mut $T[], i: i32, N: i32): void  __native('.splice');
fn    pop(a: &mut $T[]): void __native('.pop()');

fn  clear(a: &mut $T[]): void __native('.clear()');
fn resize(a: &mut $T[], len: i32): void __native('.resize');
fn shrink(a: &mut $T[], len: i32): void __native('.shrink');

fn sort(a: &mut $T[]): void __native('<fu/vec/sort.h>', 'fu::sort');


// Concats.
//
//  flatten: str/arr a+b+c chains into a n-ary binop -
//  adjoin : str/arr chain adjacent += for the same left-arg.
//
//      Currently just testing notations,
//        but can we make this more generic?
//          Will it be useful? Array ops are really
//            the only thing we care about optimizing.

fn +(a: $T[], b: $T[]): $T[] __native;
fn +(a: $T[], b: $T  ): $T[] __native;
fn +(a: $T  , b: $T[]): $T[] __native;

fn +=(a: &mut string, b: string): &mut string __native;
fn + (a:      string, b: string):      string __native;


// Strings.

fn  len(a: string): i32 __native('.size()');
fn find(a: string, b: string): i32 __native('<fu/vec/find.h>', 'fu::lfind');
fn  has(a: string, b: string): bool __native('<fu/vec/find.h>', 'fu::has');

fn  [](a: string, i: i32): string __native;

fn ==(a: string, b: string): bool __native;
fn !=(a: string, b: string): bool __native;
fn  >(a: string, b: string): bool __native;
fn  <(a: string, b: string): bool __native;
fn >=(a: string, b: string): bool __native;
fn <=(a: string, b: string): bool __native;

fn starts(a: string, with: string): bool __native('<fu/vec/find.h>', 'fu::lmatch');
fn   ends(a: string, with: string): bool __native('<fu/vec/find.h>', 'fu::rmatch');

fn slice (a: string, i0: i32, i1: i32): string __native('<fu/vec/slice.h>', 'fu::slice');
fn slice (a: string, i0: i32): string __native('<fu/vec/slice.h>', 'fu::slice');

fn substr(a: string, i0: i32, i1: i32): string __native('<fu/vec/slice.h>', 'fu::substr');
fn char  (a: string, i0: i32): i32 __native;


// TODO: .replace() is a faster impl of .split().join().
//  How do we express this so that .split.joins are automatically promoted?
//   This would be generally useful, e.g.
//    .map.maps and .map.filters could use this to skip allocs.

fn   split(str: string, sep: string): string[] __native('<fu/vec/split.h>', 'fu::split');
fn    join(a: string[], sep: string): string __native('<fu/vec/join.h>', 'fu::join');
fn replace(in: string, all: string, with: string): string __native('<fu/vec/replace.h>', 'fu::replace');


// Maps.

fn [](a: Map($K, $V), b: &$K)
    case ($a -> &mut Map($K, $V)): &mut $V __native;
    case ($a -> &    Map($K, $V)): &    $V __native;
    case ($a ->      Map($K, $V)):      $V __native;

fn keys  (a: Map($K, $V)): $K[] __native('.m_keys');
fn values(a: Map($K, $V)): $V[] __native('.m_values');
fn has   (a: Map($K, $V), b: $K): bool __native('<fu/vec/find.h>', 'fu::has');
fn count (a: Map($K, $V)): i32 __native('.size()');


// Assertions, bugs & fails.

fn throw(reason: string): never __native('<fu/never.h>', 'fu::fail');
fn assert(): never __native('<fu/never.h>', 'fu::fail()');


// Butt plugs.

// TODO we should go for an any $B -> call stringify(b) macro.
fn +(a: string, b: i32): string __native;
fn +(a: string, b: f64): string __native;
fn +(a: i32, b: string): string __native;
fn +(a: f64, b: string): string __native;

// TODO fix impure io.
fn now_hr(): f64 __native('<fu/now.h>', 'fu::now_hr()');
fn now_utc(): f64 __native('<fu/now.h>', 'fu::now_utc()');

fn env_get(key: string): string __native('<fu/env.h>', 'fu::env_get');

fn file_size(path: string): i32 __native('<fu/io.h>', 'fu::file_size');
fn file_read(path: string): string __native('<fu/io.h>', 'fu::file_read');
fn file_write(path: string, body: string): i32 __native('<fu/io.h>', 'fu::file_write');

fn fs_cwd(): string __native('<fu/io.h>', 'fu::fs_cwd()');
fn fs_mkdir_p(path: string): i32 __native('<fu/io.h>', 'fu::fs_mkdir_p');
fn fs_mkdir_p(path: string, mode: i32): i32 __native('<fu/io.h>', 'fu::fs_mkdir_p');

fn shell_exec(cmd: string): i32 __native('<fu/shell.h>', 'fu::shell_exec');
fn shell_exec(cmd: string, stdout: &mut string): i32 __native('<fu/shell.h>', 'fu::shell_exec');

fn hash_tea(str: string): string __native('<fu/tea.h>', 'fu::hash_tea');

fn i32(v: f64): i32 __native;

fn exit(code: i32): never __native;

`;

fn solvePrelude(): Context
{
    // In order to keep the prelude around,
    //  I'm thinking we'll just prep a ready-to-copy template,
    //   with prelude solved at modid 0.
    let implicit mut ctx: Context;
    let implicit mut module = getModule('');

    let lexed   = lex(prelude_src, '__prelude');
    let root    = parse(0, '__prelude', :lexed.tokens).root;
    let solved  = solve(root);

    module.out.solve = solved;
    setModule(module);

    return ctx;
}

pub let CTX_PRELUDE: Context = solvePrelude();
