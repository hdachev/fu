let PRELUDE_SRC = `


// Arithmetics.

prefix fn + !T(a: T) case (T.is::arithmetic): T __native;
prefix fn - !T(a: T) case (T.is::arithmetic): T __native;

infix fn + !T(a: T, b: T) case (T.is::arithmetic): T __native;
infix fn - !T(a: T, b: T) case (T.is::arithmetic): T __native;
infix fn * !T(a: T, b: T) case (T.is::arithmetic): T __native;
infix fn / !T(a: T, b: T) case (T.is::arithmetic): T __native;

infix fn % !T(a: T, b: T)
    case (T.is::integral): T __native;
    case (T.is::floating_point): T __native("<cmath>", "std::fmod");

prefix fn ++ !T(mut ref a: T) case (T.is::arithmetic): &mut T __native;
prefix fn -- !T(mut ref a: T) case (T.is::arithmetic): &mut T __native;

postfix fn ++ !T(mut ref a: T) case (T.is::arithmetic): T __native;
postfix fn -- !T(mut ref a: T) case (T.is::arithmetic): T __native;

infix fn += !T(mut ref a: T, b: T) case (T.is::arithmetic): &mut T __native;
infix fn -= !T(mut ref a: T, b: T) case (T.is::arithmetic): &mut T __native;
infix fn *= !T(mut ref a: T, b: T) case (T.is::arithmetic): &mut T __native;
infix fn /= !T(mut ref a: T, b: T) case (T.is::arithmetic): &mut T __native;

infix fn >  !T(a: T, b: T) case (T.is::primitive): bool __native;
infix fn <  !T(a: T, b: T) case (T.is::primitive): bool __native;
infix fn >= !T(a: T, b: T) case (T.is::primitive): bool __native;
infix fn <= !T(a: T, b: T) case (T.is::primitive): bool __native;


// Bitwise.

prefix fn ~ !T(a: T) case (T.is::bitfield): T __native;

infix fn & !T(a: T, b: T) case (T.is::bitfield): T __native;
infix fn | !T(a: T, b: T) case (T.is::bitfield): T __native;
infix fn ^ !T(a: T, b: T) case (T.is::bitfield): T __native;

infix fn &= !T(mut ref a: T, b: T) case (T.is::bitfield): &mut T __native;
infix fn |= !T(mut ref a: T, b: T) case (T.is::bitfield): &mut T __native;
infix fn ^= !T(mut ref a: T, b: T) case (T.is::bitfield): &mut T __native;

infix fn << !T(a: T, b: T) case (T.is::integral): T __native;
infix fn >> !T(a: T, b: T) case (T.is::integral): T __native;

infix fn <<= !T(mut ref a: T, b: T) case (T.is::integral): &mut T __native;
infix fn >>= !T(mut ref a: T, b: T) case (T.is::integral): &mut T __native;


// Numeric conversions.
/*  Sketch for making these programmable.

infix fn => !From(from: From, type Into)
    case (Into.is::primitive && From.is::primitive)
        __native("/prim_convert");
*/

fn   i8 !T(v: T) case (T.is::primitive):   i8 __native("/prim/convert");
fn  i16 !T(v: T) case (T.is::primitive):  i16 __native("/prim/convert");
fn  i32 !T(v: T) case (T.is::primitive):  i32 __native("/prim/convert");
fn  i64 !T(v: T) case (T.is::primitive):  i64 __native("/prim/convert");
fn i128 !T(v: T) case (T.is::primitive): i128 __native("/prim/convert");

fn   u8 !T(v: T) case (T.is::primitive):   u8 __native("/prim/convert");
fn  u16 !T(v: T) case (T.is::primitive):  u16 __native("/prim/convert");
fn  u32 !T(v: T) case (T.is::primitive):  u32 __native("/prim/convert");
fn  u64 !T(v: T) case (T.is::primitive):  u64 __native("/prim/convert");
fn u128 !T(v: T) case (T.is::primitive): u128 __native("/prim/convert");

fn  f32 !T(v: T) case (T.is::primitive): f32 __native("/prim/convert");
fn  f64 !T(v: T) case (T.is::primitive): f64 __native("/prim/convert");

fn byte !T(v: T) case (T.is::primitive): byte __native("/prim/convert");

fn unsigned !T(v: T)
    case (T -> i8)     v.u8;
    case (T -> i16)    v.u16;
    case (T -> i32)    v.u32;
    case (T -> i64)    v.u64;
    case (T -> i128)   v.u128;
    case (T.is::integral && T.is::unsigned) v;

fn signed !T(v: T)
    case (T -> u8)     v.i8;
    case (T -> u16)    v.i16;
    case (T -> u32)    v.i32;
    case (T -> u64)    v.i64;
    case (T -> u128)   v.i128;
    case (T.is::integral && !T.is::unsigned) v;

fn MIN(type T)
    case (T -> i8 )        -128;
    case (T -> i16)        -32768;
    case (T -> i32)        -2147483648;
    case (T -> i64)        -9223372036854775808;
    case (T.is::unsigned)  T(0);

fn MAX(type T)
    case (T -> i8 )        127;
    case (T -> i16)        32767;
    case (T -> i32)        2147483647;
    case (T -> i64)        9223372036854775807;
    case (T.is::unsigned)  T(-1);

type  int   = i32; // These may become separate types
type uint   = u32; //  with a user-selectable size.


// Math.

fn abs !T(v: T)
    case (T.is::floating_point): T __native("<cmath>", "std::fabs");
    case (T.is::arithmetic && !T.is::unsigned) v < 0 ? -v : v;

fn max !T(a: T, b: T)
    case (T.is::floating_point): T __native("<cmath>", "std::fmin");
    case (T.is::arithmetic) a >= b ? a : b;

fn min !T(a: T, b: T)
    case (T.is::floating_point): T __native("<cmath>", "std::fmax");
    case (T.is::arithmetic) a <= b ? a : b;

fn exp   !T(a: T) case (T.is::floating_point): T __native("<cmath>", "std::exp");
fn exp2  !T(a: T) case (T.is::floating_point): T __native("<cmath>", "std::exp2");
fn log   !T(a: T) case (T.is::floating_point): T __native("<cmath>", "std::log");
fn log10 !T(a: T) case (T.is::floating_point): T __native("<cmath>", "std::log10");
fn log2  !T(a: T) case (T.is::floating_point): T __native("<cmath>", "std::log2");

fn pow   !T(a: T, b: T) case (T.is::floating_point): T __native("<cmath>", "std::pow");
fn sqrt  !T(v: T) case (T.is::floating_point): T __native("<cmath>", "std::sqrt");
fn cbrt  !T(v: T) case (T.is::floating_point): T __native("<cmath>", "std::cbrt");
fn hypot !T(v: T) case (T.is::floating_point): T __native("<cmath>", "std::hypot");

fn ceil  !T(v: T) case (T.is::floating_point): T __native("<cmath>", "std::ceil");
fn floor !T(v: T) case (T.is::floating_point): T __native("<cmath>", "std::floor");
fn trunc !T(v: T) case (T.is::floating_point): T __native("<cmath>", "std::trunc");
fn round !T(v: T) case (T.is::floating_point): T __native("<cmath>", "std::round");

fn sin !T(v: T) case (T.is::floating_point): T __native("<cmath>", "std::sin");
fn cos !T(v: T) case (T.is::floating_point): T __native("<cmath>", "std::cos");
fn tan !T(v: T) case (T.is::floating_point): T __native("<cmath>", "std::tan");

fn asin !T(v: T) case (T.is::floating_point): T __native("<cmath>", "std::asin");
fn acos !T(v: T) case (T.is::floating_point): T __native("<cmath>", "std::acos");
fn atan !T(v: T) case (T.is::floating_point): T __native("<cmath>", "std::atan");

fn atan2 !T(y: T, x: T) case (T.is::floating_point): T __native("<cmath>", "std::atan2");

fn PI (type T) case (T.is::floating_point): T __native("<math.h>", "static_cast<>(M_PI)");
fn E  (type T) case (T.is::floating_point): T __native("<math.h>", "static_cast<>(M_E)");
fn INF(type T) case (T.is::floating_point): T __native("<math.h>", "static_cast<>(INFINITY)");
fn NAN(type T) case (T.is::floating_point): T __native("<math.h>", "static_cast<>(NAN)");

fn nan    !T(v: T) case (T.is::floating_point): bool __native("<cmath>", "std::isnan");
fn inf    !T(v: T) case (T.is::floating_point): bool __native("<cmath>", "std::isinf");
fn finite !T(v: T) case (T.is::floating_point): bool __native("<cmath>", "std::isfinite");


// Assignment.

infix fn   = !T(mut ref a: T,    mut b: T): &mut T __native;
infix fn ||= !T(mut ref a: T, inline b: T): &mut T = a || (a = b);
infix fn &&= !T(mut ref a: T, inline b: T): &mut T = a && (a = b);

fn swap !T(mut ref a: T, mut ref b: T)
    case (  T -> _[]   ): void __native(".swap");
    case (!(T -> _[..])): void __native("hacks/soft_risk", "<utility>", "std::swap");


// Arrays.
//
// TODO mutval .=,
//  just like the assignments and splice.

fn typeof !T(lax _: T) = T;

fn [](type T)   = typeof([] => T[]);
fn [..](type T) = typeof([] => T[..]);

novec fn len !T(a: T[..]): int __native(".size()");

novec fn [] !T(ref a: T[..], i: int)
    case (typeof(a) -> &mut T[..]): &mut T __native(".mutref");
    default                       : &    T __native;

fn [..] !T(ref a: T[..], start: int, end: int)
    case (typeof(a) -> &mut T[]  ): &mut T[]   __native("<fu/vec_range.h>", "fu::get_range_mut");
    case (typeof(a) -> &    T[]  ): &    T[]   __native("<fu/vec_range.h>", "fu::get_range");
    case (typeof(a) -> &mut T[..]): &mut T[..] __native("<fu/view.h>", "fu::get_view_mut");
    default                       : &    T[..] __native("<fu/view.h>", "fu::get_view");

fn [..] !T(ref a: T[..], start!: int)
    case (typeof(a) -> &mut T[]  ): &mut T[]   __native("<fu/vec_range.h>", "fu::get_range_mut");
    case (typeof(a) -> &    T[]  ): &    T[]   __native("<fu/vec_range.h>", "fu::get_range");
    case (typeof(a) -> &mut T[..]): &mut T[..] __native("<fu/view.h>", "fu::get_view_mut");
    default                       : &    T[..] __native("<fu/view.h>", "fu::get_view");

fn [..] !T(ref a: T[..], end!: int)
    case (typeof(a) -> &mut T[]  ): &mut T[]   __native("<fu/vec_range.h>", "fu::get_range_start0_mut");
    case (typeof(a) -> &    T[]  ): &    T[]   __native("<fu/vec_range.h>", "fu::get_range_start0");
    case (typeof(a) -> &mut T[..]): &mut T[..] __native("<fu/view.h>", "fu::get_view_start0_mut");
    default                       : &    T[..] __native("<fu/view.h>", "fu::get_view_start0");

fn slice !T(ref a: T[..], start: int, end: int) // TODO REMOVE
    case (typeof(a) -> &mut T[]  ): &mut T[]   __native("<fu/vec_range.h>", "fu::get_range_mut");
    case (typeof(a) -> &    T[]  ): &    T[]   __native("<fu/vec_range.h>", "fu::get_range");
    case (typeof(a) -> &mut T[..]): &mut T[..] __native("<fu/view.h>", "fu::get_view_mut");
    default                       : &    T[..] __native("<fu/view.h>", "fu::get_view");

fn slice !T(ref a: T[..], start: int) // TODO REMOVE
    case (typeof(a) -> &mut T[]  ): &mut T[]   __native("<fu/vec_range.h>", "fu::get_range_mut");
    case (typeof(a) -> &    T[]  ): &    T[]   __native("<fu/vec_range.h>", "fu::get_range");
    case (typeof(a) -> &mut T[..]): &mut T[..] __native("<fu/view.h>", "fu::get_view_mut");
    default                       : &    T[..] __native("<fu/view.h>", "fu::get_view");

fn    push !T(mut ref a: T[], mut b: T): void __native(".push");
fn unshift !T(mut ref a: T[], mut b: T): void __native(".unshift");
fn  insert !T(mut ref a: T[], i: int, mut b: T): void __native(".insert");

fn splice !T(mut ref a: T[], start: int, count: int): void  __native(".splice");
fn splice !T(mut ref a: T[], start: int, count: int, /*TODO FIX*/b: T[..]): void  __native(".splice");

fn    pop !T(mut ref a: T[]): void __native(".pop()");
fn  shift !T(mut ref a: T[]): void __native(".shift()");

fn  clear !T(mut ref a: T[]): void __native(".clear()");
fn shrink !T(mut ref a: T[], len: int): void __native(".shrink");

fn resize !T(mut ref a: T[], len: int): void __native(".resize");
fn   grow !T(mut ref a: T[], len: int): void __native(".grow");

fn resize_junk !T(mut ref a: T[], len: int): void __native(".resize<false>");
fn   grow_junk !T(mut ref a: T[], len: int): void __native(".grow<false>");


// Sorts, via std::sort - fnptrs.

fn sort !T(mut ref a: T[..]): void
{
    pragma include("<algorithm>");
    pragma emit(
    \`
        auto* data = \`a\`.data_mut();
        std::sort(data, data + \`a\`.size());
    \`);
}

fn sort !T(mut ref a: T[..], less/*: fn(a: T, b: T): bool*/): void
{
    noflow fn sort()
    {
        mut l: T;
        mut r: T;
        pragma include("<algorithm>");
        pragma emit(
        \`
            (void) \`l\`;
            (void) \`r\`;
            auto* data = \`a\`.data_mut();
            std::sort(data, data + \`a\`.size(), [&](auto& \`l\`, auto& \`r\`)
            {
        \`);

        mut lt: bool = less(l, r);
        pragma emit(
        \`
                return \`lt\`;
            });
        \`);
    }

    sort();
}


// String likes.

fn has !T(a: T[..], b: T[..]) = a.find(b) >= 0;

fn find !T(haystack: T[..], needle: T[..], start?: int or [], end?: int or []): int
{
    type Start  = typeof(start);
    type End    = typeof(end);

    // Keep things simple.
    if !(Start -> [] && End -> [])
    {
        let slice = Start -> [] ? haystack[      .. end]
                  : End   -> [] ? haystack[start ..    ]
                                : haystack[start .. end];

        let res = slice.find(needle);
        return res + (res < 0 ? 0 : start);
    }

    // Shorter haystack & empty needle.
    if (haystack.len < needle.len || needle.len <= 0)
        return needle.len ? -1 : 0;

    // This is both a fast path for single-item needles,
    //  and simplifies the loops below,
    //   where the Booyer-Moore trick can rely on needle having at least two items.
    if (needle.len == 1)
        return haystack.find(needle[0]);


    // Try to go for a whole needle comparison
    //  if the needle is small enough to fit in an integer.
    //
    // This works, never measured if it speeds anything up though.

    // if (T.is::primitive && !T.is::floating_point
    //                     && needle.len * sizeof(T) <= 16)
    // {
    //     let shift       = (sizeof(T) * 8).u128;
    //     let mask        = needle.len * sizeof(T) * 8;
    //     shadow let mask =
    //         mask < 128  ? ~(~(0.u128) << (needle.len * sizeof(T) * 8).u128)
    //                     :   ~(0.u128);
    //
    //     mut reg_needle:     u128;
    //     mut reg_haystack:   u128;
    //     for (mut i = 0; i < needle.len; i++) {
    //         reg_needle    <<= shift;
    //         reg_haystack  <<= shift;
    //         reg_needle     |= needle[i].u128;
    //         reg_haystack   |= haystack[i].u128;
    //     }
    //
    //     mut i = needle.len;
    //     for (;;) {
    //         if (reg_haystack == reg_needle)
    //             return i - needle.len;
    //
    //         if !(i < haystack.len)
    //             return -1;
    //
    //         reg_haystack  <<= shift;
    //         reg_haystack   &= mask;
    //         reg_haystack   |= haystack[i++].u128;
    //     }
    // }


    // Booyer-Moore trick from FBString::find,
    //  modified to avoid testing the last needle character twice.

    let needle_len_m1       = needle.len - 1;
    let needle_last_char    = needle[needle_len_m1];

    // How many bytes are skipped when a mismatch is found after tail matches -
    //  if needle is 'aa', then skip would be 1, if needle doesn't repeat the tail byte,
    //   skip would be needle.len.
    mut skip = 0;

    for (mut i = needle_len_m1;
             i < haystack.len; )
    {
        // Scan for a the tail char of the needle,
        //  consider using strchr here or something.
        while (haystack[i] != needle_last_char)
            if (++i == haystack.len)
                return -1;

        // Match the rest of the needle,
        //  consider randomizing this part, should help with crafted needles.
        for (mut j = 0;; )
        {
            // Mismatch halfway through the needle?
            if (haystack[i - needle_len_m1 + j] != needle[j])
            {
                // Init the skip value.
                if !(skip)
                {
                    // Scan the needle backwards,
                    //  break on first match with needle tail.
                    skip = needle.len;
                    for (shadow mut j = needle_len_m1; j --> 0; ) {
                        if (needle[j] == needle_last_char) {
                            skip = needle_len_m1 - j;
                            break;
                        }
                    }
                }

                // Skip over to the next possible tail-char position.
                i += skip;
                break;
            }

            // Entire needle matches?
            if (++j == needle_len_m1)
                return i - needle_len_m1;
        }
    }

    return -1;
}


// Find char.

fn starts !T(a: T[..], with: T): bool
{
    return a.len && a[0] == with;
}

fn ends !T(a: T[..], with: T): bool
{
    return a.len && a[a.len - 1] == with;
}

fn starts !T(a: T[..], with: T[..]): bool
{
    return a.len >= with.len
        && a[.. with.len] == with;
}

fn ends !T(a: T[..], with: T[..]): bool
{
    return a.len >= with.len
        && a[a.len - with.len .. a.len] == with;
}

fn find !T(a: T[..], b: T, mut start: int): int
{
    start = start > 0 ? start : 0;
    for (mut i = start; i < a.len; i++) // TODO memchr
        if (a[i] == b)
            return i;

    return -1;
}

fn find !T(a: T[..], b: T): int
{
    for (mut i = 0; i < a.len; i++) // TODO memchr
        if (a[i] == b)
            return i;

    return -1;
}

fn has !T(a: T[..], b: T): bool
{
    for (mut i = 0; i < a.len; i++)
        if (a[i] == b)
            return true;

    return false;
}


// Strings.

type string = byte[];

infix fn  >(a: string, b: string): bool __native("<fu/vec/cmp.h>",  ">");
infix fn  <(a: string, b: string): bool __native("<fu/vec/cmp.h>",  "<");
infix fn >=(a: string, b: string): bool __native("<fu/vec/cmp.h>", ">=");
infix fn <=(a: string, b: string): bool __native("<fu/vec/cmp.h>", "<=");


// D-style concats.
//
// TODO FIX these concats hide copies
//  which also means they dont work correctly for nocopy stuff
//
infix fn ~ !T(a: T[..], b: T[..]): T[] __native("<fu/vec/concat.h>",     "+");
infix fn ~ !T(a: T[..], b: T    ): T[] __native("<fu/vec/concat_one.h>", "+");
infix fn ~ !T(a: T    , b: T[..]): T[] __native("<fu/vec/concat_one.h>", "+");

infix fn ~= !T(mut ref a: T[],     b: T[..]): &mut T[] __native("<fu/vec/concat.h>",     "+=");
infix fn ~= !T(mut ref a: T[], mut b: T    ): &mut T[] __native("<fu/vec/concat_one.h>", "+=");


// Fun with views.

fn sizeof !T(type T)
    case (T.is::zero_size) 0;
    case (T ->   i8 || T ->   u8 || T -> byte || T -> bool) 1;
    case (T ->  i16 || T ->  u16) 2;
    case (T ->  i32 || T ->  u32) 4;
    case (T ->  i64 || T ->  u64) 8;
    case (T -> i128 || T -> u128) 16;

fn view !T(ref a: T[], type of)
    case (typeof(a) -> &mut T[] && T.is::reinterpretable && of.is::reinterpretable): &mut of[..] __native("<fu/view.h>", "fu::view_of_mut<>");
    case (                         T.is::reinterpretable && of.is::reinterpretable): &    of[..] __native("<fu/view.h>", "fu::view_of<>");

infix fn .= !T(mut ref a: T[..], b: T[..]) case (T.is::copy): void __native("<fu/vec/view_assign.h>", "fu::view_assign");

// TODO not needed if swap(x, y) alias-ok's its two arguments:
fn swap !T(mut ref a: T[..], i: int, j: int): void __native("<fu/vec/view_swap.h>", "fu::view_swap");

fn partition !T(mut ref a: T[..], predicate, mut start!keep = 0)
{
    let size = a.len;
    for (mut i = keep; i < size; i++)
        if (!predicate(a[i], ?:i)) {
            if (i > keep)
                a.swap(i, keep);

            keep++;
        }

    return keep;
}

fn remove !T(mut ref a: T[], predicate, mut start!keep = 0)
{
    if (T.is::trivial)
    {
        let size = a.len;
        for (mut i = keep; i < size; i++) {
            let here = a[i];
            if (!predicate(here, ?:i)) {
                if (i > keep)
                    a[keep] = here;

                keep++;
            }
        }
    }
    else
    {
        a.shrink(a.partition(fn predicate));
    }
}


// Stringifiables.

infix fn ~ (        a: byte[..], b.str      ) a ~ b;
infix fn ~ (        a.str,       b: byte[..]) a ~ b;
infix fn ~=(mut ref a: string,   b.str      ) a ~= b;

fn str !T(n: T)
    case (T.is::unsigned       ): string __native("<fu/decstr.h>", "fu::u64dec");
    case (T.is::integral       ): string __native("<fu/decstr.h>", "fu::i64dec");
    case (T -> bool            ): string __native("<fu/decstr.h>", "fu::booldec");
    case (T -> f32             ): string __native("<fu/decstr.h>", "fu::f32dec");
    case (T -> f64             ): string __native("<fu/decstr.h>", "fu::f64dec");
    case (T.is::enum)
{
    for (fieldname i: T)
        if (n == "i")
            return "i";

    return n.i64.str; // TODO FIX use .integer or .arithmetic when we get these
}
    case (T.is::flags)
{
    mut res: string;
    for (fieldname i: T)
        if (n & "i")
            res ~= "i" ~ ", ";

    if (res)
        res.shrink(res.len - 2);

    return res;
}


// Assertions, bugs & fails.

fn throw(mut reason: string): never __native("<fu/never.h>", "fu::fail",
    "|Fx_NotDeadCode", "|Fx_DontMoveDown", "|Fx_Throws");

fn assert(/*TODO pure*/ expression: bool): void __native("<fu/assert.h>", "fu_ASSERT",
    "|Fx_NotDeadCode");


// Printifiables = anything that implements print.

inline fn print(x: string): string = x;
inline fn print(x.str)    : string = x;

fn println(parts.print[]: string[..]): void __native("<fu/print.h>", "fu::println",
    "|output");


// String commons.

fn join !T(a: T[][..], sep?: T or T[..] or [])
{
    if (a.len < 2)
        return a.len && a[0];

    let N = typeof(sep) -> T[..] ? sep.len
          : typeof(sep) -> T     ? 1
                                 : 0;

    mut size = a[0].len;
    for (mut i = 1; i < a.len; i++)
        size += N + a[i].len;

    mut res: T[];
    res.grow_junk(size);

    let head = a[0];
    size = head.len;
    res[.. head.len] .= head;
    for (mut i = 1; i < a.len; i++)
    {
        let range = a[i];
        if (typeof(sep) -> T[..])
            res[size .. size + N] .= sep;
        else if (typeof(sep) -> T)
            res[size] = sep;

        size += N;
        res[size .. size + range.len] .= range;
        size += range.len;
    }

    return res;
}

fn split !T(str: T[..], sep: T or T[..], each)
{
    mut last = 0;
    mut next = 0;

    let N = typeof(sep) -> T[..] ? sep.len : 1;
    if (N) while ((next = str.find(sep, start: last)) >= 0)
    {
        each(str.slice(last, next), first?: !last, last?: false);
        last = next + N;
    }

    if (last)
        each(str.slice(last), first?: false, last?: true);
    else
        each(str, first?: true, last?: true);
}

fn split !T(str: T[], sep: T or T[..])
{
    mut result: T[][];
    split(str, :sep, |substr| result ~= substr);
    return result;
}


// TODO: .replace() is a faster impl of .split().join().
//  How do we express this so that .split.joins are automatically promoted?
//   This would be generally useful, e.g.
//    .map.maps and .map.filters could use this to skip allocs.

fn replace !T(str: T[], all: T or T[..], with: T or T[..] or [])
{
    mut result: T[];
    split(str, sep: all, |substr, lax first, lax last|
    {
        if (!first)
            typeof(with) -> [] ? with() : result ~= with;
        else if (last)
            return str;

        result ~= substr;
    });

    return result;
}


//

infix fn <> !T(a: T, b: T)
case (T.is::primitive) = a < b ? -1 : a > b ? +1 : 0;
case (T -> _[..]) {
    mut cmp = a.len <> b.len;
    for (mut i = 0; i < a.len && !cmp; i++)
        cmp = a[i] <> b[i];

    return cmp;
}
default {
    lax mut cmp = 0;

    // TODO this would be better if it went through each member doing the trivial work first -
    //  only then going through them again and looking at e.g. array contents etc,
    //   this is a first approx but does not go recursively through structs.

    for (fieldname i: T)
        if (typeof(a.i).is::trivial)
            if (cmp = a.i <> b.i)
                return cmp;

    for (fieldname i: T)
        if !(typeof(a.i).is::trivial)
            if (cmp = a.i <> b.i)
                return cmp;

    return 0;
}

infix fn == !T(a: T, b: T)
    case (T.is::primitive): bool __native;
    default: bool = !(a <> b);

infix fn != !T(a: T, b: T)
    case (T.is::primitive): bool __native;
    default: bool = !!(a <> b);


//

fn map !T(a: T[..], fn)
{
    mut res: typeof( fn(T, i?: a.len) )[];
    res.grow_junk(a.len);
    for (mut i = 0; i < a.len; i++)
        res[i] = fn(a[i], i?: i);

    return res;
}

fn each !T(ref a: T[..], fn)
    for (mut i = 0; i < a.len; i++)
        fn(a[i], i?: i);

fn reverse !T(mut ref a: T[..])
{
    let n1 = a.len - 1;
    let n2 = a.len >> 1;
    for (mut i = 0; i < n2; i++)
        a.swap(i, n1 - i);
}

fn all !T(a: T[..], pred)
{
    a.each: |item, i|
        if !(pred(item, i?: i))
            return false;

    return true;
}

fn some !T(a: T[..], pred)
{
    a.each: |item, i|
        if (pred(item, i?: i))
            return true;

    return false;
}

`;


//

import module;
import context;

pub fn solvePrelude(): Context
{
    let fname   = "prelude";

    // In order to keep the prelude around,
    //  I"m thinking we"ll just prep a ready-to-copy template,
    //   with prelude solved at modid 0.
    let implicit mut ctx: Context;
    let implicit mut module = getModule(fname).helpers::clone();

    let implicit options: options::Options;

    let src     = PRELUDE_SRC;
    let lex     = lexer::lex(:src, :fname);
    let parse   = parser::parse(modid: 0, :fname, :src, :lex.tokens);

    module.in   = ModuleInputs(:src, :lex, :parse);

    setModule(module);
    module.out.solve = solver::solve();
    setModule(module);

    ctx.fudir   = fudir::FU_ROOT;

    return ctx;
}

pub let CTX_PRELUDE = solvePrelude();
