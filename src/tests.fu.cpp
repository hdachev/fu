#include <cstdint>
#include <fu/int.h>
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/defer.h>
#include <fu/never.h>
#include <fu/vec/LEGACY_find.h>
#include <fu/vec/LEGACY_slice.h>
#include <par/parfor.hpp>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>

struct s_TestDiffs;
struct s_TestResult;
struct s_Options;
struct s_Lint;
typedef int s_SolverNotes;
typedef fu::u8 s_CGDefects;
typedef fu::u8 s_DevOptions;
struct s_Context;
struct s_Module;
struct s_ModuleInputs;
struct s_LexerOutput;
struct s_Token;
enum s_kind: fu::u8;
struct s_LineColChars;
struct s_ParserOutput;
struct s_Node;
typedef uint16_t s_DeclAsserts;
typedef fu::u8 s_ParseSyntax;
typedef unsigned s_Flags;
struct s_TokenIdx;
struct s_Import;
struct s_ModuleOrder;
struct s_ModuleOutputs;
struct s_Struct;
struct s_Target;
struct s_ScopeItem;
struct s_Shape;
struct s_SolverOutput;
struct s_SolvedNode;
struct s_Helpers;
struct s_Type;
struct s_ValueType;
struct s_Lifetime;
typedef fu::u8 s_VFacts;
struct s_Scope;
struct s_Overload;
typedef uint16_t s_SolverStatus;
struct s_Extended;
struct s_Argument;
struct s_BitSet;
struct s_COWInside;
typedef fu::u8 s_ExitPaths;
struct s_Template;
struct s_TEA;
typedef uint16_t s_FxMask;
struct s_CodegenOutput;
struct s_ModuleStats;
struct s_ModuleStat;
struct s_Profile;
struct s_Map_iIYL7rECCBg;
fu::str serialize_pma6HIQy(const s_TestDiffs&);
int write_t5NVzxJy(fu::str&&, fu::view<char>, unsigned);
s_Context ZERO_nyNhVYvN(fu::vec<fu::str>&&, s_Options&&, s_TestDiffs&);
void append_JNUBnj3w(s_TestDiffs&, const s_TestDiffs&);
void TODO_wUYWWjRs(const fu::vec<fu::str>&, const fu::str&, s_TestDiffs&);
void TODO_bvxMZmIw(const fu::str&, const fu::str&, s_TestDiffs&);
void ZERO_SAME_oJfgtjf4(fu::view<fu::str>, s_TestDiffs&);

                                #ifndef DEF_s_TestDiffs
                                #define DEF_s_TestDiffs
struct s_TestDiffs
{
    fu::vec<fu::str> keys;
    fu::vec<fu::str> vals;
    explicit operator bool() const noexcept
    {
        return false
            || keys
            || vals
        ;
    }
};
                                #endif

                                #ifndef DEF_s_TestResult
                                #define DEF_s_TestResult
struct s_TestResult
{
    fu::str error;
    s_TestDiffs testdiffs;
    explicit operator bool() const noexcept
    {
        return false
            || error
            || testdiffs
        ;
    }
};
                                #endif

                                #ifndef DEF_s_SolverNotes
                                #define DEF_s_SolverNotes
inline constexpr s_SolverNotes s_SolverNotes_N_FnRecursion = 1;
inline constexpr s_SolverNotes s_SolverNotes_N_FnResolve = 2;
inline constexpr s_SolverNotes s_SolverNotes_N_FnReopen = 4;
inline constexpr s_SolverNotes s_SolverNotes_N_TypeRecursion = 8;
inline constexpr s_SolverNotes s_SolverNotes_N_TypeResolve = 16;
inline constexpr s_SolverNotes s_SolverNotes_N_TypeReopen = 32;
inline constexpr s_SolverNotes s_SolverNotes_N_DeadCode = 64;
inline constexpr s_SolverNotes s_SolverNotes_N_DeadCall = 128;
inline constexpr s_SolverNotes s_SolverNotes_N_DeadLet = 256;
inline constexpr s_SolverNotes s_SolverNotes_N_DeadArrlit = 512;
inline constexpr s_SolverNotes s_SolverNotes_N_DeadLoopInit = 1024;
inline constexpr s_SolverNotes s_SolverNotes_N_DeadConv = 2048;
inline constexpr s_SolverNotes s_SolverNotes_N_NonTrivAutoCopy = 4096;
inline constexpr s_SolverNotes s_SolverNotes_N_RelaxRespec = 8192;
inline constexpr s_SolverNotes s_SolverNotes_N_UnusedImplicit = 16384;
inline constexpr s_SolverNotes s_SolverNotes_N_UnusedCall = 32768;
inline constexpr s_SolverNotes s_SolverNotes_N_UnusedDefer = 65536;
inline constexpr s_SolverNotes s_SolverNotes_N_UnusedTry = 131072;
inline constexpr s_SolverNotes s_SolverNotes_N_UnusedAndOr = 262144;
inline constexpr s_SolverNotes s_SolverNotes_N_UnusedIfElse = 524288;
inline constexpr s_SolverNotes s_SolverNotes_N_UnusedArrlit = 1048576;
inline constexpr s_SolverNotes s_SolverNotes_N_UnusedLet = 2097152;
inline constexpr s_SolverNotes s_SolverNotes_N_BckMustSeq = 4194304;
inline constexpr s_SolverNotes s_SolverNotes_N_AARMustSeq = 8388608;
inline constexpr s_SolverNotes s_SolverNotes_N_AARSoftRisk = 16777216;
inline constexpr s_SolverNotes s_SolverNotes_N_MoveMustSeq = 33554432;
inline constexpr s_SolverNotes s_SolverNotes_N_SD_HasStaticInit = 67108864;
inline constexpr s_SolverNotes s_SolverNotes_N_SD_ExternPrivates = 134217728;
inline constexpr s_SolverNotes s_SolverNotes_N_COWRestrict = 268435456;

inline constexpr s_SolverNotes MASK_s_SolverNotes
    = s_SolverNotes_N_FnRecursion
    | s_SolverNotes_N_FnResolve
    | s_SolverNotes_N_FnReopen
    | s_SolverNotes_N_TypeRecursion
    | s_SolverNotes_N_TypeResolve
    | s_SolverNotes_N_TypeReopen
    | s_SolverNotes_N_DeadCode
    | s_SolverNotes_N_DeadCall
    | s_SolverNotes_N_DeadLet
    | s_SolverNotes_N_DeadArrlit
    | s_SolverNotes_N_DeadLoopInit
    | s_SolverNotes_N_DeadConv
    | s_SolverNotes_N_NonTrivAutoCopy
    | s_SolverNotes_N_RelaxRespec
    | s_SolverNotes_N_UnusedImplicit
    | s_SolverNotes_N_UnusedCall
    | s_SolverNotes_N_UnusedDefer
    | s_SolverNotes_N_UnusedTry
    | s_SolverNotes_N_UnusedAndOr
    | s_SolverNotes_N_UnusedIfElse
    | s_SolverNotes_N_UnusedArrlit
    | s_SolverNotes_N_UnusedLet
    | s_SolverNotes_N_BckMustSeq
    | s_SolverNotes_N_AARMustSeq
    | s_SolverNotes_N_AARSoftRisk
    | s_SolverNotes_N_MoveMustSeq
    | s_SolverNotes_N_SD_HasStaticInit
    | s_SolverNotes_N_SD_ExternPrivates
    | s_SolverNotes_N_COWRestrict;
                                #endif

                                #ifndef DEF_s_CGDefects
                                #define DEF_s_CGDefects
inline constexpr s_CGDefects s_CGDefects_GNUStmtExpr = s_CGDefects(1u);
inline constexpr s_CGDefects s_CGDefects_Goto = s_CGDefects(2u);
inline constexpr s_CGDefects s_CGDefects_PointlessMustSeq = s_CGDefects(4u);
inline constexpr s_CGDefects s_CGDefects_LocalConstBool = s_CGDefects(8u);
inline constexpr s_CGDefects s_CGDefects_ConstCast = s_CGDefects(16u);
inline constexpr s_CGDefects s_CGDefects_PointlessLocal = s_CGDefects(32u);
inline constexpr s_CGDefects s_CGDefects_IrrelevantLiteral = s_CGDefects(64u);
inline constexpr s_CGDefects s_CGDefects_DuplicateFunctions = s_CGDefects(128u);

inline constexpr s_CGDefects MASK_s_CGDefects
    = s_CGDefects_GNUStmtExpr
    | s_CGDefects_Goto
    | s_CGDefects_PointlessMustSeq
    | s_CGDefects_LocalConstBool
    | s_CGDefects_ConstCast
    | s_CGDefects_PointlessLocal
    | s_CGDefects_IrrelevantLiteral
    | s_CGDefects_DuplicateFunctions;
                                #endif

                                #ifndef DEF_s_DevOptions
                                #define DEF_s_DevOptions
inline constexpr s_DevOptions s_DevOptions_DEV_Print = s_DevOptions(1u);
inline constexpr s_DevOptions s_DevOptions_DEV_Parallel = s_DevOptions(2u);
inline constexpr s_DevOptions s_DevOptions_DEV_ExpectFail = s_DevOptions(4u);
inline constexpr s_DevOptions s_DevOptions_DEV_DontFoldLiterals = s_DevOptions(8u);
inline constexpr s_DevOptions s_DevOptions_DEV_CG_LifetimeAnnots = s_DevOptions(16u);

inline constexpr s_DevOptions MASK_s_DevOptions
    = s_DevOptions_DEV_Print
    | s_DevOptions_DEV_Parallel
    | s_DevOptions_DEV_ExpectFail
    | s_DevOptions_DEV_DontFoldLiterals
    | s_DevOptions_DEV_CG_LifetimeAnnots;
                                #endif

                                #ifndef DEF_s_Lint
                                #define DEF_s_Lint
struct s_Lint
{
    int maxwarn;
    explicit operator bool() const noexcept
    {
        return false
            || maxwarn
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Options
                                #define DEF_s_Options
struct s_Options
{
    s_Lint lint;
    s_SolverNotes break_notes;
    s_CGDefects break_defects;
    s_DevOptions dev;
    unsigned shuffle;
    explicit operator bool() const noexcept
    {
        return false
            || lint
            || break_notes
            || break_defects
            || dev
            || shuffle
        ;
    }
};
                                #endif

                                #ifndef DEF_s_kind
                                #define DEF_s_kind
enum s_kind: fu::u8
{
    s_kind_sof = 1u,
    s_kind_err = 2u,
    s_kind_eof = 3u,
    s_kind_id = 4u,
    s_kind_op = 5u,
    s_kind_int = 6u,
    s_kind_real = 7u,
    s_kind_char = 8u,
    s_kind_str = 9u,
    s_kind_bool = 10u,
    s_kind_definit = 11u,
    s_kind_empty = 12u,
    s_kind_struct = 13u,
    s_kind_union = 14u,
    s_kind_primitive = 15u,
    s_kind_flags = 16u,
    s_kind_enum = 17u,
    s_kind_fn = 18u,
    s_kind_copy = 19u,
    s_kind_move = 20u,
    s_kind_arrlit = 21u,
    s_kind_not = 22u,
    s_kind_call = 23u,
    s_kind_argid = 24u,
    s_kind_root = 25u,
    s_kind_block = 26u,
    s_kind_if = 27u,
    s_kind_or = 28u,
    s_kind_and = 29u,
    s_kind_loop = 30u,
    s_kind_jump = 31u,
    s_kind___far_jump = 32u,
    s_kind_defer = 33u,
    s_kind_try = 34u,
    s_kind_let = 35u,
    s_kind_letdef = 36u,
    s_kind_typecast = 37u,
    s_kind_typeassert = 38u,
    s_kind_typeparam = 39u,
    s_kind_unwrap = 40u,
    s_kind_pragma = 41u,
    s_kind_break = 42u,
    s_kind_return = 43u,
    s_kind_continue = 44u,
    s_kind_import = 45u,
    s_kind_addroffn = 46u,
    s_kind_forfieldsof = 47u,
    s_kind_members = 48u,
    s_kind_fnbranch = 49u,
    s_kind_pattern = 50u,
    s_kind_typeunion = 51u,
    s_kind_typetag = 52u,
    s_kind___relaxed = 53u,
    s_kind___convert = 54u,
    s_kind___preceding_ref_arg = 55u,
    s_kind___no_kind_yet = 56u,
    s_kind___tombstone = 57u,
    s_kind_type = 58u,
    s_kind_var = 59u,
    s_kind_field = 60u,
    s_kind_enumv = 61u,
    s_kind_template = 62u,
    s_kind___native = 63u,
    s_kind_inline = 64u,
};
                                #endif

                                #ifndef DEF_s_DeclAsserts
                                #define DEF_s_DeclAsserts
inline constexpr s_DeclAsserts s_DeclAsserts_A_NOCOPY = s_DeclAsserts(1u);
inline constexpr s_DeclAsserts s_DeclAsserts_A_NOVEC = s_DeclAsserts(2u);
inline constexpr s_DeclAsserts s_DeclAsserts_A_TRIVIAL = s_DeclAsserts(4u);
inline constexpr s_DeclAsserts s_DeclAsserts_A_PURE = s_DeclAsserts(8u);
inline constexpr s_DeclAsserts s_DeclAsserts_A_PURE_CTX = s_DeclAsserts(16u);
inline constexpr s_DeclAsserts s_DeclAsserts_A_PURE_FX = s_DeclAsserts(32u);
inline constexpr s_DeclAsserts s_DeclAsserts_A_NOFLOW = s_DeclAsserts(64u);
inline constexpr s_DeclAsserts s_DeclAsserts_A_NOTHROW = s_DeclAsserts(128u);
inline constexpr s_DeclAsserts s_DeclAsserts_A_NOCRASH = s_DeclAsserts(256u);
inline constexpr s_DeclAsserts s_DeclAsserts_A_NOIO = s_DeclAsserts(512u);
inline constexpr s_DeclAsserts s_DeclAsserts_A_FAST = s_DeclAsserts(1024u);
inline constexpr s_DeclAsserts s_DeclAsserts_A_NOINLINE = s_DeclAsserts(2048u);

inline constexpr s_DeclAsserts MASK_s_DeclAsserts
    = s_DeclAsserts_A_NOCOPY
    | s_DeclAsserts_A_NOVEC
    | s_DeclAsserts_A_TRIVIAL
    | s_DeclAsserts_A_PURE
    | s_DeclAsserts_A_PURE_CTX
    | s_DeclAsserts_A_PURE_FX
    | s_DeclAsserts_A_NOFLOW
    | s_DeclAsserts_A_NOTHROW
    | s_DeclAsserts_A_NOCRASH
    | s_DeclAsserts_A_NOIO
    | s_DeclAsserts_A_FAST
    | s_DeclAsserts_A_NOINLINE;
                                #endif

                                #ifndef DEF_s_ParseSyntax
                                #define DEF_s_ParseSyntax
inline constexpr s_ParseSyntax s_ParseSyntax_PS_PARENS = s_ParseSyntax(1u);
inline constexpr s_ParseSyntax s_ParseSyntax_PS_DISCARD_IF_BLOCK_TAIL = s_ParseSyntax(2u);
inline constexpr s_ParseSyntax s_ParseSyntax_PS_ALWAYS_DISCARD = s_ParseSyntax(4u);
inline constexpr s_ParseSyntax s_ParseSyntax_PS_NOT_AN_EXPRESSION = s_ParseSyntax(8u);

inline constexpr s_ParseSyntax MASK_s_ParseSyntax
    = s_ParseSyntax_PS_PARENS
    | s_ParseSyntax_PS_DISCARD_IF_BLOCK_TAIL
    | s_ParseSyntax_PS_ALWAYS_DISCARD
    | s_ParseSyntax_PS_NOT_AN_EXPRESSION;
                                #endif

                                #ifndef DEF_s_Flags
                                #define DEF_s_Flags
inline constexpr s_Flags s_Flags_F_CALL_HAS_DOT = 1u;
inline constexpr s_Flags s_Flags_F_CALL_HAS_ARGPARENS = 2u;
inline constexpr s_Flags s_Flags_F_CALL_HAS_NAMED_ARGS = 4u;
inline constexpr s_Flags s_Flags_F_OPERATOR = 8u;
inline constexpr s_Flags s_Flags_F_TYPENAME = 16u;
inline constexpr s_Flags s_Flags_F_COMPOUND_ID = 32u;
inline constexpr s_Flags s_Flags_F_ARGID_IS_OPTIONAL = 64u;
inline constexpr s_Flags s_Flags_F_LAX = 128u;
inline constexpr s_Flags s_Flags_F_SHADOW = 256u;
inline constexpr s_Flags s_Flags_F_MUSTNAME = 512u;
inline constexpr s_Flags s_Flags_F_WRITTEN_TO = 1024u;
inline constexpr s_Flags s_Flags_F_MUT = 2048u;
inline constexpr s_Flags s_Flags_F_CONST = 4096u;
inline constexpr s_Flags s_Flags_F_VAL = 8192u;
inline constexpr s_Flags s_Flags_F_REF = 16384u;
inline constexpr s_Flags s_Flags_F_IMPLICIT = 32768u;
inline constexpr s_Flags s_Flags_F_USING = 65536u;
inline constexpr s_Flags s_Flags_F_CONVERSION = 131072u;
inline constexpr s_Flags s_Flags_F_PUB = 262144u;
inline constexpr s_Flags s_Flags_F_EXTERN = 524288u;
inline constexpr s_Flags s_Flags_F_HOTSWAP = 1048576u;
inline constexpr s_Flags s_Flags_F_PREDICATE = 2097152u;
inline constexpr s_Flags s_Flags_F_REST_ARG = 4194304u;
inline constexpr s_Flags s_Flags_F_INJECTED = 8388608u;
inline constexpr s_Flags s_Flags_F_TEMPLATE = 16777216u;
inline constexpr s_Flags s_Flags_F_INLINE = 33554432u;
inline constexpr s_Flags s_Flags_F_LAMBDA = 67108864u;
inline constexpr s_Flags s_Flags_F_COW_INSIDE = 134217728u;

inline constexpr s_Flags MASK_s_Flags
    = s_Flags_F_CALL_HAS_DOT
    | s_Flags_F_CALL_HAS_ARGPARENS
    | s_Flags_F_CALL_HAS_NAMED_ARGS
    | s_Flags_F_OPERATOR
    | s_Flags_F_TYPENAME
    | s_Flags_F_COMPOUND_ID
    | s_Flags_F_ARGID_IS_OPTIONAL
    | s_Flags_F_LAX
    | s_Flags_F_SHADOW
    | s_Flags_F_MUSTNAME
    | s_Flags_F_WRITTEN_TO
    | s_Flags_F_MUT
    | s_Flags_F_CONST
    | s_Flags_F_VAL
    | s_Flags_F_REF
    | s_Flags_F_IMPLICIT
    | s_Flags_F_USING
    | s_Flags_F_CONVERSION
    | s_Flags_F_PUB
    | s_Flags_F_EXTERN
    | s_Flags_F_HOTSWAP
    | s_Flags_F_PREDICATE
    | s_Flags_F_REST_ARG
    | s_Flags_F_INJECTED
    | s_Flags_F_TEMPLATE
    | s_Flags_F_INLINE
    | s_Flags_F_LAMBDA
    | s_Flags_F_COW_INSIDE;
                                #endif

                                #ifndef DEF_s_VFacts
                                #define DEF_s_VFacts
inline constexpr s_VFacts s_VFacts_AlwaysTrue = s_VFacts(1u);
inline constexpr s_VFacts s_VFacts_AlwaysFalse = s_VFacts(2u);
inline constexpr s_VFacts s_VFacts_Typename = s_VFacts(4u);

inline constexpr s_VFacts MASK_s_VFacts
    = s_VFacts_AlwaysTrue
    | s_VFacts_AlwaysFalse
    | s_VFacts_Typename;
                                #endif

                                #ifndef DEF_s_SolverStatus
                                #define DEF_s_SolverStatus
inline constexpr s_SolverStatus s_SolverStatus_SS_LAZY = s_SolverStatus(1u);
inline constexpr s_SolverStatus s_SolverStatus_SS_DID_START = s_SolverStatus(2u);
inline constexpr s_SolverStatus s_SolverStatus_SS_DIRTY = s_SolverStatus(4u);
inline constexpr s_SolverStatus s_SolverStatus_SS_FINALIZED = s_SolverStatus(8u);
inline constexpr s_SolverStatus s_SolverStatus_SS_UPDATED = s_SolverStatus(16u);
inline constexpr s_SolverStatus s_SolverStatus_SS_TYPE_RECUR = s_SolverStatus(32u);
inline constexpr s_SolverStatus s_SolverStatus_SS_FN_RECUR = s_SolverStatus(64u);
inline constexpr s_SolverStatus s_SolverStatus_SS_FN_OOE_RTL = s_SolverStatus(128u);
inline constexpr s_SolverStatus s_SolverStatus_SS_HOIST = s_SolverStatus(256u);
inline constexpr s_SolverStatus s_SolverStatus_SS_UNUSED = s_SolverStatus(512u);
inline constexpr s_SolverStatus s_SolverStatus_SS_MATCHED = s_SolverStatus(1024u);
inline constexpr s_SolverStatus s_SolverStatus_SS_MOVED_FROM = s_SolverStatus(2048u);
inline constexpr s_SolverStatus s_SolverStatus_SS_ARGUMENT = s_SolverStatus(4096u);
inline constexpr s_SolverStatus s_SolverStatus_SS_Debug_AllPassesComplete = s_SolverStatus(8192u);

inline constexpr s_SolverStatus MASK_s_SolverStatus
    = s_SolverStatus_SS_LAZY
    | s_SolverStatus_SS_DID_START
    | s_SolverStatus_SS_DIRTY
    | s_SolverStatus_SS_FINALIZED
    | s_SolverStatus_SS_UPDATED
    | s_SolverStatus_SS_TYPE_RECUR
    | s_SolverStatus_SS_FN_RECUR
    | s_SolverStatus_SS_FN_OOE_RTL
    | s_SolverStatus_SS_HOIST
    | s_SolverStatus_SS_UNUSED
    | s_SolverStatus_SS_MATCHED
    | s_SolverStatus_SS_MOVED_FROM
    | s_SolverStatus_SS_ARGUMENT
    | s_SolverStatus_SS_Debug_AllPassesComplete;
                                #endif

                                #ifndef DEF_s_ExitPaths
                                #define DEF_s_ExitPaths
inline constexpr s_ExitPaths s_ExitPaths_XP_NonEmptyReturn = s_ExitPaths(1u);
inline constexpr s_ExitPaths s_ExitPaths_XP_EmptyReturn = s_ExitPaths(2u);
inline constexpr s_ExitPaths s_ExitPaths_XP_NoReturn = s_ExitPaths(4u);

inline constexpr s_ExitPaths MASK_s_ExitPaths
    = s_ExitPaths_XP_NonEmptyReturn
    | s_ExitPaths_XP_EmptyReturn
    | s_ExitPaths_XP_NoReturn;
                                #endif

                                #ifndef DEF_s_FxMask
                                #define DEF_s_FxMask
inline constexpr s_FxMask s_FxMask_Fx_NotDeadCode = s_FxMask(1u);
inline constexpr s_FxMask s_FxMask_Fx_NonDeterministic = s_FxMask(2u);
inline constexpr s_FxMask s_FxMask_Fx_DontMoveUp = s_FxMask(4u);
inline constexpr s_FxMask s_FxMask_Fx_DontMoveDown = s_FxMask(8u);
inline constexpr s_FxMask s_FxMask_Fx_Input = s_FxMask(16u);
inline constexpr s_FxMask s_FxMask_Fx_Output = s_FxMask(32u);
inline constexpr s_FxMask s_FxMask_Fx_Throws = s_FxMask(64u);
inline constexpr s_FxMask s_FxMask_Fx_Crashes = s_FxMask(128u);
inline constexpr s_FxMask s_FxMask_Fx_Crashes_Div0 = s_FxMask(256u);
inline constexpr s_FxMask s_FxMask_Fx_Crashes_OOB = s_FxMask(512u);
inline constexpr s_FxMask s_FxMask_Fx_Crashes_Assert = s_FxMask(1024u);
inline constexpr s_FxMask s_FxMask_Fx_Crashes_Exit = s_FxMask(2048u);
inline constexpr s_FxMask s_FxMask_Fx_Syscall = s_FxMask(4096u);
inline constexpr s_FxMask s_FxMask_Fx_Blocks = s_FxMask(8192u);
inline constexpr s_FxMask s_FxMask_Fx_Blocks_Alloc = s_FxMask(16384u);
inline constexpr s_FxMask s_FxMask_Fx_Blocks_Await = s_FxMask(32768u);

inline constexpr s_FxMask MASK_s_FxMask
    = s_FxMask_Fx_NotDeadCode
    | s_FxMask_Fx_NonDeterministic
    | s_FxMask_Fx_DontMoveUp
    | s_FxMask_Fx_DontMoveDown
    | s_FxMask_Fx_Input
    | s_FxMask_Fx_Output
    | s_FxMask_Fx_Throws
    | s_FxMask_Fx_Crashes
    | s_FxMask_Fx_Crashes_Div0
    | s_FxMask_Fx_Crashes_OOB
    | s_FxMask_Fx_Crashes_Assert
    | s_FxMask_Fx_Crashes_Exit
    | s_FxMask_Fx_Syscall
    | s_FxMask_Fx_Blocks
    | s_FxMask_Fx_Blocks_Alloc
    | s_FxMask_Fx_Blocks_Await;
                                #endif

                                #ifndef DEF_s_Helpers
                                #define DEF_s_Helpers
struct s_Helpers
{
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Target
                                #define DEF_s_Target
struct s_Target
{
    uint64_t _packed;
    explicit operator bool() const noexcept
    {
        return false
            || _packed
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Lifetime
                                #define DEF_s_Lifetime
struct s_Lifetime
{
    fu::str uni0n;
    explicit operator bool() const noexcept
    {
        return false
            || uni0n
        ;
    }
};
                                #endif

                                #ifndef DEF_s_BitSet
                                #define DEF_s_BitSet
struct s_BitSet
{
    fu::vec<fu::u8> _data;
    explicit operator bool() const noexcept
    {
        return false
            || _data
        ;
    }
};
                                #endif

                                #ifndef DEF_s_ModuleOrder
                                #define DEF_s_ModuleOrder
struct s_ModuleOrder
{
    int dep_depth;
    explicit operator bool() const noexcept
    {
        return false
            || dep_depth
        ;
    }
};
                                #endif

                                #ifndef DEF_s_TEA
                                #define DEF_s_TEA
struct s_TEA
{
    unsigned v0;
    unsigned v1;
    explicit operator bool() const noexcept
    {
        return false
            || v0
            || v1
        ;
    }
};
                                #endif

                                #ifndef DEF_s_ScopeItem
                                #define DEF_s_ScopeItem
struct s_ScopeItem
{
    fu::str id;
    uint64_t _packed;
    explicit operator bool() const noexcept
    {
        return false
            || id
        ;
    }
};
                                #endif

                                #ifndef DEF_s_LexerOutput
                                #define DEF_s_LexerOutput
struct s_LexerOutput
{
    fu::vec<s_Token> tokens;
    explicit operator bool() const noexcept
    {
        return false
            || tokens
        ;
    }
};
                                #endif

                                #ifndef DEF_s_TokenIdx
                                #define DEF_s_TokenIdx
struct s_TokenIdx
{
    int modid;
    int tokidx;
    explicit operator bool() const noexcept
    {
        return false
            || modid
            || tokidx
        ;
    }
};
                                #endif

                                #ifndef DEF_s_ValueType
                                #define DEF_s_ValueType
struct s_ValueType
{
    unsigned quals;
    fu::str canon;
    explicit operator bool() const noexcept
    {
        return false
            || quals
            || canon
        ;
    }
};
                                #endif

                                #ifndef DEF_s_LineColChars
                                #define DEF_s_LineColChars
struct s_LineColChars
{
    int line;
    int col;
    int chars;
    explicit operator bool() const noexcept
    {
        return false
            || line
            || col
            || chars
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Map_iIYL7rECCBg
                                #define DEF_s_Map_iIYL7rECCBg
struct s_Map_iIYL7rECCBg
{
    fu::vec<fu::str> keys;
    fu::vec<fu::str> vals;
    explicit operator bool() const noexcept
    {
        return false
            || keys
            || vals
        ;
    }
};
                                #endif

                                #ifndef DEF_s_ModuleStat
                                #define DEF_s_ModuleStat
struct s_ModuleStat
{
    double time;
    int alloc_count;
    int alloc_bytes;
    explicit operator bool() const noexcept
    {
        return false
            || time
            || alloc_count
            || alloc_bytes
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Shape
                                #define DEF_s_Shape
struct s_Shape
{
    fu::str basePrim;
    uint64_t non_triv_mask;
    uint64_t hash;
    int flatCount;
    int declDepth;
    explicit operator bool() const noexcept
    {
        return false
            || basePrim
            || non_triv_mask
            || hash
            || flatCount
            || declDepth
        ;
    }
};
                                #endif

                                #ifndef DEF_s_CodegenOutput
                                #define DEF_s_CodegenOutput
struct s_CodegenOutput
{
    fu::str src;
    fu::vec<fu::str> link;
    fu::vec<fu::str> include_dirs;
    fu::vec<fu::str> extra_sources;
    fu::vec<int> live;
    s_CGDefects defects;
    explicit operator bool() const noexcept
    {
        return false
            || src
            || link
            || include_dirs
            || extra_sources
            || live
            || defects
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Scope
                                #define DEF_s_Scope
struct s_Scope
{
    fu::vec<s_Overload> overloads;
    fu::vec<s_Extended> extended;
    fu::vec<s_ScopeItem> items;
    fu::vec<s_ScopeItem> implicits;
    fu::vec<int> imports;
    fu::vec<int> privates;
    fu::vec<s_Target> usings;
    fu::vec<s_Target> converts;
    int pub_items;
    int pub_implicits;
    int pub_converts;
    s_Scope(const s_Scope&) = delete;
    s_Scope(s_Scope&&) = default;
    s_Scope& operator=(const s_Scope&) = delete;
    s_Scope& operator=(s_Scope&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || overloads
            || extended
            || items
            || implicits
            || imports
            || privates
            || usings
            || converts
            || pub_items
            || pub_implicits
            || pub_converts
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Token
                                #define DEF_s_Token
struct s_Token
{
    s_kind kind;
    s_LineColChars lcc;
    fu::str value;
    explicit operator bool() const noexcept
    {
        return false
            || kind
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Import
                                #define DEF_s_Import
struct s_Import
{
    s_TokenIdx token;
    fu::str value;
    explicit operator bool() const noexcept
    {
        return false
            || token
            || value
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Type
                                #define DEF_s_Type
struct s_Type
{
    s_ValueType vtype;
    s_Lifetime lifetime;
    s_VFacts vfacts;
    explicit operator bool() const noexcept
    {
        return false
            || vtype
            || lifetime
            || vfacts
        ;
    }
};
                                #endif

                                #ifndef DEF_s_ModuleStats
                                #define DEF_s_ModuleStats
struct s_ModuleStats
{
    s_ModuleStat lex;
    s_ModuleStat parse;
    s_ModuleStat solve;
    s_ModuleStat codegen;
    explicit operator bool() const noexcept
    {
        return false
            || lex
            || parse
            || solve
            || codegen
        ;
    }
};
                                #endif

                                #ifndef DEF_s_COWInside
                                #define DEF_s_COWInside
struct s_COWInside
{
    s_ValueType vtype;
    s_TokenIdx token;
    int argTarget;
    int mayEscapeVia;
    s_ExitPaths exitPaths;
    explicit operator bool() const noexcept
    {
        return false
            || vtype
            || token
            || argTarget
            || mayEscapeVia
            || exitPaths
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Struct
                                #define DEF_s_Struct
struct s_Struct
{
    s_kind kind;
    fu::str name;
    s_Target target;
    fu::vec<s_ScopeItem> items;
    fu::vec<int> imports;
    fu::vec<s_Target> converts;
    s_Shape shape;
    explicit operator bool() const noexcept
    {
        return false
            || kind
            || name
            || target
            || items
            || imports
            || converts
            || shape
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    s_kind kind;
    s_DeclAsserts asserts;
    s_ParseSyntax syntax;
    s_Flags flags;
    fu::str value;
    fu::vec<s_Node> items;
    s_TokenIdx token;
    s_Node(const s_Node&) = default;
    s_Node(s_Node&&) = default;
    s_Node& operator=(s_Node&&) = default;
    s_Node& operator=(const s_Node& selfrec) { return *this = s_Node(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || kind
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Context
                                #define DEF_s_Context
struct s_Context
{
    fu::str base_dir;
    fu::vec<s_Module> modules;
    fu::vec<int> dep_order;
    s_Map_iIYL7rECCBg files;
    s_Map_iIYL7rECCBg fuzzy;
    s_Context(const s_Context&) = delete;
    s_Context(s_Context&&) = default;
    s_Context& operator=(const s_Context&) = delete;
    s_Context& operator=(s_Context&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || base_dir
            || modules
            || dep_order
            || files
            || fuzzy
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Profile
                                #define DEF_s_Profile
struct s_Profile
{
    double now;
    explicit operator bool() const noexcept
    {
        return false
            || now
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Template
                                #define DEF_s_Template
struct s_Template
{
    s_Node node;
    fu::vec<int> imports;
    explicit operator bool() const noexcept
    {
        return false
            || node
        ;
    }
};
                                #endif

                                #ifndef DEF_s_ParserOutput
                                #define DEF_s_ParserOutput
struct s_ParserOutput
{
    s_Node root;
    fu::vec<s_Import> imports;
    fu::vec<fu::str> warnings;
    explicit operator bool() const noexcept
    {
        return false
            || root
            || imports
            || warnings
        ;
    }
};
                                #endif

                                #ifndef DEF_s_SolvedNode
                                #define DEF_s_SolvedNode
struct s_SolvedNode
{
    s_kind kind;
    s_Helpers helpers;
    s_Flags flags;
    int _loop_start;
    fu::str value;
    fu::vec<s_SolvedNode> items;
    s_TokenIdx token;
    s_Type type;
    s_Target target;
    s_SolvedNode(const s_SolvedNode&) = default;
    s_SolvedNode(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(const s_SolvedNode& selfrec) { return *this = s_SolvedNode(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || kind
        ;
    }
};
                                #endif

                                #ifndef DEF_s_ModuleInputs
                                #define DEF_s_ModuleInputs
struct s_ModuleInputs
{
    fu::str src;
    s_LexerOutput lex;
    s_ParserOutput parse;
    explicit operator bool() const noexcept
    {
        return false
            || src
            || lex
            || parse
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Overload
                                #define DEF_s_Overload
struct s_Overload
{
    s_kind kind;
    s_Flags flags;
    s_SolverStatus status;
    fu::str name;
    s_Type type;
    s_SolvedNode solved;
    explicit operator bool() const noexcept
    {
        return false
            || kind
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Extended
                                #define DEF_s_Extended
struct s_Extended
{
    int min;
    int max;
    fu::vec<s_Argument> args;
    fu::vec<s_COWInside> cows_inside;
    s_Target spec_of;
    s_Template tEmplate;
    fu::vec<s_Overload> locals;
    s_TEA sighash;
    s_FxMask fx_mask;
    explicit operator bool() const noexcept
    {
        return false
            || tEmplate
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Argument
                                #define DEF_s_Argument
struct s_Argument
{
    fu::str name;
    fu::str autocall;
    s_Type type;
    s_SolvedNode dEfault;
    s_Flags flags;
    s_Target target;
    s_BitSet may_invalidate;
    s_BitSet may_alias;
    explicit operator bool() const noexcept
    {
        return false
            || name
            || autocall
            || type
            || dEfault
            || flags
            || target
            || may_invalidate
            || may_alias
        ;
    }
};
                                #endif

                                #ifndef DEF_s_SolverOutput
                                #define DEF_s_SolverOutput
struct s_SolverOutput
{
    s_SolvedNode root;
    s_Scope scope;
    s_SolverNotes notes;
    s_SolverOutput(const s_SolverOutput&) = delete;
    s_SolverOutput(s_SolverOutput&&) = default;
    s_SolverOutput& operator=(const s_SolverOutput&) = delete;
    s_SolverOutput& operator=(s_SolverOutput&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || root
            || scope
            || notes
        ;
    }
};
                                #endif

                                #ifndef DEF_s_ModuleOutputs
                                #define DEF_s_ModuleOutputs
struct s_ModuleOutputs
{
    fu::vec<s_Struct> types;
    s_SolverOutput solve;
    s_CodegenOutput cpp;
    s_ModuleOutputs(const s_ModuleOutputs&) = delete;
    s_ModuleOutputs(s_ModuleOutputs&&) = default;
    s_ModuleOutputs& operator=(const s_ModuleOutputs&) = delete;
    s_ModuleOutputs& operator=(s_ModuleOutputs&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || types
            || solve
            || cpp
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Module
                                #define DEF_s_Module
struct s_Module
{
    int modid;
    fu::str fname;
    s_ModuleInputs in;
    s_ModuleOrder order;
    s_ModuleOutputs out;
    s_ModuleStats stats;
    s_Profile profile;
    s_Module(const s_Module&) = delete;
    s_Module(s_Module&&) = default;
    s_Module& operator=(const s_Module&) = delete;
    s_Module& operator=(s_Module&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || modid
            || fname
            || in
            || order
            || out
            || stats
            || profile
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_FUDIR
                                #define DEF_FUDIR
extern const fu::str FUDIR;
                                #endif

                                #ifndef DEF_RW_RW_RW
                                #define DEF_RW_RW_RW
inline constexpr unsigned RW_RW_RW = (((0x6u << 6u) | (0x6u << 3u)) | (0x6u << 0u));
                                #endif

inline static s_TestResult l_50_0_NIWNSdZP(const fu::vec<fu::str>& test)
{
    /*MOV*/ fu::str error {};
    /*MOV*/ s_TestDiffs testdiffs {};
    const s_Options options = s_Options { s_Lint{}, s_SolverNotes{}, s_CGDefects{}, s_DevOptions_DEV_Parallel, 0u };

    try
    {
    {
        ZERO_nyNhVYvN(fu::vec<fu::str>(test), s_Options(options), testdiffs);
    }
    }
    catch (const std::exception& o_0)
    {
        fu::str e = fu::to_str(o_0.what());

        error = static_cast<fu::str&&>(e);
    }
;
    return s_TestResult { static_cast<fu::str&&>(error), static_cast<s_TestDiffs&&>(testdiffs) };
}

inline static s_TestResult& l_41_2_LQQhCeVk(const int i, fu::view<fu::vec<fu::str>> arr, fu::view_mut<s_TestResult> result)
{
    return (result.mutref(i) = l_50_0_NIWNSdZP(arr[i]));
}

inline static void parallel_for_kjNnHdwt(const int min, int end, fu::view<fu::vec<fu::str>> arr, fu::view_mut<s_TestResult> result)
{
    int start = (end & 0);
    (void) start;

    typedef decltype(start) start_t;
    typedef decltype(end) end_t;

    fu::parallel_for(size_t(end), size_t(min > 1 ? min : 1), [&](size_t Start, size_t End)
    {
        auto start = (start_t) Start;
        auto end   = (end_t  ) End;

    for (int i = start; i < end; i++)
        l_41_2_LQQhCeVk(i, arr, result);

    });

}

                                #ifndef DEF_map_mfgL1tSZdg9
                                #define DEF_map_mfgL1tSZdg9
inline fu::vec<s_TestResult> map_mfgL1tSZ(fu::view<fu::vec<fu::str>> arr, const int min)
{
    /*MOV*/ fu::vec<s_TestResult> result {};
    result.grow<false>(arr.size());
    parallel_for_kjNnHdwt(min, arr.size(), arr, result);
    return /*NRVO*/ result;
}
                                #endif

static fu::vec<fu::vec<fu::str>>& PARZERO_EiSsO8S1(const fu::str& src, fu::vec<fu::vec<fu::str>>& PARZERO_queue)
{
    return (PARZERO_queue += fu::vec<fu::str> { fu::slate<1, fu::str> { fu::str(src) } });
}

static fu::vec<fu::vec<fu::str>>& PARZERO_ELAwpNeF(const fu::vec<fu::str>& src, fu::vec<fu::vec<fu::str>>& PARZERO_queue)
{
    return (PARZERO_queue += fu::vec<fu::str>(src));
}

                                #ifndef DEF_replace_t9kb9bFxF28
                                #define DEF_replace_t9kb9bFxF28
inline fu::str replace_t9kb9bFx(const fu::str& str, fu::view<char> all, fu::view<char> with)
{
    /*MOV*/ fu::str result {};

    {
        int last = 0;
        int next = 0;
        const int N = all.size();
        if (N)
        {
            while (((next = fu::lfind(str, all, last)) >= 0))
            {

                {
                    fu::str substr = fu::slice(str, last, next);
                    const bool first = !last;
                    if (!first)
                        result += with;

                    result += substr;
                };
                last = (next + N);
            };
        };
        if (last)
        {
            fu::str substr = fu::slice(str, last);
            result += with;
            result += substr;
        }
        else
            return fu::str(str);

    };
    return /*NRVO*/ result;
}
                                #endif

static fu::str EXPR_YjV92WOu(fu::view<char> varname, const fu::str& assertion)
{
    return replace_t9kb9bFx(assertion, "@"_fu, varname);
}

static void ARROPS_fPM0yqMu(fu::view<char> literal, fu::view<char> operation, fu::str&& assertion, fu::vec<fu::vec<fu::str>>& PARZERO_queue)
{
    assertion = (("("_fu + assertion) + ")"_fu);
    fu::str src {};
    src += "\n"_fu;
    src += "\n    {"_fu;
    src += (("\n        mut arr0 = ["_fu + literal) + "];"_fu);
    src += (("\n        arr0."_fu + operation) + ";"_fu);
    src += (("\n        if ("_fu + EXPR_YjV92WOu("arr0"_fu, assertion)) + " != 0) return 13;"_fu);
    src += "\n    }"_fu;
    src += "\n"_fu;
    src += (("\n    mut orig = ["_fu + literal) + "];"_fu);
    src += "\n"_fu;
    src += "\n    {"_fu;
    src += "\n        mut arr1 = orig;"_fu;
    src += (("\n        arr1."_fu + operation) + ";"_fu);
    src += (("\n        if ("_fu + EXPR_YjV92WOu("arr1"_fu, assertion)) + " != 0) return 17;"_fu);
    src += "\n    }"_fu;
    src += "\n"_fu;
    src += "\n    {"_fu;
    src += "\n        ref arr2 = orig;"_fu;
    src += "\n        if (arr2.len != 5) return 38;"_fu;
    src += (("\n        arr2."_fu + operation) + ";"_fu);
    src += (("\n        if ("_fu + EXPR_YjV92WOu("arr2"_fu, assertion)) + " != 0) return 23;"_fu);
    src += "\n    }"_fu;
    src += "\n"_fu;
    src += "\n    return 0;"_fu;
    src += "\n"_fu;
    PARZERO_EiSsO8S1(src, PARZERO_queue);
}

void runTests()
{
    /*MOV*/ fu::str TESTDIFFS_FILE = (FUDIR + "testdiff/now.td"_fu);
    s_TestDiffs testdiffs = s_TestDiffs{};
    fu_DEFER_IF_OK(write_t5NVzxJy(static_cast<fu::str&&>(TESTDIFFS_FILE), serialize_pma6HIQy(testdiffs), RW_RW_RW));
    fu::vec<fu::vec<fu::str>> PARZERO_queue {};
    fu_DEFER_IF_OK(
    {
        fu::vec<s_TestResult> results = map_mfgL1tSZ(PARZERO_queue, 0);
        /*MOV*/ fu::str error {};
        for (int i = 0; i < results.size(); i++)
        {
            const s_TestResult& result = results[i];
            if (result.error)
                error += (result.error + "\n"_fu);
            else
            {
                append_JNUBnj3w(testdiffs, result.testdiffs);
            };
        };
        if (error)
            fu::fail(static_cast<fu::str&&>(error));

    });
    PARZERO_EiSsO8S1("\n        <fail return>\n        fn main(): i32 {}               <pass/>\n        fn main(): i32 { return 0; }    </fail>\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        <fail return>\n        fn test(): i32 {}               <pass/>\n        fn test(): i32 { return 0; }    </fail>\n        fn main() test();\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        return 1 - 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        return <fail COMPILER BUG or INCORRECT TESTCASE exit code 3>\n                        3 <pass/>\n                        0 </fail>\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        return 0\n        <fail COMPILER BUG or INCORRECT TESTCASE exit code>\n            || throw(\"TESTERR\")\n                 <pass/></fail>\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn sum(a: i32, b: i32): i32\n            a + b;\n\n        return sum(1, -1);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn sum(a: i32, b: i32)\n            a + b;\n\n        return sum(1, -1);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn sign(a: i32)\n            a > 0 ? 1 : a < 0 ? -1 : 0;\n\n        return sign(7) + sign(-3) + sign(0);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn sign(a: i32) {\n            if (a > 0)\n                return 1;\n\n            return -2;\n        }\n\n        return sign(10) * 2 + sign(-5);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn sign(a: i32) {\n            if (a > 0)\n                return 1;\n            else\n                return -2;\n        }\n\n        return sign(10) * 2 + sign(-5);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            let  i = -1;\n            let sb = i.i8;\n            let  b = i.u8;\n\n            return sb == -1 && b == 255 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            let sb = (-1).i8;\n            let  i =  sb.i32;\n            let  u =  sb.u32;\n\n            return i == -1 && u.i32 == 255 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            let b = byte(200);\n            let i = b.i32;\n            return i == 200 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        mut arr = [ 0 ];\n        return arr[0];\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let a = 3;\n        mut b = a;\n        b++;\n        return b - (a + 1);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        mut sum = 0;\n        for (mut i = 0; i < 10; i++)\n            sum++;\n\n        return sum * 2 - 20;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        mut sum = 0;\n        for (mut i = 10; i --> 0; )\n            sum--;\n\n        return sum * 2 + 20;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn decr(num: &mut i32)\n            num--;\n\n        mut res = 0;\n        decr(res);\n        return res + 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn decr(ref num: i32)\n            num--;\n\n        mut res = 0;\n        decr(res);\n        return res + 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        mut res = 0;\n        fn decr()\n            res--;\n\n        decr();\n        return res + 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        mut res = 0;\n        fn decr(num: &mut i32) { num--; } // ret void\n\n        decr(res);\n        return res + 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        mut sum = 0;\n        while (sum < 15)\n            sum++;\n\n        return sum - 15;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        <fail ++>\n        let sum = 0;        <pass/>\n        mut sum = 0;        </fail>\n        while (sum < 15)\n            sum++;\n\n        return sum - 15;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        mut sum = 0;\n        while (sum < 15)\n            sum += 2;\n\n        return sum - 16;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        mut i = 5;\n        mut sum = 0;\n        while (let x = i--) sum += x - i;\n        return sum - 5;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn named(a: i32, b: i32)\n            a - b * 2;\n\n        return named(b: 3, 6);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn named(a: i32, b: i32)\n            a - b * 2;\n\n        fn other(a: i32, b: i32)\n            named(:b, :a);\n\n        return other(b: 3, 6);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn ret_only_arg(a) a;\n        <split/>\n        fn main() 0.ret_only_arg;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Range {\n            min: i32;\n            max: i32;\n        }\n\n        fn size(r: Range)\n            r.max - r.min;\n\n        return size(Range(14, 21)) - 7;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Range {\n            min: i32;\n            max: i32;\n        }\n\n        mut r = Range(1, 2);\n        r.min++;\n        return r.max - r.min;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Range {\n            min: i32;\n            max: i32;\n        }\n\n        <fail ++>\n        let r =             <pass/>\n        mut r =             </fail>\n            Range(1, 2);\n\n        r.min++;\n        return r.max - r.min;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Range {\n            r_min: i32;\n            r_max: i32;\n        }\n\n        fn size(using r: Range)\n            r_max - r_min;\n\n        return size(Range(14, 21)) - 7;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct X {\n            a: i32;\n        }\n\n        fn test(using x: X, b: i32) a + b;\n        fn hey(using x: X) test(-1);\n\n        return X(1).hey;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Pos {\n            x: i32;\n        }\n\n        struct Player {\n            using pos: Pos;\n        }\n\n        fn dist(using p: Player, other: Player)\n            x - other.x;\n\n        let a = Player(Pos(10));\n        let b = Player(Pos( 4));\n\n        return dist(a, b) - 6;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct A { x: i32; y: i32; };\n        struct B { x: i32; z: i32; };\n        fn test(using left: A, using right: B)\n            <fail ambig x 2:20+1 using left 4:17+5 3:20+1 using right 4:32+5>\n            x + z; <pass/>\n            y + z; </fail>\n\n        fn main() test(A(1, 1), B(-1, -1));\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct CurrentFn {\n            parent_idx: i32;\n            using RoR?: CurrentFn_ResetOnResolve; // not yet populated\n        };\n\n        struct CurrentFn_ResetOnResolve {\n            ret_count: i32;\n        };\n\n        fn test(f: CurrentFn) f.parent_idx - f.ret_count;\n        fn main() test(CurrentFn(1, CurrentFn_ResetOnResolve(1)));\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct HasPredicate {\n            true kind   : string;\n            items       : i32;\n        };\n\n        fn main() {\n            let isTrue  = HasPredicate(\"let\", 0);\n            let isFalse = HasPredicate(\"\",    1);\n            return isTrue && !isFalse ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Stuff { name: string };\n\n        fn shadowsStructMember(using stuff: Stuff, other: string) {\n            shadow let name = other || name;\n            return name;\n        }\n\n        fn main() = shadowsStructMember(Stuff(\"a\"), \"bb\").len - 2;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn call_with_using_and_explicit_arg(x: i32, y: i32) = x + 7*y;\n        fn main () {\n            using let y = 1;\n            return call_with_using_and_explicit_arg(x: 2) - 9;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn call_with_using_explicit_and_trailing(x: i32, y: i32, m: i32) = (x + 7*y) * m;\n        fn main () {\n            using let x = 1;\n            return call_with_using_explicit_and_trailing(y: 2, 3) - 45;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        <fail items not trivial>\n        trivial<pass/></fail>\n        struct Node { items: Node[]; };\n\n        fn main() {\n            mut n: Node;\n            return n.items.len;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Other { using w: Node };\n\n        struct Node {\n            <fail self recursive (Node|Other) (2:30+1|6:13+1)>\n            v: Node;           <fail/>\n            v: Other;          <pass/>\n            v: i32;            </fail>\n        };\n\n        fn main() {\n            mut node: Node;\n            return node.v ? 1 : 0;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn sqr(implicit ref b: i32) {\n            return b *= b;\n        }\n        <split/>\n        fn main() {\n            struct Hey {\n                implicit a: i32;\n                implicit b: i32;\n            };\n\n            using mut hey = Hey(10, 20);\n            sqr();\n            return hey.a == 10 && hey.b == 400 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(x: i32) {\n            <fail annotation not a type 4:20+1>\n            mut y: x;                   <pass/>\n            mut y = x;                  </fail>\n            y += x;\n            return y;\n        }\n\n        fn main() test(2) - 4;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Hey { v: i32 }\n\n        fn test(x: Hey) {\n            <fail annotation not a type 6:23+1>\n            mut y: Hey(1);              <pass/>\n            mut y = Hey(1);             </fail>\n            y.v += x.v;\n            return y;\n        }\n\n        fn main() test(Hey(2)).v - 3;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let x = 3;\n        return x / 2 - 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn hey(a) a * a;\n        fn main = 0.hey;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn div3by(a: $T) 3 / a;\n        return div3by(2) - 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn div3by(a) 3 / a;\n        return div3by(2) - 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn add3(a: i32, b = 3) a + b;\n        fn main() add3(-3);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn add3(a: $T, b = 3) a + b;\n        struct v1 { x: i32; };\n        fn +(a: v1, b: i32) v1(a.x + b);\n        fn main() add3(2.v1).x - 5;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn mul_ab_init(a: $T, b = 0) a*b;\n        fn main() mul_ab_init(1);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn mul_ab_annot_init(a: $T, b: $T = 0) a*b;\n        fn main() mul_ab_annot_init(1);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn mul_ab_opt(a: $T, b?: $T) a*b;\n        fn main() mul_ab_opt(1);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn ab(a, b) a + b*2;\n        fn main() ab(b: 1, a: -2);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct yi32 { y: i32; };\n        fn add_s_vy(v, s) s + v.y;\n        fn main() add_s_vy(v: yi32(1), -1);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct xi32 { x: i32; };\n        fn add_s_vx(s, v) s + v.x; // <- args reordered\n        fn main() add_s_vx(v: xi32(1), -1);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn ab(a, b = 0, c = 0) a + b*2 + c*3;\n        fn main() ab(3, c: -1);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn ab(a, b = -1) a + b*2;\n        fn main() ab(3.0, -1.5).i32;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let NEG_ONE_FIVE = -1.5;\n        fn ab(a: $T, b: $T = -1) a + b*2;\n        fn main() ab(3, NEG_ONE_FIVE).i32;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let TWO = 2.0;\n        fn ab(a: $T, b: $T = -1) a + b*2;\n        fn main() ab(TWO).i32;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn self_rec_template(x: $T): $T\n            x > 0 ? self_rec_template(x / 2 - 5) : x;\n\n        fn main()\n            self_rec_template(7) + 2;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn ab_rec(a: $T): $T = a ? ba_rec(a - 2) : -100;\n        fn ba_rec(a: $T): $T = a ? ab_rec(a - 7) : -200;\n        fn main() ab_rec(11) + 200;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            let a = 1;\n            fn add1(b) a + b;\n            return 2.add1 - 3;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        pub fn MAP(a: [$T], fn) {               ;; !N_DeadCode\n            mut res: typeof( fn($T) )[];\n            res.grow_junk(a.len);\n            for (mut i = 0; i < a.len; i++) res[i] = fn(a[i]);\n            return res;\n        }\n\n        pub fn clone(a: $T)\n        case ($T.is::copy) a;\n        case ($T -> [$U]) a.MAP(fn clone);\n        default {\n            mut res: $T;\n            for (fieldname i: $T) res.i = a.i.clone();\n            return res;\n        }\n\n        pub nocopy struct Scope { x: i32; };\n        pub struct ModuleOutputs { deps: Scope[]; };\n\n        pub fn test(a: ModuleOutputs) {\n            let b = a.clone();\n            return a.deps.len - b.deps.len;\n        }\n\n        pub fn main() test(ModuleOutputs);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct X { a: i32; };\n        inline fn add_uxa_b_inline(using x: X, b: i32) a + b;\n        fn hey(using x: X) add_uxa_b_inline(-1);\n        return X(1).hey;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct X { a: i32; };\n        fn add_uxa_b_template(using x: X, b /* untyped */) a + b;\n        fn hey(using x: X) add_uxa_b_template(-1);\n        return X(1).hey;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn incr(a) a++;\n        fn main() {\n            mut a = 1;\n            incr: || a;\n            return a - 2;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        inline fn inl_lies(x: u32)<fail actual return match annot>: i32<pass/></fail> = x;\n        fn main() 0.inl_lies ? 1 : 0;                           ;; PointlessLocal\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn what(ref x: i32, ref y: i32) {\n            <fail bad call swap>\n            let z = y;   <pass/>\n            ref z = y;   </fail>\n            swap(x, z);  // swap is defined(ref x: $T, ref y: $T),\n        }                //  we ignore the 'ref' part in type patterns,\n                         //   so we only notice later when checking the spec\n        fn main() {\n            mut a = 1; mut b = 0; what(a, b);\n            return a;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn any(a, b) a || b;\n        fn main() any(0, []);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn both(a, b) a && b;\n        fn main() both(1, []);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn either(a, b) a ? a : b;\n        fn main() either(0, []);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn both_same_type(_<fail $T is not defined><pass/>: $T</fail>, y) =\n            typeof(y) -> $T;\n\n        fn main()   = both_same_type(1.u32, 1.i32) ? 1\n                    : both_same_type(1.i32, 1.i32) ? 0\n                    : 2;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn arrof !T(lax _: T[], type U)\n            case (T -> U)   true;\n            default         false;\n\n        fn main() {\n            mut a: i32[];\n            return arrof(a, i32) && !arrof(a, u32) ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            mut x: i32 = 0;\n            return (typeof(x) -> &mut i32).i32 - 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn work(visit) visit(1, 2);\n        fn main() work: |_, _| return 0;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn each(ref moot: u32) moot++;\n\n        fn Lifetime_process(lt: string, each) {\n            for (mut i = 0; i < lt.len; i++) {\n                fn climb(mut parent: string) // .... ///// what happened is this recursively picked up fn each from prelude\n                    Lifetime_process(parent, fn each); ///  on each nested iteration, which grew the addrofn type,\n                                             // ^^^^ /////   resulting in a new mangle on each go.\n                each(climb: fn climb, lt.slice(i, lt.len));\n            }\n        }\n\n        fn main() {\n            mut result = \"\";\n            Lifetime_process(\"abc\", each: |lt, climb| {\n                result ~= \" \" ~ lt;\n                if (let init = lt.slice(0, lt.len - 1))\n                    climb(init);\n            });\n\n            return result == \" abc ab a b bc b c\" ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        using flags Flags { F_SOME; F_OTHER };\n\n        fn parseInlineDecl(mut flags, flag = F_OTHER) {\n            flags |= flag;\n            return flags;\n        }\n\n        fn parseNoInline(mut flags) {\n            return parseInlineDecl(:flags, flag: []);\n        }\n\n        fn main() = parseInlineDecl(F_SOME).i32\n                  - parseNoInline(F_SOME).i32 * 3;\n    "_fu, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        struct Range { lo_incl: int; hi_excl: int };\n\n        fn each(using _: Range, each)\n            for (mut i = lo_incl; i < hi_excl; i++)\n                each(i);\n    "_fu, "\n        fn main() {\n            mut sum = 0;\n            _0::Range(0, 10).each: |i| sum += i;\n            return sum - 45 ;\n        }\n    "_fu } }, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn hello(mut x: <alt>i32<alt/>$T</alt>[]) {\n            x.each: |ref it| it++;\n            return x;\n        }\n\n        fn main() {\n            mut a = [ 1 ];\n            let b = hello(a);\n            for (mut i = 0; i < min(a.len, b.len); i++)\n                return a[i] + b[i] - 3;\n\n            <fail missing final return 10:13+3> <pass/>\n            return 1;                           </fail>\n        }\n    "_fu, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        struct Things(type T) { ARR: T[] };\n    "_fu, "\n<alt>\n        fn add !T(ref a: _0::Things(T), b: _0::Things(T))\n            a.ARR ~= b.ARR;\n<alt/>\n        fn add(ref a.ARR, b.ARR)\n            a ~= b;\n</alt>\n        fn main() {\n            type i32s = _0::Things(i32);\n            mut a: i32s;\n            mut b: i32s;\n            a.add(b);\n            return a.ARR.len;\n        }\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<3, fu::str> { "\n        struct Things(type T) { ARR: T[] };\n<alt>\n        fn add(ref a: Things($T), b: Things($T))\n            a.ARR ~= b.ARR;\n<alt/>\n        fn add(ref a.ARR, b.ARR)\n            a ~= b;\n</alt>\n    "_fu, "\n        struct Events(type A, type B) {\n            a: _0::Things(A);\n            b: _0::Things(B);\n        };\n\n        fn Events_merge(ref e0: Events($A, $B), e1: Events($A, $B))\n        {\n            fn Events_merge(ref a: _0::Things($T), b: _0::Things($T))\n                a.add(b);\n\n            for (fieldname i: Events($A, $B))\n                Events_merge(e0.i, e1.i);\n        }\n    "_fu, "\n        fn main() {\n            mut e0: _1::Events(i32, u32);\n            mut e1: _1::Events(i32, u32);\n            for (mut i = 0; i < 3; i++) {\n                e0.a.ARR ~= i;\n                e1.a.ARR ~= 3 + i;\n                if (i & 1) {\n                    e0.b.ARR ~= 0xff;\n                    e1.b.ARR ~= 0xfe;\n                }\n            }\n\n            e0.Events_merge(e1);\n            return e0.a.ARR == [ 0, 1, 2, 3, 4, 5 ]\n                && e0.b.ARR == [ 0xff, 0xfe ] ? 0 : 1;\n        }\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        pub fn identity(dont_leak_me) dont_leak_me;\n    "_fu, "\n        let dont_leak_me = 1;\n        fn main() _0::identity(dont_leak_me * 2) - 2;\n    "_fu } }, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        pub inline fn inl_id_leak(dont_leak_me) dont_leak_me;\n        let dont_leak_me = 1;\n        fn main() inl_id_leak(dont_leak_me * 2) - 2;            ;; PointlessLocal\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let static = 1;\n        fn template(arg) static + arg;\n        let arg = 7;                        // <- template shouldn't see this\n        let result = template(arg / -4);    // <- when specializing here\n        fn main() result;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            let static = 1;\n            fn template(arg) static + arg;\n            let arg = 7; // same here, except we're in a fn.\n            return template(arg / -4);\n        }\n    "_fu, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        fn template_add(a, b) a + b;\n    "_fu, "\n        struct HasInt { i: i32 };\n        <split/>\n        fn +(a: HasInt, b: HasInt) HasInt(a.i + b.i);\n        fn main() _0::template_add(HasInt(1), HasInt(2)).i - 3;\n    "_fu } }, PARZERO_queue);
    TODO_wUYWWjRs(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        fn template_add(a, b) a + b;\n    "_fu, "\n        struct HasInt { i: i32 };\n        fn main() {\n            infix fn +(a: HasInt, b: HasInt) HasInt(a.i + b.i); // its hard to defend this -\n            _0::template_add(HasInt(1), HasInt(2)).i - 3;       //  the thing above works but this doesn't.\n        }                                                       //   given the autoshadowing, we might just want to allow everything.\n    "_fu } }, "Bad call to + 2:33+1"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        fn inner(i: i32): i32\n            i > 0 ? outer(i - 1) : 0;\n\n        fn outer(i: i32): i32\n            2 * inner(i);\n\n        return outer(1);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(one: i32) {\n            let zero = one - 1;\n            let two  = one * 2;\n\n            <alt>\n            inline </alt>\n            fn inner(i: i32): i32\n                i > zero ? outer(i - one) : zero;\n\n            fn outer(i: i32): i32\n                two * inner(i);\n\n            return outer(one) + (two - one) * 17;\n        }\n\n        fn main() test(1) - 17;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn inner(i: i32): i32\n            outer(i - 1);\n\n        fn outer(implicit x: i32, i: i32): i32\n            i > 0   ? inner(i)\n                    : x + i;\n\n        let implicit x = 7;\n        return outer(1) - 7;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn inner_noret(i: i32)\n            outer_noret(i - 1);\n\n        fn outer_noret(implicit x: i32, i: i32)\n            i > 0   ? inner_noret(i)\n                    : x + i;\n\n        let implicit x = 7;\n        return outer_noret(1) - 7;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        inline fn inner_inl(i: i32): i32\n            outer_inl(i - 1);\n\n        fn outer_inl(implicit x: i32, i: i32): i32\n            i > 0   ? inner_inl(i)\n                    : x + i;\n\n        let implicit x = 7;\n        return outer_inl(1) - 7;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn inner_templ(i): i32\n            outer_templ(i - 1);\n\n        fn outer_templ(implicit x: i32, i): i32\n            i > 0   ? inner_templ(i)\n                    : x + i;\n\n        let implicit x = 7;\n        return outer_templ(1) - 7;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn inner_templ_noret(i)\n            outer_templ_noret(i - 1);\n\n        fn outer_templ_noret(implicit x: i32, i)\n            i > 0   ? inner_templ_noret(i)\n                    : x + i;\n\n        let implicit x = 7;\n        return outer_templ_noret(1) - 7;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn outer(i: i32): i32\n            i > 0   ? inner(i)\n                    : 2 * i;\n\n        fn inner(implicit x: i32, i: i32): i32\n            outer(i - 2 * x);\n\n        let implicit x = 3;\n        return outer(6);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn has_implicit(implicit i: i32, add: i32): i32\n            i + add;\n\n        inline fn injects_implicit_while_inlined(): i32\n            has_implicit(1); // broken by no ss.declash\n\n        fn main() {\n            let implicit i = 2;\n            return injects_implicit_while_inlined() - 3;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        inline fn outer_inl(i: i32): i32\n            i > 0   ? inner_inl(i)\n                    : 2 * i;\n\n        fn inner_inl(implicit x: i32, i: i32): i32\n            outer_inl(i - 2 * x); // broken by no ss.declash\n\n        let implicit x = 3;\n        return outer_inl(6);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn outer_templ(i): i32\n            i > 0   ? inner_templ(i)\n                    : 2 * i;\n\n        fn inner_templ(implicit x: i32, i): i32\n            outer_templ(i - 2 * x);\n\n        let implicit x = 3;\n        return outer_templ(6);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn outer(implicit x: i32, i: i32): i32\n            i > 0   ? inner(i)\n                    : x + i;\n\n        fn inner(i: i32): i32\n            outer(i - 1);\n\n        let implicit x = 7;\n        return outer(1) - 7;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn outer(implicit x: i32, i: i32)\n            i > 0   ? inner(i)\n                    : x + i;\n\n        fn noret(i: i32) = outer(i);\n\n        fn template(i) = i & 1 ? outer(i) : noret(i);\n\n        fn inner(i: i32): i32\n            template(i - 1);\n\n        fn main() {\n            let implicit x = 7;\n            return outer(1) - 7;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn returns_x(implicit x: i32): i32\n            = x;\n\n        fn calls_self_1(call_self = false): i32\n            = !call_self ? returns_x : calls_self_1 * 2;\n\n        let implicit x = 7;\n        return calls_self_1(true) - 14;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn returns_x(implicit x: i32): i32\n            = x;\n\n        fn calls_self_2(call_self = false): i32\n            = call_self ? calls_self_2 * 3 : returns_x;\n\n        let implicit x = 7;\n        return calls_self_2(true) - 21;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn returns_x(implicit x: i32): i32\n            = x;\n\n        fn calls_self_3(call_self = false): i32\n        {\n            let add = 1; // <- this wasnt visible\n            fn do_call_self(mul: i32 = 0)\n                = calls_self_3 * mul + add;\n\n            return call_self ? do_call_self(4) : returns_x;\n        }\n\n        let implicit x = 7;\n        return calls_self_3(true) - 29;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn noret_x(implicit x: i32) x;\n\n        fn templ_calls_self_2(call_self): i32\n            = call_self ? templ_calls_self_2(false) * 3 : noret_x;\n\n        fn main() {\n            let implicit x = 7;\n            return templ_calls_self_2(true) - 21;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Range {\n            min: i32;\n            max: i32;\n        }\n\n        fn size(using implicit r: Range)\n            max - min;\n\n        fn test()\n            size();\n\n        let implicit r = Range(14, 21);\n\n        return test  - 7;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Range {\n            min: i32;\n            max: i32;\n        }\n\n        fn size(using implicit r: Range)\n            max - min;\n\n        fn inner()\n            size();\n\n        fn outer()\n            inner();\n\n        let implicit r = Range(14, 21);\n\n        return outer() - 7;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            let a = 1;\n            let b = 2;\n            let c = 3;\n\n            fn depth1(x: i32) {\n                fn depth2(y: i32) {\n                    return sibling1(x + y + b);\n                }\n\n                return depth2(x + a);\n            }\n\n            fn sibling1(z: i32): i32 {\n                return z + c;\n            }\n\n            return depth1(0) - 6;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn goto0(x): i32 = x ? goto0(x / 2) : 0;\n        fn main() goto0(1);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn goto0(x) x ? goto0(x / 2) : 0;\n        fn main() goto0(1);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn goto0(x) x ? goto0(x / 2) : x; // ideally same as above\n        fn main() goto0(1);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn goto0(x) x && goto0(x / 2); // ideally same as above [again]\n        fn main() goto0(1);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn ref_a(ref a: i32) a;\n\n        fn main() {\n            mut a: i32;\n            ref r = ref_a(a);\n            r++;\n            return a - 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn ref_a_or_ref_b(ref a: i32, ref b: i32)\n            a || b;\n\n        fn main() {\n            mut a: i32;\n            mut b: i32;\n            ref a_or_b = ref_a_or_ref_b(a, b);\n            a_or_b++;\n            return b - 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn impl(implicit ref _impl: i32) _impl;\n        fn arg_or_impl(ref arg: i32) arg || impl;\n        fn main() {\n            implicit mut _impl: i32;\n            mut arg: i32;\n            ref ref = arg_or_impl(arg);\n            return arg - ref;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn hello(ref a: i32[], ref b: i32[], x: i32): &mut i32[] {\n            if (x == 0) return a;\n            if (x == 1) return b;\n            return hello(b, a, x / 17);\n        }\n\n        fn main() {\n            mut a = [1, 2, 3];\n            mut b = [4, 5, 6];\n            hello(a, b, 397)[1] *= 5;\n            return b[1] - 25;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        pub fn ZERO(implicit ref sum: i32, mut x: i32) {\n            while (x) {\n                ZERO( --x ); // Same as below but without the unused 'y' thing,\n                sum += x;    //  everything works because the call to ZERO isnt really unconditional,\n            }                //   and if it were, then the never return would actually be correct.\n        }\n\n        fn main() {\n            implicit mut sum = 0;\n            ZERO(4);\n            return sum - 11;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        pub fn ZERO(implicit ref sum: i32, mut x: i32) {\n            while (x) {\n                let y = x / 2;\n                ZERO( --x ); // Unconditional self recursion, initially hinted as t_never,\n                ZERO(   y ); //  meaning y remains unused here on first solve.\n                sum += x;\n            }\n        }\n\n        fn main() {\n            implicit mut sum = 0;\n            ZERO(4);\n            return sum - 12;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Node {\n            items: Node[];\n        }\n\n        fn solve(root: Node)\n        {\n            fn solveBlock(node: Node) {\n                let items = solveNodes(node.items);\n                return solveBlock(items);                       ;; ConstCast\n            }\n\n            fn solveBlock(items: i32[]) {\n                if (!Lifetime_allowsMutrefReturn(items))\n                    throw(\"Nope!\");\n\n                return items;\n            }\n\n            fn solveNode(node: Node, implicit ref next: i32) {\n                if (!node.items)\n                    return [ next++ ];\n\n                let implicit CTX = node.items.len; // <- this shows up as an closure-arg with an outdated revision\n                return solveBlock(node);\n            }\n\n            fn Lifetime_each(items, visit)\n                for (mut i = items.len; i --> 0; )\n                    visit(items[i]);\n\n            fn Lifetime_allowsMutrefReturn(items: i32[]) {\n                Lifetime_each(:items, visit: |item, implicit CTX: i32| {\n                    if (item == CTX)\n                        return false;\n                });\n\n                return true;\n            }\n\n            fn solveNodes(nodes: Node[]) {\n                mut result: i32[];\n                for (mut i = 0; i < nodes.len; i++)\n                    result ~= solveNode(nodes[i]);\n\n                return result;\n            }\n\n            return solveNode(root);\n        }\n\n        fn main() {\n            implicit mut next = 0;\n\n            let solve = solve(Node([\n                Node([ Node ]),\n                Node(),\n            ]));\n\n            return solve.len - 2;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn woot(implicit x: i32) = x;\n\n        fn main() {\n            <fail no implicit x>\n            <pass/>\n            let implicit x = 2;\n            </fail>\n            return woot() - 2;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        <fail no implicit y>\n        fn woot(implicit y: i32) = y;\n        <pass/>\n        fn woot(implicit x: i32) = x;\n        </fail>\n\n        fn hey() {\n            let implicit x = 2;\n            return woot() - 2;\n        }\n\n        let here = hey();\n        fn main() = here;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            mut x = +1;\n            mut y: typeof(x) = -x;\n            return x + y;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        ;; N_UnusedImplicit\n        fn dont_inject_my_implicit_args(implicit unused_implicit_arg: i32) {\n            return unused_implicit_arg;\n        }\n\n        fn not_extern() {\n            mut x: typeof(dont_inject_my_implicit_args) = 2;\n            return x;\n        }\n\n        fn not_extern(mut x: typeof(dont_inject_my_implicit_args)) {\n            return x;\n        }\n\n        fn main() {\n            return not_extern() + not_extern(-2);\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn mustwarn_unused_implicit(implicit forgot_to_use: i32, ref x: i32) {\n            <fail unused forgot_to_use>\n            x *= 3;             <pass/>\n            x *= forgot_to_use; </fail>\n        }\n\n        fn main() {\n            mut x = 7;\n            implicit forgot_to_use = 3;\n            mustwarn_unused_implicit(x);\n            return x == forgot_to_use * 7 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn log_append(implicit ref log_out: string, str: string)\n            log_out ~= str;\n\n        let VERBOSE = false;\n\n        fn verbose(implicit ref log_events: i32, inline stuff: string)\n        {\n            if (VERBOSE) log_append(stuff);\n            log_events++;\n        }\n\n        fn main() {\n            <fail unused log_out 15:30+7>\n            implicit     mut log_out: string; <pass/>\n            implicit lax mut log_out: string; </fail>\n\n            implicit mut log_events: i32;\n            verbose(\"Hello!\");\n            verbose(\"World!\");\n\n            return log_events == 2 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n\n        // TODO remove this, currently gets repeatedly\n        //  rebuilt & rejected because of -Werror\n        pragma emit(`#pragma GCC diagnostic ignored \"-Wpragmas\"`);\n        pragma emit(`#pragma GCC diagnostic ignored \"-Winfinite-recursion\"`);\n\n        fn infRec(x: i32) {\n            if (x > 1)\n                return infRec(x - 1);\n            else                        <fail infinite recur X:X>\n                return infRec(x + 1);   <pass/>\n                return x;               </fail>\n        }\n\n        fn main() infRec(1);\n    "_fu, "BUG exit code"_fu, testdiffs);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        struct NeverImported { x: i32 };\n        fn wrap(x: i32) NeverImported(x * 10);\n    "_fu, "\n        fn rec(y: i32)\n            if (y < 0)  return _0::wrap(rec(y + 7).x);\n            else        return _0::wrap(y);\n\n        fn main() rec(-2).x - 500;\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        fn wantsImplicit(implicit ref x: i32) = x++;\n    "_fu, "\n        fn main() {\n            <fail no implicit x 4:37+1 2:39+1>  <pass/>\n            implicit mut x: i32 = 0;            </fail>\n            return _0::wantsImplicit();\n        }\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<4, fu::str> { "\n        struct TokenIdx { id: i32 };\n    "_fu, "\n        import _0;\n        fn fail(implicit a: TokenIdx, b: i32) =\n            a.id + b;\n    "_fu, "\n        import _1;\n        fn cleanID(c: i32) =\n            fail(c) + 3;\n    "_fu, "\n        import _0;\n        import _2;\n        fn solvePrelude(d: i32) {\n            <fail no implicit in scope 10:25+1 6:27+1 4:17+1 3:26+1><pass/>\n            let implicit a: TokenIdx = TokenIdx(2);                 </fail>\n            return cleanID(d) + 5;\n        }\n\n        let CTX_PRELUDE =\n            solvePrelude(7);\n\n        fn main() =\n            CTX_PRELUDE - 17;\n    "_fu } }, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn Lifetime_process(lt: string, each) {\n            fn visit(chars) {\n                for (mut i = 0; i < chars.len; i++) {                   <alt>\n                    inline fn climb(mut parent)           visit(parent);<alt/>\n                    noinline fn climb(mut parent)         visit(parent);<alt/>\n                    inline fn climb(mut parent: string)   visit(parent);<alt/>\n                    noinline fn climb(mut parent: string) visit(parent);<alt/>\n                    let climb = fn visit;                               </alt>\n\n                    each(climb?: fn climb, chars.slice(i, chars.len))\n                }\n            }\n\n            visit(lt);\n        }\n\n        fn main() {\n            mut result = \"\";\n            Lifetime_process(\"abc\", each: |lt, climb| {\n                result ~= lt;\n                if (let init = lt && lt.slice(0, lt.len - 1))\n                    climb(init);\n            });\n\n            return result == \"abcababbcbc\" ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Helper { id: i32; type: string };\n\n        fn main() {\n            mut helpers = [\n                Helper(13, \"This is a long string, shouldn't fit in small string opti.\"),\n            ];\n\n            fn solveNode(\n                <fail solveNode 23:32+1 helpers type both alias 5:17+7>\n                ref <pass/>\n                mut </fail>\n                type: string) {\n                helpers && helpers.pop();\n                return type;\n            }\n\n            mut fallback: string;\n            fn lookup(id: i32) {\n                helpers.each: |ref h| if (h.id == id) return h.type;\n                return fallback;\n            }\n\n            mut str = solveNode(lookup(13));\n            str ~= str;\n            return helpers.len * 1000 + str.len - 116;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        enum Kind       { return; expr }\n        struct Type     { canon: string }\n        struct Helpers  { id: string; ret_actual: Type }\n        struct Node     { kind: Kind; value: string; items?: Node[] }\n\n        fn Scope_pop(implicit ref _helpers: Helpers[])\n            _helpers && _helpers.pop();\n\n        fn test(implicit mut _helpers: Helpers[], root: Node)\n        {\n            fn solveNode(node: Node,\n\n                // TODO fix this is stupid, just documenting the reasoning here\n                <fail arg solveNode:type is ref-returned from fn solveNode 28:33+1><pass/>\n                mut\n                </fail>\n                val type?: Type\n            ) {\n                if (node.kind == Kind.return)\n                    return solveJump(node);\n\n                Scope_pop();\n                return type;\n            }\n\n            fn solveJump(node: Node) {\n                let h       = Scope_lookupLabel(node.value);\n                let n_expr  = node.items && node.items[0];\n                return solveNode(n_expr, type: h.ret_actual);\n            }\n\n            fn Scope_lookupLabel(id: string) {\n                _helpers.each: |item| item.id == id && { return item };\n                throw(\"No label '\" ~ id ~ \"' in scope.\");\n            }\n\n            return solveNode(root);\n        }\n\n        fn main() {\n            implicit mut _helpers = [\n                Helpers(\"hello\", Type(\"Hello\")),\n                Helpers(\"world\", Type(\"World\")),\n            ];\n\n            let res = test(\n                Node(Kind.return, \"world\", [\n                    Node(Kind.expr, \"hello\")\n                ]));\n\n            return res.canon == \"World\" ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        struct Target { globid: i32 };\n        struct SolvedNode { target: Target; items?: SolvedNode[] }\n        struct Argument { target: Target };\n        struct Overload { solved: SolvedNode };\n        struct Extended { args: Argument[] };\n\n        noinline fn lazySolveStartDetectRecursionBug(overloads: Overload[], extended: Extended[], root: SolvedNode)\n        {\n            using fn GET(target: Target)\n                overloads[target.globid];\n\n            using fn EXT(target: Target)\n                extended[target.globid];\n\n            fn cgNode(n: SolvedNode) {\n                mut src = \"\";\n                n.items.each: |member|\n                    src ~= cgFn(member.target);\n\n                return src;\n            }\n\n            fn cgFn(target: Target) {\n                mut src = cgNode(target.solved);\n                target.args.each: |host_arg|\n                    src ~= binding(host_arg);\n\n                return src;\n            }\n\n            fn binding(target: Target)      cgNode(target.solved);\n            fn binding(arg: Argument)       binding(arg.target);\n\n            return cgNode(root);\n        }\n\n        fn main() {\n            return lazySolveStartDetectRecursionBug(\n                [ Overload() ], [ Extended() ], SolvedNode()).len;\n        }\n    "_fu, "BUG spec.args.len(3) != original.args.len(4)"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        struct Hello { x: i32 };\n        implicit ref hello: Hello;\n        fn woot() = hello.x++;\n\n        <split/>\n        fn main() {\n            shadow implicit mut hello = Hello(1);\n            return woot() * 10 + hello.x - 12;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct World { x: i32 };\n        struct Hello {  <fail no implicit world :24+1 because of 6:30+5><pass/>\n            implicit    </fail> world: World;\n        };\n\n        fn woot(implicit ref world: World) = world.x++;\n\n        <split/>\n        fn main() {\n            using mut hello = Hello(World(1));\n            return woot() * 10 + hello.world.x - 12;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let x = 1;\n\n        fn test(): &i32\n            x;\n\n        return test - 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let a = 1;\n        let x: &i32 = a;\n\n        return a - x;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Test {\n            x: &i32;\n        }\n\n        let a = 1;\n        let test = Test(a);\n\n        return test.x - 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        mut a = 0;\n        mut b = a;\n        b++;\n        let c = a = b;\n\n        return a - c;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        mut arr = [0, 1, 2, 3, 4];\n        arr.push(5);\n\n        fn test(view: &i32[]): i32 {\n            mut sum = 0;\n            for (mut i = 0; i < view.len; i++)\n                sum += view[i];\n\n            return sum - 15;\n        }\n\n        return test(arr);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        mut arr: i32[] = [1, 2, 3, 4];\n        arr.push(5);\n\n        fn test(view: &i32[]): i32 {\n            mut sum = 0;\n            for (mut i = 0; i < view.len; i++)\n                sum += view[i];\n\n            return sum - 15;\n        }\n\n        return test(arr);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let x = 5;\n        mut arr = [ -5 ];\n        arr.push(x);\n        return arr[0] + arr[1];\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        <fail name>\n        let x = [ named: 0 ]; <pass/>\n        let x = [        0 ]; </fail>\n        return x[0];\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        mut other: i32[][];\n        mut arr:   i32[][];\n        for (mut i = 4; i --> 0; )\n        {\n            arr.resize(i);\n\n            // fill up with non small vecs so we can check alloc counts\n            for (shadow mut i = 0; i < arr.len; i++)\n                arr[i] ||= [ i, i, i, i, i, i, i, i ]; // defeat small vec\n\n            // now this convers the \"Last chance to do nothing\" opti -\n            //  noop resize a shared vec.\n            other = arr;\n            arr.resize(other.len || i);\n        }\n        return other.len;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            mut nums: i32[];\n            for (mut i = 0; i < 100; i++) nums ~= 1;\n\n            <fail COW will break (8:27+4|8:41+4) 7:17+4>\n            ref zero    = nums[nums.len / 2];\n            let allOnes = <alt>nums<alt/>indirect_copy(nums)</alt>;\n            <pass/>\n            let allOnes = <alt>nums<alt/>indirect_copy(nums)</alt>;\n            ref zero    = nums[nums.len / 2];\n            </fail>\n\n            zero = 0;\n\n            mut o = 0;\n            for (mut i = 0; i < allOnes.len; i++)\n                if (allOnes[i] == 1)\n                    o++;\n\n            return zero == 0 && o == 100 ? 0 : 1;\n        }\n\n        noinline fn indirect_copy(arr: i32[])\n            arr.len & 1\n                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]\n                : arr; // <- we take this branch\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            mut nums: i32[];\n            for (mut i = 0; i < 100; i++) nums ~= 1;\n\n            let OPAQUE  = nums.len == 100 * nums[nums.len / 2];\n\n            <fail COW will break (13:34+2|13:48+2) 9:17+4>\n            ref zero    = nums[nums.len / 2];\n            let woot    = OPAQUE && nums;\n            <pass/>\n            let woot    = OPAQUE && nums;\n            ref zero    = nums[nums.len / 2];\n            </fail>\n\n            let allOnes = <alt>OPAQUE && woot<alt/>indirect_copy(OPAQUE && woot)</alt>;\n\n            zero = 0;\n\n            mut o = 0;\n            for (mut i = 0; i < allOnes.len; i++)\n                if (allOnes[i] == 1)\n                    o++;\n\n            return zero == 0 && o == 100 ? 0 : 1;\n        }\n\n        noinline fn indirect_copy(arr: i32[])\n            arr.len & 1\n                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]\n                : arr; // <- we take this branch\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            mut nums: i32[];\n            for (mut i = 0; i < 100; i++) nums ~= 1;\n\n            let OPAQUE  = nums.len == 100 * nums[nums.len / 2];\n            mut other   = 0;\n\n            <fail COW will break (12:27+4|12:41+4|11:27+4|11:41+4)>\n            ref woot    = nums[nums.len / 2];\n            ref zero    = OPAQUE ? woot : other;\n            let allOnes = <alt>nums<alt/>indirect_copy(nums)</alt>;\n            <fail/>\n            ref woot    = nums[nums.len / 2];\n            let allOnes = <alt>nums<alt/>indirect_copy(nums)</alt>;\n            ref zero    = OPAQUE ? woot : other;\n            <pass/>\n            let allOnes = <alt>nums<alt/>indirect_copy(nums)</alt>;\n            ref woot    = nums[nums.len / 2];\n            ref zero    = OPAQUE ? woot : other;\n            </fail>\n\n            zero = 0;\n\n            mut o = 0;\n            for (mut i = 0; i < allOnes.len; i++)\n                if (allOnes[i] == 1)\n                    o++;\n\n            return zero == 0 && o == 100 ? 0 : 1;\n        }\n\n        noinline fn indirect_copy(arr: i32[])\n            arr.len & 1\n                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]\n                : arr; // <- we take this branch\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        <alt>\n        noinline fn cow_after_ref_indirect(ref zero: i32, allOnes: i32[]) cow_after_ref(:zero, :allOnes);\n        noinline fn cow_after_ref(ref zero: i32, allOnes: i32[])\n        <alt/>\n        noinline fn cow_after_ref_indirect(allOnes: i32[], ref zero: i32) cow_after_ref(:allOnes, :zero);\n        noinline fn cow_after_ref(allOnes: i32[], ref zero: i32)\n        </alt>\n        {\n            zero = 0;\n\n            mut o = 0;\n            for (mut i = 0; i < allOnes.len; i++)\n                if (allOnes[i] == 1)\n                    o++;\n\n            return zero == 0 && o == 100 ? 0 : 1;\n        }\n\n        fn main() {\n            mut nums: i32[];\n            for (mut i = 0; i < 100; i++)\n                nums ~= 1;\n\n            <alt>\n            return cow_after_ref(           <alt/>\n            return cow_after_ref_indirect(  </alt>\n                zero: nums[nums.len / 2], allOnes: <alt>nums<alt/>indirect_copy(nums)</alt>);\n        }\n\n        noinline fn indirect_copy(arr: i32[])\n            arr.len & 1\n                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]\n                : arr; // <- we take this branch\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            mut nums: i32[];\n            for (mut i = 0; i < 100; i++) nums ~= 1;\n\n            <fail COW will break (8:27+4|8:41+4) 30:19+3 7:17+6>\n            ref zeroes  = nums[10:20];\n            let allOnes = <alt>nums<alt/>indirect_copy(nums)</alt>;\n            <pass/>\n            let allOnes = <alt>nums<alt/>indirect_copy(nums)</alt>;\n            ref zeroes  = nums[10:20];\n            </fail>\n\n            for (mut i = 0; i < zeroes.len; i++)\n                zeroes[i] = 0;\n\n            mut o = 0;\n            for (mut i = 0; i < allOnes.len; i++)\n                if (allOnes[i] == 1)\n                    o++;\n\n            mut z = 0;\n            for (mut i = 0; i < zeroes.len; i++)\n                if (!zeroes[i])\n                    z++;\n\n            return z == 10 && o == 100 ? 0 : 1;\n        }\n\n        noinline fn indirect_copy(arr: i32[])\n            arr.len & 1\n                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]\n                : arr; // <- we take this branch\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        <alt>\n        noinline fn cow_after_ref_indirect(ref zeroes: [i32], allOnes: i32[]) cow_after_ref(:zeroes, :allOnes);\n        noinline fn cow_after_ref(ref zeroes: [i32], allOnes: i32[])\n        <alt/>\n        noinline fn cow_after_ref_indirect(allOnes: i32[], ref zeroes: [i32]) cow_after_ref(:allOnes, :zeroes);\n        noinline fn cow_after_ref(allOnes: i32[], ref zeroes: [i32])\n        </alt>\n        {\n            for (mut i = 0; i < zeroes.len; i++)\n                zeroes[i] = 0;\n\n            mut o = 0;\n            for (mut i = 0; i < allOnes.len; i++)\n                if (allOnes[i] == 1)\n                    o++;\n\n            mut z = 0;\n            for (mut i = 0; i < zeroes.len; i++)\n                if (!zeroes[i])\n                    z++;\n\n            return z == 10 && o == 100 ? 0 : 1;\n        }\n\n        fn main() {\n            mut nums: i32[];\n            for (mut i = 0; i < 100; i++)\n                nums ~= 1;\n\n            <alt>\n            return cow_after_ref(           <alt/>\n            return cow_after_ref_indirect(  </alt>\n                zeroes: nums[10:20], allOnes: <alt>nums<alt/>indirect_copy(nums)</alt>);\n        }\n\n        noinline fn indirect_copy(arr: i32[])\n            arr.len & 1\n                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]\n                : arr; // <- we take this branch\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(ref nums: i32[][])\n        {\n            <fail COW will break (6:31+1|6:45+1) 36:19+3 5:17+6>\n            ref zeroes  = nums[nums.len / 2];\n            mut allOnes = <alt>nums[nums.len / 2]<alt/>indirect_copy(nums[nums.len / 2])</alt>;\n            <pass/>\n            mut allOnes = <alt>nums[nums.len / 2]<alt/>indirect_copy(nums[nums.len / 2])</alt>;\n            ref zeroes  = nums[nums.len / 2];\n            </fail>\n\n            for (mut i = 0; i < zeroes.len; i++)\n                zeroes[i] = 0;\n\n            mut o = 0;\n            for (mut i = 0; i < allOnes.len; i++)\n                if (allOnes[i] == 1)\n                    o++;\n\n            mut z = 0;\n            for (mut i = 0; i < zeroes.len; i++)\n                if (!zeroes[i])\n                    z++;\n\n            return o == 10 && z == 10 ? 0 : 10;\n        }\n\n        fn main() {\n            mut nums: i32[][];\n            for (mut i = 0; i < 4; i++)\n                nums ~= [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ];\n\n            return test(nums);\n        }\n\n        noinline fn indirect_copy(arr: i32[])\n            arr.len & 1\n                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]\n                : arr; // <- we take this branch\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct TwoVecs {\n            ones: i32[]; twos: i32[];\n        };\n\n        fn main() {\n            mut orig: TwoVecs;\n            for (mut i = 0; i < 100; i++) {\n                orig.ones ~= 1;\n                orig.twos ~= 2;\n            }\n\n            <fail COW will break (15:27+4|15:41+4) 34:40+1 40:19+3>\n            ref zero    = orig.ones[orig.ones.len / 2];\n            let all     = <alt>orig<alt/>indirect_copy(orig)</alt>;\n            <pass/>\n            let all     = <alt>orig<alt/>indirect_copy(orig)</alt>;\n            ref zero    = orig.ones[orig.ones.len / 2];\n            </fail>\n\n            zero = 0;\n\n            mut o = 0;\n            for (mut i = 0; i < all.ones.len; i++)\n                if (all.ones[i] == 1)\n                    o++;\n\n            mut t = 0;\n            for (mut i = 0; i < all.twos.len; i++)\n                if (all.twos[i] == 2)\n                    t++;\n\n            return zero == 0 && o == 100 && t == 100 ? 0 : 1;\n        }\n\n        noinline fn indirect_copy(tv: TwoVecs)\n            TwoVecs(ones: indirect_copy(tv.ones),\n                    twos: indirect_copy(tv.twos));\n\n        noinline fn indirect_copy(arr: i32[])\n            arr.len & 1\n                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]\n                : arr; // <- we take this branch\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct TwoVecs {\n            ones: i32[];\n            twos: i32[];\n        };\n\n        <alt>\n        noinline fn cow_after_ref_indirect(ref zero: i32, all: TwoVecs) cow_after_ref(:zero, :all);\n        noinline fn cow_after_ref(ref zero: i32, all: TwoVecs)\n        <alt/>\n        noinline fn cow_after_ref_indirect(all: TwoVecs, ref zero: i32) cow_after_ref(:all, :zero);\n        noinline fn cow_after_ref(all: TwoVecs, ref zero: i32)\n        </alt>\n        {\n            zero = 0;\n\n            mut o = 0;\n            for (mut i = 0; i < all.ones.len; i++)\n                if (all.ones[i] == 1)\n                    o++;\n\n            mut t = 0;\n            for (mut i = 0; i < all.twos.len; i++)\n                if (all.twos[i] == 2)\n                    t++;\n\n            return zero == 0 && o == 100 && t == 100 ? 0 : 1;\n        }\n\n        fn main() {\n            mut orig: TwoVecs;\n            for (mut i = 0; i < 100; i++) {\n                orig.ones ~= 1;\n                orig.twos ~= 2;\n            }\n\n            <alt>\n            return cow_after_ref(           <alt/>\n            return cow_after_ref_indirect(  </alt>\n                zero: orig.ones[orig.ones.len / 2], all: <alt>orig<alt/>indirect_copy(orig)</alt>);\n        }\n\n        noinline fn indirect_copy(tv: TwoVecs)\n            TwoVecs(ones: indirect_copy(tv.ones),\n                    twos: indirect_copy(tv.twos));\n\n        noinline fn indirect_copy(arr: i32[])\n            arr.len & 1\n                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]\n                : arr; // <- we take this branch\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        noinline fn test(ref barr: i32[][], ref x: i32[]) {\n            for (mut i = 0; i < x.len; i++)\n                x[i] += 2;\n\n            for (mut i = 0; i < barr.len; i++) {\n                ref b = barr[i];\n                for (mut j = 0; j < b.len; j++)\n                    b[j] += 1;\n            }\n\n            barr ~= [ 0 ];\n        }\n\n        fn main() {\n            mut arr: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];\n\n            <fail COW will break (20:24+3|20:38+3) 31:19+3>\n            ref x = arr[0];\n            mut barr = <alt>arr<alt/>indirect_copy(arr)</alt>;\n            <pass/>\n            mut barr = <alt>arr<alt/>indirect_copy(arr)</alt>;\n            ref x = arr[0];\n            </fail>\n\n            test(:barr, x);\n\n            return barr == [ [1,2,3,4,5,6,7,8], [9,10,11,12,13,14,15,16], [0] ] ? 0 : 1;\n        }\n\n        noinline fn indirect_copy(arr: i32[][])\n            arr.len & 1\n                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]\n                : arr; // <- we take this branch\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        noinline fn test(ref barr: i32[][], ref x: i32[]) {\n            for (mut i = 0; i < x.len; i++)\n                x[i] += 2;\n\n            for (mut i = 0; i < barr.len; i++) {\n                ref b = barr[i];\n                for (mut j = 0; j < b.len; j++)\n                    b[j] += 1;\n            }\n\n            barr ~= [ 0 ];\n        }\n\n        noinline fn outer(ref a: i32[][], ref b: i32[][])\n        {\n            <fail both alias arr (28:17+3|28:31+3|27:17+3|27:31+3) 30:35+3>\n            ref x = a[0];\n            mut barr = <alt>b<alt/>indirect_copy(b)</alt>;\n            <fail/>\n            mut barr = <alt>b<alt/>indirect_copy(b)</alt>;\n            ref x = a[0];\n            <pass/>\n            mut barr = <alt>b<alt/>indirect_copy(b)</alt>;\n            mut x = a[0];\n            </fail>\n\n            test(:barr, x);\n\n            return barr;\n        }\n\n        fn main() {\n            mut arr: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];\n\n            let barr = outer(arr, arr);\n            return barr == [ [1,2,3,4,5,6,7,8], [9,10,11,12,13,14,15,16], [0] ] ? 0 : 1;\n        }\n\n        noinline fn indirect_copy(arr: i32[][])\n            arr.len & 1\n                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]\n                : arr; // <- we take this branch\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Ephemeral {\n            id:             i32;\n            scope_skip?:    Ephemeral[];\n        };\n\n        struct SolverState {\n            _scope_skip:    Ephemeral[];\n            _ephs:          Ephemeral[];\n        };\n\n        fn snap(i: i32, ref s: SolverState) {\n            ref eph        = s._ephs[i]; // cannotCOW false positive, copy(s._scope_skip) <- ref eph, but they're disjoint\n            eph.scope_skip = <alt>s._scope_skip<alt/>indirect_copy(s._scope_skip)</alt>;\n            return eph;\n        }\n\n        fn main() {\n            mut s = SolverState(\n                _scope_skip: [ Ephemeral(1), Ephemeral(2), Ephemeral(3) ],\n                _ephs:       [ Ephemeral(4) ],\n            );\n\n            return snap(:s, 0).scope_skip.len - 3;\n        }\n\n        noinline fn indirect_copy!<T>(arr: T[])\n            arr.len & 1\n                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]\n                : arr; // <- we take this branch\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        // This one unrelated to COW but variation of test above.\n        <flip>\n        struct Ephemeral { // When first, we cg declarations in the wrong order\n            id:             i32;\n            scope_skip?:    ScopeSkip;\n        };\n        <flip/>\n        struct ScopeSkip { // When first, we complain about recursive types\n            left:           Ephemeral[];\n            right:          Ephemeral[];\n        };\n        </flip>\n\n        struct SolverState {\n            _scope_skip:    ScopeSkip;\n            _ephs:          Ephemeral[];\n        };\n\n        fn snap(i: i32, ref s: SolverState) {\n            mut scope_skip  = s._scope_skip;\n            ref eph         = s._ephs[i];\n            eph.scope_skip  = scope_skip;\n            return eph;\n        }\n\n        fn main() {\n            mut s = SolverState(\n                _scope_skip: ScopeSkip(\n                    [ Ephemeral(1), Ephemeral(2), Ephemeral(3) ],\n                    [ Ephemeral(4), Ephemeral(5) ]\n                ),\n                _ephs:       [ Ephemeral(4) ],\n            );\n\n            return snap(:s, 0).scope_skip.left.len - 3;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Node { items: Node[] };\n\n        fn unwrap_all(ref nodes: Node[]) {\n            for (mut i = 0; i < nodes.len; i++) {\n                ref n = nodes[i];\n                if (n.items)        // cannotCOW false pos\n                    n = n.items[0]; //  copy(n.items[0]) <- ref n\n            }                       //   via parent nodes\n        }\n\n        fn count(nodes: Node[]) {\n            mut N = nodes.len;\n            for (mut i = 0; i < nodes.len; i++)\n                N += nodes[i].items.count;\n            return N;\n        }\n\n        fn main() {\n            mut nodes = [ Node([ Node() ]) ];\n            nodes.unwrap_all();\n            return nodes.count - 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        noinline fn conditionalCopyOrWrite(ref a: i32[][], ref b: i32[][]) {\n            ref either = (a || b)[0];\n            <alt>\n            if (either.len & 1)\n                b = a;              // <- no issue here\n            else                    //  either only written to\n                either ~= 1;        //   if copy never created.\n            <alt/>\n            if (either.len & 1 == 0)\n                either ~= 1;\n            else\n                b = a;\n            </alt>\n        }\n\n        fn arr(n: i32) {\n            mut arr: i32[];\n            for (mut i = 1; i <= n; i++) arr ~= i;\n            return arr;\n        }\n\n        fn check(arr: i32[]) {\n            mut sum = 0;\n            for (mut i = 0; i < arr.len; i++) sum += arr[i];\n            return sum;\n        }\n\n        fn check(arr: i32[][]) {\n            mut sum = 0;\n            for (mut i = 0; i < arr.len; i++) sum = sum * 100 + check(arr[i]);\n            return sum;\n        }\n\n        fn main() {\n            mut a = [ arr( 8), arr( 9) ];\n            mut b = [ arr(10), arr(11) ];\n\n            conditionalCopyOrWrite(:a, :b);\n\n            return check(a) == 3600 + 45 + 100\n                && check(b) == 5500 + 66\n                    ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct SolvedNode {\n            items: SolvedNode[];\n        };\n\n        fn mutateThenCopy(ref callsite: SolvedNode, ref root: SolvedNode) {\n            callsite.items ~= callsite;\n            mut result = root;\n            result.items ~= root;\n            return result;\n        }\n\n        fn main() {\n            fn count(node: SolvedNode) {\n                mut c = 1;\n                node.items.each: |item| c += count(item);\n                return c;\n            }\n\n            mut a: SolvedNode;\n            mut b = mutateThenCopy(a, a);\n            return 1000 * a.count + b.count - 2004;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct SolvedNode {\n            items: SolvedNode[];\n        };\n\n        fn mutateThenCopy(ref root: SolvedNode) {\n            fn copyRoot() {\n                mut result = root;\n                result.items ~= root;\n                return result;\n            }\n\n            fn bck_call(ref callsite: SolvedNode) {\n                callsite.items ~= callsite; // mutation\n                return copyRoot();          // copy inside\n            }\n\n            return bck_call(root);\n        }\n\n        fn main() {\n            fn count(node: SolvedNode) {\n                mut c = 1;\n                node.items.each: |item| c += count(item);\n                return c;\n            }\n\n            mut a: SolvedNode;\n            mut b = a.mutateThenCopy();\n            return 1000 * a.count + b.count - 2004;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct SolvedNode {\n            items: SolvedNode[];\n        };\n\n        fn mutateCopyMutate(ref callsite: SolvedNode, ref root: SolvedNode) {\n            callsite.items ~= callsite;\n            mut result = root;\n            root.items ~= root;\n            return result;\n        }\n\n        fn main() {\n            fn count(node: SolvedNode) {\n                mut c = 1;\n                node.items.each: |item| c += count(item);\n                return c;\n            }\n\n            mut a: SolvedNode;\n            mut b = mutateCopyMutate(a, a);\n            return 1000 * a.count + b.count - 4002;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct SolvedNode {\n            items: SolvedNode[];\n        };\n\n        fn mutateCopyMutate(ref root: SolvedNode) {\n            fn copyRoot() {\n                mut result = root;\n                root.items ~= root;\n                return result;\n            }\n\n            fn bck_call(ref callsite: SolvedNode) {\n                callsite.items ~= callsite; // mutation\n                return copyRoot();          // copy inside\n            }\n\n            return bck_call(root);\n        }\n\n        fn main() {\n            fn count(node: SolvedNode) {\n                mut c = 1;\n                node.items.each: |item| c += count(item);\n                return c;\n            }\n\n            mut a: SolvedNode;\n            mut b = a.mutateCopyMutate();\n            return 1000 * a.count + b.count - 4002;\n        }\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        struct SolvedNode {\n            items: SolvedNode[];\n        };\n\n        fn mutateThenCopyAfterRecursion(ref root: SolvedNode) {\n            fn mutateThenCopy(ref callsite: SolvedNode) {\n                callsite.items ~= callsite;\n\n                mut result = root;\n                result.items ~= root;\n                return result;\n            }\n<flip>\n            fn indirectRecursion(ref node: SolvedNode) {\n                ref items = node.items;\n\n                // The root copies made at the end of each bck_node call\n                //  would indeed be invalid if they survived,\n                //   but they get return-discarded here.\n                for (mut i = items.len; i --> 1; )\n                    bck_node(items[i]);                         ;; !N_COWRestrict\n                                                                ;; PointlessMustSeq\n                return items && bck_node(items[0]);\n            }\n<flip/>\n            fn bck_node(ref node: SolvedNode)\n                node.items\n                    ? indirectRecursion(node)\n                    : mutateThenCopy(node);\n</flip>\n            return bck_node(root);\n        }\n\n        fn main() {\n            fn count(node: SolvedNode) {\n                mut c = 1;\n                node.items.each: |item| c += count(item);\n                return c;\n            }\n\n            mut a: SolvedNode;\n            mut b = a.mutateThenCopyAfterRecursion();\n            return 1000 * a.count + b.count - 2004;\n        }\n    "_fu, "if/else no common supertype SolvedNode[] 17:21+1"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        struct Node {\n            items?: Node[];\n        };\n\n        fn obtuseEscapeOnNextLoopIter(ref node: Node, ref root: Node) {\n            mut escape: Node;\n            <fail both alias root 26:17+4>\n            ref <pass/>\n            fn  </fail> items = node.items;\n\n            for (mut i = items.len; i --> 0; ) {\n                <alt>\n                if (i)      escape = root;\n                else        items[i].items ~= escape;\n                <alt/>\n                if (i == 0) items[i].items ~= escape;\n                else        escape = root;\n                </alt>\n            }\n        }\n\n        fn main() {\n            fn count(node: Node) {\n                mut c = 1;\n                node.items.each: |item| c += count(item);\n                return c;\n            }\n\n            mut root = Node([ Node, Node ]);\n            obtuseEscapeOnNextLoopIter(root, root);\n\n            // Now root should be:\n            // Node([ Node([ Node([ Node, Node ]) ]), Node ])\n            //\n            // If COW breaks this can get self-recursive,\n            //  currently blows up with a segfault if 'ref items'.\n            //\n            return root.count - 6;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct SolvedNode {\n            items: SolvedNode[];\n        };\n\n        fn cowAfterConditionalWithLoop(ref a: SolvedNode, ref b: SolvedNode) {\n            if (a.items.len & 1) {\n                ref items = a.items;\n                for (mut i = 0; i < items.len; i++)\n                    cowAfterConditionalWithLoop(items[i], b);\n            }\n\n            a.items ~= b;\n        }\n\n        fn main() {\n            mut x = SolvedNode([ SolvedNode ]);\n            <fail both alias x>\n            ref y = x;  <pass/>\n            mut y = x;  </fail>\n            cowAfterConditionalWithLoop(x, y);                  ;; N_COWRestrict\n\n            fn count(node: SolvedNode) {\n                mut c = 1;\n                node.items.each: |item| c += count(item);\n                return c;\n            }\n\n            return x.count == 6 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct SolvedNode {\n            items: SolvedNode[];\n        };\n\n        fn copiesRootBeforeThrow(ref root: SolvedNode, ref escape: SolvedNode)\n        {\n            fn fail(reason: string)\n                reason.len & 1 && throw(\"odd: \" ~ reason)\n                               || throw(reason);\n\n            fn bck_node(ref node: SolvedNode) {\n                ref items = node.items;\n                for (mut i = 0; i < items.len; i++) {\n                    ref item = items[i];\n                    bck_node(item);\n\n                    if (item.items.len > 1) {\n                        escape = root;\n                        <fail both alias root 29:21+1>\n                        if (escape.items.len > 3)       <pass/>\n                        if (true)                       </fail>\n                            fail(\"#\" ~ escape.items.len);\n                    }\n                }\n\n                node.items ~= node;\n            }\n\n            bck_node(root);\n        }\n\n        fn main() {\n            fn count(node: SolvedNode) {\n                mut c = 1;\n                node.items.each: |item| c += count(item);\n                return c;\n            }\n\n            mut escape: SolvedNode;\n            mut a = SolvedNode([ SolvedNode ]);\n            a.copiesRootBeforeThrow(:escape);\n\n            let C0 = a.count;\n            if (C0 != 6)            return 1;\n\n            try {\n                a.copiesRootBeforeThrow(:escape);\n            }\n            catch (e) {\n                a.items ~= SolvedNode(); // escape !== a\n                let C1 = a.count;\n                let C2 = escape.count;\n                if (C1 != 11)           return 2;\n                if (C2 != 10)           return 3;\n                else if (e != \"#2\")     return 4;\n                else                    return 0;\n            }\n\n            return 5;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct A { ints: i32[] };\n\n        fn copyInts_then_mutateBytes(ref bytes: byte[], a: A) {\n        <flip>\n            for (mut i = 0; i < bytes.len; i++)\n                bytes[i] = 0.byte;\n        <flip/>\n            mut ret = a;\n        </flip>\n            ret.ints.pop();\n            return ret;\n        }\n\n        fn main() {\n            mut a = A([ 1, 1, 1, 1, 1, 2, 2, 2, 2, 2 ]);\n\n            <fail var a 16:17+1 COW will break 21:56+1 due to bytes 19:18+5>\n            ref <pass/>\n            fn  </fail> bytes = a.ints.view(of: byte);\n\n            let b = copyInts_then_mutateBytes(:bytes, :a);\n\n            mut sum = 0;\n            for (mut i = 0; i < b.ints.len; i++)\n                sum += b.ints[i];\n\n            return sum - 13;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Wrapper { str: string };\n\n        fn validateCOW_falsePos_with_typeMayPointInto_disabled(\n            ref _scope: Wrapper[])\n        {\n            fn findFirstSet() {\n                _scope.each: |wrapper|\n                    if (wrapper.str)\n                        return wrapper.str;\n\n                return \"None\";\n            }\n\n            fn wrapper_cannotPointInto_String(h: int) {\n                ref wrapper = _scope[h];\n                wrapper.str = findFirstSet();\n            }\n\n            for (mut i = 0; i < _scope.len; i++)\n                wrapper_cannotPointInto_String(i);\n        }\n\n        fn main() {\n            mut _scope = [ Wrapper() ];\n            validateCOW_falsePos_with_typeMayPointInto_disabled(_scope);\n            return _scope.len == 1 && _scope[0].str.len - 4;\n        }\n    "_fu, PARZERO_queue);
    ARROPS_fPM0yqMu("0,1,2,3,4"_fu, "push(5)"_fu, "@[1] + @[4] - @[5]"_fu, PARZERO_queue);
    ARROPS_fPM0yqMu("0,1,2,3,4"_fu, "insert(5, 5)"_fu, "@[1] + @[4] - @[5]"_fu, PARZERO_queue);
    ARROPS_fPM0yqMu("0,1,2,3,4"_fu, "pop()"_fu, "@[1] + @[3] - @.len"_fu, PARZERO_queue);
    ARROPS_fPM0yqMu("0,1,2,3,4"_fu, "splice(4, 1)"_fu, "@[1] + @[3] - @.len"_fu, PARZERO_queue);
    ARROPS_fPM0yqMu("0,1,2,3,4"_fu, "unshift(5)"_fu, "@[2] + @[5] - @[0]"_fu, PARZERO_queue);
    ARROPS_fPM0yqMu("0,1,2,3,4"_fu, "insert(0, 5)"_fu, "@[2] + @[5] - @[0]"_fu, PARZERO_queue);
    ARROPS_fPM0yqMu("0,1,2,3,4"_fu, "shift()"_fu, "@[0] + @[2] - @[3]"_fu, PARZERO_queue);
    ARROPS_fPM0yqMu("0,1,2,3,4"_fu, "insert(1, 5)"_fu, "@[2] + @[5] - @[1]"_fu, PARZERO_queue);
    ARROPS_fPM0yqMu("0,1,2,3,100"_fu, "splice(1, 3)"_fu, "@.len + @[0] + @[1] - 102"_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let OPERATORS = [ \"+\", \"-\", \"*\", \"/\" ];\n\n        fn main()\n            OPERATORS[2] == \"*\" ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Y { b: bool; }\n        struct X { y: Y[]; }\n\n        mut x: X[];\n        x.push( X([ Y(true) ]) );\n\n        return x.len + x[0].y.len * 2 - 3;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct SelfRec { x: SelfRec[]; };\n        fn main() SelfRec( [ SelfRec() ] ).x.len - 1; // <- solved with a dirty selfrec & defctor\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct ABRec { x: BARec[]; };\n        struct BARec { x: ABRec[]; };\n        fn main() ABRec( [ BARec() ] ).x.len - 1; // <- solved with a dirty selfrec & defctor\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct ABRec { x: BARec[]; y: ABBARec[]; };\n        struct BARec { x: ABRec[]; y: ABBARec[]; };\n        struct ABBARec { x: ABRec[]; y: BARec[]; };\n        fn main() ABRec( [ BARec() ], [ ABBARec() ] ).x.len - 1; // <- solved with a dirty selfrec & defctor\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        mut a = [7, 1, 5, 3, 99, -13]; // [-13, 1, 3, 5, 7, 99]\n        a.sort();\n        return a[0] + a[1] + a[3] + a[4];\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let a = [0, 1, 2, 3];\n        let b = a.slice(1, 3);\n        return b.len - b[1];\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let a = [0, 1, 2, 3];\n        let b = a.slice(1);\n        return b.len - b[2];\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn collectDedupes(mut vals<alt>: i32[]</alt>) {\n            vals.sort();\n            return vals[0];\n        }\n\n        fn main() {\n            let vals = [ 1, 0 ];\n            return collectDedupes(vals);\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn sort01(ref arr: [$T]) {\n            mut tmp: $T;\n            if (arr[0] > arr[1]) {\n                swap(arr[0], tmp);\n                swap(arr[1], tmp);\n            }\n        }\n\n        fn collectDedupes(mut vals) {\n            vals.sort01();\n            return vals[0];\n        }\n\n        fn main() {\n            let vals = [ 1, 0 ];\n            return collectDedupes(vals);\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        mut str = \"hello \";\n        str ~= \"world\";\n\n        return str.len - 11;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let str = \"hello \" ~ \"world\";\n\n        return str.starts(with: \"hel\")\n             ? str  .ends(with: \"rld\")\n             ? str.len - 11\n             : 171\n             : 173;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let str = \"a\" ~ 1710010;\n\n        return str == \"a1710010\"\n             ? 0 : 101;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let str = \"hello world\";\n        mut cpy = \"\";\n        for (mut i = 0; i < str.len; i++)\n            cpy ~= str[i];\n\n        return (cpy.len - 11) + (cpy == str ? 0 : 1);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        return \"hello world\".find(\"world\")\n             - 2 * [1, 7, 13, 14, 19].find(14);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        return (\"hello world\".has(\"world\") ? 1 : 0)\n             + ([1, 14, 96, 2].has(14)     ? 2 : 0)\n             - 3;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let hw = \"hello world!\";\n        let a = hw.slice(6, 6 + 5);\n        let b = hw.substr(6, 5);\n        return a == b && a == \"world\" ? a.len - 5 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let tests =\n        [\n            \"\",\n            \" \",\n            \"  \",\n            \"hey you duders\",\n            \" hey you duders\",\n            \"hey you duders \",\n            \"  hey you duders \",\n            \"  hey you  duders \",\n            \"  hey you  duders  \"\n        ];\n\n        fn test(item: string)\n            item == item.split(\" \").join(\" \")\n                ? 0\n                : item.len;\n\n        mut sum = 0;\n        for (mut i = 0; i < tests.len; i++)\n            sum += test(tests[i]);\n\n        return sum;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            let sj = \"heelloo\"  .split(\"ee\").join(\"e\")\n                                .split('o').join(\"o!\")\n                                .split(\"he\").join();            ;; DuplicateFunctions\n\n            return sj == \"llo!o!\" ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() '\\e'.i32 - 27\n             ||   '\\0'.i32\n             || '\\x11'.i32 - 17\n             || '\\xaA'.i32 - 170;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main()   <fail unterminated char literal 3:13+2>\n            'c      <fail/>  // '\n            'c\n            '       <pass/>\n            'c'     </fail>\n                .i32 - 99;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main()   <fail invalid char literal 3:13+4>\n            'cb'    <pass/>\n            'c'     </fail>\n                .i32 - 99;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main()   <fail unterminated string use backticks 3:13+2>\n            \"c      <fail/>  // \"\n            \"c\n            \"       <pass/>\n            `c\n            `      </fail>\n                [0].i32 - 99;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main()                           <fail invalid code point 3:14+10>\n            \"\\u{ffffff}\".u32               <pass/>\n            \"\\u{042e}\" == \"\xD0\xAE\"  ? 0 : 1     </fail>\n            ;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            mut hello = \"hello\";\n            mut olleh = hello;\n            olleh.reverse();\n            return olleh == \"olleh\" ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main()\n            \"hello\".replace(all: \"h\", with: \"H\") == \"Hello\" &&\n            \"hello\".replace(all: 'e', with: 'E') == \"hEllo\" &&\n            \"hello\".replace(all: \"l\", with: 'L') == \"heLLo\" &&\n            \"hello\".replace(all: 'o', with: \"O\") == \"hellO\" &&\n            \"hello\".replace(all: \"l\", with:  []) == \"heo\"\n                ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn cnct(a: string, b: string) a ~ b;\n\n        fn main()\n            cnct( <fail missing comma before world 6:29>\n                a: \"hello, \"`world!\n` <pass/>\n                a: \"hello, \", `world!\n` </fail>\n            ).len - 14;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() (\"\" ~ \"\").len;\n    "_fu, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        let empty_str = \"\";\n    "_fu, "\n        fn main() = _0::empty_str.len;\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        let empty_str = \"\";\n        let empty_str_ref = empty_str;\n    "_fu, "\n        fn main() = _0::empty_str_ref.len;\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        let non_empty_str = \"This is a non-empty string that's too long for small string opti.\";\n        let non_empty_str_ref = non_empty_str;\n    "_fu, "\n        fn main() = _0::non_empty_str_ref.len - 65;\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        let non_empty_str = \"This is a non-empty string that's too long for small string opti.\";\n        let non_empty_slice = non_empty_str[5:];\n    "_fu, "\n        fn main() = _0::non_empty_slice.len - 60;\n    "_fu } }, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let strA = \"0123456789abcdef0123456789ABCDEF\";\n\n        fn main()\n        {\n            let a0 = mem::ALLOC_STAT_COUNT();\n            strA.slice(0, 26) == \"0123456789abcdef0123456789\" || throw(\"bad slice\");\n\n            let a1 = mem::ALLOC_STAT_COUNT();\n            a0 == a1 || throw(\"did alloc\");\n\n            return 0;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let strA = \"0123456789abcdef0123456789ABCDEF\";\n\n        fn main()\n            strA.slice(26, 32) == \"ABCDEF\"\n                ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct NotAString { hey: string };\n        fn main() {\n            mut a = \"Hello\";\n            mut b = NotAString(\"World!\");\n            <fail NotAString not a string 7:22+1>\n            return a < b ? 0 : 1;         <pass/>\n            return a < b.hey ? 0 : 1;     </fail>\n        }\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        mut x: Map(string, i32);\n\n        x[\"hello\"] = 1;\n        x[\"world\"] = 2;\n\n        return x[\"hello\"] - x[\"world\"] + 1;\n    "_fu, "Map is not defined"_fu, testdiffs);
    TODO_bvxMZmIw("\n        mut x: Map(string, i32);\n\n        x[\"hello\"] = 1;\n        x[\"world\"] = 2;\n\n        let b = \"hello world\";\n        mut offset = 0;\n\n        fn pop(): string {\n            mut a = \"\";\n\n            while (offset < b.len) {\n                let c = b[offset++];\n                if (c == ' ')\n                    break;\n\n                a ~= c;\n            }\n\n            return a;\n        }\n\n        return x[pop()] - x[pop()] + 1;\n    "_fu, "Map is not defined"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        fn test(a = 1, b = 2) a + b;\n        return test() - 3;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(a = 1, b = 2) a + b;\n        return test(b: -1);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(a = 1, b = 2) a + b;\n        return test(-2);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Test { a?: i32; b?: i32; }\n        let t = Test(1);\n        return t.a - 1 + t.b * 7;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Test { a?: i32; b?: i32; }\n        let t = Test(1);\n        return t.b;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Test { a?: i32; b?: i32; }\n        let t = Test(a: 1);\n        return t.a - 1 + t.b * 7;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Test { a?: i32; b?: i32; }\n        let t = Test(b: 1);\n        return t.b - 1 + t.a * 7;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Test { x?: i32; };\n        fn hey() Test();\n        return hey.x;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Test { x?: i32; };\n        fn hey(y: i32 = 0)\n            y   ? Test(1)\n                : Test();\n\n        return hey.x;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        <fail bad call>\n        fn test(a = \"hello\") a.len;     <pass/>\n        fn test(a = 0) a + 1;           </fail>\n        fn main() test(-1);\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        fn test(a = 3, b = a * 2) a + b;\n        fn main() test + test(a: -1) * 3;\n    "_fu, "no implicit test:a in scope"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        fn woot(ref a: i32, ref b: i32) {\n            ref c = a || b;\n            fn arg_defaulted_to_closure(ref x = c)\n                x *= 2;\n\n            arg_defaulted_to_closure( );\n            arg_defaulted_to_closure(a);\n            arg_defaulted_to_closure(b);\n        }\n\n        fn main() {\n            mut a = 1;\n            mut b = 1;\n            woot(a, b);\n            return a == 4 && b == 2 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(ref a: i32, mut incr: i32) {\n            fn woot(ref x, ref b = a) { // 'a' closes over here!\n                if (x & 1) {\n                    x /= 2;\n                    return test(x, b);\n                }\n                return b += x;\n            }\n\n            return woot(incr<alt>, a</alt>);\n        }\n\n        fn main() {\n            mut x = 10;\n            return test(x, 5) == 12 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Arg { name: string };\n        fn main() {\n            let arg = Arg(<fail argument name id>id<pass/>name</fail>: \"hey\");\n            return arg.name.len - 3;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn uses_implicit(implicit ref sum: i32) {\n            return sum++;\n        }\n        <split/>\n        inline fn inline_implicit_from_defarg(hello: i32, defaulted_argument: i32 = uses_implicit) {\n            return hello * defaulted_argument;\n        }\n        <split/>\n        fn main() {\n            implicit mut sum = 3;\n            let res = inline_implicit_from_defarg(sum);         ;; GNUStmtExpr\n            return sum == 4 && res == 9 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        // reduct: inline_implicit_from_defarg ooe bug\n        fn main() {\n            <alt>\n            return ooe_block_arg(z: 0, a: 3);\n        }\n\n        fn ooe_block_arg(mut z: i32, mut a: i32) {\n            <alt/>\n            mut z = 0;\n            mut a = 3;\n            return ooe_block_arg(:z, :a);\n        }\n\n        fn ooe_block_arg(ref z: i32, ref a: i32) {\n            <alt/>\n            mut z = 0;\n            mut a = 3;\n            </alt>\n                        ;; N_BckMustSeq\n            <alt>\n            let res = a * { ref x = z || a; x++ };              ;; GNUStmtExpr\n            return a == 4 && res == 9 ? 0 : 1;\n            <alt/>\n            let res = { ref x = z || a; x++ } * a;              ;; GNUStmtExpr\n            return a == 4 && res == 12 ? 0 : 1;\n            </alt>\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        // reduct: inline_implicit_from_defarg\n        fn test(ref a: i32, ref z: i32) {\n            <alt>\n            inline                                              ;; N_BckMustSeq\n            <alt/>\n            noinline                                            ;; N_AARMustSeq\n            </alt>\n            fn ooe_closure(ref hello<alt>: i32</alt>) {\n                let res = hello * { ref x = z || a; x++ };      ;; GNUStmtExpr\n                hello += 10;\n                return res;\n            }\n\n            let res = ooe_closure(a);\n            return a == 14 && res == 9 ? 0 : 1;\n        }\n\n        fn main() {\n            mut a = 3;\n            mut z = 0;\n            return test(:a, :z);\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        // gcc doesn't cg RTL with just * for this testcase, but this breaks it\n        noinline fn mul(a: i32, b: i32) = a * b;\n\n        // reduct: inline_implicit_from_defarg\n        fn test(ref a: i32, ref z: i32) {\n            <alt>\n            inline                                              ;; N_BckMustSeq\n            <alt/>\n            noinline                                            ;; N_AARMustSeq\n            </alt>\n            fn ooe_closure(ref hello<alt>: i32</alt>) {\n                let res = mul({ ref x = z || a; x++ }, hello);  ;; GNUStmtExpr\n                hello += 10;\n                return res;\n            }\n\n            let res = ooe_closure(a);\n            return a == 14 && res == 12 ? 0 : 1;\n        }\n\n        fn main() {\n            mut a = 3;\n            mut z = 0;\n            return test(:a, :z);\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        inline fn uses_implicit_inside() {\n            inline fn uses_implicit(implicit ref sum: i32) {\n                return sum++;\n            }\n\n            return uses_implicit;\n        }\n\n        <alt>\n        inline                                                  ;; GNUStmtExpr\n        <alt/>\n        ;; N_BckMustSeq\n        </alt>\n        fn inline_implicit_from_defarg(hello: i32, defaulted_argument: i32 = uses_implicit_inside) {\n            return hello * defaulted_argument;\n        }\n\n        fn main() {\n            implicit mut sum = 3;\n            let res = inline_implicit_from_defarg(sum);\n            return sum == 4 && res == 9 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        inline fn uses_implicit(implicit ref sum: i32) = sum++;\n        inline fn uses_implicit_inside() = uses_implicit;\n\n        <alt>\n        inline                                                  ;; GNUStmtExpr\n        <alt/>\n        ;; N_BckMustSeq\n        </alt>\n        fn inline_implicit_from_defarg(defaulted_argument: i32 = uses_implicit_inside, hello: i32 = 0)\n            hello * defaulted_argument;\n\n        fn main() {\n            implicit mut sum = 3;\n            let res = inline_implicit_from_defarg(hello: sum);\n            return sum == 4 && res == 12 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            struct Type { canon: string };\n\n            mut _lookups: int;\n            mut _t_bool: Type;\n\n            fn t_bool() {\n                return _t_bool ||= Scope_lookupType(\"bool\");\n            }\n\n            fn Scope_lookupType(canon: string) {\n                _lookups++;\n                return Type(:canon);\n            }\n\n            fn check(a<alt>: Type</alt>, b = t_bool) {\n                return a.canon.len + b.canon.len;\n            }\n\n            return check(t_bool) + _lookups - 9;\n        }\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        struct Type { canon: string };\n        struct Node { kind: string; value: string };\n        struct SolvedNode { value: string; type: Type };\n\n        fn solve(root: Node)\n        {\n            mut _t_bool: Type;\n\n            fn createBool(value: string, type = t_bool)\n                return SolvedNode(:value, :type);\n\n            fn solveNode(node: Node)\n                return node.kind == \"bool\"\n                    && createBool(:node.value);\n    <alt>\n            fn solveNode(canon: string)\n                return Type(:canon);\n\n            fn t_bool()\n                return _t_bool ||= solveNode(\"t_bool\");\n    <alt/>\n            fn t_bool()\n                return _t_bool ||= Type(\"t_bool\");\n    </alt>\n            return solveNode(root);\n        }\n\n        fn main() {\n            let s = solve(Node(kind: \"bool\", value: \"Hello!\"));\n            return s.value      == \"Hello!\"\n                && s.type.canon == \"t_bool\"\n                    ? 0 : 1;\n        }\n    "_fu, "Declaration cycle 10:16+10"_fu, testdiffs);
    TODO_bvxMZmIw("\n        struct Type { canon: string };\n        struct Node { kind: string; value: string };\n        struct SolvedNode { value: string; type: Type };\n\n        fn createBool(value: string, type = t_bool)\n            return SolvedNode(:value, :type);\n\n        fn solveNode(node: Node)\n            return node.kind == \"bool\"\n                && createBool(:node.value);\n<alt>\n        fn solveNode(canon: string)\n            return Type(:canon);\n\n        fn t_bool(implicit ref _t_bool: Type)\n            return _t_bool ||= solveNode(\"t_bool\");\n<alt/>\n        fn t_bool(implicit ref _t_bool: Type)\n            return _t_bool ||= Type(\"t_bool\");\n</alt>\n        fn solve(root: Node)\n        {\n            implicit mut _t_bool: Type;\n            return solveNode(root);\n        }\n\n        fn main() {\n            let s = solve(Node(kind: \"bool\", value: \"Hello!\"));\n            return s.value      == \"Hello!\"\n                && s.type.canon == \"t_bool\"\n                    ? 0 : 1;\n        }\n    "_fu, "Declaration cycle 11:30+1"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        fn woot(hello!?, world!?) {\n            hello(one?: 1);\n            world(two?: 2);\n        }\n\n        fn main() {\n            mut res = 0;\n            woot(hello: |one| res += one);                      ;; DuplicateFunctions\n            woot(world: |two| res += two);\n            return res - 3;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn woot(hello!?, world!?) {\n            hello(one?: 1);\n            world(two?: 2);\n        }\n\n        fn main() {                                             ;; DuplicateFunctions\n            mut res = 0;\n            <fail duplicate explicitly named argument hello 10:17+1>\n            woot(hello: |one| res += one, hello: |one| res += one); <pass/>\n            woot(hello: |one| res += one, world: |two| res += two); </fail>\n            return res - 3;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let s = 7;\n        return s ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let s = 0;\n        return s ? 1 : 0;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let s = \"hello\";\n        return s ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let s = \"\";\n        return s ? 1 : 0;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let s = [ 4 ];\n        return s ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        mut s = [ 4 ];\n        s.pop();\n        return s ? 1 : 0;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct S { x: i32; }\n        let s: S = S(1);\n        return s ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct S { x: i32; }\n        let s: S;\n        return s ? 1 : 0;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        mut sum = 0;\n        :OUTER for (mut y = 1; y < 10; y++)\n        {\n            sum += y * 10; // 10, 20\n            for (mut x = 1; x < 10; x++)\n            {\n                sum += x; // 1, 1, 2\n                if (y == 1) continue :OUTER;                    ;; Goto\n                if (x == 2) break    :OUTER;\n            }\n        }\n\n        return sum - 34;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn for_fn(mut i: i32, n: i32, visit)\n            for (; i < n; i++)\n                visit(i);\n\n        mut sum = 0;\n        :OUTER for_fn(1, 10): |y| // same as above but via helper fn\n        {\n            sum += y * 10; // 10, 20\n            for_fn(1, 10): |x|\n            {\n                sum += x; // 1, 1, 2\n                if (y == 1) continue :OUTER;                    ;; Goto\n                if (x == 2) break    :OUTER;\n            }\n        }\n\n        return sum - 34;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn twice(what)\n            for (mut i = 0; i < 2; i++)\n                what(i);\n\n        mut x = 0;\n        :TWICE twice: |i<alt>: int</alt>| {\n            x += i;\n            if (!x++) continue :TWICE;\n        }\n\n        return x - 3;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        mut sum = 0;\n        :OUTER for (mut x = 0;; x++) {\n            for (mut y = 0; y < x; y++) {\n                if (y & 1 && !(x & 1))\n                    continue :OUTER;                            ;; Goto\n\n                sum += x;\n            }\n\n            sum += x * 1000 + 100;\n            if (x > 1) ;; EXPECT break;\n                break; // anon\n        }\n\n        // x=0:           + 0100\n        // x=1: 1         + 1100\n        // x=2: 2\n        // x=3: 3 + 3 + 3 + 3100 break\n        return sum - 4312;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(ref sum: i32) {\n            :FIRST {\n                if (sum & 1)\n                    break:\n                        FIRST;\n                sum++;\n            }\n            :SECOND {\n                if (sum & 1)\n                    break:\n                        <fail label>\n                        FIRST;      <pass/>\n                        SECOND;     </fail>\n                sum++;\n\n                if (sum & 2)\n                    break:\n                        SECOND;\n                sum++;\n            }\n        }\n\n        fn main() {\n            mut sum = 0;\n            test(sum);\n            return sum - 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let x = \"hello\";\n        lax let y = \"world\";\n        let w = x || y;\n\n        return w == \"hello\" ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let x = \"hello\";\n        let y = \"world\";\n        let w = x && y;\n\n        return w == \"world\" ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let x = \"hello\";\n        lax let y = \"world\";\n        let w = 3 && x || y;\n\n        return w == \"hello\" ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let x = \"hello\";\n        let y = \"world\";\n        let arr: i32[];\n        let w = arr && x || y;\n\n        return w == \"world\" ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let x = \"hello\";\n        let y = \"world\";\n        let arr: i32[];\n        let w = arr && x || y || throw(\"Nope.\");\n\n        return w == \"world\" ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn what(a: i32) {\n            a == 2 || a & 1 || throw(\"what1\");\n            a  > 1 && a & 1 && throw(\"what2\");\n            a  > 0 && a & 3 || throw(\"what3\");\n            return a + 4;\n        }\n        fn main() 1.what - 2.what + 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn gen(len: i32) {\n            mut res: i32[];\n            for (mut i = 0; i < len; i++) res ~= i;\n            return res;\n        }\n        fn test(len: i32) {\n            let x = [-5, +5];\n            let y = len.gen && x;\n            return x[y.len / 2];\n        }\n        fn main() 0.test + 1.test;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn is_mutref(t: string)     t.len == 6;\n        fn is_never(t: string)      t.len == 5;\n\n        fn test(ref init: string, ref annot: string)\n            init.is_mutref && annot ||\n            init.is_never  && annot || throw(\"noreturn\");\n\n        fn main() {\n            mut annot = \"hey!\";\n            mut init = \"woot!\";\n            return test(:init, :annot).len - 4;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(mut init: string) {\n            init.len && init || throw(\"noreturn\");\n            return init.len;\n        }\n\n        fn main() test(\"woot!\") - 5;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn is_mutref(t: string)     t.len == 6;\n        fn is_never(t: string)      t.len == 5;\n        let F_ARG = 1;\n\n        fn test(ref init: string, ref annot: string, mut flags: i32) {\n            init.is_mutref  || init.is_never  && annot\n                            || !init && flags & F_ARG\n                            || throw(\"noreturn\");\n            return flags;\n        }\n\n        fn main() {\n            mut annot = \"hey!\";\n            mut init = \"woot!\";\n            return test(:init, :annot, 0);\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn a(a)  a ?  a : [];   // ifs used cons-type to seed alt-type\n        fn b(b) !b ? [] : b;    //  which works for 'a', but not for 'b'.\n        fn main() 1.a - 1.b;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Type { i: i32 };\n        fn is_mutref (t: Type) !!(t.i & 3);\n        fn is_ref    (t: Type) !!(t.i & 1);\n        fn clear_refs(t: Type) Type(t.i &~ 3);\n\n        fn tryClearRefs(t: Type, mutref?: bool): Type =     // type-hints vs type-assertions:\n            (mutref ? t.is_mutref : t.is_ref)               //  solveBlocks used within '&&' and '?'\n                && clear_refs(t);                           //   so the '?' complained 'bool' doesnt assign to 'Type'\n\n        fn main() {\n            let a = tryClearRefs(Type(6), true);\n            let b = tryClearRefs(Type(6), false);\n            return a.i + b.i - 4;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn ambig_or(x: i32, y: f32)\n            \"Hello: \" ~\n                <fail ambig operand non bool context>       // So it happened that at some point I had an 'a || b'\n                    (x || y)                  <pass/>       //  where a and b were of the same type used in string concat like this,\n                    (x || y.i32)              </fail>       //   and then later when the types no longer matched this fell back silently to a '!!a || !!b'\n                ;                                           //    which was is not the intent but compiled fine because str concat also accepts bool.\n\n        fn main() {\n            mut res = ambig_or(1, 2);\n            return res == \"Hello: 1\" ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn unambig_or(b: bool, i: i32, f: f32)  <alt>\n            b || i || f;                        <alt/>      // But currently the thinking is that so long as one operand is a bool\n            i || f || b;                        </alt>      //  the whole thing should weaken to (!!a || !!b) instead of erroring out.\n\n        fn main() = unambig_or(false, 0, 0).i32;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Node { items: Node[] };\n\n        fn isFieldChain(arg: Node) {\n            if (arg.items.len > 1)\n                return false;\n\n            return !arg.items || isFieldChain(arg.items[0]);\n        }\n\n        fn main() {\n            let empty       = Node();\n            let chain       = Node([ Node ]);\n            let not_chain   = Node([ Node, Node ]);\n\n            return empty.isFieldChain\n                && chain.isFieldChain\n                && !not_chain.isFieldChain ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn underconcat(dedupe: string, sighash: string)\n            dedupe && sighash\n                ? dedupe ~ '_' ~ sighash\n                : dedupe || sighash;\n\n        fn main() {\n            let a   = underconcat(\"a\", \"\");\n            let b   = underconcat(\"\", \"b\");\n            let c   = underconcat(\"\", \"\");\n            let ab  = underconcat(\"a\", \"b\");\n\n            let res = a ~ \",\" ~ b ~ \",\" ~ c ~ \",\" ~ ab;\n            return res == \"a,b,,a_b\" ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        <alt>\n        noinline                <alt/>\n        inline    ;; GNUStmtExpr</alt>\n        fn twiceUnlessEmpty(x) {\n            return x && [ x, x ];\n        }\n\n        fn main() {\n            return  twiceUnlessEmpty(2)\n                && !twiceUnlessEmpty(0) ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn hello(ref str) {\n            str ~= \"world\";\n            <fail condition is void 9:17+1 2:12+5>  <pass/>\n            return str.len & 1;                     </fail>\n        }\n\n        fn main() {\n            mut str = \"hello, \";\n            if (!hello(str)) str ~= \"!\";\n            return str.len - 13;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(x: i32) {\n            <fail y is not defined 6:24+1>\n            if (x > 1) let y = 20;      <pass/>\n            let y = x > 1 && 20;        </fail>\n\n            return x + y;\n        }\n\n        fn main() test(7) - 27;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(x: i32) {\n            <fail misleading indent 5:13+3>\n            if (x > 1)\n            let y = 20;                 <pass/>\n            let y = x > 1 && 20;        </fail>\n\n            return x + y;\n        }\n\n        fn main() test(7) - 27;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        mut i = 7;\n        i ||= 11;\n        return i - 7;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        mut i = 0;\n        i ||= 11;\n        return i - 11;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        mut a = 1;\n        mut b = 0;\n        a ||= ++b;\n        return  b;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        mut CHANGE = false;\n        CHANGE ||= true;\n        return CHANGE.i32 - 1;\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        mut m: Map(string, string);\n        mut g = 0;\n\n        m[\"hello\"] = \"world\";\n        fn f() {\n            g++;\n            return \"cruel world\";\n        }\n\n        m[\"hello\"] ||= f();\n        return g;\n    "_fu, "Map is not defined"_fu, testdiffs);
    TODO_bvxMZmIw("\n        mut m: Map(string, string);\n        mut g = 0;\n\n        m[\"_not_hello_\"] = \"world\";\n        fn f() {\n            g++;\n            return \"cruel world\";\n        }\n\n        m[\"hello\"] ||= f();\n        return g - 1;\n    "_fu, "Map is not defined"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        fn and_incr(ref x: i32, v: i32)\n            x &&= x + v;\n\n        fn main() {\n            mut x: i32 = 0;\n            and_incr(x, 10);\n            return x;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Test { x: i32; }\n        fn test(t: &mut Test) t.x++;\n        mut t = Test();\n        <fail orphan call () 9:9+1>\n        t.test;             <pass/>\n        t.test();           </fail>\n        return t.x - 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        {\n            {\n                return 0;\n            }\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        {\n        <fail block>\n        {\n            return 0;\n        }\n        <pass/>\n            {\n                return 0;\n            }\n        </fail>\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        {\n            return 0;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        {\n            return 0;\n        <fail block>\n       }\n        <pass/>\n        }\n        </fail>\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        {\n            return 0;\n        <fail block>\n         }\n        <pass/>\n        }\n        </fail>\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let y = [ 1 ];              ;; TODO fu::slate<1, int> y\n        let <fail unused><pass/>lax</fail>\n            z = [ 2 ];              ;; TODO fu::slate<1, int> z\n\n        return y[0] - 1\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn fail(a: string) throw(\"hey: \" ~ a);\n        fn hello(a: string,\n            <fail unused><pass/>lax</fail>\n            b: string)\n                a && fail(a) ? b : a;\n\n        fn main() hello(\"\", \"nope\").len;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn incr(ref x: i32) x++;\n        fn lints_ambig_expr_indent(ref a: i32, ref b: i32) {\n            return a.incr\n            <fail indent>\n            +\n            <pass/>\n              +\n            </fail>\n                b.incr;\n        }\n\n        fn main() {\n            mut a = 0; mut b = 0;\n            lints_ambig_expr_indent(a, b);\n            return a - b;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn lints_ambig_jump_semis(mut x: i32) {\n            <fail indent>\n            return\n            x;\n            <pass/>\n            return x;\n            </fail>\n        }\n\n        fn main() 0.lints_ambig_jump_semis;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn incr(ref a: i32) ++a;\n        fn A(ref a: i32) a || <fail parenthes left side>\n                              a = A(incr(a));    <pass/> // Lint should complain here,\n                             (a = A(incr(a)));   </fail> //  this was an honest mistake.\n\n        fn main() { mut v = 0; return A(v) - 1; }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(is_mutref: bool, args: i32[], ref sum: i32) {\n            <fail indent else>\n            if (is_mutref)\n                for (mut i = 0; i < args.len; i++)\n                    if (args[i] & 1)\n                        sum += args[i];\n            <pass/>\n            if (is_mutref) {\n                for (mut i = 0; i < args.len; i++)\n                    if (args[i] & 1)\n                        sum += args[i];\n            }\n            </fail>\n            else\n                for (mut i = 0; i < args.len; i++)\n                    if (args[i] & 2)\n                        sum += args[i];\n        }\n\n        fn main() {\n            mut sum = 0;\n            test(true , [ 1,  2,  3  ], sum);\n            test(false, [ 11, 22, 33 ], sum);\n            return sum - 1 - 3 - 11 - 22;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        //\n        // The -1.abs problem.\n        //\n        // Ruby lexes the minus into the numeric literal.\n        //  This is kinda inconsistent, altough it does make sense.\n        //\n        // Rust & all c-likes lex to -abs(1).\n        //  Rust linters warn about this.\n        //\n        // One thing we can do is change the precedence of some unaries\n        //  to above method call - others, like ! benefit from usual precedence.\n        //   In my experience, the unary * op in c/cpp always disappoints re: precedence,\n        //    but the & op usually works the way you want it to.\n        //     So introducing more precedence rules is a really questionable idea.\n        //\n        // We'll go the rust way for starters,\n        //  this will be a compile time error for now.\n        //\n        fn test()   <fail parenthes explicit>\n            -1.0    <pass/>\n            (-1.0)  </fail>\n                .abs;\n\n        fn main() test ? 0 : 7;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn id(x) = x;\n        fn main() {\n            return id(\n                0 +\n            <fail ambig indent>\n               0  <pass/>\n                0 </fail>\n            );\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn doStuff(stuff) {\n            stuff();\n        }\n\n        fn main() {\n            doStuff(\n                <alt>\n                stuff: |_?| {\n                <alt/>\n                stuff: |_?|\n                {\n                <alt/>\n                stuff: |\n                    _?| {\n                <alt/>\n                stuff: |\n                    _?|\n                {\n                </alt>\n                    return 0;\n                });\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn doStuff(stuff) {\n            stuff();\n        }\n\n        fn main() {\n            <alt>\n            doStuff(stuff: || {\n            <alt/>\n            doStuff(stuff: ||\n                {\n            </alt>\n                    return 0;\n                });\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        noinline fn test(ref a: i32, ref b: i32) {\n            return (++a) + 10 * (++b);                          ;; N_AARMustSeq\n        }\n\n        fn main() {                                             ;; N_AARSoftRisk\n            mut x = 0;\n        <alt>\n            let z = test(x, x);\n        <alt/>\n            ref y = x;\n            let z = test(x, y);\n        </alt>\n            return x == 2 && z == 21 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        noinline fn test_inner(ref a: i32, ref b: i32)\n            (++a) + 10 * (++b);                                 ;; N_AARMustSeq\n\n        noinline fn test_outer(ref a: i32, ref b: i32)\n            test_inner(a, b);\n\n        fn main() {                                             ;; N_AARSoftRisk\n            mut x = 0;\n        <alt>\n            let z = test_outer(x, x);\n        <alt/>\n            ref y = x;\n            let z = test_outer(x, y);\n        </alt>\n            return x == 2 && z == 21 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        noinline fn test(ref a: i32[]) {\n            ref b = a[0];\n            if (a.len & 1) {\n                <fail invalidate 9:13 6:19>\n                a ~= 1; // Invalidates 'b'.\n                <pass/>\n                b++;\n                </fail>\n            }\n            b++;\n        }\n\n        fn main() {\n            mut arr = [ 1 ]; test(arr);\n            mut sum = 0;\n            for (mut i = 0; i < arr.len; i++) sum += arr[i];\n            return sum - 3;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        nocopy struct nci32 { i: i32; };\n\n        noinline fn test(ref a: nci32, b: nci32) a.i++ || b.i;\n        fn main() {\n            mut x = nci32(0);\n            <fail arguments b and a both alias var x 6:17+1>\n            ref y = x;                        <pass/>\n            let y = nci32(0);                 </fail>\n\n            return test(x, y);\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        noinline fn test(ref a: i32[]) {\n            ref b = a[0];\n            if (a.len & 1) { // Lets be extra sure here.\n                <fail invalidate 7:17 6:19>\n                a ~= 1; // Invalidates 'b'.\n                b++;\n                <pass/>\n                b++;\n                a ~= 1;\n                </fail>\n            }\n        }\n\n        fn main() {\n            mut arr = [ 1 ]; test(arr);\n            mut sum = 0;\n            for (mut i = 0; i < arr.len; i++) sum += arr[i];\n            return sum - 3;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        noinline fn test(ref a: i32[]) {\n            ref b = a[0];\n            for (mut i = 2; i --> 0; )\n            {\n                b++; // Same thing but reordered as a loop.\n                if (a.len & 3) {\n                    <fail inval next iter 9:23 6:17>\n                    a ~= 1; // Invalidates 'b'.\n                    <pass/>\n                    b++;\n                    </fail>\n                }\n            }\n            a ~= 100; // Invalidates 'b' but that's fine!\n        }\n\n        fn main() {\n            mut arr = [ 1 ]; test(arr);\n            mut sum = 0;\n            for (mut i = 0; i < arr.len; i++) sum += arr[i];\n            return sum - 105;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        noinline fn test(ref a: i32[]) {\n            ref b = a[0];\n            for (mut i = 2; i --> 0; )\n            {\n                if (i & 1) {\n                    b += 2; // Same thing but reordered as a loop.\n                }\n                else {\n                    <fail inval next iter 11:23 7:21>\n                    a ~= 1; // Invalidates 'b', same as a above, but now in an if/else -\n                    <pass/> //  got the used-in-a-loop stuff wrong when switching to cant_invalidate.\n                    b += 3;\n                    </fail>\n                }\n            }\n            a ~= 100; // Invalidates 'b' but that's fine!\n        }\n\n        fn main() {\n            mut arr = [ 1 ]; test(arr);\n            mut sum = 0;\n            for (mut i = 0; i < arr.len; i++) sum += arr[i];\n            return sum - 106;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        // both args alias, but there's no risk of inval.\n        noinline fn incr_a_or_b(ref a: i32, ref b: i32)\n            (a || b)++;\n\n        fn main() {\n            mut Z = 0;\n            mut A = 1;\n            mut B = 0;\n\n            incr_a_or_b(Z, B); // incr B, now 1\n            incr_a_or_b(A, B); // incr A, now 2\n            incr_a_or_b(B, B); // incr _target, now 2 // alias!\n\n            return (100*A + B) - 202;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct V { v: i32; };\n\n        fn main() {\n            mut A: V = [ 1 ];\n            ref a = A.v;\n            ref b = A.v;\n            ref c = a || b;\n            return ++++c - 3; // double mutation of a union\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct V { v: i32; };\n\n        fn main() {\n            mut A: V = [ 1 ];\n            ref a = A.v;\n            ref b = A.v;\n            return ++++(a || b) - 3; // same, without a helper var\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct V { v: i32; w?: i32; ww?: i32; };\n\n        fn main() {\n            mut A: V = [ 1 ];\n            mut B: V = [ 1 ];\n\n            <fail invalidate 20:20 18:15>\n            ref aa = A.v || A.w; <pass/>\n            fn  aa = A.v || A.w; </fail>\n\n            ref bb = B.v || B.w;\n            ++++bb;\n\n            ref a = A.v || A.ww;\n            ref b = B.v || B.ww;\n\n            ref c = a || b;\n            ++++c;\n\n            return aa - 3; // same, without a helper var\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        // a can alias b\n        // c can alias d\n        noinline fn ab_cd(ref a: i32, ref b: i32, ref c: i32, ref d: i32) {\n            ref ab = a || b;\n            ref cd = c || d;\n            ++++ab;\n            ++++cd;\n        }\n\n        fn main() {\n            mut ab = 0;\n            mut cd = 0;\n\n            <fail alias>\n            ab_cd(ab, cd, ab, cd); <pass/>\n            ab_cd(ab, ab, cd, cd); </fail>\n\n            return ab - cd;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct X { i: i32; j: i32; };\n        // a can alias b\n        // c can alias d\n        noinline fn ab_cd_defer(ref a: X, ref b: X, ref c: X, ref d: X, j?: bool) {\n            ref ab = a || b;\n            defer {\n                ref abi = j ? ab.j : ab.i;\n                ++++abi;\n            }\n            ref cd = c || d;\n            ref cdi = j ? cd.j : cd.i;\n            ++++cdi;\n        }\n\n        fn main() {\n            mut ab = X(0, 0);\n            mut cd = X(0, 0);\n\n            <fail alias>\n            ab_cd_defer(ab, cd, ab, cd); <pass/>\n            ab_cd_defer(ab, ab, cd, cd); </fail>\n\n            return ab.i - cd.i;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        // a can alias b\n        // c can alias d\n        noinline fn ab_cd_inner(ref a: i32, ref b: i32, ref c: i32, ref d: i32) {\n            ref ab = a || b;\n            ref cd = c || d;\n            ++++ab;\n            ++++cd;\n        }\n\n        noinline fn ab_cd_outer(ref a: i32, ref b: i32, ref c: i32, ref d: i32)\n            ab_cd_inner(a, b, c, d);\n\n        fn main() {\n            mut ab = 0;\n            mut cd = 0;\n\n            <fail alias>\n            ab_cd_outer(ab, cd, ab, cd); <pass/>\n            ab_cd_outer(ab, ab, cd, cd); </fail>\n\n            return ab - cd;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        // a can alias b\n        // c can alias d\n        // e can alias f\n        // g can alias h\n        noinline fn abcd_efgh(\n            ref a: i32, ref b: i32, ref c: i32, ref d: i32,\n            ref e: i32, ref f: i32, ref g: i32, ref h: i32)\n        {\n            ref ab = a || b; ref cd = c || d; ref abcd = ab || cd;\n            ref ef = e || f; ref gh = g || h; ref efgh = ef || gh;\n            ++++abcd; ++++ab; ++++cd;\n            ++++efgh; ++++ef; ++++gh;\n        }\n\n        fn main() {\n            mut ab = 0; mut cd = 0;\n            mut ef = 0; mut gh = 0;\n\n            <fail alias var cd 17:29+2>\n            abcd_efgh(ab, ab, cd, gh, ef, ef, cd, gh); <pass/>\n            abcd_efgh(ab, ab, cd, cd, ef, ef, gh, gh); </fail>\n\n            return (ab + cd) - (ef + gh);\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        noinline fn incr_a_or_b_and_b_or_a(ref a: i32, ref b: i32) {\n            ref x = a || b; ++x;\n            ref y = b || a; ++y;                                ;; N_AARSoftRisk\n        }\n\n        fn main() {\n            mut a = 0;\n\n            <alt>\n            incr_a_or_b_and_b_or_a(a, a);\n            <alt/>\n            ref b = a;\n            incr_a_or_b_and_b_or_a(a, b);\n            </alt>\n\n            return a - 2;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        // same as below -\n        //  but using a helper variable\n        //   which provides a \"name\" for the outcome of a|b.\n        noinline fn incr_a_or_b_by2_via_x(ref a: i32, ref b: i32) {\n            ref x = a || b;\n            ++++x;\n        }\n\n        fn main() {\n            mut Z = 0;\n            mut A = 2;\n            mut B = 0;\n\n            incr_a_or_b_by2_via_x(Z, B); // incr B, now 2\n            incr_a_or_b_by2_via_x(A, B); // incr A, now 4\n            incr_a_or_b_by2_via_x(B, B); // incr _target, now 4 // alias!\n\n            return (100*A + B) - 404;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        // same as above -\n        //  but notice we increment twice, which breaks current setup.\n        noinline fn incr_a_or_b_by2(ref a: i32, ref b: i32)\n            ++++(a || b);\n\n        fn main() {\n            mut Z = 0;\n            mut A = 2;\n            mut B = 0;\n\n            incr_a_or_b_by2(Z, B); // incr B, now 2\n            incr_a_or_b_by2(A, B); // incr A, now 4\n            incr_a_or_b_by2(B, B); // incr _target, now 4 // alias!\n\n            return (100*A + B) - 404;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        noinline fn alias(ref arr: i32[], ref item: i32) {\n            arr ~= 1;\n            return item;\n        }\n\n        fn main() {\n            mut a = [ 0 ];\n            <fail alias>\n            ref c = alias(a, a[0]);\n            <pass/>\n            mut b = [ 0 ];\n            ref c = alias(a, b[0]);\n            </fail>\n            return c++;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        noinline fn test(ref a: i32[], ref b: i32[]) {\n            <fail invalidate 7:28 6:30>\n            ref aa = a[0]; <pass/>\n            fn  aa() a[0]; </fail>\n\n            ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.\n            ref cc = bb || aa;     // Mustn't compile.\n            return cc;\n        }\n\n        fn main() { mut a = [ 0 ]; mut b = [ 0 ]; return test(a, b); }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        noinline fn test(ref a: i32[], ref b: i32[]) {\n            <fail invalidate 7:26 6:30>\n            ref aa = a[0]; <pass/>\n            fn  aa() a[0]; </fail>\n\n            ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.\n            return bb || aa;       // Same as above, but no explicit binding.\n        }\n\n        fn main() { mut a = [ 0 ]; mut b = [ 0 ]; return test(a, b); }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        noinline fn noop(x) x;\n        noinline fn test(ref a: i32[], ref b: i32[]) {\n            <fail invalidate 8:31 7:30>\n            ref aa = a[0]; <pass/>\n            fn  aa() a[0]; </fail>\n\n            ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.\n            return noop(bb || aa); // Same as above, but bound at callsite.\n        }\n\n        fn main() { mut a = [ 0 ]; mut b = [ 0 ]; return test(a, b); }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        noinline fn either(a, b) a || b;\n        noinline fn test(ref a: i32[], ref b: i32[]) {\n            <fail invalidate 8:31 7:30>\n            ref aa = a[0]; <pass/>\n            fn aa()  a[0]; </fail>\n\n            ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.\n            return either(bb, aa); // For completeness.\n        }\n\n        fn main() { mut a = [ 0 ]; mut b = [ 0 ]; return test(a, b); }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        noinline fn what(ref cond: i32, ref cons: i32)\n            cond && (cons += 1);\n\n        fn main() {\n            mut x = 1;\n            return what(x, x) - 2;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Target {\n            overload: i32[];\n            extended: i32[];\n        };\n\n        noinline fn which(ref t: Target, i: i32) i & 1\n            ? t.overload\n            : t.extended;\n\n        fn test(ref target: Target)\n        {\n            ref overload = target.which(target.overload.len);\n            ref extended = target.which(target.overload.len + 1);\n\n            mut change = false;\n            if (overload)\n            {\n                for (mut i = 0; i < overload.len; i++)\n                {\n                    let a = overload[i];\n                    let b = extended[i];\n                    if (a != b)\n                    {\n                        change = true;\n                        break;\n                    }\n                }\n            }\n\n            if (change)\n            {\n                extended[0] = 3;\n\n                shadow ref overload = target.which(target.overload.len);\n                overload[0] = 5; // Said write to overload invalidates ext on next loop iter.\n            }\n        }\n\n        fn main()\n        {\n            mut target = Target([ 0 ], [ 1 ]);\n            target.test();\n            return target.overload[0] * 10 + target.extended[0] * 100 - 350;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(ref a: i32, ref b: i32) {\n            a += b;\n            b += a;\n        }\n\n        struct AB { a: i32; b: i32 };\n\n        fn main() {\n            mut ab = AB(1, 2);\n<fail test:a test:b both alias ab 16:21+1>\n        <alt>\n            ref a = ab.a;\n            ref b = ab.a;\n        <alt/>\n            ref a = ab.b;\n            ref b = ab.b;\n        </alt>\n            test(a, b);\n<pass/>\n        <alt>\n            ref a = ab.a;\n            ref b = ab.b;\n            test(a, b);\n        <alt/>\n            ref a = ab.a;\n            test(a, ab.b);\n        <alt/>\n            test(ab.a, ab.b);\n        </alt>\n</fail>\n            return ab.b - 5;\n        }\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        struct Helper { vars: i32[]; };\n\n        fn test(ref _helpers: Helper[], helpers_idx: i32) {\n            ref old = _helpers[helpers_idx - 1].vars;\n            ref new = _helpers[helpers_idx    ].vars;\n            new    ~= old[helpers_idx];\n        }\n\n        fn main() {\n            mut helpers = [ Helpers([ 1, 2 ]), Helpers([ 4, 8 ]) ];\n            test(helpers, 1);\n            return helpers[1][2] - 2;\n        }\n    "_fu, "ref old 7:23+3"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        fn outer() {\n            mut sum = 0;\n            mut x = 1;\n            for (;;) {      // bck complained that the write to 'x' at the end\n                let v = x;  //  invalidates use of 'v' on next loop iter here, which is not true\n                for (mut i = 0; i < 10; i++) {\n                    sum += v;\n                    if (sum > 40)\n                        return sum;\n                }\n\n                x = v * 2;\n            }\n        }\n\n        fn main() outer - 42;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn append_self(ref a: i32[])\n        {\n            let b = a;\n            a ~= b; // b narrowed down to a slice which is non-copyable\n                    //  but it (unfortunately) wanted to copy to a temp.\n        }\n\n        fn main() {\n            mut arr = [1, 2];\n            arr.append_self();\n            return arr[2] + arr[3] - 3;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn but_is_it_pure(ref x: i32) {\n            <fail not pure 6:9 8:34 4:21>\n            return x++; <pass/>\n            return x;   </fail>\n        }\n        pure fn pure_fn(ref a: i32, ref b: i32) {\n            ref x = a || b;\n            return but_is_it_pure(x);\n        }\n        fn main() {\n            mut x = 0;\n            mut y = 0;\n            return pure_fn(x, y);\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        noinline fn inner(ref x: i32, n: i32) {\n            return outer(x, n);\n        }\n\n        noinline fn report_write_here(ref x: i32, n: i32) {\n            <fail outer 24:25 report_write_here 16:45 += 8:22>\n            return x += n;                             <pass/>\n            return x + n;                              </fail>\n        }\n\n        noinline fn outer(ref x: i32, n: i32) {\n            if (n & 3) {\n                if (n & 2)\n                    return inner(x, n / 2);\n                else\n                    return report_write_here(x, n);\n            }\n            else {\n                return inner(x, n + 1);\n            }\n        }\n\n        pure fn not_pure(ref x: i32, n: i32) {\n            return outer(x, n);\n        }\n\n        fn main() {\n            mut x = 0;\n            return not_pure(x, 0) == 1 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            mut _info: string[];\n\n            pure fn fail(mut reason: string = \"\") {\n                for (mut i = _info.len; i --> 0; ) {\n                    ref info = _info[i]; // notice the ref, has to relax away\n                    reason ~= info<alt> && i<alt/> ? i : []</alt>;\n                }\n\n                return reason;\n            }\n\n            return fail.len;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            mut _info = [ 101 ];\n\n            pure fn fail(mut reason: string = \"\") {\n                ref info = _info[0]; // <- notice the ref, has to relax away\n                reason ~= info<alt> && (\"\" ~ info)<alt/> ? (\"\" ~ info) : []</alt>;\n                return reason;\n            }\n\n            return fail.len - 3; // \"101\".len is 3.\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Helpers { row: i32[]; };\n\n        fn test(ref _helpers: Helpers[], mut N: i32, row: i32)\n        {\n            fn solveNode_H(h: Helpers) {\n                while (N % h.row[h.row.len - 1]) {\n                    N--;\n                    _helpers.grow(_helpers.len * 2);\n                }\n            }\n\n            fn solveJump() {\n                solveNode_H(_helpers[row]);\n                return _helpers.len;\n            }\n\n            return solveJump() - 1 * 2*2*2*2;\n        }\n\n        fn main()\n        {\n            mut _helpers = [ Helpers([ 1, 2, 3, 4, 5 ]) ];\n            return test(_helpers, row: 0, N: 4)\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Helpers { row: i32[]; };\n\n        fn test(ref _helpers: Helpers[], mut N: i32, row: i32)\n        {\n            fn solveNode_HH_inner(h: Helpers) {\n                while (N % h.row[h.row.len - 1]) {\n                    N--;\n                    _helpers.grow(_helpers.len * 2);\n                }\n            }\n\n            fn solveNode_HH(h: Helpers) {\n                return solveNode_HH_inner(h);\n            }\n\n            fn solveJump() {\n                solveNode_HH(_helpers[row]);\n                return _helpers.len;\n            }\n\n            return solveJump() - 1 * 2*2*2*2;\n        }\n\n        fn main()\n        {\n            mut _helpers = [ Helpers([ 1, 2, 3, 4, 5 ]) ];\n            return test(_helpers, row: 0, N: 4)\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(ref _helpers: i32[][], mut N: i32, row: i32)\n        {\n            fn solveNode_a(h: i32[]) {\n                while (N % h[h.len - 1]) {\n                    N--;\n                    _helpers.grow(_helpers.len * 2);\n                }\n            }\n\n            fn solveJump() {\n                solveNode_a(_helpers[row]); // We've relaxed to a view, which bck can't copy\n                return _helpers.len;\n            }\n\n            return solveJump() - 1 * 2*2*2*2;\n        }\n\n        fn main()\n        {\n            mut _helpers = [[ 1, 2, 3, 4, 5 ]];\n            return test(_helpers, row: 0, N: 4)\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Arg { i: i32; };\n\n        // A mutref fail.\n        fn mutargs(args: &mut Arg[])\n        {\n            // This miscompiles to ref into args,\n            //  after which we invalidate the reference.\n            //\n            <fail inval badref>\n            ref <pass/>\n            mut </fail> badref = args[0];\n\n            args = [ Arg(11) ]; // INVALIDATE badref.\n            return badref;\n        }       // oct2021: now latest issue here is that\n                //  this gets bcked AFTER jump lifetimes are unwound\n                //   and it all looks as if everything's fine (lt badref == lt args).\n\n        fn main()\n        {\n            mut args = [ Arg(7) ];\n            return mutargs(args).i - 7;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Arg { i: i32[]; };\n\n        fn witharg(using a: Arg)\n            i[i.len - 1] * 4;\n\n        fn mutargs(args: &mut Arg[]) {\n            <fail invalidate badref>\n            ref <pass/>\n            let </fail> badref = args[0];\n\n            args = [ Arg([ 11 ]) ]; // INVALIDATE badref.\n            return witharg(badref);\n        }\n\n        fn main() {\n            mut args = [ Arg([ 7 ]) ];\n            return mutargs(args) - 28;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Arg { i: i32[]; };\n\n        fn witharg(using a: Arg, x: i32)\n            i[i.len - 1] * x;\n\n        fn mutargs(args: &mut Arg[]) {\n            <fail inval badref>\n            ref <pass/>\n            let </fail> badref = args[0];\n\n            for (mut i = 0;; i++) {\n                let ret = witharg(badref, i * 4);\n                if (ret)\n                    return ret;\n\n                args = [ Arg([ 11 ]) ]; // INVALIDATE badref.\n            }\n        }\n\n        fn main() {\n            mut args = [ Arg([ 7 ]) ];\n            return mutargs(args) - 28;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(ref woot: i32[], x: i32, y: i32) {\n            ref b = woot[y];\n            ref a = woot[x]; // the 'shadow ref' below ...\n            if (a == 1) {\n                <fail invalidate write to woot at 4:25>\n                <pass/>\n                shadow ref a = woot[x]; // ... should relax 'ref a' above to a let ...\n                </fail>\n                a += 1;\n            }\n            else {\n                b += 1; // ... and this should ignore cond write above.\n            }\n        }\n\n        fn main() {\n            mut x = [ -1, +1 ];\n            test(x, 0, 1);\n            return x[1] - 2;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(ref a: i32[], ref b: i32[]) {\n            <alt>\n            if (a[0]++ == 1)                                    ;; N_AARSoftRisk\n            <alt/>\n            if (a[0] == 1)\n            </alt>\n                a ~= 1;\n            else\n                b ~= 1;\n        }\n\n        fn main() {\n            mut x = [ 1 ];\n            test(x, x);\n            return x.len - 2;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        nocopy struct Woot { x: i32[]; y: i32[] };\n\n        fn test(ref w: Woot) {\n            ref x = w.x;\n            <fail cannot access x 9:13+1 inval write y 8:15+2>\n            ref y = w.x; <pass/>\n            ref y = w.y; </fail>\n            y ~= y; // <- DONT RESOLVE BY COPY! ref can relax to let\n            x ~= y;\n        }\n\n        fn main() {\n            mut w = Woot([ 1, 2, 3, 4, 5, 6, 7 ], [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]);\n            test(w);\n            return w.x.len - 25;\n        }\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        nocopy struct Woot { x: i32[]; y: i32[] };\n\n        fn test(ref w0: Woot, ref w1: Woot) {\n            ref x = w0.x;\n            <fail arguments test:w1 and test:w0 14:21+1 both alias var w 13:17+1>\n            ref y = w1.x; <pass/>\n            ref y = w1.y; </fail> // <- doesnt realize w0.x can't alias w1.y\n            y ~= y; // <- DONT RESOLVE BY COPY! ref can relax to let\n            x ~= y;\n        }\n\n        fn main() {\n            mut w: Woot;\n            test(w, w);\n            return w.x.len;\n        }\n    "_fu, "arguments test:w1 and test:w0 14:21+1 both alias var w 13:17+1"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        fn indexIntoImplicit(j: i32, implicit strings: string[]) strings[j];\n\n        fn selfRecurBeforeImplicitDep(x: i32)\n        {\n            // On second solve we're talking about a region, but the argnode is gone.\n            fn T(i: i32) selfRecurBeforeImplicitDep(i / 2);\n            if (x > 1) return T(x);\n            return indexIntoImplicit(x);\n        }\n\n        fn main() {\n            let implicit strings = [ \"a\", \"b\" ];\n            return selfRecurBeforeImplicitDep(2) == \"b\" ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        <fail arg a 27:42+1 inval by subseq write injected arg out 27:48+1 via grow 8:21+1>\n        nocopy                 <pass/></fail>\n        struct Type       { canon: string; };\n        struct SolvedNode {  type: Type;   };\n\n        fn solved(type: Type, implicit ref out: SolvedNode[]) {\n            out.grow(out.len * 100 + 1);\n\n            ref tail = out[out.len - 1];\n            tail.type.canon = type.canon;\n            return tail;\n        }\n\n        fn createMap(a: Type, b: Type): Type {\n            return Type(a.canon ~ b.canon);\n        }\n\n        fn evalTypeAnnot(nodes: string[]): SolvedNode\n        {\n            fn T(i: i32)\n                evalTypeAnnot([ nodes[i] ]).type;\n\n            // Each T() call should invalidate the results from previous T() calls -\n            //  so this shouldn't compile if Type is nocopy.\n            if (nodes.len > 1)\n                return solved(createMap(T(0), T(1)));           ;; PointlessMustSeq\n\n            return solved(Type(nodes[0]));\n        }\n\n        fn main() {\n            implicit mut out: SolvedNode[];\n            let annot = evalTypeAnnot([ \"a\", \"b\" ]);\n            return out.len == 10101 && annot.type.canon.len == 2 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            mut x = 0;\n            let s = ++x + ++x;\n            return s - 3; // Not 4! one arg must invalidate\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        <fail arg inval subsequent write 14:23 14:26+4 14:34+4 8:16+2>\n        nocopy <pass/></fail>\n        struct X { x: i32; }\n        fn sum(a: X, b: X) a.x + b.x;\n\n        fn incr(ref x: X) {\n            x.x++;\n            return x;\n        }\n\n        fn main() {\n            mut x: X;\n            return sum(x.incr, x.incr) - 3; // Not 4! one arg must invalidate\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        <fail arg inval subsequent write 23:23 23:26+4 23:34+4 16:18+2>\n        nocopy <pass/></fail>\n        struct X { x: i32; }\n        struct Y { y: X;   }\n\n        fn x(y: Y) y.y.x;\n        fn sum(a, b) a.x + b.x;\n\n        fn incr(ref x: X) {\n            x.x++;\n            return x;\n        }\n\n        fn incr(ref y: Y) {\n            y.y.x++;\n            return y;\n        }\n\n        fn main() {\n            mut x: Y;\n            ref y = x.y;\n            return sum(y.incr, x.incr) - 3; // Not 4! one arg must invalidate\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        <fail arg inval subsequent write 19:27+2 19:33+4 19:22+4 7:16+2>\n        nocopy <pass/></fail>\n        struct X { x: i32; };\n\n        fn incr(ref x: X) {\n            x.x++;\n            return x;\n        }\n\n        fn +=(a: X, b: X) {\n            // Notice, this is not a real +=,\n            //  just checking the order of eval here.\n            return a.x + b.x;\n        }\n\n        fn test(ref x: X, ref y: X) {\n            ref xy = y || x;\n            return x.incr += xy.incr; // <- xy invalidated by x.incr\n        }\n\n        fn main() {\n            mut x: X;\n            mut y: X;\n            return test(x, y) - 3;\n        }\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        <alt>\n        nocopy\n        </alt>\n        struct X { items: i32[]; };\n        fn popfirst(mut arr: X[]) arr[0]; // mcom_BlockReturn after relax: arr[] adds 'static\n        fn main() popfirst([ X() ]).items.len;\n    "_fu, "cannot be copied or moved 6:38+1"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        struct AB { a: i32[][]; b: i32[][]; };\n\n        fn problematic_moves(mut ab: AB) {\n            ref ra = ab.a;\n            return ra.len & 1 ? ra[0] : ab.b[0];\n        }\n\n        fn main() {\n            mut ab = AB(\n                [[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9]],\n                [[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]]);\n\n            mut pick = ab.problematic_moves;\n            return pick[9] - ab.a[0][9];\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        <fail cannot be copied or moved 20:31>\n        nocopy <pass/></fail>\n        struct NC { x: i32; y: i32 };\n\n        fn wants_val(mut a: NC) {\n            a.x++;\n            a.y++;\n            return a;\n        }\n\n        fn incr_by(mut a: NC, b: NC) {\n            a.x += b.x;\n            a.y += b.y;\n            return a;\n        }\n\n        fn main() {\n            mut v = NC(-1, -1);\n            mut w = wants_val(v);\n            return (w || v).x + 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        nocopy struct SolvedNode {\n            items: SolvedNode[];\n        };\n\n        fn test(mut a: SolvedNode, mut b: SolvedNode) {\n            <alt>\n            ref n = a || b;\n            <alt/>\n            ref n = a.items ? a : b;\n            </alt>\n            return n;\n        }\n\n        fn main() test([], []).items.len;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        <fail cannot access invalidated>\n        nocopy            <pass/></fail>\n        struct SolvedNode { len: i32; }\n\n        fn createBlock(mut last: SolvedNode) {\n            let tail     = last || last;\n            let unwrap   = tail || tail;\n            last.len--;\n            return unwrap;\n        }\n\n        fn main() {\n            return createBlock([]).len;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        <fail cannot access invalidated>\n        nocopy            <pass/></fail>\n        struct SolvedNode { items: SolvedNode[] };\n\n        fn popAndOr(ref node: SolvedNode) {\n            let N = node.items.len;\n\n            let pop = node.items[N - 1];\n            if (N > 2) {\n                node.items.pop();\n            }\n            else {\n                let head = node.items[0];\n                node = head;\n            }\n\n            return pop;\n        }\n\n        fn main() {\n            mut a = SolvedNode([ SolvedNode, SolvedNode ]);\n            let b = a.popAndOr();\n            return a.items.len + b.items.len;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        <fail cannot access invalidated>\n        nocopy            <pass/></fail>\n        struct Items {\n            len: i32;\n        }\n\n        struct SolvedNode {\n            items: Items;\n        }\n\n        struct Nodes {\n            last: SolvedNode;\n        }\n\n        fn pop(ref n: Nodes) {\n            n.last.items.len--;\n        }\n\n        fn createBlock(mut items: Nodes) {\n            let tail = items.last;\n            let unwrap = tail.items;\n            items.pop();\n            return unwrap;\n        }\n\n        fn main() {\n            return createBlock(Nodes(SolvedNode([]))).len;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        <fail cannot access invalidated>\n        nocopy            <pass/></fail>\n        struct SolvedNode {\n            items: SolvedNode[];\n        };\n\n        // Reducing the thing below.\n        fn createBlock(mut items: SolvedNode[]) {\n            let tail = items[items.len - 1];\n            let unwrap = tail.items;\n            items.pop();\n            return unwrap;\n        }\n\n        fn main() {\n            return createBlock([ SolvedNode ]).len;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        <fail cannot access invalidated>\n        nocopy            <pass/></fail>\n        struct SolvedNode {\n            kind: string;\n            items: SolvedNode[];\n        };\n\n        // Same as below but mut.\n        fn createBlock(mut items: SolvedNode[]) {\n            if (items.len) for (;;) {\n                let tail = items[items.len - 1]; // const-indexed but generated mutref tail, must be F_RRET?\n                if (tail.kind != \"block\")\n                    break;\n\n                let unwrap = tail.items;\n                items.pop();\n                return unwrap;\n            }\n\n            return [];\n        }\n\n        fn main() {\n            return createBlock([]).len;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        <fail cannot access invalidated>\n        nocopy            <pass/></fail>\n        struct SolvedNode {\n            kind: string;\n            items: SolvedNode[];\n        };\n\n        // Same as above but ref.\n        fn createBlock(ref items: SolvedNode[]) {\n            if (items.len) for (;;) {\n                let tail = items[items.len - 1];\n                if (tail.kind != \"block\")\n                    break;\n\n                let unwrap = tail.items; // unwrap needs to copy here\n                items.pop(); ////////////// <- nuked here, but ignored!\n                return unwrap;\n            }\n\n            return [];\n        }\n\n        fn main() {\n            mut items: SolvedNode[];\n            return createBlock(items).len;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(ref a: i32[]) = a.swap(0, 1);\n\n        fn main() {\n            mut nums = [1, 2];\n            nums.test();\n            return nums.len == 2 && nums[0] == 2 && nums[1] == 1\n                 ? 0\n                 : 1;\n        }\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        fn Swap(ref arr: i32[], x: i32, y: i32)\n            swap(arr[x], arr[y]);\n\n        fn main() {\n            mut a = [ 1, 2 ];\n            a.Swap(0, 1);\n            return a[0] - 2 == 0 && a[1] - 1 == 0 ? 0 : 1;\n        }\n    "_fu, "arg a 3:21+1 inval by subseq write arr 3:29+1"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        fn test(ref arg: i32[]) {\n            let encloses_unchanged = arg;\n\n            fn closure()\n                for (mut i = 0; i < arg.len; i++)\n                    arg[i] += encloses_unchanged[i];\n\n            closure();\n            if (arg.len & 1)\n                closure();\n        }\n\n        fn main() {\n            mut a = [ 3 ];\n            test(a);\n            return a[0] - 9;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        inline fn must_not_return_ref_or_view(ref x: i32[][]) {\n            let y = x[100];\n            x.shrink(y.len);\n            return y;\n        }\n\n        fn main() {\n            mut arr: i32[][];\n            arr.grow(101);\n            arr[100] = [ 7 ]\n            return arr.must_not_return_ref_or_view()[0] - 7;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct HasVec { x: i32[] };\n        inline fn last(x: i32[]) x[x.len - 1];                  ;; GNUStmtExpr\n\n        <alt>\n        inline                                                  ;; GNUStmtExpr\n                                                                ;; PointlessLocal\n        </alt>\n        fn will_return_value(ref x: HasVec) {\n            let bck_will_cpy = x;\n\n            let vec0 = bck_will_cpy.x;\n            if (bck_will_cpy.x.len & 1)\n                return vec0;\n\n            x.x ~= x.x.len;\n            let vec1 = bck_will_cpy.x;\n            return vec1;\n        }\n\n        fn main() {\n            mut x = HasVec([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]);\n            return will_return_value(x).last/*9*/ - x.x.last/*10*/ + 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn PASS_borrowCheck_incr_a_ret_b(ref a: i32, ref b: i32) {\n            a++;        // we're done writing to a before\n            return b;   //  EXTRA DRAMA: we dont cg const refs for primitives right now\n        }\n\n        fn main() {\n            mut x = 5;\n            PASS_borrowCheck_incr_a_ret_b(x, x);\n            return x - 6;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn PASS_borrowCheck_reduct(ref a: i32, ref b: i32[])\n        {\n            // If this were (ref!b a, ref b):\n            //\n            // When a points into b:\n            //  - a++ read ok, write ok\n            //   - b read ok, write ok + invalidates a\n            //    - a not usable from here on\n            //\n            // The point is we should be able to deduce this automatically,\n            //  if nothing a-related is used after b gets used for the first time,\n            //   then we're fine if b aliases a ...\n            //\n            // ... EXCEPT that's if b doesn't acceptTempCopies -\n            //  meaning it's either F_IMPLICIT or F_REF -\n            //   otherwise there's ambiguity.\n            //\n            a++;\n            b ~= 10;\n        }\n\n        fn main() {\n            mut arr = [ 9 ];\n            PASS_borrowCheck_reduct(arr[0], arr);               ;; PointlessMustSeq\n            return arr[0] - arr[1];\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Node { id: i32; items?: Node[]; };\n\n        fn traverse(node: Node, visit) {\n            visit(node);\n            for (mut i = 0; i < node.items.len; i++)\n                traverse(node.items[i], fn visit);\n        }\n\n        fn PASS_borrowCheck(ref root: Node) {\n            mut n: i32;\n            fn count(id: i32)\n                traverse(root): |i|\n                    if (i.id == id)\n                        n++;\n\n            fn check(ref node: Node) {\n                if (node.items)\n                    for (mut i = 0; i < node.items.len; i++)\n                        check(node.items[i]);                   ;; PointlessMustSeq\n                else\n                    count(node.id++);\n            }\n\n            check(root);\n            return n;\n        }\n\n        fn main() {\n            mut tree = Node(0, [ Node(2), Node(2) ]);\n            return PASS_borrowCheck(tree) - 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn check(implicit root: i32[], node: i32[])\n            root.len - node.len;\n\n        fn PASS_borrowCheck(        <fail because of 2:27+4 NOT implicit arg root 6:22+4>\n                     root: i32[])   <pass/>\n            implicit root: i32[])   </fail>\n                check(root);\n\n        fn main()\n            [ 1, 2, 3 ].PASS_borrowCheck();\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Node { id: i32; items?: Node[]; };\n\n        fn traverse(node: Node, visit) {\n            visit(node);\n            for (mut i = 0; i < node.items.len; i++)\n                traverse(node.items[i], fn visit);\n        }\n\n        // Same as above, but not a closure.\n        fn count(id: i32, implicit root: Node, implicit ref n: i32)\n            traverse(root): |i|\n                if (i.id == id)\n                    n++;\n\n        fn check(ref node: Node) {\n            if (node.items)\n                for (mut i = 0; i < node.items.len; i++)\n                    check(node.items[i]);                   ;; PointlessMustSeq\n            else\n                count(node.id++);\n        }\n\n        fn PASS_borrowCheck(implicit ref root: Node) {\n            implicit mut n: i32;\n            check(root); // <- Usage intersection failure: Node & Node\n            return n;\n        }\n\n        fn main() {\n            mut tree = Node(0, [ Node(2), Node(2) ]);\n            return PASS_borrowCheck(tree) - 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Node { id: i32; items?: Node[]; };\n\n        fn traverse(node: Node, visit) {\n            visit(node);\n            for (mut i = 0; i < node.items.len; i++)\n                traverse(node.items[i], fn visit);\n        }\n\n        // Same as above, but no implicits.\n        fn count(id: i32, ref root: Node, implicit ref n: i32)\n            traverse(root): |i|\n                if (i.id == id)\n                    n++;\n\n        // AAR: check(ref node, ref root) accepted,\n        //       but (ref root, ref node) rejected.\n        <alt>\n        fn check(ref root: Node, ref node: Node) { <alt/>\n        fn check(ref node: Node, ref root: Node) { </alt>\n            if (node.items)\n                for (mut i = 0; i < node.items.len; i++)\n                    check(:root, node.items[i]);                ;; PointlessMustSeq\n            else\n                count(:root, node.id++);\n        }\n\n        fn PASS_borrowCheck(ref root: Node) {\n            implicit mut n: i32;\n            check(:root, root);\n            return n;\n        }\n\n        fn main() {\n            mut tree = Node(0, [ Node(2), Node(2) ]);\n            return PASS_borrowCheck(tree) - 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        pub fn grow_if_oob(ref a: $T[], i: i32) {\n            if (a.len <= i) a.grow(i + 1);\n            return a[i];\n        }\n\n        fn grow_if_oob_to_len_from_self(ref arr: i32[], idx: i32)\n            arr.grow_if_oob(arr[idx]); // i was F_REF for some reason\n\n        fn main() {\n            mut arr = [3];\n            arr.grow_if_oob_to_len_from_self(0) = 2;\n\n            mut sum = 0;\n            for (mut i = 0; i < arr.len; i++) sum += arr[i];\n            return sum - 5;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn used_in_a_loop__invalidated__by_new_var(\n            ref arr: i32[], ref barr: i32[], ref carr: i32[])\n        {\n            ref head = arr[arr.len - 1];\n            for (mut i = 0; i < arr.len; i++) {\n                head += arr.len;\n                let head_cpy = head + 0;\n                ref barrcarr = barr || carr;\n                barrcarr.resize(head_cpy);\n            }\n        }\n\n        fn main() {\n            mut arr = [ 1 ];\n\n            <fail both alias arr 15:17+3>\n            ref barr = arr; <pass/>\n            mut barr = arr; </fail>\n\n            used_in_a_loop__invalidated__by_new_var(arr, barr, barr);\n            return barr.len == 2 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn grow_if_oob(ref a: i32[], i: i32) {\n            if (a.len <= i) a.grow(i + 1);\n            return a[i];\n        }\n\n        fn assign(ref what: i32, ref to: i32) to = what;\n\n        fn two_writes_in_an_arg(ref arr: i32[], ref brr: i32[], ref x: i32)\n            assign( what: x ? arr.grow_if_oob(10)\n                            : brr.grow_if_oob(10), to: x );\n\n        fn main() {\n            mut arr = [ 0, 1, 2, 3 ];\n            mut brr = [ 0, 2, 4, 6 ];\n\n            <fail arg 3 x 2 brr both alias 20:51>\n            ref x = brr[0];               <pass/>\n            mut x = 0;                    </fail>\n\n            return two_writes_in_an_arg(arr, brr, x);\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn grow_if_oob(ref a: i32[], i: i32) {\n            if (a.len <= i) a.grow(i + 1);\n            return a[i];\n        }\n\n        fn assign(ref what: i32, ref to: i32) to = what;\n\n        fn two_writes_in_an_arg(ref arr: i32[], ref brr: i32[], ref x: i32)\n            assign( what: x ? arr.grow_if_oob(10)\n                            : brr.grow_if_oob(10), to: x );\n\n        fn main() {                         <flip>\n            mut zero = 0;\n            mut empty: i32[];               <flip/>\n            mut arr = [ 0, 1, 2, 3 ];\n            mut brr = [ 0, 2, 4, 6 ];       </flip>\n\n            <fail arg 3 x 2 brr both alias 25:58+8>\n            ref x = brr[0];                 <pass/>\n            mut x = 0;                      </fail>\n\n            ref opaque_x    = brr.len > arr.len ? zero  : x;\n            ref opaque_brr  = brr.len > arr.len ? empty : brr;\n\n            return two_writes_in_an_arg(arr, opaque_brr, opaque_x);\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Node { items: Node[] };\n\n        fn main() {\n            mut root = Node([\n                Node([ Node, Node ])\n            ]);\n\n            <fail both arg alias root>\n            swap(root.items[0], root);  <pass/> // write to root invalidates root.items[0]\n            root = root.items[0];       </fail> // this is fine\n\n            return root.items.len - 2;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn grow_if_oob(ref a: i32[], i: i32) {\n            if (a.len <= i) a.grow(i + 1);\n            return a[i];\n        }\n\n        fn assign(ref to: i32, ref what: i32) to = what;\n\n        fn two_writes_in_an_arg(ref x: i32, ref arr: i32[], ref brr: i32[])\n            assign( to: x,  what: arr.grow_if_oob(10)           ;; !N_BckMustSeq\n                               || brr.grow_if_oob(10));         ;; !N_MoveMustSeq\n\n        fn test(ref x: i32, ref arr: i32[], ref brr: i32[]) {\n            two_writes_in_an_arg(\n                <fail arg 2 arr 1 x both alias 17:22>\n                    x || arr[0],              <pass/>\n                    x,                        </fail>\n                    :arr, :brr);\n\n            return x;\n        }\n\n        fn main() {\n            mut arr = [ 0 ];\n            mut brr = [ 0 ];\n            mut x   = 0;\n\n            return test(:x, :arr, :brr);\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn writes_to_two_args(ref item: i32, ref arr: i32[], ref brr: i32[]) {\n            ref arrbrr = arr || brr;\n            arrbrr.resize(100 + arrbrr.len);\n            return item += arrbrr.len;\n        }\n\n        fn main() {\n            mut arr: i32[] = [      ];\n            mut brr: i32[] = [ -101 ];\n\n            <fail alias brr>\n            ref item = brr[0]; <pass/>\n            mut item = brr[0]; </fail>\n\n            return writes_to_two_args(:item, :arr, :brr);\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn reads_from_two_args(ref left: i32, ref right: i32, ref arr: i32[], ref brr: i32[]) {\n            ref arrbrr = arr || brr;\n            ref item = left || right;\n            arrbrr.resize(100 + arrbrr.len);\n            return item += arrbrr.len;\n        }\n\n        fn main() {\n            mut arr: i32[] = [      ];\n            mut brr: i32[] = [ -101 ];\n\n            mut left = 0;\n\n            <fail alias brr>\n            ref right = brr[0]; <pass/>\n            mut right = brr[0]; </fail>\n\n            return reads_from_two_args(:left, :right, :arr, :brr);\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn grow(ref arr: i32[], by!n: i32) {\n            arr.resize(arr.len + n);\n            return arr;\n        }\n\n        fn incr__ltr_oee(ref what: i32, by: i32)\n            what += by;\n\n        fn reads_from_two_args__single_expr(ref left: i32, ref right: i32, ref arr: i32[], ref brr: i32[])\n            incr__ltr_oee(left || right, grow(arr || brr, by: 100).len);\n\n        fn main() {\n            mut arr: i32[] = [      ];\n            mut brr: i32[] = [ -101 ];\n\n            mut left = 0;\n\n            <fail alias brr>\n            ref right = brr[0]; <pass/>\n            mut right = brr[0]; </fail>\n\n            return reads_from_two_args__single_expr(:left, :right, :arr, :brr);\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            mut arr = [ 1,1,1,1,1 ];\n            mut sum = 0;\n\n            // veach(view) should decay to a slice -\n            //  which push will invalidate.\n            //\n            fn veach(                   <fail both alias arr 3:17+3>\n                /* no explicit val */   <fail/>\n                ref                     <pass/>\n                mut                     </fail>\n                    view, fn)\n            {\n                for (mut i = 0; i < view.len; i++) {\n                    fn(view[i]);\n                    arr ~= arr; // Relocate arr.\n                }\n            }\n\n            arr.veach: |ref i| sum +=   <alt>\n                (i *= 2)                <alt/>\n                (i *  2)                </alt>;\n\n            return sum - 10;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            mut arr = [ 1,1,1,1,1 ];\n            mut sum = 0;\n\n            // veach(view) should decay to a slice -\n            //  which push will invalidate.\n            //\n            fn veach(ref view, fn) {\n                for (mut i = 0; i < view.len; i++) {\n                    fn(view[i]);\n                    <fail both alias arr 3:17+3>\n                    arr ~= arr; // Relocate arr.\n                    <pass/></fail>\n                }\n            }\n\n            arr.veach: |ref i| sum +=   <alt>\n                (i *= 2)                ;; PointlessMustSeq\n                                        <alt/>\n                (i *  2)                </alt>;\n\n            return sum - 10;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        struct Context {\n            modules:    Module[];\n        };\n\n        nocopy struct Module {\n            in?:        string;\n            fname:      string;\n        };\n\n        fn getFile(implicit ref ctx: Context, fname: string) {\n            for (mut i = 0; i < ctx.modules.len; i++)\n                if (ctx.modules[i].fname == fname)\n                    return ctx.modules[i].in;\n\n            ctx.modules ~= Module(:fname, in: fname ~ '\\n' ~ fname ~ '\\n');\n            return ctx.modules[ctx.modules.len - 1].in;\n        }\n\n        fn getModule(implicit ref ctx: Context, fname: string) {\n            for (mut i = 0; i < ctx.modules.len; i++)\n                if (ctx.modules[i].fname == fname)\n                    return ctx.modules[i];\n\n            return [];\n        }\n    "_fu, "\n        import _0;\n\n        fn ensureParsed(fname: string) {\n            let module = getModule(fname);\n            if (!module.in)\n                return getFile(fname).len\n                <fail module invalidated by write to ctx>\n                    || module.in.len;\n                <pass/>\n                    || throw(fname);\n                </fail>\n\n            return module.in.len;\n        }\n\n        fn main() {\n            implicit mut ctx: Context;\n            return ensureParsed(\"a\") - 4;\n        }\n    "_fu } }, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        nocopy struct NCThing {\n            items: i32[];\n        };\n\n        fn mut_in_loop_before_break(ref thing: NCThing) {\n            mut sum = 0;\n\n            ref items = thing.items;\n            for (mut i = 0; i < items.len; i++)\n            {\n                sum += items[i];\n                if (sum > 10)\n                {\n                    thing = NCThing();\n                    <fail write 15:27 inval use items next loop iter 10:33>\n                    if (sum > 20)                                   <pass/>\n                    if (true)                                       </fail>\n                        break;\n                }\n\n                items[i] *= 2;\n            }\n\n            return sum;\n        }\n\n        fn main() {\n            mut thing = NCThing([ 10 ]);\n            return mut_in_loop_before_break(thing)\n                 + mut_in_loop_before_break(thing)\n                 - 30\n                 + thing.items.len;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct XY { x: i32; y: i32 };\n\n        fn main() {\n            mut xy: XY;\n            <fail ref x 13:20+1 invalidated by write to xy 10:18+2>\n            ref x = xy.x;                                   <pass/>\n            fn  x = xy.x;                                   </fail>\n\n            pragma emit(`\n                `xy`.x++;\n            `);\n\n            return x - 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct XY { x: i32; y: i32 };\n\n        fn main() {\n            mut xy: XY;\n            <fail 11:22 inval next loop iter 9:21>\n            ref x = xy.x;                  <pass/>\n            fn  x = xy.x;                  </fail>\n\n            while (!x)\n                pragma emit(`\n                    `xy`.x++;\n                `);\n\n            return xy.x - 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct XY { x: i32; y: i32 };\n\n        fn bckErr_fromPragmaEmit(ref xy: XY) {\n            pragma emit(`\n                `xy`.x++;\n            `);\n        }\n\n        fn main() {\n            mut xy: XY;\n            <fail bckErr_fromPragmaEmit>\n            ref x = xy.x;        <pass/>\n            fn  x = xy.x;        </fail>\n\n            bckErr_fromPragmaEmit(xy);\n            return x - 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct XY { x: i32; y: i32 };\n\n        fn test(ref xy: XY, ref zw: XY) {\n            <fail cannot access ref x 12:20+1 inval by write xy 9:21+2>\n            ref x = xy.x;                                   <pass/>\n            fn  x = xy.x;                                   </fail>\n\n            pragma emit(`\n                `xy || zw`.x++;\n            `);\n\n            return x;\n        }\n\n        fn main() {\n            mut xy: XY;\n            return test(xy, xy) - 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Ext { ext: Ext[] };\n\n        fn EXT(implicit ext: Ext[], a: i32) ext[a];\n\n        fn EXT_insert(implicit ref ext: Ext[], a: i32) {\n            ext.insert(a, Ext());\n            return ext[a];\n        }\n\n        fn solveTypedef(a: i32, b: i32) EXT_insert(a) = EXT(b);\n\n        fn main() {\n            implicit mut ext = [ Ext([ Ext, Ext ]) ];\n\n            for (mut i = 0; i < 128; i++)\n                solveTypedef(0, 0);\n\n            return ext[0].ext.len == 2 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn ints(implicit ref _ints: i32[]) _ints;\n        fn sum (implicit ref _sum:  i32)   _sum;\n\n        // while trying to sort implicit args i noticed tests didnt catch\n        //  args getting reordered but AAR masks not updating\n        //   this tries to reproduce the same thing\n        fn flippedInjectedArgsWithBrokenAARMasks()\n            if (sum) // the point of this is to inject _sum before _ints\n                for (mut i = ints.len; i --> 0; )\n                    ints.push(sum);\n\n        fn main() {\n            implicit mut _ints: i32[] = [ 0 ];\n            <fail alias _ints>\n            implicit ref _sum = _ints[0];\n            <pass/>\n            implicit mut _sum = 0;\n            </fail>\n\n            flippedInjectedArgsWithBrokenAARMasks();\n            return ints[0];\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Node {\n            nodes: Node[];\n        };\n\n        noinline fn append_a_onto_b_100_times(ref willPush: Node, ref pushWhat: Node) {\n            for (mut i = 0; i < 100; i++)\n                willPush.nodes ~= pushWhat;\n        }\n\n        noinline fn clear_and_return_ref_to_self(ref node: Node) {\n            node.nodes.clear();\n            return node;\n        }\n\n        noinline fn crash_if_b_refs_into_a(ref willEmpty: Node, ref willPush: Node) {\n            return append_a_onto_b_100_times(\n                // indexes inside, should crash\n                willPush.nodes[0],\n                // empties the nodes\n                clear_and_return_ref_to_self(willEmpty));\n        }\n\n        fn main() {\n            mut willEmpty: Node = [[ Node() ]];\n\n            <fail both alias willEmpty 28:47>\n            crash_if_b_refs_into_a(willEmpty, willEmpty);\n            <pass/>\n            mut willPush = willEmpty;\n            crash_if_b_refs_into_a(willEmpty, willPush);\n            </fail>\n\n            return willEmpty.nodes.len == 0 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Node { nodes: Node[] };\n\n        noinline fn soft_risk_inner(ref a: Node, ref b: Node)\n            for (mut i = 0; i < 100; i++)\n                a.nodes ~= b;\n\n        noinline fn soft_risk_outer(ref a: Node, ref b: Node)\n            soft_risk_inner(a, b.nodes[0]);\n\n        fn main() {\n            mut root = Node([ Node ]);\n\n            <fail both alias root 12:17+4>\n            soft_risk_outer(root, root);    <pass/>\n            mut cpy = root;\n            soft_risk_outer(root, cpy);     </fail>\n\n            return root.nodes.len == 101 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct ScopeItem { k: string; v: i32 };\n\n        fn dequalify_andGetScope(ref id: string, implicit locals: ScopeItem[], implicit globals: ScopeItem[]) {\n            if (id.ends(with: \"g\")) {\n                id.pop();\n                return globals;\n            }\n\n            return locals;\n        }\n\n        fn solveAddrOfFn(mut id: string) {\n            fn visitScope(items: ScopeItem[]) {\n                items.each: |item|\n                    if (item.k == id)\n                        return item.v;\n\n                return -1;\n            }\n\n            // on gcc visitScope:id bound to a slice before mutation\n            return visitScope(dequalify_andGetScope(id));       ;; N_BckMustSeq\n        }\n\n        fn main() {\n            let implicit locals  = [ ScopeItem(\"a\", 1), ScopeItem(\"b\", 2), ScopeItem(\"c\", 3) ];\n            let implicit globals = [ ScopeItem(\"a\", 10), ScopeItem(\"b\", 20), ScopeItem(\"c\", 30) ];\n            let result = solveAddrOfFn(\"a\") + solveAddrOfFn(\"bg\");\n            return result == 21 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn cmp_ooe(mut stuff: i32[], ref needSort: bool) {\n            mut result: i32[] = [];\n            mut last = -1;\n            for (mut i = 0; i < stuff.len; i++) {\n                let t = stuff[i];\n                if !(t & 1) continue;\n                if (last > (last = t)) needSort = true;\n                result ~= t;\n            }\n\n            if (needSort) result.sort();\n            return result;\n        }\n\n        fn checksum(stuff: i32[]) {\n            mut result = 0;\n            for (mut i = 0; i < stuff.len; i++) {\n                result *= stuff[i];\n                result += stuff[i];\n            }\n            return result;\n        }\n\n        fn main() {\n            mut needSort = false;\n            let aa = checksum(cmp_ooe([1, 2, 3, 4, 5], :needSort));\n            let bb = !needSort\n                  && checksum(cmp_ooe([7, 4, 3, 2, 1], :needSort));\n\n            return needSort ? aa * 100 + bb - 3549 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn clearAndReturn(ref a: i32[]) {\n            a.clear();\n            return a;\n        }\n\n        <alt>\n        fn refOOE(ref a: i32[], b: i32[]) <alt/>\n        fn refOOE(b: i32[], ref a: i32[]) </alt>\n            a ~= b;\n\n        fn main() {\n            mut ints = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];\n            refOOE(a: clearAndReturn(ints), b: ints);\n            return ints.len - 10;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Type { nontriv: Type[] };\n        struct Node { type: Type };\n\n        let zero    = Type();\n        let one     = Type([ Type ]);\n        let two     = Type([ Type, Type ]);\n\n        noinline fn solve(ref nodes: Node[])\n        {\n            noinline fn propagateType(ref node: Node, val slot: Type) {\n                shadow let slot =\n                    node.type.nontriv.len == 2 ? two : slot;\n\n            <alt>\n                for (mut i = 0; i < nodes.len; i++)\n                    nodes[i].type = zero;\n            <alt/>\n                nodes = nodes.map(|lax n| Node(zero));\n            </alt>\n\n                nodes ~= Node(slot);\n            }\n\n            for (mut i = nodes.len; i --> 0; ) {\n                ref node = nodes[i];\n\n                propagateType(node,\n                <alt>\n                    node.type.nontriv.len == 0 ? zero : node.type\n                    //              missing copy around ^^^^^^^^^\n                    //      alt-1: wrong result, alt-2: segfault\n                <alt/>\n                    node.type\n                </alt>);\n            }\n        }\n\n        fn main() {\n            mut nodes = [ Node(one) ];\n            solve(nodes);\n\n            return nodes.len == 2\n                && nodes[0].type == zero\n                && nodes[1].type == one\n                    ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        nocopy struct NC { x: i32 };\n\n        noinline fn add(a: i32, b: i32)\n            a + b;\n\n        noinline fn test(a: NC, ref b: NC)\n            add(10 * a.x, ++b.x);                               ;; N_AARMustSeq\n\n        fn main() {\n            mut nc = NC(1);\n            return test(nc, nc) - 12;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Node { value: i32; children?: Node[] };\n\n        noinline fn used_in_a_nested_loop_after_break(ref n: Node)\n        {\n            ref first = n.children[0];\n\n            mut sum = 0;\n            for (mut i = 0; i < n.children.len; i++) {\n                for (shadow mut i = 0; i < n.children.len; i++) {\n                    sum += n.children[i].value;\n\n                    if (sum & 1) {\n                        // write followed by inner-loop break -\n                        //  not on the same path as the use of first below ...\n                        n.children ~= Node(i);\n\n                        <fail cannot access first 23:21+5 inval by write n 16:36+2>\n                        break;                                              <pass/>\n                        return sum;                                         </fail>\n                    }\n\n                    // ... which will be used again on next outer-loop iter.\n                    first.value += sum;\n                }\n            }\n\n            return sum;\n        }\n\n        fn main() {\n            mut n = Node(0, [ Node(2), Node(1) ]);\n            let sum = used_in_a_nested_loop_after_break(n);\n            return sum - 3;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Node { value: i32; children?: Node[] };\n\n        noinline fn used_in_a_preceding_nested_loop(ref n: Node)\n        {\n            ref first = n.children[0];\n\n            mut sum = 0;\n            for (mut i = 0; i < n.children.len; i++) {\n\n                for (shadow mut i = 0; i < n.children.len; i++)\n                    first.children ~= Node(i);\n\n                for (shadow mut i = 0; i < n.children.len; i++) {\n                    sum += n.children[i].value;\n\n                    if (sum & 1) {\n                        n.children ~= Node(i);\n\n                        <fail write to n 18:36+2 inval use of first 12:21+5 on next loop iter>\n                        break;          <pass/>\n                        return sum;     </fail>\n                    }\n                }\n            }\n\n            return sum;\n        }\n\n        fn main() {\n            mut n = Node(0, [ Node(2), Node(1) ]);\n            let sum = used_in_a_preceding_nested_loop(n);\n            return sum - 3;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        noinline fn used_after_break_from_block(ref arr: i32[])\n        {\n            <fail cannot access first 18:20+5 inval by write to arr 10:34+1>\n            ref <pass/>\n            mut </fail> first = arr[0];\n\n            :BLOCK {\n                if (first & 2) {\n                    if (first & 1) {\n                        arr.clear();\n                        break :BLOCK;                           ;; Goto\n                    }\n\n                    first++;\n                }\n            }\n\n            return first;\n        }\n\n        fn main() {\n            mut arr = [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 18, 19 ];\n            return used_after_break_from_block(arr) - 3;\n        }\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        fn hello(ref arr: i32[], ref item: i32)\n            arr ~= ++item;\n\n        fn ret_last(ref arr: i32[])\n            arr[arr.len - 1];\n\n        fn concat_self_ret_last(ref arr: i32[])\n            ret_last(arr ~= arr)\n\n        fn main() {\n            mut arr = [ 1, 2, 3 ];\n            hello(arr, concat_self_ret_last(arr));\n            return ret_last(arr) - 4;\n        }\n    "_fu, "arr 13:19+3 inval by subseq 13:44+1 concat_self_ret_last"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        fn Last(ref arr: i32[])\n            arr[arr.len - 1];\n\n        fn Push(ref arr: i32[]) {\n            arr.push([]);\n            return arr.Last;\n        }\n\n        fn Assign(ref b: i32, ref into: i32)\n            into = ++b;\n\n        fn main() {\n            mut arr = [ 1, 2, 3 ];\n\n            <fail write to arr 21:43+1 inval use b 21:30+1 next loop iter>\n            ref <pass/>\n            fn  </fail> b = arr.Last;\n\n            for (mut i = 0; i < 10; i++) {\n                mut tmp: i32;\n                Assign(tmp = b, into: Push(arr));\n            }\n\n            return arr.Last - 13;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            mut arr = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ];\n            <fail ref item4 11:26+5 inval by write to arr 10:18+3>\n            ref <pass/>\n            let </fail> item4 = arr[4];\n\n            mut out = 7;\n\n            pragma emit(`\n                `arr` = {};\n                `out` = `item4`;\n            `);\n\n            return out * 2 - 8;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct A { ints: i32[] };\n        struct B { a0: A; a1: A };\n\n        noinline fn either(ref a: B) a.a0 || a.a1;\n\n        fn main() {\n            mut b0 = B( A([ 1, 2, 3, 4, 5, 6, 7, 8 ]),\n                        A([ 9, 10, 11, 12, 13, 14, 15, 16 ]));\n\n            let b1 = b0;\n\n            ref a0 = either(b0);\n            a0.ints.clear();\n            a0.ints ~= 1;\n\n            return    1 * b0.a0.ints.len +   10 * b0.a1.ints.len\n                 +  100 * b1.a0.ints.len + 1000 * b1.a1.ints.len\n                 - 8881;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct TokenIdx { tokidx: i32 };\n\n        fn FAIL(implicit _here: TokenIdx, reason: string): never\n            throw(_here && reason);\n\n        noinline fn opaque_bool_check(lt: string)\n            return !!lt;\n\n        fn Lifetime_process(lt: string, each) {\n            fn visit(chars) {\n                for (mut i = 0; i < chars.len; i++) {\n                    fn climb(mut parent: string) {\n                        visit(parent);\n                        continue;\n                    }\n\n                    each(climb?: fn climb, chars.slice(i, chars.len))\n                    i == chars.len - 1 || <alt>FAIL<alt/>throw</alt>(\"here-0\");\n                }\n            }\n\n            visit(lt);\n        }\n\n        fn main() {\n            let implicit mut _here: TokenIdx;\n\n            fn fail(mut reason: string, backtrack!?: string): never {\n                if (backtrack) _here = [];\n                return FAIL(reason);\n            }\n\n            fn climbWhat(mut str: string) {\n                str || fail(\"here-1\");\n                str.pop();\n                return str;\n            }\n\n            mut result = \"\";\n            Lifetime_process(\"abc\", each: |lt, climb|\n            {\n                result ~= lt;\n                let init = lt.climbWhat;\n                if (init.opaque_bool_check)\n                    climb(init);\n            });\n\n            return result == \"abcababbcbc\" ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Module { modid: i32; scope: string[] }\n        struct Target { modid: i32; globid: i32 }\n        struct Solver { scope: string[]; tp: string }\n\n        // This hit flatCount asserts in lifetime paths during bck\n        fn test(\n            implicit ref ctx:       Module[],\n            using implicit ref ss:  Solver,\n            target:                 Target)\n        {\n            ref s = ctx.len > target.modid\n                    ? ctx[target.modid].scope\n                    : scope;\n\n            return s.len > target.globid\n                    ? s[target.globid]\n                    : tp;\n        }\n\n        fn main() {\n            implicit mut ss = Solver(scope: [ \"h\", \"w\" ], tp: \"Hello!\");\n            implicit mut ctx = [\n                Module(modid: 0, scope: [ \"hello\", \"world\" ]),\n                Module(modid: 1, scope: [ \"Hello\", \"World\" ]),\n            ];\n\n            let append = \", \" ~ test(Target(modid: 1, globid: 1))\n                       ~ \"! \" ~ test(Target(modid: 0, globid: 2));\n\n            ref res = test(Target(modid: 0, globid: 0));\n            res ~= append;\n\n            return res == \"hello, World! Hello!\" ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Target       { modid: i32; globid: i32 }\n        struct SolvedNode   { items: SolvedNode[]; target?: Target }\n\n        fn stealInit(ref allNodes: SolvedNode[], t: Target)\n        {\n            fn GET_mut(target: Target)\n                allNodes[target.globid];\n\n            ref node = GET_mut(t);\n            if (node.items && node.items[0]) {\n                mut init: SolvedNode;\n                swap(init, node.items[0]); // flatCount mismatch here\n                return init;\n            }\n\n            return [];\n        }\n\n        fn main() {\n            mut allNodes = [\n                SolvedNode([\n                    SolvedNode([\n                        SolvedNode(),\n                    ]),\n                ]),\n            ];\n\n            novec fn count(items: SolvedNode[]) {\n                mut count = items.len;\n                items.each: |node| count += node.items.count;\n                return count;\n            }\n\n            let cnt0 = allNodes.count;\n            let init = stealInit(allNodes, Target(0, 0));\n            let cnt1 = [ init ].count;\n            let cnt2 = allNodes.count;\n\n            return cnt0 == 3 && cnt1 == 2 && cnt2 == 2 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        noinline fn test(ref ints: i32[], ref iview: i32[:]) {\n            inline fn a() {\n                mut empty: i32[];\n                ref indirect = ints || empty;\n                indirect ~= indirect;\n            }\n\n            inline fn b() {\n                mut empty: i32[];\n                ref indirect = iview || empty;\n\n                ref head = indirect[: indirect.len / 2];\n                for (mut i = 0; i < head.len; i++) head[i] *= 2;\n\n                ref tail = indirect[indirect.len - indirect.len / 2 :];\n                for (mut i = 0; i < tail.len; i++) tail[i] *= 2;\n            }\n\n            <fail at call to test 26:24+4 both alias ints 25:17+4>\n            a(); b(); <pass/>\n            b(); a(); </fail>\n        }\n\n        fn main() {\n            mut ints = [ 1, 2, 3, 4, 5 ];\n            test(ints, ints);\n            return ints == [ 2, 4, 3, 8, 10, 2, 4, 3, 8, 10 ] ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct TEA { a: byte[]; b: byte[] };\n\n        fn hash(ref res: TEA, u8view: byte[]) {\n            let u32len  = u8view.len & ~3;\n            let u32view = u8view[: u32len];\n            ref out     = res.a || res.b;\n            out        ~= out;\n            mut x       = u32view ~ \"?\";\n            out        ~= x;\n        }\n\n        fn main() {\n            mut res: TEA;\n            res.b = \"hello, world! \";\n            hash(res, res.b);\n            return res.b == \"hello, world! hello, world! hello, world?\"\n                 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct TwoVecs { a: i32[]; b: i32[] };\n\n        noinline fn disjoint_refs(ref tv: TwoVecs) {\n            <alt>\n            ref         <alt/>\n            noinline fn <alt/>\n            inline fn   </alt> a = tv.a;\n\n            <alt>\n            ref         <alt/>\n            noinline fn <alt/>\n            inline fn   </alt> b = tv.b;\n\n            a ~= b; // 21\n            b ~= a; // 32\n            a ~= b; // 53\n        }\n\n        fn main() {\n            mut tv = TwoVecs(\n                [  1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ],\n                [ 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ]);\n\n            disjoint_refs(tv);\n            return tv.a.len - 53;\n        }\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        nocopy struct PrimArray { prims: i32[]; }\n        nocopy struct Node { index: i32; items?: Node[]; }\n        nocopy struct SolverState { _root: Node; _prim_arrays: PrimArray[] }\n\n        noinline fn AAR_typesCantAlias_lifetimesIntersect(using ref ss: SolverState)\n        {\n            fn unorderedPrep_B(ref root: Node) {\n                let index  = root.index;\n                if (_prim_arrays.len > index) {\n                    ref eph     = _prim_arrays[index];\n                    eph.prims  ~= root.index += eph.prims.len;\n                               // ^^^^^^^^^^ should notice eph can't alias root\n                }\n            }\n\n            return _root.unorderedPrep_B();\n        }\n\n        fn main() {\n            mut ss = SolverState(Node(), [ PrimArray() ]);\n            ss.AAR_typesCantAlias_lifetimesIntersect();\n            return ss._eph.len == 1 && ss._eph[0].things.len == 1 ? 0 : 1;\n        }\n    "_fu, "both alias ref arg ss 6:69+2"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        struct TokenIdx { modid: i32 }\n        struct SolverState { _solver_safety: int }\n\n        noinline fn doTrySpecialize(\n            there: TokenIdx,\n            using implicit ref _ss: SolverState,\n            implicit ref _here: TokenIdx)\n        {\n            let here0   = _here; ///// <- this emitted a const auto&,\n            _here       = TokenIdx( /////// immediately clobbered here\n                _here.modid + there.modid);\n\n            let solver_safety0  = _solver_safety++;\n            if (solver_safety0 > 1)\n                return _here.modid ~ \":\" ~ there.modid ~ \";\";\n\n            defer {\n                _here           = here0;\n                _solver_safety  = solver_safety0;\n            }\n\n            return _here.modid ~ \";\";\n        }\n\n        fn main() {\n            implicit mut _here: TokenIdx;\n            implicit mut _ss: SolverState;\n\n            mut res = \"\";           res ~= doTrySpecialize(TokenIdx(1));\n            _ss._solver_safety++;   res ~= doTrySpecialize(TokenIdx(2));\n            _ss._solver_safety++;   res ~= doTrySpecialize(TokenIdx(3));\n            _ss._solver_safety++;   res ~= doTrySpecialize(TokenIdx(4));\n\n            return res == \"1;2;3:3;7:4;\" ? 0 : 1;                 ;; DuplicateFunctions\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct TokenIdx { modid: i32 }\n        struct SolverState { _solver_safety: int }\n\n        noinline fn doTrySpecialize(\n            there: TokenIdx,\n            using implicit ref _ss: SolverState,\n            implicit ref _here: TokenIdx)\n        {\n            let here0   = _here; ///// <- this emitted a const auto&,\n            _here       = TokenIdx( /////// immediately clobbered here\n                _here.modid + there.modid);\n\n            let solver_safety0  = _solver_safety++;\n            if (solver_safety0 > 1) {\n                return _here.modid ~ \":\" ~ there.modid ~ \";\";\n            }\n            else {\n                defer {\n                    _here           = here0;\n                    _solver_safety  = solver_safety0;\n                }\n\n                if (_here.modid & 1)\n                    return _here.modid ~ \";\";\n            }\n\n            return _here.modid ~ \"!\";\n        }\n\n        fn main() {\n            implicit mut _here: TokenIdx;\n            implicit mut _ss: SolverState;\n\n            mut res = \"\";           res ~= doTrySpecialize(TokenIdx(1));\n            _ss._solver_safety++;   res ~= doTrySpecialize(TokenIdx(2));\n            _ss._solver_safety++;   res ~= doTrySpecialize(TokenIdx(3));\n            _ss._solver_safety++;   res ~= doTrySpecialize(TokenIdx(4));\n\n            return res == \"1;0!3:3;7:4;\" ? 0 : 1;                 ;; DuplicateFunctions\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn incr_out(ref out: i32[][], a: i32[], b: i32[]) {\n            out ~= a;\n            out ~= b;\n        }\n\n        fn incr_state(ref state: i32[]) {\n            state ~= state.len;\n            return state;\n        }\n\n        fn bck_discards_its_edits_to_defer_nodes(\n            ref out: i32[][], ref state: i32[])                 ;; PointlessMustSeq\n        {\n            incr_out        (:out, incr_state(state), incr_state(state));\n            defer incr_out  (:out, incr_state(state), incr_state(state));\n            return out;\n        }\n\n        fn main() {\n            mut state = [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ];\n            mut out: i32[][];\n            bck_discards_its_edits_to_defer_nodes(:out, :state);\n\n            mut result = 0;\n            for (mut i = 0; i < out.len; i++) {\n                let item = out[i];\n                result += item.len << ((3 - i) * 4);\n            }\n\n            return result.u32 == 0xabcd ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        nocopy struct Val { x: i32 };\n        struct Out { v: Val };\n        fn move_Val_into_Out(mut v: Val)    = Out(:v);\n        fn main()                           = move_Val_into_Out(Val(0)).v.x;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn must_not_move_mystr(n: i32) {\n            mut mystr = \"\";\n            for (mut i = 0; i < n; i++)\n                mystr ~= \"!\";\n\n            mut result: string[];\n            for (mut i = 0; i < n; i++)\n                result ~= mystr;\n\n            return result.join();\n        }\n\n        fn main() = must_not_move_mystr(3).len - 9;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Type {\n            canon: string;\n            quals: int;\n        };\n\n        fn takes_ref_and_val(ref r!: Type, mut v!: Type) {\n            v.canon ~= r.canon;\n            r.canon ~= v.canon;\n            v.quals |= r.quals;\n            return r;\n        }\n\n        fn main() {\n            mut t = Type(\"abc\", 123);\n            return takes_ref_and_val(r: t, v: t).canon.len - 9;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Type {\n            canon: string;\n            quals: int;\n        };\n\n        fn takes_two_strings(mut a: Type, mut b: Type) {\n            b.canon ~= a.canon;\n            a.canon ~= b.canon;\n            a.quals |= b.quals;\n            return a;\n        }\n\n        fn move_on_last_use_OOE(mut canon: string, quals: int) {\n            canon ~= canon;\n            return takes_two_strings(   ;; N_MoveMustSeq\n                Type(:canon, :quals),\n                Type(:canon, :quals));  // out of order move-into-struct will break this\n        }\n\n        fn main() {\n            let res = move_on_last_use_OOE(\n                \"1234567890abcdef1234567890abcdef\" // len=32, *2 = 64, *3 = 192\n                    1000);\n\n            return res.canon.len + res.quals - 1192;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Type {\n            canon: string;\n            quals: int;\n        };\n\n        fn takes_two_strings_and_an_int(mut a: Type, mut b: Type, c: int) {\n            b.canon ~= a.canon;\n            a.canon ~= b.canon;\n            a.quals |= b.quals;\n            a.quals += c;\n            return a;\n        }\n\n        fn moves_reordered_by_bck_OOE(mut canon: string, mut quals: int) {\n            canon ~= canon;\n            return takes_two_strings_and_an_int(    ;; N_MoveMustSeq\n                Type(:canon, 0),\n                Type(:canon, quals++), // quals++ triggered bck MUSTSEQ\n                             quals  ); //  which reordered arg b BEFORE arg a,\n        }                              //   which broke move-on-last-use.\n\n        fn main() {\n            let res = moves_reordered_by_bck_OOE(\n                \"1234567890abcdef1234567890abcdef\" // len=32, *2 = 64, *3 = 192\n                    0);\n\n            return res.canon.len + res.quals - 193;\n        }\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        fn track_last_loop_confusion(mut a: string, mut b: string)\n        {\n            for (mut i = 0; i < 6; i++) {\n                a ~= a; // foil smallstring opti\n                b ~= b; //  both are 64 chars long\n            }\n\n            ref x = a.len == 64 ? b : a;\n            ref y = b.len == 64 ? x : a; // y points to b two refs deep\n\n            mut result = b; // <-- BROKEN MOVE FROM b HERE\n\n            // once\n            for (mut i = result.len / 64; i --> 0; ) {\n                y ~= y;         // now 128, ensures y not a view\n                result ~= y;    // for a total of 192\n            }\n\n            return result;\n        }\n\n        fn main() {\n            mut res = track_last_loop_confusion(\"a\", \"b\");\n            return res.len == 192 ? 0 : 1;\n        }\n    "_fu, "COW will break 16:22+1 9:17+1"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        nocopy struct NCItem { x: i32 };\n\n        fn unshift_odds_push_evens(n: i32) {\n            mut arr: NCItem[];\n            for (mut i = 0; i < n; i++) {\n                let item = NCItem(i);\n                if (i & 1)  arr.unshift(item);                  ;; !*MustSeq\n                else        arr.push(item);\n            }\n            return arr;\n        }\n\n        fn main() {\n            let arr = unshift_odds_push_evens(3);\n            return arr[0].x == 1\n                && arr[1].x == 0\n                && arr[2].x == 2 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        nocopy struct NCThing { x: i32 };\n\n        fn last_used_before_break(mut nc: NCThing, N: i32) {\n            mut res: NCThing;\n            for (mut i = 0; i < N; i++) {\n                nc.x *= 2;\n                if (nc.x > 10) {\n                    if (nc.x > 20) return nc;\n                    res = nc; // <- should move here ...\n                    break;\n                }\n            }\n\n            <fail cannot be copied or moved 10:27>\n            if (nc.x > 15) return nc; // <- ... unless used here.\n            <pass/></fail>\n\n            res.x *= 10;\n            return res;\n        }\n\n        fn main() {\n            let res = last_used_before_break(NCThing(3), 10);\n            return res.x - 120;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        nocopy struct NCThing { str: string };\n\n        fn last_used_in_defer(mut nc: NCThing, ref other: NCThing) {\n            defer other = nc; // last use, move here!\n            while (nc.str.len < 64)\n                nc.str ~= nc.str;\n\n            <fail cannot be copied or moved 10:20>\n            return nc;                     <pass/>\n            return nc.str.len;             </fail>\n        }\n\n        fn main() {\n            mut other: NCThing;\n            last_used_in_defer(NCThing(\"Hello!\"), other);\n            return other.str.len - 96;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        nocopy struct Node { nodes: Node[]; }\n\n        noinline fn add(a: i32, b: i32) {\n            return a + b;\n        }\n\n        fn main() {\n            mut res = Node([ Node ]);\n            mut cpy: Node;\n\n            mut res_len = 0;\n            mut cpy_len = 0;                                    ;; N_MoveMustSeq\n            <alt>\n            mut sum = (res_len = res.nodes.len) + (cpy_len = (cpy = res).nodes.len); <alt/>\n            mut sum = add(res_len = res.nodes.len, cpy_len = (cpy = res).nodes.len); </alt>\n\n            return cpy.nodes.len == cpy_len\n                && res_len == 1\n                && cpy_len == 1\n                && sum == 2             ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        nocopy struct NC { ncs: NC[] };\n\n        struct Foreign { name: NC; kind: i32; flags: i32 };\n        struct Local   { kind: i32; flags: i32; name: NC };\n\n        fn intoLocal(using mut f: Foreign) = Local(:kind, :flags, :name);\n\n        <split/>\n        fn main() {\n            let foreign = Foreign(NC([ NC(), NC() ]), 0, 0);\n            let local = intoLocal(foreign);\n            return local.name.ncs.len - 2;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct A { items: i32[] };\n        struct B { items: i32[] };\n\n        <alt>\n        fn takesRef_OOE(ref a: A, b: B) <alt/>\n        fn takesRef_OOE(b: B, ref a: A) </alt>\n            a.items ~= b.items;\n\n        struct C { items: i32[] };\n\n        fn C2B(mut c: C) B(c.items);\n\n        fn selectA(mut c: C, ref a0: A, ref a1: A) {\n            ref a   = c.items.len & 1 ? a0 : a1;\n            a.items = c.items;\n            return a;\n        }\n\n        fn main() {\n            mut c = C([ 1, 2, 3, 4, 5, 6, 7 ]);\n            mut a0: A;\n            mut a1: A;\n\n            takesRef_OOE(                                       ;; N_MoveMustSeq\n                a: selectA(:c, :a0, :a1),\n                b: C2B(:c));\n\n            return a0.items.len - 14;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        nocopy struct NoCopy { a: i32[]; b: i32[] };\n\n        noinline fn mustRelaxMut(mut nc: NoCopy)\n            nc.a.len - nc.b.len;\n\n        fn main() {\n            mut x = NoCopy([ 0 ], [ 0, 1 ]);\n            mut y = NoCopy([ 0, 1, 2, 3 ], [ 0, 1, 2 ]);\n            for (mut i = 0; i < 10; i++) {\n                if (mustRelaxMut(x) + mustRelaxMut(y))\n                    return 1;\n\n                x.a.push(x.a.len);\n                y.b.push(y.b.len);\n            }\n\n            return 0;\n        }\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        struct BINOP {\n            P: Map(string, i32);\n        };\n\n        fn setupOperators(): BINOP\n        {\n            mut out: BINOP;\n\n            fn binop(op: string)\n                out.P[op] = 7;\n\n            binop(\",\");\n\n            return out;\n        }\n\n        shadow let BINOP = setupOperators();\n        let P_COMMA = BINOP.P[\",\"] || throw(\"Assertion failed.\");\n\n        fn main() P_COMMA - 7;\n    "_fu, "Map is not defined"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        // -no-lambda\n        // This converted to a ref-returning\n        // logical chain for some reason.\n        let hex = true;\n        let trail = \"x\";\n        if (!(trail >= \"0\" && trail <= \"9\") &&\n            !(hex && (trail >= \"a\" && trail <= \"f\"\n                   || trail >= \"A\" && trail <= \"F\")))\n        {\n            return 0;\n        }\n\n        return 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Type     { i: i32; };\n        struct Token    { i: i32; };\n        struct ScopeIdx { i: i32; };\n\n        struct SolvedNode\n        {\n            kind:       string;\n            flags?:     i32;\n            value?:     string;\n            items?:     SolvedNode[];\n            token:      Token;\n\n            type:       Type;\n            target?:    ScopeIdx;\n        };\n\n        let _here: Token;\n\n        fn createDefaultInit(type: Type): SolvedNode\n        {\n            // Broken arg re-arrange.\n            return SolvedNode(\n                kind: \"definit\",\n                token: _here,\n                :type);\n        }\n\n        return createDefaultInit(Type()).target.i;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Type         { i: i32; };\n        struct Scope        { i: i32; };\n        struct Partial      { i: i32; };\n        struct Template     { i: i32; };\n        struct SolvedNode   { i: i32; };\n\n        fn Scope_add(\n            scope: &mut Scope,\n            kind: string, id: string, type: Type,\n\n            min: i32 = 0,\n            max: i32 = 0,\n            arg_n: string[]     = [],\n            arg_t: Type[]       = [],\n            arg_d: SolvedNode[] = [],\n            template: Template  = [],\n            partial: Partial    = []): i32\n        {\n            return scope.i\n                 + kind.len + id.len + type.i\n                 + min + max + arg_n.len + arg_t.len + arg_d.len\n                 + template.i + partial.i;\n        }\n\n        mut _scope: Scope;\n        let id: string;\n        let t_template: Type;\n        let min: i32;\n        let max: i32;\n        let arg_n: string[];\n        let template: Template;\n\n        return Scope_add(\n            _scope,\n            \"\", id, t_template,\n            min, max, arg_n,\n            :template);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let i = 0;\n        let items = [ \"\" ];\n        i == items.len - 1 || throw(\"what?\");\n        return i;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        return false /* test */\n             ? 0xffffff.i32 // what is this\n             : 0 // madness\n             ;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(id: i32) id;\n        return test(/*id*/0); // <- bad parse\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn path_normalize(p: string): string {\n            mut path = p.split(\"/\");\n\n            for (mut i = path.len; i --> 0; ) {\n                let part: &string = path[i];\n                if (part == \".\" || !part && i > 0 && i < path.len - 1)\n                    path.splice(i, 1);\n            }\n\n            return path.join(\"/\");\n        }\n\n        fn main() path_normalize(\"./hello///hey\") == \"hello/hey\" ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn path_normalize(p: string): string {\n            mut path = p.split(\"/\");\n\n            for (mut i = path.len; i --> 0; ) {\n                let part = path[i];\n                if (part == \".\" || !part && i > 0 && i < path.len - 1)\n                    path.splice(i, 1);\n            }\n\n            for (mut i = 1; i < path.len; i++) {\n                if (path[i] == \"..\")\n                    path.splice(--i, 2);\n            }\n\n            return path.join(\"/\");\n        }\n\n        fn path_join(a: string, b: string)\n            path_normalize(a ~ \"/\" ~ b);\n\n        fn main()\n            path_join(\"hello/hey\", \"./../you//\") == \"hello/you/\"\n                ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        pub struct Template { locals: ScopeMemo; }; // <- used ahead of the def, was missing q_trivial\n        pub struct ScopeMemo { x: i32; }; // <- trivial, discovered on solve here after Template is done\n        pub fn +(a: ScopeMemo, b: ScopeMemo) a.x + b.x; // <- used here after both structs are done\n\n        pub fn main() {\n            let a = Template(ScopeMemo(+3));\n            let b = Template(ScopeMemo(-3));\n            return a.locals + b.locals; // <- fails to match.\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        novec fn novec_each(ref a: $T[], fn)\n            for (mut i = 0; i < a.len; i++)\n                fn(a[i]);\n\n        fn main() {\n            mut a = [ 1 ];\n            a.novec_each: |ref i| i *= 2;\n            return a[0] - 2;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        novec fn Each(ref a: [$T], fn)\n            for (mut i = 0; i < a.len; i++)\n                fn(a[i]);\n\n        struct Node { kind: string; items: Node[]; flags: i32; };\n\n        let F_PREDICATE = 2;\n\n        fn parse(tokens: byte[]): Node {\n            mut _idx = 0;\n\n            fn parseStructDecl(flags! = 0): Node {\n                mut items = parseBlockLike('}');\n\n                :F_PREDICATE {\n                    items.Each: |item|\n                        if (item.kind == \"let\")\n                            if (item.flags & F_PREDICATE)\n                                break :F_PREDICATE;             ;; Goto\n\n                    items.Each: |ref item|\n                        if (item.kind == \"let\")\n                            item.flags |= F_PREDICATE;\n                }\n\n                return Node(\"struct\", items, :flags);\n            }\n\n            fn parseBlockLike(endToken: byte): Node[] {\n                mut items: Node[] = [];\n                for (;;) {\n                    let token = tokens[_idx++];                 ;; !N_BckMustSeq\n                    if (token == endToken)                      ;; !N_MoveMustSeq\n                        break;\n\n                    items ~= Node(\"let\", [], flags: token == '+' && F_PREDICATE);\n                }\n\n                return items;\n            }\n\n            return parseStructDecl();\n        }\n\n        fn main() {\n            let tokens = \"+-}\";\n            let p = parse(tokens).items;\n            return p.len - p[0].flags\n                         + p[1].flags * 17;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        pub struct MeshBuilder\n        {\n            verts?:     byte[];\n            indices?:   byte[];\n            vert_bytes: i32;\n            num_verts?: i32;\n        };\n\n        pub fn alloc(\n            using mb: &mut MeshBuilder,\n            new_verts: i32,\n            new_indices: i32)\n        {\n            verts.resize_junk((verts.len + new_verts) * vert_bytes);\n\n            let index_bytes = 4;\n            indices.resize_junk((indices.len + new_indices) * index_bytes);\n        }\n\n        pub fn setup_quads(\n            using mb: &mut MeshBuilder, // <- the 'using' introduced more bindings,\n            num_quads: i32)             // <-  advancing the target index number of this arg,\n                : &mut [byte]           // <-   confusing the callsite lifetime of this view.\n        {\n            let b0 = verts.len;\n            let v0 = num_verts;\n            let i0 = indices.len;\n\n            mut v1 = v0;\n\n            alloc(num_quads * 4, num_quads * 6);\n\n            let indices_i32: &mut [i32] =\n                indices[i0 : indices.len]\n                    .view(i32);\n\n            for (mut i = 0; i < indices_i32.len; i += 6)\n            {\n                indices_i32[i    ] = v1;\n                indices_i32[i + 1] = v1 + 1;\n                indices_i32[i + 2] = v1 + 2;\n\n                indices_i32[i + 3] = v1;\n                indices_i32[i + 4] = v1 + 2;\n                indices_i32[i + 5] = v1 + 3;\n\n                v1 += 4;\n            }\n\n            num_verts = v1;\n\n            return verts[b0 : verts.len];\n        }\n\n        let QUAD_VBO: f32[] =\n        [\n            -1, -1, 0,      0, 0, 1,    0, 0,\n            +1, -1, 0,      0, 0, 1,    1, 0,\n            +1, +1, 0,      0, 0, 1,    1, 1,\n            -1, +1, 0,      0, 0, 1,    0, 1,\n        ];\n\n        pub fn main()\n        {\n            mut mb = MeshBuilder(\n                vert_bytes: 4 * (3+3+2));\n\n            mb.setup_quads(1).view(f32) .= QUAD_VBO;\n\n            return mb.num_verts - 4;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn target(implicit ref _target: i32) _target;\n\n        // this suddenly reported that it doesn't see __solveStruct\n        fn GET_mut(ref x: i32) x || target;\n\n        // while i was trying to reproduce an ambig \"o\" fail here\n        fn __solveStruct(mut arg: i32): i32 {\n            if (arg) {\n                ref o = GET_mut(arg);\n                o++;\n                checkRecursions(o, o);\n            }\n            return arg;\n        }\n\n        fn checkRecursions(ref o: i32, incr: i32): void { GET_mut(o) += incr; }\n\n        fn main() {\n            implicit mut _target = 0;\n            return __solveStruct(1) - 4;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            mut target = 0;\n            fn GET_mut(ref x: i32) x || GET_mut(target += 1);   ;; PointlessMustSeq\n            return GET_mut(target) - 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn target(implicit ref _itarg: i32) _itarg;\n\n        fn main() {\n            implicit mut _itarg = 0;\n            fn GET_mut(ref x: i32) x || GET_mut(target += 1);   ;; PointlessMustSeq\n            return GET_mut(target) - 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn target(implicit ref _itarg: i32) _itarg;\n        fn GET_mut(ref x: i32) x || GET_mut(target += 1);       ;; PointlessMustSeq\n\n        fn main() {\n            implicit mut _itarg = 0;\n            return GET_mut(target) - 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            mut target = 0;\n            fn GET_mut(ref x: i32) x || GET_mut(++target);      ;; PointlessMustSeq\n            return GET_mut(target) - 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        // TODO use something like pragma lax to opt-out of cc warnings.\n        // Output looks fine & works on gcc/clang but gcc warns and breaks build.\n        pragma emit(`#pragma GCC diagnostic ignored \"-Wsequence-point\"`);\n\n        fn main() {\n            mut target = 0;\n            fn __solveStruct(mut arg: i32): i32 {\n                ref o = GET_mut(arg); o += target;\n                return target;\n            }\n\n            fn GET_mut(ref x: i32)\n                x || (target = __solveStruct(target += 1));     ;; PointlessMustSeq\n\n            return __solveStruct(0) - 2;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn incr(ref a: i32) ++a;\n        fn A(ref a: i32) a || (a = B(incr(a)));\n        fn B(ref b: i32) b || (b = A(incr(b)));\n        fn main() { mut v = 0; return A(v) - 1; }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn incr(ref a: i32) ++a;\n        fn A(ref a: i32) { ref aa = a || (a = B(incr(a))); return aa; }\n        fn B(ref b: i32) { ref bb = b || (b = A(incr(b))); return bb; }\n        fn main() { mut v = 0; return A(v) - 1; }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main()\n        {\n            fn Each(cond, cons) cond && cons();\n            fn arg(implicit ref __arg: i32) __arg;\n            fn __solveStruct(x = 3) Each(arg, || arg += x);\n            implicit mut __arg = 1;\n            return __solveStruct - 4;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            fn Each(cond, cons)                     cond && cons();\n            fn arg_incr_x(mut arg: i32)             Each(arg, || arg);\n            return arg_incr_x(+7) - 7;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            fn Each(cond, cons)                     cond && cons();\n            fn arg_incr_x(mut arg: i32, x = 0)      Each(arg, || arg += x);\n            return arg_incr_x(+7, -11) + 4;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            fn Each(cond, cons)                     cond && cons();\n            fn arg_incr_x(mut arg: i32, x = 0): i32 {\n                Each(arg, || arg += x);\n                return arg;\n            }\n            return arg_incr_x(+7, -11) + 4;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main()\n        {\n            mut target = 0;\n\n            fn Each(cond, cons) cond && cons();\n\n            fn GET_mut(ref x: i32) x || (target = __solveStruct(target));\n\n            fn __solveStruct(mut arg: i32, x = 0): i32 {\n                Each(arg, || arg += x);\n                if (arg) {\n                    ref o = GET_mut(arg);\n                    o++;\n                    checkRecursions(o, o);\n                }\n                return arg;\n            }\n\n            fn checkRecursions(ref o: i32, incr: i32): void { GET_mut(o) += incr; }\n\n            return __solveStruct(1) - 4;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main()\n        {\n            mut target = 0;\n\n            // this suddenly reported that it doesn't see __solveStruct\n            fn GET_mut(ref x) x || (target = __solveStruct(target));\n\n            // while i was trying to reproduce an ambig \"o\" fail here\n            fn __solveStruct(mut arg: i32): i32 {\n                if (arg) {\n                    ref o = GET_mut(arg);\n                    o++;\n                    checkRecursions(o, o);\n                }\n                return arg;\n            }\n\n            fn checkRecursions(ref o: i32, incr: i32): void { GET_mut(o) += incr; }\n\n            return __solveStruct(1) - 4;\n        }\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        struct ValueType { modid: i32; };\n        struct Type { using vtype: ValueType; };\n        struct Target { modid: i32; index: i32; };\n        struct Overload { name: string; id: string; };\n\n        fn GET(target: Target): Overload =\n            Overload(\n                name: \"N\" ~ target.index,\n                  id: \"I\" ~ target.index);\n\n        fn main() {\n            mut specs: Map(string, Target);\n\n            fn setSpec(mangle: string) {\n                ref t = specs[mangle] ||= Target;\n\n                // This template should start expanding on GET(target).name,\n                //  which should conflict with overload name.\n                fn name(shadow target)\n                    GET(target) <fail ambig>\n                        .name;  <pass/>\n                        .id;    </fail>\n\n                return t.name;\n            }\n\n            return setSpec(\"hey\").len - 2;\n        }\n    "_fu, "Map is not defined"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        pub struct ScopeSkip { start: i32; end: i32; };\n\n        pub fn Each(items: [$T], scope_skip: ScopeSkip[], fn, start = 0) {\n            let END_DUMMY = ScopeSkip(start: items.len, end: items.len);\n\n            mut i0 = start;\n            for (mut i = 0; i < scope_skip.len + 1; i++) {\n                let ss = i < scope_skip.len ? scope_skip[i] : END_DUMMY;\n                if (ss.end <= i0)\n                    continue;\n\n                let i1 = ss.start;\n                for (shadow mut i = i0; i < i1; i++)\n                    fn(items[i]);\n\n                i0 = ss.end;\n            }\n        }\n\n        pub fn test(items?: i32[]) {\n            mut sum = 0;\n            let ss: ScopeSkip[];\n            items.Each(ss, |item| sum += item, start: sum);\n            return sum;\n        }\n\n        pub fn main() test();\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        fn setupOperators(P_PREFIX_UNARY) // <- template\n        {\n            struct BINOP {\n                PRECEDENCE:     Map(string, i32);\n                RIGHT_TO_LEFT:  Map(i32,   bool);\n            };\n\n            mut out: BINOP; // <- no BINOP in scope\n            mut precedence = P_PREFIX_UNARY;\n            mut rightToLeft = false;\n\n            fn binop(ops: string[]) {\n                precedence++;\n                out.RIGHT_TO_LEFT[precedence] = rightToLeft;\n                for (mut i = 0; i < ops.len; i++)\n                    out.PRECEDENCE[ops[i]] = precedence;\n            }\n\n            binop([ \"|>\" ]);\n\n            //\n            return out;\n        }\n\n        let BINOP = setupOperators(-1);\n\n        fn main() {\n            let precedence = BINOP.PRECEDENCE[\"|>\"];\n            return precedence;\n        }\n    "_fu, "Map is not defined"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        fn Each(a: [$T], fn, start!?: i32)\n            for (mut i = start; i < a.len; i++)\n                fn(a[i]);\n\n        fn main() {\n            mut sum = 0;\n            let a = [ 1, 2, 3 ];\n            a.Each(|i| sum += i, start: sum);   // <- start inferred to ref i32, which couldnt definit\n            return sum - 6;                     //     perhaps we can use the optionality to infer constness\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        <fail novec>\n        novec // Abusing to test novec, unrelated to the test\n        <pass/></fail>\n        fn ScopeSkip_push(ref scope_skip: i32[]) {\n            if (scope_skip) scope_skip[0]++;\n            else            scope_skip ~= 1;\n        }\n\n        fn main() {\n            mut scope_skip = [ 1 ];\n            ScopeSkip_push(scope_skip);\n            return scope_skip[0] - 2;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Hello { v: i32[] };\n\n        fn main() {\n            let h = Hello();\n\n            <fail novec>\n            novec // qSTACK bug with args.len == 0 at call to Hello\n            <pass/></fail>\n            fn hello(woot?: i32)\n                woot ? Hello() : h;\n\n            return hello.v.len;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Module  { cpp:    string; };\n        struct Context { module: Module; };     // Simplification of next test, no need to consider COW here\n\n        fn snippet2cpp(cpp: string): string {\n            let ctx = Context( Module(cpp) );\n            {\n                let module = ctx.module;        // This was const Module& =  ... which can't be moved from.\n                if (module.cpp)\n                    return module.cpp;          ;; EXPECT return static_cast<fu::str&&>\n            }\n\n            return \"\";\n        }\n\n        fn main() snippet2cpp(\"1\").len - 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Module  { cpp:     string;   };\n        struct Context { modules: Module[]; };  // Module[] is COW-capable -\n                                                //  - either prove there's no COW,\n        fn snippet2cpp(cpp: string): string {   //  - or don't attempt to move out the item.\n            let ctx = Context([ Module(cpp) ]);\n            for (mut i = 0; i < ctx.modules.len; i++)\n            {\n                let module = ctx.modules[i];    ;; TODO .unique(i)\n                if (module.cpp)\n                    return module.cpp;          ;; TODO return static_cast<fu::str&&>\n            }\n\n            return \"\";\n        }\n\n        fn main() snippet2cpp(\"1\").len - 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(x: string) {\n            // cg fail: fwd annots of the two fns where unconsting hey to \"enable move\",\n            //          basically the decision was made in the wrong scope.\n            let hey = \"hey\";\n            fn inner(you: string) you && hey ~ you || outer(\"what#1\");\n            fn outer(arg: string) inner(arg && \" \" ~ arg) || inner(\"what#2\");\n            return outer(x);\n        }\n\n        fn main() test(\"you\").len - 7;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Target { modid!: i32; packed!: i32; };\n        inline fn index(a: Target) a.packed;\n\n        <split/>\n\n        struct CurrentFn { using target: Target; };\n        fn hello(c?: CurrentFn) c.index;\n        fn main() hello;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct ID   { offset: i32;  };\n        struct Data { items:  ID[]; };\n\n        using fn Data(implicit all: Data[], nid: ID): Data {\n            return all[nid.offset];\n        }\n\n        fn test(node: ID) {\n            let init = node.items[0];\n            return init.items.len;\n        }\n\n        fn main() {\n            let implicit all =  [ Data([ ID(1)      ])\n                                , Data([ ID, ID, ID ]) ];\n\n            return 0.ID.test - 3;\n        }\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        struct Context\n        {\n            fuzzy: Map(string, string);\n            files: string[];\n        }\n\n        fn resolveFile(\n            implicit ctx: &mut Context,\n            from: string, name: string): string\n        {\n            let path    = from ~ name;\n            let cached  = ctx.fuzzy[path];\n            if (cached)\n                return cached == \"\v\" ? \"\" : cached;\n\n            fn tryResolve(): string\n            {\n                let exists = file::size(path) >= 0;\n                if (exists)\n                    return path;\n\n                return \"\";\n            };\n\n            let resolve = tryResolve();\n            ctx.fuzzy[path] = resolve || \"\v\";\n            return resolve;\n        }\n\n        pub fn resolveFile(\n            implicit ctx: &mut Context,\n            path: string): string\n        {\n            let fuzzy = path.find('\v');\n            if (fuzzy > 0)\n            {\n                let from = path.slice(0, fuzzy);\n                let name = path.slice(fuzzy + 1);\n                if (from && name && !name.has('\v'))\n                {\n                    let res = resolveFile(:from, :name);\n                    if (res)\n                        return res;\n\n                    // Tests have the files prepopulated,\n                    //  we only pay the cost of lookup when about to fail compile.\n                    let prepopulated = from ~ name;\n                    if (ctx.files.has(prepopulated))\n                        return prepopulated;\n                }\n            }\n\n            return path;\n        }\n\n        fn main() {\n            implicit mut ctx: Context;\n            return resolveFile(\"a\").len - 1;\n        }\n    "_fu, "Map is not defined"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        struct S { i: i32; };\n\n        fn hello(ref s: S, w: i32) {\n            infix fn |=(<fail ambig 6:17><pass/>shadow </fail>ref s: S, v: i32)\n                s.i |= v << w;\n\n            s |= 2;\n        }\n\n        fn main() {\n            mut s = 1.S;\n            s.hello(3);\n            return s.i - 17;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn lex(src: string) {\n            let end = src.len;\n            mut idx = 0;\n\n            fn err_str(idx1: i32) {\n                while (idx < end && src[idx] == ' ') idx++;\n                return src.slice(idx, idx1);\n            }\n\n            fn err(idx1_x2: i32) err_str(idx1_x2 /2);\n            return err(end *2);\n        }\n\n        fn main() lex(\"    hello\").len - 5;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        pub fn ZERO(implicit ref sum: i32, mut sources: string[]): void\n        {\n            // Fuzzing module splits.\n            for (mut i = 0; i < sources.len; i++)\n            {\n                for (;;)\n                {\n                    ref src     = sources[i];\n\n                    mut start0  = src.find(\"[split/]\");\n                    if (start0 < 0)\n                        break;\n\n                    let start00 = start0;\n                    let start1  = start0 + 8;\n                    while (start0 && src[start0 - 1] == ' ') start0--;\n\n                    let moduleA = src.slice(0, start0);\n                    let moduleB = src[start0 : start00] ~ \"import _\" ~ i ~ \";\" ~ src[start1 : src.len];\n                    let without = src[0 : start0] ~ src[start1 : src.len];\n\n                    sources[i]  = without;\n                    ZERO(:sources);\n\n                    sources[i]  = moduleA;\n                    sources.insert(i + 1, moduleB);\n                }\n\n                sum += sources[i].len;\n            }\n        }\n\n        fn main() {\n            implicit mut sum: i32;\n\n            ZERO( \"AAAA|BB[split/]CC\".split(\"|\") );\n            let expect = 4+2+2 + 4+2+2 + 10; // 10 = \"import _0;\"\n\n            return sum - expect;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct SolvedNode {\n            bli: i32;\n        };\n\n        // --> [2] ... triggered the solve of this fn, ...\n        fn SolvedNode(blah: string) {\n            return SolvedNode(blah.len.NOT_PREPPED_YET);\n        }\n\n        // [1] During prep, this type annotation ...\n        fn ARG_ANNOT_TRIGGERS_SOLVE(node: SolvedNode) {\n            return node.bli + 2;\n        }\n\n        // --> --> [3] ... which couldnt yet see this fn (prep didnt reach here).\n        fn NOT_PREPPED_YET(x: i32) {\n            return x * 2;\n        }\n\n        fn main() {\n            return ARG_ANNOT_TRIGGERS_SOLVE(SolvedNode(\"hello\")) - (2*5+2);\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct SolvedNode       { nodeidx: i32; };\n        struct CurrentFn        { using out: SolvedNode; };\n\n        struct Target           { index: i32; };\n        struct SolvedNodeData   { target: Target; };\n        struct Overload         { nodes: SolvedNodeData[]; };\n\n        fn test(ref overloads: Overload[],\n                ref _current_fn: CurrentFn)\n        {\n            using fn GET(target: Target) {\n                let o = overloads[target.index];\n                return o;\n            }\n\n            using fn SolvedNodeData(nid: SolvedNode) {\n                let nodes = overloads[nid.nodeidx].nodes;\n                return nodes[nid.nodeidx];\n            }\n\n            let current_fn  = _current_fn.target;               // <- this is a ref into overloads\n            let debug_2     = current_fn && GET(current_fn);    // <- this is the perceived write to overloads\n            return debug_2 && current_fn.index;                 // <- which invalidates this read\n        }\n\n        fn main() {\n            mut _current_fn = CurrentFn(SolvedNode(0));\n            mut overloads   = [ Overload([ SolvedNodeData(Target(0)) ]) ];\n\n            return test(overloads, _current_fn);\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct SolvedNode       { nodeidx: i32; };\n        struct CurrentFn        { using out: SolvedNode; };\n\n        struct Target           { index: i32; };\n        struct SolvedNodeData   { target: Target; };\n        struct Overload         { nodes: SolvedNodeData[]; };\n\n        fn test(ref overloads: Overload[],\n                ref _current_fn: CurrentFn)\n        {\n            using fn GET(target: Target) {\n                if (target.index != 303) // Same as above, different setup.\n                    return overloads[target.index];\n\n                return []; // Also this fails to solve: cannot definit mutref\n            }\n\n            using fn SolvedNodeData(nid: SolvedNode) {\n                return nid.nodeidx != 303 // Same as above, rewording as a logical.\n                    && overloads[nid.nodeidx].nodes[nid.nodeidx];\n            }\n\n            let current_fn  = _current_fn.target;               // <- this is a ref into overloads\n            let debug_2     = current_fn && GET(current_fn);    // <- this is the perceived write to overloads\n            return debug_2 && current_fn.index;                 // <- which invalidates this read\n        }\n\n        fn main() {\n            mut _current_fn = CurrentFn(SolvedNode(0));\n            mut overloads   = [ Overload([ SolvedNodeData(Target(0)) ]) ];\n\n            return test(overloads, _current_fn);\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Token {\n            col: i32;\n            line: i32;\n            value: string;\n        };\n\n        fn parse(tokens: Token[]) {\n            mut _idx = 0;\n            mut _loc = 0;\n\n            fn fail(mut reason = \"\") {\n                let loc  = tokens[_loc];\n                let here = tokens[_idx];\n                if (!reason)\n                    reason = \"Unexpected '\" ~ here.value ~ \"'.\";\n\n                let l0 = loc.line;  let c0 = loc.col;\n                let l1 = here.line; let c1 = here.col;\n\n                let addr = l1 == l0\n                    ? \"@\" ~ l1 ~ \":\" ~ c1\n                    : \"@\" ~ l0 ~ \":\" ~ c0 ~ \"..\" ~ l1 ~ \":\" ~ c1;\n\n                return throw(addr ~ \":\\n\\t\" ~ reason);\n            }\n\n            fn consume(value: [byte], err = \"\") {\n                let token = tokens[_idx];\n                if (token.value == value) {\n                    _idx++;\n                    return token;\n                }\n\n                return fail((err || \"Expected\") ~ \" '\" ~ value ~ \"', got '\" ~ token.value ~ \"'.\");\n            }\n\n            fn parseRoot() {\n                let ret = consume(\"sof\");\n                _loc = _idx;\n                return ret;\n            }\n\n            return parseRoot();\n        }\n\n        fn main() {\n            return parse([ Token(1, 1, \"sof\") ]).value.len - 3;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn CallerNode(mut t?: i32, arr?: i32[])\n        {\n            for (mut i = 0; i < arr.len; i++) {\n                return CallerNode(arr[i]);\n                //     ^^^^^^^^^^\n                // fn CallerNode: Arg #1, arr not assignable to host_arg:\n                //      expect: []+252i32: ref copy resize\n                //      actual: []+252i32: ref\n            }\n\n            return t;\n        }\n\n        fn main() = CallerNode();\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Target       { index: i32; };\n        struct SolvedNode   { target: Target; args: SolvedNode[]; };\n\n        fn CallerNode(\n            mut target: Target,\n            mut args: SolvedNode[] = [],\n            reorder?: i32[],\n            conversions?: Target[][]): SolvedNode\n        {\n            if (reorder) {\n                mut args_out: SolvedNode[]; args_out.resize(reorder.len);\n                for (mut i = 0; i < reorder.len; i++) {\n                    let idx = reorder[i];\n                    if (idx >= 0)\n                        args_out[i] = args[idx];\n                }\n\n                args = args_out;\n            }\n\n            for (mut argIdx = 0; argIdx < conversions.len; argIdx++) {\n                let conversion = conversions[argIdx];\n                for (mut i = 0; i < conversion.len; i++) {\n                    args[argIdx] = CallerNode(conversion[i]);\n                    //             ^^^^^^^^^^\n                    // fn CallerNode: Arg #2, reorder not assignable to host_arg:\n                    //      expect: []+252i32: ref copy resize\n                    //      actual: []+252i32: ref copy\n                }\n            }\n\n            return SolvedNode(:target, :args);\n        }\n\n        fn main() {\n            return CallerNode(Target(0)).target.index;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn qSTACK(x: i32) {\n            let rec = x & 1 && \"rec \";\n            let via = !rec && qSTACK(x / 2);\n            return \"\\n\" ~ rec ~ \"at #\" ~ x ~ via;\n        }\n\n        fn main() qSTACK(2).len - 2 - 4 - 8 - 2;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct SolvedNode { items: SolvedNode[] };\n\n        fn solve(node: SolvedNode) {\n            mut events = 0;\n\n            fn propagateType(shadow node: SolvedNode) {\n                fn tryTrackLastUse() !(node.items.len & 1);\n                let canDiscard = node.items.len != 0;\n                fn discardIntoBlock() tryTrackLastUse();\n\n                if (canDiscard && discardIntoBlock)\n                    propagateType(node.items[0]);\n\n                events++;\n            }\n\n            propagateType(node);\n            return events;\n        }\n\n        fn main() solve(SolvedNode([ SolvedNode(), SolvedNode() ])) == 2 ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn path_relative(from: string, to: string): string {\n            let min = from.len < to.len ? from.len : to.len;\n\n            mut same = 0;\n            for (mut i = 0; i < min; i++) {\n                let a = from[i];\n                let b = to[i];\n\n                if (b != a)\n                    break;\n\n                if (b == '/')\n                    same = i + 1;\n            }\n\n            mut res: string;\n            for (mut i = same; i < from.len; i++)\n                if (from[i] == '/')\n                    res ~= \"../\";\n\n            res ~= to.slice(same);\n            return res;\n        }\n\n        fn main() {\n            let from    = \"/a/b/c\";\n            let to      = \"/a/e/f\";\n            let rel     = path_relative(:from, :to);\n\n            return rel == \"../e/f\" ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        inline fn test(ref a: i32[]) {\n            if ((a[0] + a[2]) & 1) {\n                shadow ref a = a[0 : 2];                        ;; GNUStmtExpr\n                return a;\n            }\n            else {\n                shadow ref a = a[2 : 4];                        ;; PointlessLocal\n                return a;\n            }\n        }\n\n        inline fn sum(ref a: [i32]) {\n            mut sum = 0;\n            for (mut i = 0; i < a.len; i++) sum += a[i];\n            for (mut i = 0; i < a.len; i++) a[i] = sum;\n            return a;\n        }\n\n        fn main() {\n            mut a = [ 1, 2, 3, 4 ];\n            return sum(test(a))[0] - 7;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        inline fn test(ref a: i32[], ref b: i32[]) {\n            if ((a[0] + b[0]) & 1)\n                return a;\n\n            return b;\n        }\n\n        inline fn sum(ref a: i32[]) {\n            mut sum = 0;\n            for (mut i = 0; i < a.len; i++) sum += a[i];\n            a.shrink(1);\n            a[0] = sum;\n            return a;\n        }\n\n        fn main() {\n            mut a = [ 1, 2 ];\n            mut b = [ 3, 4 ];\n            return sum(test(a, b))[0] - 7;                      ;; GNUStmtExpr\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        inline fn grow_if_oob(ref a: $T[], i: i32): &mut $T {\n            if (a.len <= i)\n                a.grow(i + 1);\n\n            return a[i];\n        }\n\n        inline fn hey(ref arr: i32[], a: i32) {\n            if (a & 1) {\n                arr.grow_if_oob(a)++;\n                <alt>\n                return arr[0 : a + 1];\n                </alt>\n            }\n\n            return arr;\n        }\n\n        fn main() {\n            mut a = [ 1 ];\n            return a[0] - hey(a, 1)[1];                         ;; GNUStmtExpr\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn serializeType(type: string, debug: string)\n            debug ~ \":\" ~ type;\n\n        fn mangleArguments(args: [$T]): string {\n            mut mangle = \"\";\n            for (mut i = 0; i < args.len; i++) {\n                if (i) mangle ~= \",\";\n                mangle ~= serializeType(args[i], debug: \"M\");\n            }\n            return mangle;\n        }\n\n        fn trySpecialize(args: string[], ref args_mangled: string) {\n            args_mangled ||= mangleArguments(args);\n            return args_mangled.len;\n        }\n\n        fn main() {\n            mut args_mangled: string;\n            return trySpecialize([ \"a\", \"b\" ], args_mangled) - 7;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let EMIT_CPP = 1 << 0;\n        let EMIT_OBJ = 1 << 1;\n        let EMIT_BIN = 1 << 2;\n\n        struct Cmd { self: string; options: i32 };\n\n        inline fn unlessHasExt(str: string) {\n            let idx = str.find('.');                            ;; GNUStmtExpr\n            if (idx > 0)\n                return [];\n\n            return str;\n        }\n\n        fn parseOptions(argv: string[]) {\n            mut idx = 0;\n            fn next(): string {\n                let i = idx++;\n                if (i < argv.len) return argv[i];\n                return \"\";\n            }\n\n            let self = next();\n            if (argv.len == 1) // Exit 0 on no command, else we fail build-checks.\n                return [];\n\n            mut options: i32;\n            mut val = next();\n            while (val.len > 1 && val[0] == '-') {\n                mut opt = val;\n                if (opt[1] != '-') {\n                    opt = [ opt[1] ];\n                    val = '-' ~ val.slice(2);\n                    if (val == \"-\")\n                        val = next();\n                }\n                else\n                    val = next();\n\n                fn option(short: string, o: i32) {\n                    if (opt == short) {\n                        options |= o;\n                        opt = \"\";\n                    }\n                }\n\n                option(\"c\", EMIT_CPP);\n                option(\"o\", EMIT_OBJ);\n                option(\"b\", EMIT_BIN);\n\n                if (opt)\n                    throw(\"Unknown option: '\" ~ opt ~ \"'.\");\n            }\n\n            return Cmd(unlessHasExt(self), options);\n        }\n\n        fn main() = parseOptions([ \"./hey\", \"-c\", \"-b\" ]).options - (EMIT_CPP | EMIT_BIN);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn withPrefixed(b: byte, view: [byte], fn) {\n            mut tmp: string;\n            return fn(view.len > 1 ? view : tmp = b ~ view);\n        }\n\n        fn main() withPrefixed('a', \"b\"): |ab| return ab.len - 2;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn tryIntersect(left: [byte], right: [byte], withMatch) {\n            let l =  left[0];\n            let r = right[0];\n            let lq = l > '0' && l < '8';\n            let rq = r > '0' && r < '8';\n\n            if (left[lq && 1 : left.len] != right[rq && 1 : right.len])\n                return false;\n\n            let ll = lq && l.i32 - '0'.i32;\n            let rr = rq && r.i32 - '0'.i32;\n            let qq = ll | rr;\n\n            <alt>\n            mut tmp: string;\n            return withMatch(qq == ll ? left\n                           : qq == rr ? right\n                           : tmp = (qq.byte ~ left[lq && 1 : left.len]),\n            <alt/>\n            return withMatch(qq == ll ? left\n                           : qq == rr ? right\n                           : qq.byte ~ left[lq && 1 : left.len],\n            </alt>\n                left?:  qq == ll,\n                right?: qq == rr);\n        }\n\n        fn main() {\n            tryIntersect(\"7a012345678900123456789001234567890\"\n                       , \"5a012345678900123456789001234567890\"): |m, left!|\n            {\n                return m == \"7a012345678900123456789001234567890\" && left ? 0 : 100;\n            }\n\n            return 101;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn tryIntersect(left: [byte], right: [byte], ifLeft, ifNotLeft) {\n            let l =  left[0];\n            let r = right[0];\n            let lq = l > '0' && l < '8';\n            let rq = r > '0' && r < '8';\n\n            if (left[lq && 1 : left.len] != right[rq && 1 : right.len])\n                return false;\n\n            let ll = lq && l.i32 - '0'.i32;\n            let rr = rq && r.i32 - '0'.i32;\n            let qq = ll | rr;\n\n            if (qq == ll)   ifLeft();\n            else            ifNotLeft(qq == rr ? right : qq ~ right[rq && 1 : right.len]);\n\n            return true;\n        }\n\n        fn TP_get(typeParams!: string, id!: string)\n        {\n            id || throw(\"Assertion failed.\");\n\n            mut start = 0;\n            for (;;)\n            {\n                let idx = typeParams.find(id, :start);\n                if (idx < 0)\n                    return -1;\n\n                start = id.len;\n                if (typeParams[start] == ' ')\n                    return start + 1;\n            }\n        }\n\n        fn TP_upsert(ref typeParams!: string, id!: string, canon: string) {\n            let start = TP_get(:typeParams, :id);\n            if (start < 0) {\n                typeParams ~= id;\n                typeParams ~= canon;\n                typeParams ~= '\t';\n                return true;\n            }\n\n            let end = typeParams.find('\t', :start);\n            return tryIntersect(typeParams[start : end], canon,\n                ifLeft: || { /* egyptian */\n                    return true;\n                },                  // <- Lint complained about the nested curlies here ...\n                ifNotLeft: |inter|\n                { /* pedantic */\n                    typeParams.splice(start, end - start, inter);\n                    return true;\n                });                 // <-  ... and here.\n\n            return false;\n        }\n\n        fn main() {\n            mut typeParams = \"$T 3hey\t\";\n\n            // I was fiddling with jumps, and broke return type reporting,\n            //  so that TP_upsert here was always assumed to return true (tryIntersect can return false above),\n            //   adding this because the test didn't care.\n            if (TP_upsert(:typeParams, id: \"$T\", \"x4x\"))\n                return 202;\n\n            return TP_upsert(:typeParams, id: \"$T\", \"4hey\")\n                && typeParams == \"$T 7hey\t\" ? 0 : 101;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn fails_with_silly_error(ref set: i32[], i) {\n            <fail bad call arg 4:18>\n            set  ||= i; <pass/> // this BUGged out instead of\n            set   ~= i; </fail> //  outputing a decent err msg\n            return set;\n        }\n\n        fn main() {\n            mut set = [ 0 ];\n            fails_with_silly_error(set, 2);\n\n            mut sum = 0;\n            for (mut i = 0; i < set.len; i++) sum += set[i];\n            return sum - 2;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn solve(ref output: i32[], input: i32[])\n        {\n            fn SLOW_traverse(visit)\n                for (mut i = 0; i < input.len; i++)\n                    visit(input[i]);\n\n            fn qSTACK(id: i32, implicit _current_fnort: i32) {\n                SLOW_traverse: |x|\n                    if (id == x)\n                        return id || _current_fnort;\n\n                return 0;\n            }\n\n            fn doTrySpecialize(target: i32)\n            {\n                fn updateScope(result: i32)\n                    output ~= result || qSTACK(result + 1);\n\n                if (target & 1) {\n                    updateScope(target); // 1 - 1\n                    return;\n                }\n\n                let implicit _current_fnort = target;\n                updateScope(target / 2); // 4 - 2, 2 - 1, 0 - 0\n            }\n\n            let implicit _current_fnort = 1;\n\n            doTrySpecialize(1);\n            for (mut i = 0; i < input.len; i++)\n                doTrySpecialize(input[i]);\n        }\n\n        fn main() {\n            mut output: i32[];\n            solve(output, input: [ 0, 3 ]);\n\n            return output[0] == 1\n                && output[1] == 0\n                && output[2] == 3 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        <fail does nothing><pass/>\n        lax                </fail>\n        fn noop_let_lax(lax ref x: i32) {\n            let lax y = x;\n        }\n\n        fn main() {\n            mut x = 0;\n            noop_let_lax(x);\n            return x;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        fn compile_begin(mul: i32) {\n            let id = mul * 10;\n            let implicit options = getModule(:id);\n            return compile(:id);\n        }\n\n        fn compile(implicit options: i32, id: i32) {\n            return getModule(id) + options;\n        }\n\n        fn getModule(id: i32, implicit ctx: i32) {\n            return ctx + id;\n        }\n    "_fu, "\n        import _0;\n\n        fn main() {\n            let implicit ctx = 2;\n            return compile_begin(3) - 64;\n        }\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<3, fu::str> { "\n        // An empty file.\n    "_fu, "\n        fn sqr(x: i32) x * x;\n    "_fu, "\n        import _0;\n        import _1;\n\n        fn main() = 0.sqr;\n    "_fu } }, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct vec2 {\n            x?: f32;\n            y?: f32;\n        };\n\n        inline fn *=(ref a: vec2, b: f32) {\n            a.x *= b;\n            a.y *= b;\n            return a;\n        }\n\n        fn main() {\n            mut v = vec2(1, 1);\n            v *= 0.5; // BUG: Considering copy or move for incompatible types: vec2: copy <- f32: copy\n            return v.x.i32;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<3, fu::str> { "\n        struct vec3 { x: f32; y: f32; z: f32; };\n\n        inline fn vec3(fill!: f32) vec3(fill, fill, fill);\n        inline fn vec3(x!: f32, y!?: f32, z!?: f32) vec3(x, y, z);\n        inline fn vec3(y!: f32, x!?: f32, z!?: f32) vec3(x, y, z);\n        inline fn vec3(z!: f32, x!?: f32, y!?: f32) vec3(x, y, z);\n\n        inline fn *(a: vec3, b: f32) vec3(a.x * b, a.y * b, a.z * b);\n    "_fu, "\n        import _0;\n\n        struct Atmosphere { pView: vec3; rPlanet: f32; };\n\n        let rEarth: f32 = 1e3;\n\n        fn Atmosphere(\n            altitude: f32,\n            rPlanet: f32 = rEarth,\n            vUp = vec3(z: 1)) // <- this crashes\n        {\n            let pView = vUp * (rPlanet + altitude);\n            return Atmosphere(:rPlanet, :pView);                ;; GNUStmtExpr\n        }\n    "_fu, "\n        import _0;\n        import _1;\n\n        fn main() {\n            let atmo = Atmosphere(altitude: 1e2);\n            return atmo.pView.z == 11e2 ? 0 : 1;                ;; GNUStmtExpr\n        }\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<1, fu::str> { "\n        inline fn vec3(fill!: f32) fill;\n\n        let kMie_min: f32 = 3e-6;\n        inline fn Atmo(kMie = vec3(fill: kMie_min)) = kMie;     ;; PointlessLocal\n\n        fn main() Atmo == 3e-6 ? 0 : 1;                         ;; GNUStmtExpr\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<1, fu::str> { "\n        struct vec3 { x: f32; y: f32; z: f32; };\n        inline fn vec3(fill!: f32) vec3(fill, fill, fill);\n        inline fn *(a: vec3, b: f32) vec3(a.x * b, a.y * b, a.z * b);\n\n        <split/>\n        let kMie_min: f32 = 3e-6;\n        inline fn Atmosphere(kMie = vec3(fill: kMie_min)) = kMie.y * 2;\n\n        <split/>\n        fn main() Atmosphere == 6e-6 ? 0 : 1;                   ;; GNUStmtExpr\n    "_fu } }, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Loop { l: i32 };\n        struct Ring { r: i32 };\n        struct Mesh { m: i32 };\n\n        fn op(ref m: Mesh, x: i32, l: Loop) m.m += l.l + x;\n        fn op(ref m: Mesh, r: Ring, x: i32) m.m *= r.r + x;\n        fn op(using ref m: Mesh, l: Loop, r: Ring, x: i32) {\n            l.op(:x);\n            r.op(:x);\n        }\n\n        fn main() {\n            mut m = Mesh(1);\n            m.op(Loop(2), Ring(7), x: 1);\n            return m.m == 32 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<3, fu::str> { "\n        pub struct MultiDraw { id: i32; }\n    "_fu, "\n        import _0;\n        type ViewQuads = MultiDraw;\n\n        fn ViewQuads(id!: i32, populate!): ViewQuads {\n            mut vq = ViewQuads(:id);\n            populate(vq);\n            return vq;\n        }\n    "_fu, "\n        import _1;\n        fn ViewQuads(id!: i32, camera!: i32): ViewQuads {\n            return ViewQuads(:id, populate: |ref vq| vq.id += camera);\n        }\n\n        fn main() {\n            return ViewQuads(id: 2, camera: 5).id - 7;\n        }\n    "_fu } }, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn setupOperators()\n        {\n            struct Maplike {\n                keys: string[];\n                vals: i32[];\n            };\n\n            fn set(ref m: Maplike, k: string, v: i32) {\n                m.keys ~= k;\n                m.vals ~= v;\n            }\n\n            struct BINOP {\n                PRECEDENCE: Maplike;\n                RIGHT_TO_LEFT: bool[];\n            };\n\n            mut out: BINOP;\n            mut precedence: i32 = -1;\n            mut rightToLeft = false;\n\n            fn binop(ops: string[]) {\n                precedence++;\n                out.RIGHT_TO_LEFT ~= rightToLeft;\n                for (mut i = 0; i < ops.len; i++)\n                    out.PRECEDENCE.set(ops[i], precedence);\n            }\n\n            rightToLeft = false;\n            binop([ \"*\", \"/\", \"%\" ]);\n\n            rightToLeft = true;\n            binop([ \"*=\", \"/=\", \"%=\" ]);\n\n            return out;\n        }\n\n        let BINOP = setupOperators();\n        fn main() BINOP.RIGHT_TO_LEFT[1] && BINOP.PRECEDENCE.vals[3] == 1 ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn Split !T(str: T[], sep: T or T[:], each) {\n            mut last_idx = 0;\n            mut next_idx = 0;\n\n            let N = typeof(sep) -> T[:] ? sep.len : 1;\n            if (N) while ((next_idx = str.find(sep, start: last_idx)) >= 0) {\n                each(str.slice(last_idx, next_idx), first?: !last_idx, last?: false);\n                last_idx = next_idx + N;\n            }\n\n            if (last_idx)\n                each(str.slice(last_idx), first?: false, last?: true);\n            else\n                each(str, first?: true, last?: true);\n        }\n\n        fn Replace !T(str: T[], all: T or T[:], with: T or T[:] or []) {\n            mut result: T[];\n            Split(str, sep: all, |substr, lax first, lax last| {\n                if !(first) {\n                    if !(typeof(with) -> [])\n                        result ~= with;\n                }\n                else if (last) {\n                    return str;\n                }\n\n                result ~= substr;\n            });\n\n            return result;\n        }\n\n        fn main() {\n            let res = \"hello\".Replace(all: \"ll\", with: []);\n            return res == \"heo\" ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct BitSet { _data: u8[] };\n\n        fn add(using _: &mut BitSet, idx: int) {\n            let no_neg = idx & int.MIN;\n            let bucket = idx >> 3 | no_neg;\n            let bit    = idx & 7;\n            let mask   = 1 << bit.u8;\n\n            if (_data.len <= bucket)\n                _data.grow(bucket + 1);\n\n            _data[bucket] |= mask;\n        }\n\n        fn each(using _: BitSet, visit) {\n            for (mut i = 0; i < _data.len; i++) {\n                let item = _data[i];\n                if (item) for (mut b = 0; b < 8; b++) {\n                    let mask = 1 << b.u8;\n                    if (item & mask)\n                        visit(i << 3 | b.int);\n                }\n            }\n        }\n\n        struct Node { items: Node[] }\n\n        fn each(using n: Node, visit)\n            for (mut i = 0; i < n.items.len; i++)\n                visit(n.items[i]);\n\n        fn traverse(ref node: Node, ref bitset: BitSet) {\n            bitset.add(node.items.len);\n            node.each(.traverse(:bitset));\n\n            mut res = 0;\n            bitset.each: |index|\n                res += index;\n\n            return res;\n        }\n\n        fn main() {\n            mut bitset: BitSet;\n            return traverse(Node([ Node([ Node, Node, Node ]), Node ]), :bitset) == 5 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        struct Type {\n            quals: i32;\n            canon: string;\n        };\n\n        fn is_never (t: Type) t.canon == \"never\";\n        fn is_zeroes(t: Type) t.canon == \"zeroes\";\n\n        let CANNOT_definit_mutrefs = true;\n\n        fn clear_mutref(mut t: Type) {\n            t.quals &= ~1;\n            return t;\n        }\n\n        fn union(a: Type, b: Type, DONT_match_zeroes!?: bool) {\n            if (a.canon != b.canon)\n                return a.is_never  ? b\n                     : b.is_never  ? a\n                     : a.is_zeroes && !DONT_match_zeroes ? CANNOT_definit_mutrefs ? clear_mutref(b) : b\n                     : b.is_zeroes && !DONT_match_zeroes ? CANNOT_definit_mutrefs ? clear_mutref(a) : a\n                     : [];\n\n            return Type(:a.canon, a.quals | b.quals);\n        }\n    "_fu, "\n        import _0;\n        fn main() {\n            let Hey1    = Type(1, \"hey\");\n            let Zeroes  = Type(0, \"zeroes\");\n            let res     = union(Hey1, Zeroes);\n            return res.canon == \"hey\" && res.quals == 0 ? 0 : 1;\n        }\n    "_fu } }, PARZERO_queue);
    TODO_bvxMZmIw("\n        fn inline_args_and_closures(inline nums: i32[]) {       ;; GNUStmtExpr\n            mut sum: i32;\n            noinline fn woot(z: i32)                // previously a new woot was emitted\n                for (mut i = 0; i < nums.len; i++)  //  with the nums expr inlined,\n                    sum += nums[i] & z;             //   now nums doesnt inline inside woot\n\n            for (mut i = 0; i < nums.len; i++) {\n                if (i > 0) woot(nums[i] & nums[i - 1]);         ;; PointlessMustSeq\n                if (i > 1) woot(nums[i] & nums[i - 2]);\n            }\n\n            return sum;\n        }\n\n        fn main() {\n            mut x = 0;\n            let res = inline_args_and_closures([ x++, x++, x++ ]);\n            return x == 93 && res == 290 ? 0 : 1;\n        }\n    "_fu, "BUG exit code"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        <fail inline recursi>\n        inline <pass/></fail>\n        fn inlineSelfRecursion(x: int)\n            x > 10  ? inlineSelfRecursion(x / 2)\n                    : x;\n\n        fn main() inlineSelfRecursion(15) == 7 ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        <fail inline recursi>\n        inline <pass/></fail>\n        fn inlineMutualRecursion_a(x: int)\n            x > 10  ? inlineMutualRecursion_b(x / 2)\n                    : x;\n\n        inline fn inlineMutualRecursion_b(x: int)\n            x > 5   ? inlineMutualRecursion_a(x / 2)\n                    : x;\n\n        fn main() inlineMutualRecursion_a(15) == 3 ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        nocopy struct SolverOutput {\n            content?: SolverOutput[];\n        };\n\n        fn test(ref _helpers_data: i32[], mut content: SolverOutput[])\n        {\n            _helpers_data.len & 1 && _helpers_data.pop();\n            {\n                _helpers_data && throw(\"non-empty _helpers_data.\");\n                {\n                    content.len & 1 && content.pop();\n                    {\n                        return SolverOutput(:content);\n                    }\n                }\n            }\n        }\n\n        fn main() {\n            mut _helpers_data: i32[];\n            mut content: SolverOutput[];\n            return test(_helpers_data, content).content.len;    ;; !*MustSeq\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Type { quals: i32; };\n        struct Node { type: Type; };\n\n        fn unusedLetExprOrBlock(args_in: [Node], default: Node) {\n            mut inType: Type;\n            for (mut i = 0; i < args_in.len; i++) {\n                // got this while auto-reducing smth else,\n                //  nonsense but currently bugs mcom\n                lax let inValue = args_in[i] || {\n                    inType = default.type;  //      <- then, mcom tries to copy here\n                    default                 // <- first this gets discarded\n                };\n            }\n\n            return inType;\n        }\n\n        fn main() {\n            return unusedLetExprOrBlock([ Node() ], Node(Type(1))).quals - 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn parse !T(v: [byte], lax as!: T) {\n            mut result: T;\n\n            if (T.is::bitfield) {\n                for (mut i = 1; i < v.len; i++) {\n                    if (v[i] == '|') {\n                        return parse(v[0 : i], :as) | parse(v[i + 1 : v.len], :as);\n                    }\n                }\n            }\n\n            for (mut i = 0; i < v.len; i++) {\n                if (v[i] == '*') {\n                    let prefix = v[0 : i];\n                    let suffix = v[i + 1 : v.len]\n\n                    for (fieldname i: T) {\n                        let opt = \"i\";\n                        if (opt.starts(with: prefix) && opt.ends(with: suffix))\n                            result |= T.i;\n                    }\n\n                    return result;\n                }\n                else if (i > 0 && v[i] == '|') {\n                    return parse(v[0 : i], :as) | parse(v[i + 1 : v.len], :as);\n                }\n            }\n\n            for (fieldname i: T)\n                if (v == \"i\")\n                    return T.i;\n\n            return [];\n        }\n\n        flags UpperCase { Hello = 1; World = 2; Cruel = 4; CruelWorld = 8 };\n        flags LowerCase { hello = 16; world = 32; cruel = 64; cruel_world = 128 };\n\n        fn parseUpperOrLower(str: string) {\n            if (let upper = parse(str, as: UpperCase))\n                return upper.i32;\n            else if (let lower = parse(str, as: LowerCase))\n                return lower.i32;\n            else\n                return 0;\n        }\n\n        fn main() {\n            if (parseUpperOrLower(\"World|Cruel*\") != 2|4|8) return 1;\n            if (parseUpperOrLower(\"*world|hello\") != 16|32|128) return 2;\n            return 0;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Type { items: Type[]; }\n\n        fn solve(root: Type) {\n            mut out = 0;\n            fn test_node(node: Type) {\n                for (mut i = 0; i < node.items.len; i++)\n                    test_node(node.items[i]);\n\n                fn checkLt(actual: Type) {\n                    out += node.items.len;\n                    for (mut i = 0; i < actual.items.len; i++)\n                        checkLt(actual.items[i]);\n                }\n\n                checkLt(node);\n            }\n\n            test_node(root);\n            return out;\n        }\n\n        fn main() solve(Type([ Type([ Type, Type ]), Type([ Type, Type, Type ]) ])) == 34 ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn runSolver(\n            implicit ref notes: i32,\n            break_notes: i32,\n            implicit ref value: i32)\n        {\n            fn makeNote(note: i32, inline reason: string) {\n                if (break_notes & note)\n                    throw(\"#\" ~ note ~ \": \" ~ reason);\n\n                notes |= note;\n            }\n\n            if (value > 0) {\n                if (value++ & 1) return makeNote(1, \"A: \" ~ value);\n                if (value++ & 2) return makeNote(2, \"B: \" ~ value);\n            }\n            else {\n                if (value++ & 4) return makeNote(4, \"C: \" ~ value);\n                if (value++ & 8) return makeNote(8, \"D: \" ~ value);\n            }\n        }\n\n        fn main() {\n            implicit mut notes: i32;\n            <fail unused print>\n            implicit mut print: string; <pass/></fail>\n            implicit mut value = 0;\n\n            runSolver(1|2);\n            runSolver(4|8);\n            return value == 4 && notes == 2 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Target { x: i32; };\n\n        fn ScopeSkip_push_bad_args(targets: Target[], ref sum: i32) {\n            fn descend(acc?: bool) {\n                fn foreach(t: Target) {\n                    if (acc)    sum += t.x;\n                    else        descend(true);\n                }\n\n                targets.each(|u| foreach(u));\n            }\n\n            descend();\n        }\n\n        fn main() {\n            mut targets = [ Target(1), Target(2) ];\n            mut sum = 0;\n            ScopeSkip_push_bad_args(:targets, :sum);\n            return sum == 6 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Module { events: i32; };\n\n        <alt>\n        inline   <alt/>\n        noinline </alt>\n        fn profile(implicit ref module: Module, id: i32, op) {\n            let events0 = module.events;\n            op();\n            module.events += (events0 + id);\n        }\n\n        <alt>\n        inline   <alt/>\n        noinline </alt>\n        fn propagateType(implicit ref module: Module) {\n            profile(2, |<alt>lax unused?</alt>| module.events = 1);\n        }\n\n        <alt>\n        inline   <alt/>\n        noinline </alt>\n        fn runAllPasses() {\n            profile(3, fn propagateType);\n        }\n\n        fn main() {\n            implicit mut module: Module;\n            runAllPasses();\n            return module.events == 1 + 2 + 3 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Module { events: i32; };\n\n        // Same as above but uses unwrap.\n        fn profile(implicit ref module: Module, id: i32) unwrap {\n            let events0 = module.events;\n            defer module.events += (events0 + id);\n        }\n\n        <alt>\n        inline   <alt/>\n        noinline </alt>\n        fn propagateType(implicit ref module: Module) {\n            profile(2);\n            module.events = 1;\n        }\n\n        <alt>\n        inline   <alt/>\n        noinline </alt>\n        fn runAllPasses() {\n            profile(3);\n            propagateType();\n        }\n\n        fn main() {\n            implicit mut module: Module;\n            runAllPasses();\n            return module.events == 1 + 2 + 3 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Target { template: string; };\n        fn BUG(what?: string) throw(what || \"Assertion failed.\");\n\n        fn assign_WOOT(ref into: Target) {\n            mut name = \"\";\n            mut what = \"WOOT\";\n            name ||= what || BUG(); // arg inliner out of range local\n            into.template = name;\n        }\n\n        fn main() {\n            mut t = Target();\n            assign_WOOT(into: t);\n            return t.template == \"WOOT\" ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Overload { type: Type; }\n        struct Type     { lifetime: i32[]; }\n\n        fn BUG(implicit _here: i32, reason: string)\n            throw(_here ~ \": \" ~ reason);\n\n        fn is_even(type: Type) {\n            let a = !(type.lifetime.len & 1);\n            let b =   type.lifetime.len < 4;\n            a && !b && BUG(\"THROW-1\");\n            return a;\n        }\n\n        fn solve(check: Type) {\n            let implicit mut _here: i32;\n\n            using fn GET(implicit overloads: Overload[], target: i32)\n                target < 0 || target >= overloads.len\n                    ? BUG(\"THROW-2\")\n                    : overloads[target];\n\n            fn Lifetime_each(type, visit)\n                for (mut i = type.lifetime.len; i --> 0; )\n                    visit(t: type.lifetime[i]);\n\n            fn Lifetime_allEven(type: Type): bool {\n                Lifetime_each(:type, visit: |t| {\n                    if (!t.type.is_even)                return false;\n                    if (!Lifetime_allEven(t.type))      return false;\n                    _here = t;\n                });\n\n                return true;\n            }\n\n            return Lifetime_allEven(check);\n        }\n\n        fn main() {\n            let implicit overloads = [\n                Overload(),             // 0] even\n                Overload(Type([0])),    // 1] odd\n                Overload(Type([0, 0])), // 2] even\n                Overload(Type([0, 2])), // 3] even\n            ];\n\n            if !(solve(Type()))         return 1;\n            if  (solve(Type([ 1, 2 ]))) return 2;\n            if !(solve(Type([ 2, 3 ]))) return 3;\n            return 0;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Overload { name: string; args?: Argument[]; }\n        struct Argument { name: string; }\n        struct Target   { index: i32; }\n\n        fn solve(overloads: Overload[], check: Target, from?: Target)\n        {\n            fn fail(mut reason: string) {\n                if (from)\n                    reason ~= GET(from).qWHAT;\n\n                return throw(reason);\n            }\n\n            fn qWHAT(o: Overload) o.name.human;\n            fn qWHAT(a: Argument) a.name.human;\n\n            fn tryParse(id: string)\n                id.len == 1 && id[0] >= '0' && id[0] <= '9'\n                    && Target(index: id[0].i32 - '0'.i32);\n\n            fn human(id: string) {\n                let t = tryParse(:id);\n                return t ? GET(t).name : id;\n            }\n\n            fn parent(target: Target)\n                target.index > 0\n                    && Target(target.index - 1);\n\n            using fn GET(target: Target) {\n                if (overloads.len < target.index)\n                    fail(\"Parent: \" ~ (target.parent ? GET(target.parent).name : \"-\"));\n\n                return overloads[target.index - 1];\n            }\n\n            return check.qWHAT;\n        }\n\n        fn main() {\n            let overloads = [\n                Overload(\"hello\"),\n                Overload(\"1\"),\n            ];\n\n            return solve(overloads, check: Target(2)) == \"hello\" ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Type { quals: i32; lifet: i32 };\n\n        fn tryInter(a: Type, b: Type) {\n            let quals = a.quals & b.quals;\n            let lifet = a.lifet & b.lifet;\n            if (!lifet && (a.lifet || b.lifet))\n                return [];\n\n            return quals;\n        }\n\n        fn fail(reason: string) {\n            return 101 + reason.len;\n        }\n\n        fn intersect(reason: string, a: Type, b: Type) {\n            return tryInter(a, b) || fail(reason);\n        }\n\n        fn main() {\n            let a = Type(quals: 1, lifet: 1);\n            let b = Type(quals: 3, lifet: 3);\n            return intersect(\"Hello!\", a, b) == 1 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Item { val: i32 };\n\n        fn Each !T(ref a: T[:], fn)\n            for (mut i = 0; i < a.len; i++)\n                fn(a[i], i?: i);\n\n        fn parseStructDecl(ref items: [Item], ref sum: i32) {\n            if (items.len & 2)\n                parseStructDecl(items[1 : items.len], sum);     ;; PointlessMustSeq\n\n            :BLOCK {\n                items.Each: |item|\n                    if ((sum += item.val) & 2)\n                        break :BLOCK;                           ;; Goto\n\n                items.Each: |ref item|\n                    item.val += sum;\n            }\n\n            items.Each: |ref item|\n                item.val++;\n        }\n\n        fn main() {\n            mut sum = 0;\n            mut items = [ Item(0), Item(1) ];\n            parseStructDecl(items, sum);\n            return sum == 4\n                && items[0].val == 5\n                && items[1].val == 8 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Node {\n            value?: string;\n            items?: Node[];\n        };\n\n        fn SLOW_traverse(node: Node, visit) {\n            mut stack = [ node ];\n            while (stack) {\n                shadow mut node = stack[stack.len - 1];\n                stack.pop();\n                visit(node);\n                for (mut i = node.items.len; i --> 0; )\n                    stack ~= node.items[i];\n            }\n        }\n\n        fn qSTACK(node: Node) {\n            SLOW_traverse(node): |n| {\n                if (n.value && n.items)\n                    return n.value ~ \", \" ~ qSTACK(n.items[0]);\n            }\n\n            return node.value ~ \"!\";\n        }\n\n        fn main() {\n            let res = qSTACK(\n                Node(items: [\n                    Node(\"Ignore me\"),\n                    Node(\"Hello\", [ Node(\"World\") ]),\n                ]));\n\n            return res == \"Hello, World!\" ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn merge !T(l: [T], r: [T], left, right, both) {\n            mut li = 0;\n            mut ri = 0;\n            for (;;) {\n                inline fn L = l[li];\n                inline fn R = r[ri];\n                let l_done = li == l.len;\n                let r_done = ri == r.len;\n\n                let cmp = l_done ? r_done ? { return; } : +1\n                                 : r_done ? -1\n                                 : L <> R;\n                if (cmp == 0) {\n                    both(L, left?: li, right?: ri);\n                    li++;\n                    ri++;\n                }\n                else if (cmp < 0) {\n                    left(L, left?: li, right?: ri);\n                    li++;\n                }\n                else {\n                    right(R, left?: li, right?: ri);\n                    ri++;\n                }\n            }\n        }\n\n        fn inter !T(l: T[], r: T[]) {\n            if (r.len < l.len)\n                return inter(r, l);\n\n            mut result: T[];\n            mut useResult = false;\n\n            merge(l, r,\n\n            left: |_, left| {\n                if (!useResult) {\n                    useResult = true;\n                    result = l.slice(0, left);\n                }\n            },\n\n            right: |_| {},\n\n            both: |item| {\n                if (useResult)\n                    result ~= item;\n            });\n\n            return useResult ? result : l;\n        }\n\n        <split/>\n        struct Region { index: i32 };\n        struct Lifetime { uni0n: i32[]; };\n\n        fn Lifetime_inter(a: Lifetime, b: Lifetime): Lifetime = // nested { return } in merge\n            Lifetime(uni0n: inter(a.uni0n, b.uni0n));           ;; GNUStmtExpr\n\n        <split/>\n        fn main() {\n            mut a = Lifetime([ 1, 2, 3 ]);\n            mut b = Lifetime([ 2, 3, 4 ]);\n            mut c = Lifetime_inter(a, b);\n            return c.uni0n == [ 2, 3 ] ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Type { canon: string; quals: i32 };\n        struct Node { type: Type; value: string };\n\n        let t_f32 = Type(\"f32\", 2);\n        let t_f64 = Type(\"f32\", 2);\n\n        fn solveReal(lax v: string, type: Type): Type {\n            if (type.canon == t_f32.canon) return t_f32;\n            return t_f64;\n        }\n\n        fn tryRetype(node: Node, expect: Type): Type {\n            return solveReal(node.value, expect);\n        }\n\n        fn main() {\n            let a = Node(t_f64, \"0.0\");\n            let b = tryRetype(a, t_f32);\n            return b.canon == \"f32\" ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            nocopy struct Nc { items: Nc[]; };\n\n            fn rem_odd(ref items: Nc[])\n                for (mut i = items.len; i --> 0; )\n                    if (i & 1)\n                        items.splice(i, 1);\n\n            mut items: Nc[];\n            for (mut i = 0; i < 11; i++)\n                items ~= Nc(i & 1 ? [ Nc ] : [ Nc, Nc ]);\n\n            rem_odd(items);\n\n            mut sum = 0;\n            fn visit(shadow items: [Nc])\n            {\n                fn visit(nc: Nc) {\n                    sum++;\n                    visit(nc.items);\n                }\n\n                for (mut i = 0; i < items.len; i++)\n                    visit(items[i]);\n            }\n\n            visit(items);\n            return sum == 18 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let SMTH = false;\n\n        fn FAIL(reason: string, implicit ref log: string)\n            log ~= reason ~ '\\n';\n\n        fn fail_appendStack(lax mut reason: string)\n            SMTH ? reason : [];\n\n        fn fail(mut reason: string)\n            FAIL(reason.fail_appendStack());\n\n        fn main() {\n            implicit mut log = \"\";\n            fail(\"Hello!\");\n            return log.len - 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Type { quals: i32 };\n        pub fn tryLookupUserType(type: Type) = type;\n        fn propagateType(type: Type) {\n            let s = tryLookupUserType(type);\n            if (s.quals != 13 || true) return 17;\n            return 19;\n        }\n\n        fn main = 1.Type.propagateType - 17;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        <alt>\n        inline          <alt/>\n        noinline        </alt>\n        fn voidfn(ref a: i32) { a += 100; }\n\n        <alt>\n        inline   ;; Goto<alt/>\n        noinline        </alt>\n        fn returnVoidExpr(ref a: i32, ref b: i32) {\n            while (b --> 0) {\n                a++;        // bad cg emitted just 'return;'\n                if (a & 1)  return voidfn(a);\n            }\n        }\n\n        fn main() {\n            mut a = 0;\n            mut b = 10;\n            returnVoidExpr(a, b);\n            return a == 101 && b == 9 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn hello(implicit<alt>: i32</alt>) = implicit;\n        fn main() = 0.hello;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn voidIf(ref a: i32, ref b: u32)\n            <fail no common supertype i32 u32 4:17+1>\n            a   ? a++\n                : b++;\n            <pass/>\n            if (a)  a++;\n            else    b++;\n            </fail>\n\n        fn main() {\n            mut a: i32;\n            mut b: u32;\n            voidIf(:a, :b);\n            return !a && b ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct ScopeItem { id: string; uval: u32 }\n\n        fn search(ref items: [ScopeItem], id: string, ref scope_iterator: i32): u32\n        {\n            if (!scope_iterator)\n                scope_iterator = items.len;\n\n            defer if (scope_iterator == 0)\n                scope_iterator = -1;\n\n            while (scope_iterator --> 0) {\n                let item = items[scope_iterator];\n                if (item.id == id)\n                    return item.uval;\n            }\n\n            return [];\n        }\n\n        fn main() {\n            mut items = [ ScopeItem(\"a\", 1), ScopeItem(\"a\", 2), ScopeItem(\"a\", 3) ];\n            mut scope_iterator = 0;\n            mut uval: u32;\n\n            mut result: u32;\n            while (uval = items.search(\"a\", scope_iterator))\n                result += uval;\n\n            return (result - 6).signed;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn woot!E (e?: E) {\n            if (E -> [])\n                return 2;\n            else\n                return e(3);\n        }\n\n        fn main() woot * woot(|x| x * 5) - 30;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn woot(myfn) myfn(1);\n\n        fn main() {\n            mut sum = 0;            // PARSE DRAMA\n            woot: |one| sum += one; //  stmt lambda, followed by\n            (sum += 1) += 1;        //   '(' which continued as-if-expr\n            return sum -3;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        let PROFILE = <alt>true<alt/>false</alt>;\n\n        struct Empty {};\n        struct NonEmpty { v: i32 };\n\n        type Item = PROFILE ? NonEmpty : Empty;\n\n        lax fn +=(ref a: Item, b: Item)\n            for (fieldname v: Item)\n                a.v += b.v;\n\n        fn get(a: Item) PROFILE ? a.v : 0;\n    "_fu, "\n        import _0;\n        fn main() {\n            mut a: Item;\n            a += Item();\n            return a.get();\n        }\n    "_fu } }, PARZERO_queue);
    TODO_bvxMZmIw("\n        fn +=(ref a: i64, b: bool)  // Doesn't cg c++ operator (illegal, operands all prim),\n            a += b ? 100 : 0;       //  which drops the RTL ooe guarantee, solver fails to notice.\n\n        fn rellocate(ref a: i64[]) {\n            for (mut i = 0; i < 6; i++)\n                a ~= a;\n\n            return !!a.len;\n        }\n\n        fn main() {\n            mut items = [ i64(1), i64(2), i64(3), i64(4) ];\n            items[0] += rellocate(items);                       ;; N_BckMustSeq\n            return (items[0] - 101).i32;\n        }\n    "_fu, "N_BckMustSeq not listed"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        fn test(x: i32): bool   <fail return type void does not match annot bool 3:17+1>\n            let y = x > 10;     <pass/>\n                    x > 10;     </fail>\n\n        fn main() test(3).i32;\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        fn main() {\n            struct Node {};\n    <alt>\n            fn evalTypeAnnot(node: Node) =\n                return !!node;\n    <alt/>\n            fn evalTypeAnnot(node: Node): bool =\n                return node && [];\n    </alt>\n            fn trySolveTypeParams(node: Node): bool =   <fail actual return void does not match annot bool 9:21+6>\n                let expect = evalTypeAnnot(node);       <pass/>\n                             evalTypeAnnot(node);       </fail>\n\n            return trySolveTypeParams([]) && 0;\n        }\n    "_fu, "actual return Node does not match annot bool 9:21+6"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        fn grow_if_oob(ref a: $T[], i: i32) {\n            if (a.len <= i) a.grow(i + 1);\n            return a[i];\n        }\n\n        struct Scope    { overloads: Overload[]; extended: Extended[] };\n        struct Overload { name: string };\n        struct Extended { locals?: Overload[] };\n\n        fn Scope_create(ref scope: Scope, name: string, nest!?: i32): i32 {\n            ref overloads = nest > 0\n                ? scope.extended.grow_if_oob(nest - 1).locals\n                : scope.overloads;\n\n            overloads.push(Overload(:name));\n            return overloads.len;\n        }\n\n        fn main() {\n            mut scope = Scope(\n                overloads:  [ Overload(\"Hello!\") ],\n                extended:   []);\n\n            let a = scope.Scope_create(\"World!\", nest: 1);\n            let b = scope.Scope_create(\"Bananas!\");\n            return a * 10 + b - 12;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn bfind !T(keys, item: T, hit, miss) {\n            mut lo = 0;\n            mut hi = keys.len;\n\n            while (lo < hi) {\n                let i   = (hi + lo) >> 1;\n                let cmp = keys[i] <> item;\n                if (cmp == 0)\n                    return hit(i);\n            }\n\n            return miss(lo);\n        }\n\n        fn update !<T, U>(keys, item: T, extras, extra: U)\n            bfind(fn keys, :item,\n                hit:  |i| { extras[i] = extra; },\n                miss: |_| {});\n\n        fn get !<T, U>(keys: T[], item: T, extras: U[])\n            bfind(:keys, :item,\n                hit:  |i| { return extras[i]; },\n                miss: |_| { return []; });\n\n        fn Map(type K, type V)\n            struct { keys: K[]; vals: V[] };\n\n        fn set(using ref _: Map(_, _), key, value)\n            update(|| keys, key, || vals, value);\n\n        fn get(using _: Map(_, _), key)\n            get(keys, key, vals);\n\n        fn resolveFile(ref cache: Map(string, string), path: string): string\n        {\n            if (let cached = cache.get(path))\n                return cached == \"\v\" ? \"\" : cached;\n\n            cache.set(path, \"\v\");\n            return \"\";\n        }\n\n        fn main() {\n            mut cache: Map(string, string);\n            return cache.resolveFile(\"abc\").len;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Target       { globid: i32; locid: i32 }\n        struct Overload     { name: string }\n        struct Extended     { locals: Overload[] }\n\n        nocopy struct Scope {\n            overloads: Overload[]; extended: Extended[]; total: i32\n        }\n\n        fn grow_if_oob(ref a: $T[], i: i32) {\n            if (a.len <= i) a.grow(i + 1);\n            return a[i];\n        }\n\n        fn CREATE(ref scope: Scope, name: string, nest!?: Target) {\n            ref overloads = nest\n                ? scope.extended.grow_if_oob(nest.globid - 1).locals\n                : scope.overloads;\n\n            <flip>\n            scope.total++;\n            <flip/>\n            overloads ~= Overload(:name);\n            let index = overloads.len;\n            </flip>\n\n            return Target(\n                globid: nest ? nest.globid : index,\n                 locid: nest ? index       : 0);\n        }\n\n        fn GET(ref scope: Scope, target: Target)\n            target.locid\n                ? scope.extended[target.globid - 1].locals[target.locid - 1]\n                : scope.overloads[target.globid - 1];\n\n        fn DUPE(ref scope: Scope, target: Target)\n            CREATE(scope, GET(scope, target).name);\n\n        fn main() {\n            mut scope: Scope;\n            let hello = scope.CREATE(\"hello!\");\n            let world = scope.CREATE(\"world!\", nest: hello);\n            scope.DUPE(world);\n\n            mut result  = \"\";\n            scope.overloads.each: |o, i| {\n                result ~= \"+\" ~ o.name;\n                if (scope.extended.len > i)\n                    scope.extended[i].locals.each: |x|\n                        result ~= \"-\" ~ x.name;\n            }\n\n            return scope.total == 3 && result == \"+hello!-world!+world!\" ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn first(s: [$T;]) s.len && s[0];\n        struct Node { items: Node[] }\n\n        fn tryFirst(node: Node)\n            node.items\n                ? tryFirst(node.items.first)\n                : node;\n\n        fn main()\n            tryFirst(\n                Node([ Node([ Node, Node ])]))\n                    .items.len;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn first(s: [$T;]) s.len && s[0];\n        struct Node { value: i32; items: Node[] }\n\n        fn tryFirst(node: Node)\n            node.items\n                ? tryFirst(node.items.first)\n                : node;\n\n        fn main()\n            tryFirst(\n                Node(1, [ Node(2, [ Node(3, []), Node(4, []) ])]))\n                    .value - 3;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn first(s: [$T;]) s.len && s[0];\n        fn last (s: [$T;]) s.len && s[s.len - 1];\n        struct Node { value: i32; items: Node[] }\n\n        fn tryFirst(node: Node)\n            node.items  ? tryLast(node.items.first)\n                        : node;\n\n        fn tryLast(node: Node)\n            node.items  ? tryFirst(node.items.last)\n                        : node;\n\n        fn main()\n            tryFirst(\n                Node(1, [ Node(2, [ Node(3, []), Node(4, []) ])]))\n                    .value - 4;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Thing { a: i32; b: i32 };\n        struct Stuff { _gets: Thing[]; _root: Thing; _exts: Thing[] };\n\n        fn GET(ref s: Stuff, i: int) s._gets[i];\n        fn EXT(ref s: Stuff, i: int) s._exts[i];\n\n        fn lookup(ref s: Stuff, i: int) {\n            let start = s._root || s.GET(i);\n            if (!start) return start;\n            return s.EXT(i);\n        }\n\n        fn main() {\n            mut s = Stuff([ Thing(0, 1) ], Thing(1, 2), [ Thing(2, 3) ]);\n            return s.lookup(0).a - 2;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        fn Zero(implicit ref result: i32, src: i32[:]) =\n            src.each: |x, i| result += x * (i + 1);\n        fn Todo(implicit ref result: i32, src: i32[:]) =\n            src.each: |x, i| result += x * (i + 1) * 7;\n\n        fn Zero(src: i32) = Zero([ src ]);\n        fn Todo(src: i32) = Todo([ src ]);\n    "_fu, "\n        import _0;\n        fn main() {\n            implicit mut result = 0;\n\n            let Solo = fn Zero;\n            lax fn Solo_muteRest(_) {}\n            shadow let Zero = fn Solo_muteRest;\n            shadow let Todo = fn Solo_muteRest;\n\n            <alt>\n            mut queue: string;\n            fn Parzero(x: i32) queue ~= x;\n            shadow let result = || {\n                queue.each(.Zero);\n                result\n            };\n            shadow let Zero = fn Parzero;\n            </alt>\n\n            let Todo_A = fn Todo;\n            let Todo_B = fn Todo;\n\n            Zero([ 10 ]);   Zero(11);\n            Todo([ 12 ]);   Todo(13);\n            Todo_A([ 14 ]); Todo_A(15);\n            Todo_B([ 16 ]); Todo_B(17);\n            Solo([ 18 ]);   Solo(19);\n\n            return result - 37;\n        }\n    "_fu } }, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Node { items: Node[]; }\n        struct Type { value: i32 };\n\n        let t_void = Type(0);\n\n        fn main() {\n            fn createEmpty(lax type: Type or Node = t_void) = [];\n\n            fn solveTypedef(node): Type {\n                let annot = node.items\n                    && solveTypedef(node.items[0]);\n\n                if (annot) {\n                    mut relaxed = annot;\n                    return createEmpty(type: relaxed);\n                }\n\n                return createEmpty();\n            }\n\n            return solveTypedef(Node()).value;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        using flags DeclAsserts { A; B };\n        flags SomethingElse { AA; BB };\n\n        fn GET_NEXT_LOCAL_oob() {\n            fn parseNoCopy(x: DeclAsserts or SomethingElse = A) x;\n            fn parseBlockLike(y) y | parseNoCopy();\n            return parseBlockLike(B);\n        }\n\n        fn main() GET_NEXT_LOCAL_oob().i32 - 3;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() (\"hello\" == \"world\").i32;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Node { items?: Node[]; value?: i32 };\n\n        fn tryConvert(ref default: Node) {\n            if (default.items) {\n                default.items ~= default;\n                default.value += 10;\n                return true;\n            }\n\n            return false;\n        }\n\n        fn updateScope(unspecced: Node[], ref defaults: Node[]) {\n            for (mut i = 0; i < defaults.len; i++) {\n                defaults[i] = {\n                    :DEFAULT {\n                        if (!unspecced)\n                            break :DEFAULT (i < defaults.len - 1)\n                                && defaults[i + 1];\n\n                        mut default = unspecced.len > i && unspecced[i];\n                        if (default && tryConvert(default))\n                            break :DEFAULT default;\n\n                        break :DEFAULT [];\n                    }\n                };\n            }\n        }\n\n        fn main() {\n            mut nodes = [ Node(items: [ Node() ]) ];\n            for (mut i = 0; i < 4; i++) {\n                mut node = nodes[nodes.len - 1];\n                tryConvert(node);\n                nodes ~= node;\n            }\n\n            updateScope(nodes, nodes);\n\n            mut checksum = 0;\n            fn checksum(shadow nodes: Node[]) {\n                checksum += nodes.len;\n                for (mut i = 0; i < nodes.len; i++) {\n                    let node = nodes[i];\n                    checksum(node.items);\n                    checksum += 1000 * node.value;\n                }\n            }\n\n            checksum(nodes);\n            return checksum == 570124 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        struct TEA { v0: u32; v1: u32 }\n\n        inline fn r4(using ref _: TEA, ref sum: u32) {\n            mut delta: u32 = 0x9e3779b9;\n            for (mut i = 0; i < 4; i++) {\n                sum += delta;\n                v0 += ((v1<<4) + 0xA341316C) ^ (v1 + sum) ^ ((v1>>5) + 0xC8013EA4);\n                v1 += ((v0<<4) + 0xAD90777D) ^ (v0 + sum) ^ ((v0>>5) + 0x7E95761E);\n            }\n        }\n\n        inline fn u32(tea: TEA): u32 =\n            tea.v0 ^ tea.v1;                                    ;; GNUStmtExpr\n\n        fn main() {\n            mut tea: TEA;\n            mut sum: u32;\n            tea.r4(sum);\n            let actual = tea.u32;\n            return actual == 0x93bfa05 ? 0 : 1;\n        }\n    "_fu, "Ambig call to u32 4:49+3 matches inline u32 13:19+3"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        let a = 7;\n        let b = a && 3;\n        return b - 3;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct S { i: i32; }\n\n        let a = S(0);\n        let b = S(3);\n\n        return a.i\n            || (b || S(4)).i * 2 - (a || S(6)).i\n            && throw(\"woot\");\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct KindValue { kind: string; value: string; };\n\n        mut spec = KindValue(kind: \"fn\", value: \"val\");\n        spec.kind == \"fn\" && spec.value || throw(\"nope\");\n        ref v = spec.kind == \"fn\" ? spec.value : throw(\"nope\");\n\n        v ~= \"ue\";\n        return spec.value == \"value\" ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Token {\n            value: string;\n        };\n\n        fn consume(): Token {\n            return Token(\"hey\");\n        };\n\n        fn main(): i32 {\n            let a = 3;\n            let v = a && consume().value;\n            return v.len - a;\n        };\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct ScopeIdx { raw: i32; };\n        <fail bad call = 12:27+1 incompatible types for T>\n        fn thing(x: i32) x;             <pass/>\n        fn thing(x: i32) ScopeIdx(x);   </fail>\n        mut _return_scope: ScopeIdx;\n\n        fn hey(x: i32) {\n            let scope0 = thing(x);\n            _return_scope = scope0; //overload\n            return _return_scope.raw;\n        }\n\n        return hey(0);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn maybe_empty(N: i32) {\n            mut res: string[];\n            for (mut i = 0; i < N; i++) res ~= [ \"world!\" ]; // same as below but wrapped\n            return res;\n        }\n        fn main() {\n            mut arr = [ \"Hello\" ];\n            for (mut i = 0; i < 2; i++) arr ~= maybe_empty(i); // will append empty\n            return arr.join(\" \") == \"Hello world!\" ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn maybe_empty(N: i32) {\n            mut res: string[];\n            for (mut i = 0; i < N; i++) res ~= \"world!\"; // cpp template issue here\n            return res;\n        }\n        fn main() {\n            mut arr = [ \"Hello\" ];\n            for (mut i = 0; i < 2; i++) arr ~= maybe_empty(i); // will append empty\n            return arr.join(\" \") == \"Hello world!\" ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            mut _info = \"abc\";\n\n            pure fn fail(mut reason: string = \"\") {\n                ref info = _info[0]; // <- notice the ref, has to relax away\n                reason ~= info && info.i32;\n                return reason;\n            }\n\n            return fail.len - 2; // 'a' is 97, \"97\".len is 2.\n        }\n    "_fu, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        let q_mutref = 1;\n        pub let RELAX_mutref_only = q_mutref;\n        pub fn what(relax_mask: i32) relax_mask -1;\n    "_fu, "\n        import _0;\n        fn main() what(RELAX_mutref_only);\n    "_fu } }, PARZERO_queue);
    TODO_bvxMZmIw("\n        pub fn pairs(a: Map($K, $V), fn) {\n            let k = a.keys;\n            let v = a.values;\n            for (mut i = 0; i < k.len; i++)\n                fn(k[i], v[i]);\n        }\n\n        fn main() {\n            mut map: Map(i32, i32);\n            map[1] = 2;\n            map[3] = 4;\n\n            mut sum = 0;\n            map.pairs(|k, v| sum += k + v * 100);\n            return sum - 604;\n        }\n    "_fu, "Map is not defined"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        fn main() {\n            try         { return 0; }\n            catch (e)   { return e == \"x=2: even!\" ? 11 : 22; }\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn fail(str: string)\n            throw(str ~ \"!\");\n\n        fn test(x: i32)\n        {\n            // We want to override fail but\n            //  we want to call it within the override,\n            //   so we can do this i guess?\n            //\n            shadow let fail = |mut str: string| {\n                str = \"x=\" ~ x ~ \": \" ~ str;\n                fail(str);\n            };\n\n            return x & 1 || fail(\"even\");\n        }\n\n        fn main() {\n            try {\n                return test(2);\n            }\n            catch (e) {\n                <alt>\n                return e == \"x=2: even!\" ? 0 : 10;\n                <alt/>\n                shadow let e = \"hello \" ~ e;\n                return e == \"hello x=2: even!\" ? 0 : 10;\n                </alt>\n            }\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        // The Cats&Dogs example from\n        //  JuliaCon 2019: The Unreasonable Effectiveness of Multiple Dispatch\n        //   https://www.youtube.com/watch?v=kc9HwsxE1OY\n        //\n        fn encounter(a, b) {\n            let verb = meets(a, b);\n            return a.name ~ \" meets \" ~ b.name ~ \" and \" ~ verb ~ \"\\n\";\n        }\n\n        struct Dog { name: string };\n        struct Cat { name: string };\n\n        fn meets(lax a: Dog, lax b: Dog) \"sniffs\";\n        fn meets(lax a: Dog, lax b: Cat) \"chases\";\n        fn meets(lax a: Cat, lax b: Dog) \"hisses\";\n        fn meets(lax a: Cat, lax b: Cat) \"slinks\";\n\n        fn main() {\n            let fido        = Dog(\"Fido\");\n            let rex         = Dog(\"Rex\");\n            let whiskers    = Cat(\"Whiskers\");\n            let spots       = Cat(\"Spots\");\n\n            mut res = encounter(fido, rex)\n                    ~ encounter(fido, whiskers)\n                    ~ encounter(whiskers, rex)\n                    ~ encounter(whiskers, spots);\n\n            return res == \"Fido meets Rex and sniffs\\n\"\n                        ~ \"Fido meets Whiskers and chases\\n\"\n                        ~ \"Whiskers meets Rex and hisses\\n\"\n                        ~ \"Whiskers meets Spots and slinks\\n\"\n                            ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct S { i: i32; }\n        fn test(mut x: S) x.i += 1;\n        return S(-1).test;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("                                  ;; DuplicateFunctions\n        fn ARR_LAST(ref a: $T[])\n            a[a.len - 1];\n\n        let a = [1];\n        mut b = [2];\n\n        b.ARR_LAST += a.ARR_LAST;\n        return b.ARR_LAST - [3].ARR_LAST;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct mat4 { i: i32; };\n        struct RenderFrame { u_mat4_VP: mat4; };\n\n        inline fn mat4_identity() mat4(1);\n\n        fn test(output: &mut RenderFrame) {\n            output.u_mat4_VP = mat4_identity;\n        }\n\n        fn main() {\n            mut ret: RenderFrame;\n            test(ret);\n            return ret.u_mat4_VP.i - 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        pub struct ScopeSkip {\n            start: i32;\n            end:   i32;\n        };\n\n        pub fn search(skip: ScopeSkip = [])\n            skip.end - skip.start;\n\n        pub fn main()\n            <fail bad call to ScopeSkip 12:22>\n            ScopeSkip(min: -1, max: +1)     <pass/>\n            ScopeSkip(start: -1, end: +1)   </fail>\n                .end - 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct vec3 { x?: f32; y?: f32; z?: f32; };\n\n        struct mat34 {\n            mx: vec3; my: vec3; mz: vec3;\n            mo: vec3;\n        };\n\n        inline fn mat34_identity()\n            mat34(\n                vec3(x: 1),\n                vec3(y: 1),\n                vec3(z: 1), vec3 /*point3*/);\n\n        // What broke is this using reports a conflict,\n        //  because 'determinant' got expanded within 'inverse',\n        //   and there's another using mat34 there.\n        //    Basically we totally don't want it to expand there.\n        inline fn determinant(using _: mat34): f32\n            - mz.x * my.y * mx.z + my.x * mz.y * mx.z + mz.x * mx.y * my.z\n            - mx.x * mz.y * my.z - my.x * mx.y * mz.z + mx.x * my.y * mz.z;\n\n        fn inverse(using mat: mat34): mat34\n        {\n            let idet = 1 / mat.determinant;\n\n            let i_mx = vec3(\n                idet * (- mz.y * my.z + my.y * mz.z),\n                idet * (+ mz.y * mx.z - mx.y * mz.z),\n                idet * (- my.y * mx.z + mx.y * my.z));\n\n            let i_my = vec3(\n                idet * (+ mz.x * my.z - my.x * mz.z),\n                idet * (- mz.x * mx.z + mx.x * mz.z),\n                idet * (+ my.x * mx.z - mx.x * my.z));\n\n            let i_mz = vec3(\n                idet * (- mz.x * my.y + my.x * mz.y),\n                idet * (+ mz.x * mx.y - mx.x * mz.y),\n                idet * (- my.x * mx.y + mx.x * my.y));\n\n            return mat34(\n                i_mx, i_my, i_mz,\n\n                vec3( // point3\n                      mo.x * -i_mx.x +\n                      mo.y * -i_my.x +\n                      mo.z * -i_mz.x,\n\n                      mo.x * -i_mx.y +\n                      mo.y * -i_my.y +\n                      mo.z * -i_mz.y,\n\n                      mo.x * -i_mx.z +\n                      mo.y * -i_my.z +\n                      mo.z * -i_mz.z));\n        }\n\n        fn main() i32 <|\n            mat34_identity.inverse.determinant - 1;             ;; GNUStmtExpr\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct TEA { v0: u32; v1: u32 }\n\n        inline fn r4(using _: &mut TEA, sum: &mut u32) {\n            mut delta: u32 = 0x9e3779b9;\n            for (mut i = 0; i < 4; i++) {\n                sum += delta;\n                v0 += ((v1<<4) + 0xA341316C) ^ (v1 + sum) ^ ((v1>>5) + 0xC8013EA4);\n                v1 += ((v0<<4) + 0xAD90777D) ^ (v0 + sum) ^ ((v0>>5) + 0x7E95761E);\n            }\n        }\n\n        // Stack overflow solving this,\n        //  argmax is +inf, and it just\n        //   re-enters and re-enters.\n        inline fn r4(tea: &mut TEA) {\n            mut sum: u32; tea.r4(sum);\n        }\n\n        fn main() {\n            mut tea: TEA;\n            tea.r4();\n            return (tea.v0 ^ tea.v0).i32;\n        }\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        struct ScopeSkip {\n            min: i32;\n            max: i32;\n        };\n\n        fn main() {\n            let a = 1;\n            mut x: ScopeSkip; x = []; x = [ -2, 0 ]; // Inference fail.\n            mut t: ScopeSkip; t = x.min && [ x.min, a ];\n            return a + t.min + t.max;\n        }\n    "_fu, "Incompatible types for T 9:41+1"_fu, testdiffs);
    TODO_bvxMZmIw("\n        fn setupOperators(i: i32) {\n            <alt>\n            struct sB { hey: i32; };\n            struct BINOP { i: sB; };\n            <alt/>\n            fn sB(_: $T) struct { hey: $T; };\n            struct BINOP { i: sB(i32); };\n            </alt>\n            return BINOP([ i ]); // Inference fail.\n        }\n\n        fn main() setupOperators(0).i.hey;\n    "_fu, "Bad call to BINOP 7:25+1"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        struct X { i: i32; };\n        type Y = X;\n        fn main() Y(1).i / 2;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Node {\n            kind  ?: string;\n            items ?: Node[];\n            value ?: string;\n        };\n\n        fn astReplace(node: Node, mutate): Node {\n            fn walk(shadow ref node: Node) {\n                for (mut i = 0; i < node.items.len; i++)\n                    walk(node.items[i]);\n\n                mutate(node);\n            }\n\n            shadow mut node = node;\n            walk(node);\n            return node;\n        }\n\n        fn test(n: Node, a: string, b: string) {\n            return astReplace(n, |ref item: Node| {\n                if (item.value == a) {\n                    if (item.items.len == 1 && item.kind == \"call\")\n                        item.value = b;\n                    else if (item.kind == \"str\")\n                        item.value = b;\n                }\n            });\n        }\n\n        fn main() {\n            let v0 = Node(kind: \"str\", value: \"woot\");\n            let v1 = v0.test(\"woot\", \"who\");\n            return v1.value.len - 3;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            mut x:  <fail redundant typeof not a value 4:28+3>\n                    typeof(i32)     <pass/>\n                    i32             </fail> = 0;\n            return x;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct SolvedNode {\n            value: i32;\n            items?: SolvedNode[];\n        };\n\n        fn visitNodes(ref _v: $V, _n: SolvedNode)\n        {\n            fn traverse(ref v: $V, n: SolvedNode) {\n                v.visit(n);\n                for (mut i = 0; i < n.items.len; i++)\n                    traverse(v, n.items[i]);\n            }\n\n            traverse(_v, _n);\n        };\n\n        struct Visitor {\n            sum: i32;\n        };\n\n        fn visit(using ref v: Visitor, node: SolvedNode) {\n            sum += node.value;\n        };\n\n        fn main(): i32 {\n            let tree = SolvedNode(3,\n                [ SolvedNode(5), SolvedNode(7) ]);\n\n            <alt>\n            // This is an aside, managed to lose the copy qual when working structs\n            //  Initially noticed it because visitNodes tried to change its sighash\n            mut cpy = tree; cpy = tree; // <- but this fails cleanly when tree is nocopy\n            </alt>\n\n            mut myVisitor: Visitor;\n            myVisitor.visitNodes(tree);\n            return myVisitor.sum - 15;\n        };\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        return 0 > 1 ? throw(\"should type check\") : 0;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn throw_hey(): i32 {\n            throw(\"hey\");\n            return 1;\n        }\n\n        fn main(): i32 {\n            try {\n                let _x = throw_hey();\n                return _x || 7;\n            }\n            catch (err) {\n                return err.len - 3;\n            }\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn throw_hey() {\n            throw(\"hey\");\n        }\n\n        fn main(): i32 {\n            try {\n                let _x = throw_hey();\n                return _x || 7;\n            }\n            catch (err) {\n                return err.len - 3;\n            }\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn throw_hey(): i32 {\n            throw(\"hey\");\n            return 1;\n        }\n\n        fn main(): i32 {\n            try {\n                return throw_hey();\n            }\n            catch (e) {\n                return e.len - 3;\n            }\n\n            return 11;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main()\n            cli_handle([ \"hello\", \"you\" ]);\n\n        fn cli_handle(args: string[]): i32\n        {\n            mut idx = 0;\n\n            fn next() {\n                let i = idx++;\n                if (i < args.len)\n                    return args[i];\n\n                return \"\";\n            }\n\n            // Router.\n            return next().len - 5;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct X { i: i32; };\n\n        fn         ++(using x: &mut X) ++i;\n        postfix fn ++(using x: &mut X) i++;\n\n        fn main() {\n            mut x: X;\n            let a = x++;\n            let b = ++x;\n            return a || b - 2;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(s: $T) {\n            mut sum = 0;\n            for (fieldname i: $T) sum += s.i;\n            return sum;\n        }\n\n        struct XY { x: i32; y: i32; };\n\n        fn main() {\n            let thing = XY(1, 2);\n            let sum = test(thing);\n            return sum - 3;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct ScopeSkip     { imports:     i32[]; implicits:     i32[]; }\n        struct ScopeSkipMemo { imports_len: i32;   implicits_len: i32;   }\n\n        fn snap(ss: ScopeSkip) {\n            mut r: ScopeSkipMemo;\n            for (fieldname i: typeof(ss))\n                r.i_len = ss.i.len;\n\n            return r;\n        }\n\n        fn check(v) {\n            mut sum = 0; mut mul = 1;\n            for (fieldname i: typeof(v)) {\n                sum += v.i * mul; mul *= 10;\n            }\n\n            return sum;\n        }\n\n        fn main() check(snap(ScopeSkip([ 1 ], [ 2, 2 ]))) - 21;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn Lazy(getValue) {\n            struct Lazy {\n                evaluated?: bool;\n                value?:     typeof(getValue());\n                getValue?:  typeof(fn getValue);\n            };\n\n            return Lazy();\n        }\n\n        fn get(ref lazy) {\n            if (!lazy.evaluated) {\n                lazy.evaluated  = true;\n\n                // This is just exploratory stuff,\n                //  don't feel obliged to keep this working.\n                let getValue    = lazy.getValue;\n                lazy.value      = getValue();\n            }\n\n            return lazy.value;\n        }\n\n        fn main() {\n            mut calls   = 0;\n            mut lazy    = Lazy(|| calls++);\n            mut res     = lazy.get() + lazy.get();\n\n            return res == 0 && calls == 1 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn ERRLOG(implicit ref errout: string, msg = \"Assertion failed.\\n\") {\n            errout ~= msg;\n            return [];\n        }\n\n        fn tryParse(str: string) {\n            implicit mut errout: string;\n            return parse(str) || errout;\n        }\n\n        fn parse(mut str: string)\n        {\n            fn parseExpression!T(parseHead: T = fn popOneChar) {\n                let head = parseHead();\n                return parseExpressionTail(head);\n            }\n\n            fn popOneChar() {\n                if (!str) return ERRLOG(\"str.len < 1\");\n                let lastChar = str.slice(str.len - 1, str.len);\n                str.pop();\n                return lastChar;\n            }\n\n            fn popTwoChars() {\n                if (str.len < 2) return ERRLOG(\"str.len < 2\");\n                let lastChars = str.len > 1 && str.slice(str.len - 2, str.len);\n                str.shrink(str.len - 2);\n                return lastChars;\n            }\n\n            fn parseExpressionTail(head: string) {\n                return head ~ head;\n            }\n\n            return parseExpression()\n                 ~ parseExpression(parseHead: popTwoChars);\n        }\n\n        <split/>\n        let PRELUDE =  <fail no implicit errout 2:32+6>\n            parse(\"AAB\");                       <pass/>\n            tryParse(\"AAB\");                    </fail>\n\n        <split/>\n        fn main() PRELUDE.len == 6 ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn Zero(src) = src.len;\n        fn Todo(src) = src.NOT_DEFINED();\n\n        <split/>\n        fn main() {\n            let Solo            = fn Zero;\n\n            lax fn Solo_muteRest(lax src) {}\n            shadow let Zero     = fn Solo_muteRest;\n            shadow let Todo     = fn Solo_muteRest;\n\n            lax fn Noop(src)    = Zero(src);\n            shadow let Zero     = fn Noop;\n\n            let Todo_Renamed    = fn Todo;\n            Todo_Renamed(\"Unused!\");\n\n            return Solo(\"Hello World!\") - 12;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn args_in_cases(a, b)              <fail not a type (3:19+1|3:32+1)>\n            case (a -> b)                   <fail/>\n            case (typeof(a) -> b)           <fail/>\n            case (a -> typeof(b))           <pass/>\n            case (typeof(a) -> typeof(b))   </fail> = a + b;\n\n        fn main() args_in_cases(+1, -1);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("                                  ;; DuplicateFunctions\n        fn ARR_LAST(ref a: $T[])\n            case (typeof(a) -> &mut $T[]): &mut $T a[a.len - 1];\n            case (typeof(a) -> &    $T[]): &    $T a[a.len - 1];\n\n        fn main()\n        {\n            let a = [1];\n            mut b = [2];\n\n            b.ARR_LAST += a.ARR_LAST;\n            return b.ARR_LAST - 3;\n        };\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("                                  ;; DuplicateFunctions\n        fn ARR_LAST(ref a: $T[])\n            case (typeof(a) -> &mut $T[]): &mut $T a[a.len - 1];\n            case (typeof(a) -> &    $T[]): &    $T a[a.len - 1];\n\n        let a = [1];\n        mut b = [2];\n\n        b.ARR_LAST += a.ARR_LAST;\n        return b.ARR_LAST - 3;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        // Same as below, but avoids the $T call, which is also broken somehow.\n        //  DONT DELETE ME after you fix the $T, its a great example of stupid codegen -\n        //   we emit useless overloads for mutrefs when its clearly useless.\n\n        fn rec_cases(a: $T)\n        case ($T.is::primitive) {\n            if (a)      return rec_cases(a / 2);\n            else        return a;\n        }\n        default {\n            if (a.i) {\n                shadow mut a = a;\n                a.i /= 2;\n                return rec_cases(a);\n            }\n            else        return rec_cases(a.i);\n        }\n\n        struct X { i: i32; };\n        fn main() X(1).rec_cases;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn rec_cases(a: $T)\n        case ($T.is::primitive) {\n            if (a)      return rec_cases(a / 2);\n            else        return a;\n        }\n        default {\n            if (a.i)    return rec_cases($T(i: a.i / 2));\n            else        return rec_cases(a.i);\n        }\n\n        struct X { i: i32; };\n        fn main() X(1).rec_cases;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test() {\n            mut x = 5;\n            return x;\n        }\n\n        fn main()\n            test() - 5;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Test { i: i32; };\n\n        fn test() {\n            mut x = Test(5);\n            return x;\n        }\n\n        fn main()\n            test().i - 5;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Test { a: i32; b: i32; };\n\n        fn test() {\n            mut x = Test(5, -5);\n            return x;\n        }\n\n        fn main()\n            test().a + test().b;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct X { x: i32; };\n        fn ref2arg(x: X) = x;\n\n        fn main() {\n            let NOTREF = ref2arg(X(101));\n            return NOTREF.x - 101;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        <fail cannot be copied or moved 8:21>\n        nocopy <pass/></fail>\n        struct Copied { x: i32; };\n\n        fn main() {\n            let a = Copied(1);\n            mut b = a;\n            b.x++;\n            return b.x - a.x * 2;\n        }\n    "_fu, PARZERO_queue);

    PARZERO_EiSsO8S1("\n        nocopy struct NoCopy { i: i32; };\n        fn retmutref(ref nc: NoCopy) nc;\n\n        fn main() {\n            mut nc: NoCopy;\n            nc.retmutref.retmutref.i++;\n            return nc.i - 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        nocopy struct NoCopy { i: i32; };\n        fn mutrefself(ref nc: NoCopy) {\n            nc.i++;\n            return nc;\n        }\n\n        fn main() {\n            mut nc: NoCopy;\n            nc.mutrefself().mutrefself();\n            return nc.i - 2;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        nocopy struct NoCopy { i: i32; };\n\n        fn      retarg(a: NoCopy) a;\n        fn  retargs_if(a: NoCopy, b: NoCopy) a.i ? b : a;\n        fn  retargs_or(a: NoCopy, b: NoCopy) a || b;\n        fn retargs_and(a: NoCopy, b: NoCopy) a && b;\n\n        fn main() {\n            let a: NoCopy;\n            let b: NoCopy;\n            return retarg(retargs_if(a, retargs_and(a, retargs_or(a, b)))).i;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        nocopy struct NoCopy { i: i32; };\n\n        fn      retarg(a: NoCopy) a;\n        fn  retargs_if(a: NoCopy, b: NoCopy) a.i ? b : a;\n        fn  retargs_or(a: NoCopy, b: NoCopy) a || b;\n        fn retargs_and(a: NoCopy, b: NoCopy) a && b;\n\n        fn main() {\n            let a: NoCopy;                      // <- b now temp\n\n            return retarg(retargs_if(a, retargs_and(a, retargs_or(a, NoCopy)))).i;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        nocopy struct NoCopy { i: i32; };\n\n        fn      retarg(ref a) a;                    // <- now templates\n        fn  retargs_if(ref a, ref b) a.i ? b : a;\n        fn  retargs_or(ref a, ref b) a || b;\n        fn retargs_and(ref a, ref b) a && b;\n\n        fn main() {\n            mut a: NoCopy;                      // <- now muts\n            mut b: NoCopy;\n            retarg(retargs_if(a, retargs_and(a, retargs_or(a, b)))).i++;\n            return a.i + b.i - 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn as_blocks_after(x: i32) {\n            mut zero = 0;\n            if (x > 2) // a broken stmt emit lifted the loop out of the conditional\n                for (mut i = 0; i < x; i++)\n                    zero = i + i*zero;\n\n            return zero;\n        }\n\n        fn main() 2.as_blocks_after;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Lifetime { woot: Lifetime[]; };\n\n        fn Lifetime_test(x: Lifetime) {\n            x.woot.len & 1 && throw(\"This is very important.\");\n            for (mut i = 0; i < x.woot.len; i++) Lifetime_test(x.woot[i]);\n            return x;\n        }\n\n        fn Lifetime_fromBinding(x: i32) {\n            mut woot: Lifetime[];\n            for (mut i = 0; i < x; i++)\n                woot[i] = Lifetime();\n\n            ;; !N_NonTrivAutoCopy\n            //\n            //  1. Move 'woot' into Lifetime\n            //      instead of naively copying it.\n            //                             ....\n            return Lifetime_test(Lifetime(:woot));              ;; ConstCast\n            //     ....\n            //  2. Move the result out even though\n            //      Lifetime_test takes and returns refs.\n        }\n\n        fn main() 0.Lifetime_fromBinding.woot.len;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(x: i32) {                       // none of these need vecs\n            let c = [10007];                    ;; TODO fu::slate<1, int> c\n            let a = [7, 11, 9, 21, x, x, x, x]; ;; TODO fu::slate<2, int> a\n            let b = {                           ;; TODO fu::slate<1, int> b\n                :BRK {                          // !N_NonTrivAutoCopy\n                    if (x & 2) break :BRK c;\n                    if (x & 1) break :BRK [ x ]; // a val\n                    a // a ref\n                }\n            };\n            return a[0] - b[0] * a[1];\n        }\n\n        fn main() 1.test + 4.test + 74;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Test { i: i32[]; };\n\n        fn test(mut x: Test) {\n            x.i[0] += x.i[1];\n            return x;\n        }\n\n        fn main() {\n            let s = Test([ 1, 2 ]);\n            return test(s).i[0] - s.i[0] * 3;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Test { i: i32[]; };\n\n        fn test(mut x: Test): Test {\n            x.i[0] += x.i[1];\n            return x;\n        }\n\n        fn main() {\n            let s = Test([ 1, 2 ]);\n            return test(s).i[0] - s.i[0] * 3;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn compile_snippets(x0: string) x0.find('a') && throw(\"throw#1\");\n        fn ZERO(x1: string) x1.find('b') && throw(\"throw#2\");\n\n        fn FAIL(x2: string): string {                   ;; EXPECT fu::view<char> x2\n            try {\n                let ctx = compile_snippets(x2) && \"hey\";\n                return ctx;\n            }\n            catch (e) {\n                return ZERO(x2) && e;\n            }\n        }\n\n        fn main() FAIL(\"a\").len;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        // The thing below but shorter:\n        //  the '|| throw' introduces a bullshit lambda during codegen,\n        //   which misreturns a dangling reference to its own frame.\n        fn test(x: string) [x][0] || throw(\"nope!\");\n        fn main() \"what\".test.len - 4;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn only(s: $T[]) s.len == 1 ? s[0] : throw (\"len != 1: \" ~ s.len);\n\n        struct Node       { kind: string; };\n        struct SolvedNode { kind: string; };\n\n        fn solveNodes(n: Node[]) {\n            mut r: SolvedNode[];\n            for (mut i = 0; i < n.len; i++) r ~= SolvedNode(n[i].kind);\n            return r;\n        }\n\n        // the '|| throw' introduces a bullshit lambda during codegen,\n        //  which misreturns a dangling reference to its own frame.\n        fn solveDeclExpr(n: Node) solveNodes([ n ]).only || throw (\"!only\");\n\n        fn main() solveDeclExpr(Node(\"a\")).kind.len - 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        pub fn test(x: i32): i32[] { ;; !N_NonTrivAutoCopy\n            mut a = [ 4 ];\n            mut b = [ 5 ];\n            mut c = [ 6 ];\n\n            for (mut i = 0; i < x; i++) {\n                a.unshift(x);\n                b.unshift(x);\n                c.unshift(x);\n            }\n\n            inline fn which() {\n                return :test x & 1 ? a : b;\n            }\n\n            if !(x & 2)\n                return which();\n\n            return c;\n        }\n\n        fn main() test(2)[2] + test(1)[1] - 2 * test(0)[0];\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn incr_x_to_1(ref x: i32) {\n            x && throw(\"this reports return t_never\");\n            fn incr_x() { return x++; }\n            incr_x();\n        }\n        fn main() {\n            mut x = 0;\n            incr_x_to_1(x);\n            return x - 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            mut x = 0;\n            fn incr_x_to_1() {\n                x && throw(\"this reports return t_never\");\n                fn incr_x() { return x++; }\n                incr_x();\n            }\n            incr_x_to_1();\n            return x - 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn apply(fn, v) fn(v);\n        fn main() {\n            mut x = 0;\n            fn scope_using(via: i32) {\n                x && throw(\"this reports return t_never\");\n                // which messed up retcount for scope_using\n                fn visit(item: i32) {\n                    if (item) return item;\n                    return x++;\n                }\n                apply(fn visit, via);\n            }\n\n            scope_using(x);\n            return x - 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main()   <fail leading zero in numeric literal 3:13+1>\n            010     <pass/>\n            0o10    </fail>\n                == 8 ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        <alt>\n        fn main() 0b101 ==   5 ? 0 : 1; <alt/>\n        fn main() 0o101 ==  65 ? 0 : 1; <alt/>\n        fn main() 0x101 == 257 ? 0 : 1; </alt>\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main()\n            i32(f64.PI * 2.0) - 6;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main()\n            i32(f64.PI * 2 - 6);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main()\n            f64.PI * 2 - 6 |> i32;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main()\n            i32 <| f64.PI * 2 - 6;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let x: f32 = 1; fn main() 1 - x.i32;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let x: f32 = 1.0; fn main() 1 - x.i32;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let x: u8 = 1; fn main() 1 - x.i32;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let x = 1.f32; fn main() 1 - x.i32;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn gt0(x: f32) x > 0;\n        fn main() gt0(1.f32) ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Hey { x: f32; };\n        fn hey() Hey(1);\n        fn main() hey.x.i32 - 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct vec3 { x?: f32; y?: f32; z?: f32; };\n        fn test(i: i32) vec3(x: (i - 2).f32, z: 1);\n        fn main() {\n            let v = test(1);\n            return (v.x + v.z).i32;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct vec3 { x?: f32; y?: f32; z?: f32; };\n        fn test(f: f32) vec3(x: f, z: -1);\n        fn main() {\n            let v = test(-1);\n            return (v.x - v.z).i32;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn hey(i: f32) i.f32 + 0.5;\n        fn main() hey(1).i32 - 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn lin2srgb(l: f32): f32\n            l <= 0.0031308\n                ? l * 12.92\n                : 1.055 * pow(l, 1/2.4.f32) - 0.055;\n\n        fn lin255(v: f32) u32 <|\n            v.lin2srgb.max(0).min(1) * 255.99;\n\n        fn main() i32 <|\n            lin255(1) - 255;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct vec3 { x?: f32; y?: f32; z?: f32; };\n\n        inline fn /(a: f32, b: vec3)                            ;; GNUStmtExpr\n            vec3(a / b.x, a / b.y, a / b.z);\n\n        fn main() i32 <|\n            (1/vec3(x: 1)).x - 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let QUAD_DATA: f32[] =\n        [\n            -1, -1, 0,      0, 0, 1,    0, 0, 0,\n            +1, +1, 0,      0, 0, 1,    1, 1, 0,\n            -1, +1, 0,      0, 0, 1,    0, 1, 0,\n\n            -1, -1, 0,      0, 0, 1,    0, 0, 0,\n            +1, -1, 0,      0, 0, 1,    1, 0, 0,\n            +1, +1, 0,      0, 0, 1,    1, 1, 0,\n        ];\n\n        fn main() QUAD_DATA.len - 6 * 9;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(a: bool): u8 = a ? 1 : 0;\n\n        fn main() test(false).i32;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(a: bool): u8 = a && 1;\n\n        fn main() test(false).i32;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        pub let A_u8: u8 = 0x0;\n\n        fn ATTRIB(type: u8, count: i32, srgb = false): u8\n            = type & 0x3 | count.u8 << 2\n\n            // TODO can't deep-retype the last cast unfortunately:\n            //  we need another hint to drive typing here,\n            //   perhaps monogenous signatures, or else.\n            | (srgb && 0x80.u8);\n\n        fn main() ATTRIB(A_u8, 4).i32 - 16;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        pub struct Geometry    { g: i32; };\n        pub struct Texture     { t: i32; };\n        pub struct RenderFrame { r: i32; };\n\n        pub struct LogicFrame_in\n        {\n            lastLogic:  LogicFrame;\n        };\n\n        pub struct LogicFrame\n        {\n            DATA_fbx:   Geometry;\n            TEX_A:      Texture;\n            TEX_AO:     Texture;\n            TEX_M:      Texture;\n            TEX_N:      Texture;\n            TEX_R:      Texture;\n            HDR:        Texture;\n        };\n\n        pub struct RenderFrame_in\n        {\n            w:          i16;\n            h:          i16;\n            frame:      i32;\n\n            mouseX:     f32;\n            mouseY:     f32;\n            mouseBtns:  i32;\n\n            using logic:    LogicFrame;\n            lastRender:     RenderFrame;\n        };\n\n        pub fn APP_renderFrame(using args: RenderFrame_in): RenderFrame\n        {\n            return RenderFrame(args.HDR.t);\n        }\n\n        fn main() 0;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn leadingDigit(name: string) name[0].u8 - '0'.u8 < 10;\n        fn main() \"hello\".leadingDigit.i32;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() 1_000_000 - 1000000\n               || 0xffff_ffff.i32 - 0xffffffff.i32\n               || 123_456.789.i32 - 123456.789.i32;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("                                  // litfix through && /////\n        fn test(a: u32, shadows: bool)      (a << 1) | (shadows && 1);\n        fn main()                           test(1, true).i32 - 3;\n    "_fu, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        struct vec3 { x?: f32; y?: f32; z?: f32; };\n        inline fn *(a: vec3, b: vec3) vec3(a.x * b.x, a.y * b.y, a.z * b.z);\n        inline fn *(a: vec3, b: f32) vec3(a.x * b, a.y * b, a.z * b);\n        inline fn lensq(a: vec3) a.x * a.x + a.y * a.y + a.z * a.z;\n        inline fn len(a: vec3) a.lensq.sqrt;\n\n        inline fn norm(a: vec3) {\n            mut n = 1 / a.len;\n            n = n.finite ? n : 0;\n            return a * n;\n        }\n    "_fu, "\n        inline fn test(ref v) {\n            v = v.norm();                                       ;; GNUStmtExpr\n            return v.len;\n        }\n\n        fn main() {\n            mut v = _0::vec3(2, 0, 0);\n            return v.test() == 1 ? 0 : 1;\n        }\n    "_fu } }, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn sub15(x: i32) x - 15;\n        fn main() 0xf.sub15;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn pick(albedo: i32 = 0x12345678, shift = 16)\n            albedo >> shift & 0xf;\n        fn main()\n            pick() == 4 ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() abs(-19191) - 19191\n                + abs(+72713) - 72713;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        type Test = i32[];\n        fn yo(t: Test) t[0] + t[1];\n        fn main() yo([-1, +1]);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn if_first(a: $T[]) a && a[0];\n        fn hello(a: i32[]) a.if_first;\n        fn main() hello([ 3 ]) - 3;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn if_first(a: $T[]) a && a[0];\n        type X = i32[];\n        fn hello(a: X) a.if_first;\n        fn main() hello([ 3 ]) - 3;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn if_first(a: $T[]) a && a[0];\n\n        fn list(): i32[][] {\n            return [[ 3 ]];\n        }\n\n        fn hello() list.if_first.if_first;\n        fn main() hello - 3;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn if_first(a: $T[]) a && a[0];\n        type X = i32[];\n\n        fn list(): X[] {\n            return [[ 3 ]];\n        }\n\n        fn hello() list.if_first.if_first;\n        fn main() hello - 3;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let arr = [1, 2];\n        fn eq(a: i32[], b: i32[]) a == b;\n        fn main() eq(arr, arr) ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let arr = [1, 2];\n        fn eq(a: $T[], b: $T[]) a == b;\n        fn main() eq(arr, arr) ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            mut a = [ 1, 2, 3, 4 ];\n            mut b = a[1: ];\n            mut c = a[ :3];\n            mut d = a[1:3];\n\n            mut res = b ~ c ~ d;\n            return res <> [ 2, 3, 4,  1, 2, 3,  2, 3 ];\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            let str = \"hello world\";\n            let s10 = str[:5] ~ str[6:];\n            return s10.len - 10;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            mut strs = [ \"hello\", \"world\" ];\n            let hello = strs[0];\n            strs.insert(1,\n                <fail bad call>\n                hello[0:5] /* should work too, but currently expected to mismatch */ <pass/>\n                hello.slice(0, 5)</fail>\n            );\n            return strs.len - 3;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(hey: [i32])\n            hey[0] + hey[1];\n\n        fn main()\n            test([-1, +1]);\n\n        ;; EXPECT fu::slate<2, int> { -1, +1 }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(hey: &mut [i32])\n            hey[0] += hey[1];\n\n        fn main() {\n            mut hey = [-1, +1];\n            return hey.test();\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(i: i32) [ i, i + 1 ];\n        fn main() test(0)[1] - 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(hey: byte[])\n            hey.view(u32)[0];\n\n        fn main() {\n            mut hey: byte[] = [ byte(1), byte(1), byte(1), byte(1) ];\n            return (hey.test - 0x1010101).i32;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(hey: [i32])\n            hey[0] + hey[1];\n\n        fn main() {\n            let hey = [7, -1, +1];\n            return test(hey[1 : 3]);\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(hey: &mut [i32])\n            hey[0] += hey[1];\n\n        fn main() {\n            mut hey = [7, -1, +1];\n            return hey[1 : 3].test();\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(hey: &mut [i32])\n            hey.= [2, -3];\n\n        fn main() {\n            mut hey = [1, 0, 0];\n            test(hey[1 : 3]);\n            return hey[0] + hey[1] + hey[2];\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Hey {\n            i: i32;\n        };\n\n        fn test(out: &mut [Hey]) {\n            out.view(u8) .= [ 1.u8, 1.u8, 1.u8, 1.u8 ];\n        }\n\n        fn main() {\n            mut a = [ Hey ];\n            a.test();\n            return a[0].i - 16843009;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Hey {\n            i: i32;\n        };\n\n        fn test(x: &mut [i32], y: [ Hey ])\n            x .= y.view(i32);\n\n        fn main() {\n            mut a = [ 0 ];\n            test(a, [ Hey(13) ]);\n            return a[0] - 13;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Hey {\n            i: i32;\n        };\n\n        fn main() {\n            mut a = [ 0 ];\n            a .= [ Hey(13) ].view(i32);\n            return a[0] - 13;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(a: [byte], b?: [byte]) a == b;\n        fn main() test(\"\") ? 0 : 1;\n\n        ;; EXPECT (\"\"_fu, fu::view<char>{})\n\n        // This is what we had before, it's better.\n        ;; TODO (fu::view<char>{}, fu::view<char>{})\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let NOTES = [ \"AAA\", \"BBB\", \"CCC\" ];\n        fn what(annot: string) NOTES.find(annot.slice(1, annot.len));\n        fn main() what(\"!BBB\") - 1;\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        // When you pass this, delete the test above, they're the same.\n        //  The slice() should relax to a get_view, which doesnt need annot to be a string.\n        //   We generally want to remove the distinction between slice(a,b) and [a:b] altogether.\n        //\n        let NOTES = [ \"AAA\", \"BBB\", \"CCC\" ];\n        novec fn what(annot: string) NOTES.find(annot.slice(1, annot.len));\n        fn main() what(\"!BBB\") - 1;\n    "_fu, "fn what arg annot is not novec 7:9+5"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        fn Join(a: $T[][], lax sep = [])            // The sep is of type any-init.\n        {                                           //\n            if (a.len < 2)                          //\n                return a.len && a[0];               // NOT SURE WHAT'S 100% IDEAL, BUT:\n                                                    //\n            let N = typeof(sep) -> [$T;] ? sep.len  // should either match here,\n                  : typeof(sep) ->  $T   ? 1        //                                    but currently matches here, which is just wrong.\n                                 : 0;               //                           or here,\n\n            mut size = a[0].len;\n            for (mut i = 1; i < a.len; i++)\n                size += N + a[i].len;\n\n            mut res: $T[];\n            res.grow_junk(size);\n\n            let head = a[0];\n            size = head.len;\n            res[0 : head.len] .= head;\n            for (mut i = 1; i < a.len; i++)\n            {\n                let range = a[i];\n                if (typeof(sep) -> [$T;])\n                    res[size : size + N] .= sep;\n                else if (typeof(sep) -> $T)\n                    res[size] = sep;\n\n                size += N;\n                res[size : size + range.len] .= range;\n                size += range.len;\n            }\n\n            return res;\n        }\n\n        fn main() {\n            let res = Join([ \"hello\", \"world\" ], []); // the [] fails the case above\n            return res == \"helloworld\" ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        // one of these things reported there's no $S in scope.\n        fn Join(a: $T, b: $T, lax sep: $S = [])\n            case ($S -> $T || $S -> [$T;] || $S -> [])\n        {\n            return typeof(sep) -> $T || typeof(sep) -> [$T;]\n                 ? a ~ sep ~ b\n                 : a ~ b;\n        }\n\n        fn main() {\n            let res = Join(\"hello\", \"world\");\n            return res == \"helloworld\" ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        // This is the initial type union concept\n        fn Join(a: $T, b: $T, lax sep?: $T or [$T;] or [])\n        {\n            return typeof(sep) -> $T || typeof(sep) -> [$T;]\n                 ? a ~ sep ~ b\n                 : a ~ b;\n        }\n\n        fn main() {\n            let res = Join(\"hello\", \"world\");\n            return res == \"helloworld\" ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn Replace(str: $T[], all: $T or [$T;], with: $T or [$T;] or [])\n            str.len + (typeof(all)  -> $T ? 1 : all.len)\n                    + (typeof(with) -> [] ? 0 : typeof(with) -> $T ? 1 : with.len);\n\n        fn main()\n            \"Hello\".Replace(all: \"ll\", with: []) == 7 ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Hey { i: i32; }\n\n        fn main() {\n            let a = 1;\n            let r: Hey = a && [ a ];\n            return r.i - 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Hey { i: i32; }\n\n        fn main() {\n            let a: Hey[] = [ [ -1 ], [ +1 ] ];\n            return a[0].i + a[1].i;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Hey { i: i32; }\n\n        fn test(): Hey {\n            return [ 0 ];\n        }\n\n        fn main() test.i;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Test {\n        <fail bad call to Test expects 2 arg 11:20>\n            a: i32;  <pass/>\n            a?: i32; </fail>\n            b: i32;\n        };\n\n        return Test(b: 1).a;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Test {\n            b: i32;\n        <fail bad call to Test expects 2 arg 11:20>\n            a: i32;  <pass/>\n            a?: i32; </fail>\n        };\n\n        return Test(1).a;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Node {\n            items?: Node[];\n            stuff?: Node[];\n        };\n\n        fn rec_copy(ref a: Node) {\n            // If implemented naively,\n            //  by the time you copy stuff it's no longer there.\n            a = a.items[0];\n        }\n\n        fn main() {\n            mut a = Node(items: [ Node(stuff: [ Node ]) ]);\n            rec_copy(a);\n            return a.stuff.len - 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(a: i32, b!: i32 = 1) a + b;\n        return test(-1);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(hey!: i32) hey * 2;\n        <fail arg hey explicit name 4:25+4>\n        fn main() = (0).test;       <pass/>\n        fn main() = test(hey: 0);   </fail>\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(a: i32, b!: i32 = 1) a + b;\n        <fail bad call to test arg b explicit name 7:20>\n        return test(-2, +2);    <pass/>\n        return test(-2, b: +2); </fail>\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Test { a: i32; b!: i32; };\n        fn test(t: Test) t.a + t.b;\n        <fail bad call to Test arg b explicit name 8:20>\n        return Test(-2, +2).test;    <pass/>\n        return Test(-2, b: +2).test; </fail>\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Test { a?: i32; b!?: i32; };\n        fn test(t: Test) t.a + t.b;\n        <fail bad call to Test arg b explicit name 8:20>\n        return Test(-2, +2).test;    <pass/>\n        return Test(b: +2).test - 2; </fail>\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let _precedence = 0;\n        fn parseExpression(p1 = _precedence, mode! = 0) p1 + mode;\n        fn main() parseExpression();\n    "_fu, PARZERO_queue);
    ZERO_SAME_oJfgtjf4((fu::slate<3, fu::str> { "\n        fn A(x!: i32 = 0) x;\n        fn B(x: i32 = 0) A(:x);\n        fn main() A + B;\n    "_fu, "\n        fn A(x!?: i32) x;\n        fn B(x?: i32) A(:x);\n        fn main() A + B;\n    "_fu, "\n        fn A(x! = 0) x;\n        fn B(x = 0) A(:x);\n        fn main() A + B;\n    "_fu }), testdiffs);
    PARZERO_EiSsO8S1("\n        fn what(a = -1, b!: i32) a + b; // Trailing explicit args.\n        fn main() what(b: +1);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn greet(with!greeting: string)     greeting.len;\n        fn main()                           greet(with: \"Hello!\") - 6;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn Each(arr: $T[], visit)\n            for (mut i = 0; i < arr.len; i++)\n                visit(arr[i], i?: i);\n\n        fn main() {\n            mut muls = 0;\n            mut arr = [ 1, 2, 3 ];\n\n            arr.Each: |v, i!index|\n                muls += v * index; // complained no index in scope\n\n            return muls - 8;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Lifetime { using regions: i32[] };\n        fn isInvalidatedBy(write: i32[]) write.len * write[0];\n\n        // This blew up with a TODO: bck_node(non-empty argid).\n        fn main() isInvalidatedBy(write: Lifetime([ 3, 5 ])) - 6;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Node { a: i32; b: i32; c: i32; d: i32 };\n\n        fn make(a: i32, b?: i32, c?: i32)\n            Node(a, :b, :c, d: 10);\n\n        fn make(a: i32, b?: i32, c?: i32, d!: i32)\n            Node(a, :b, :c, :d);\n\n        fn res(using n: Node)\n            return a + 10 * b + 100 * c + 1000 * d;\n\n        fn main()\n            make(4, 5).res      == 10054 &&\n            make(3, b: 4).res   == 10043 &&\n            make(2, c: 3).res   == 10302 &&\n            make(1, d: 2).res   == 2001 ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn a0o0() 0;\n        fn a1o0(a : i32) a;\n        fn a2o1(a : i32, b?: i32) a + b;\n        fn a2o2(a?: i32, b?: i32) a + b;\n        fn main() a0o0(a?: 1, b?: 2) *      1   //      .\n                + a1o0(a?: 1, b?: 2) *     10   //     10\n                + a2o1(a?: 1, b?: 2) *    100   //    300\n                + a2o2(a?: 1, b?: 2) *   1000   //   3000\n                + a2o1(a : 1, <fail bad call>\n                              c       <pass/>\n                              b       </fail>\n                               ?: 2) *  10000   //  30000\n                + a2o1(a : 1)        * 100000   // 100000\n                                // ----------------------\n                                     - 133310;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        pub fn reveach(items: [$T], fn)\n            for (mut i = items.len; i --> 0; )\n                fn(items[i], i?: i);\n\n        pub fn main() {\n            mut sum = 0;\n            [1, 2, 3].reveach(|x   | sum += x          );\n            [1, 2, 3].reveach(|x, i| sum += x * i * 100);\n            return sum - 806;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        pub lax fn noop() 0;\n        pub fn woot(ref i: i32, fn) i += fn(i?: i += 1); // Will not add 1.\n\n        fn main() {\n            mut sum = 0;\n            woot(sum, fn noop);\n            return sum;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn takesFns(x, f)\n            f(x * 2, optAndUnused?: x * 3);\n\n        fn hasUnusedOptArg(x: int, alt = 7, lax optAndUnused?: int)\n            x + alt;\n\n        fn main()\n            takesFns(2, fn hasUnusedOptArg) - 11;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            let ret: i8 = <fail annot match>\n                128 <pass/>\n                127 </fail>;\n\n            return (ret - 100).i32 - 27;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            let ret: i16 = <fail annot match>\n                32768 <pass/>\n                32767 </fail>;\n\n            return (ret - 32700).i32 - 67;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            let ret: i32 = <fail annot match>\n                2147483648 <pass/>\n                2147483647 </fail>;\n\n            return (ret - 2147483600).i32 - 47;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() { // weird error, see the other two below\n            let ret: i64 = <fail bad int literal>\n                9223372036854775808 <pass/>\n                9223372036854775807 </fail>;\n\n            return (ret - 9223372036854775800).i32 - 7;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            let ret: i8 = <fail annot match>\n                -129 <pass/>\n                -128 </fail>;\n\n            return (ret + 100).i32 + 28;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            let ret: i16 = <fail annot match>\n                -32769 <pass/>\n                -32768 </fail>;\n\n            return (ret + 32700).i32 + 68;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            let ret: i32 = <fail annot match>\n                -2147483649 <pass/>\n                -2147483648 </fail>;\n\n            return (ret + 2147483600).i32 + 48;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() { // wording different from the ones above and below\n            let ret: i64 = <fail oversized signed int literal>\n                -9223372036854775809 <pass/>\n                -9223372036854775808 </fail>;\n\n            return (ret + 9223372036854775800).i32 + 8;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            let ret: u8 = <fail annot match>\n                256 <pass/>\n                255 </fail>;\n\n            return (ret - 0xff).i32;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            let ret: u16 = <fail annot match>\n                65536 <pass/>\n                65535 </fail>;\n\n            return (ret - 0xffff).i32;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            let ret: u32 = <fail annot match>\n                4294967296 <pass/>\n                4294967295 </fail>;\n\n            return (ret - 0xffffffff).i32;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() { // this is the best of the weird ones\n            let ret: u64 = <fail integer overflows u64>\n                18446744073709551616 <pass/>\n                18446744073709551615 </fail>;\n\n            return (ret - 0xffffffffffffffff).i32;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        pub fn set_once(ref entry, bit: i32): bool\n        {\n            let mask = 1 << bit.u64;    // cg'd into '1u << uint64_t(bit)'\n            if (entry & mask)           //  which doesnt work for some reason\n                return false;\n\n            entry |= mask;\n            return true;\n        }\n\n        fn main() {\n            mut entry: u64;\n            let a = set_once(entry, 32);\n            let b = set_once(entry, 32);\n            return a && !b ? 0 : 101;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            let hey: u128 = 0x8000000000000000.u128;\n            let res = hey + hey;\n            return res > hey ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            let v = <alt>u8<alt/>byte</alt>(128);\n            return v.i32 == 128 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            let v = <alt>i32<alt/>u32</alt>(128);\n            return byte(v) == byte(128) ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            let v = <alt>i32<alt/>u32</alt>(2147483648);\n            return byte(v) == byte(0) ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            let v = <alt>i32<alt/>u32</alt>(-1);\n            return byte(v) == byte(255) ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            return i32(byte(i32(128))) == 128 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn hello(a?: i32, b?: i32) = 10 * a + 100 * b;\n\n        <alt>\n        inline                                                  ;; GNUStmtExpr\n        </alt>\n        fn test(f) {\n            let a = 1; // none of these should need 'lax',\n            let b = 2; //  they're all SS_MATCHED below,\n            let c = 3; //   and their use is explicitly discard-ok.\n            return f(?:a, ?:b, ?:c);\n        }\n\n        fn main() test(fn hello) - 210;\n    "_fu, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        pub lax fn noop() {} // AUTOPUB\n        <fail hello is not defined><pass/>\n        pub\n        </fail>\n        fn hello() 3;\n    "_fu, "\n        import _0;\n        fn main() 6 - hello * 2;\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        pub struct Hey { i: i32; };\n    "_fu, "\n        fn main() 1._0::Hey.i - 1;\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<3, fu::str> { "\n        pub struct Hey { i: i32; };\n    "_fu, "\n        import _0;\n        pub inline fn test(h: Hey) h.i + 2;\n    "_fu, "\n        import _1;\n        fn main() 1._0::Hey.test - 3;                           ;; GNUStmtExpr\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<3, fu::str> { "\n        pub struct Hey { i: i32; };\n    "_fu, "\n        pub inline fn test(h: _0::Hey) h.i + 2;\n    "_fu, "\n        import _1;\n        fn main() 1._0::Hey.test - 3;                           ;; GNUStmtExpr\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<3, fu::str> { "\n        pub struct Hey { i: i32; };\n    "_fu, "\n        pub inline fn test(h: _0::Hey) h.i + 2;\n    "_fu, "\n        fn main() 1._0::Hey._1::test - 3;                       ;; GNUStmtExpr\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<4, fu::str> { "\n        pub struct You { i: i32; };\n    "_fu, "\n        pub struct Hey { using you: _0::You; };\n        pub fn init3(): Hey = [ _0::You(3) ];\n    "_fu, "\n        pub inline fn test(using h = _1::init3) i + 7;\n    "_fu, "\n        fn main() _2::test - 10;                                ;; GNUStmtExpr\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<4, fu::str> { "\n        pub struct vec3 {\n            x?: f32;\n            y?: f32;\n            z?: f32;\n        };\n    "_fu, "\n        import _0;\n\n        pub struct mat34 {\n            mx: vec3;\n            my: vec3;\n            mz: vec3;\n            mo: vec3;\n        };\n\n        pub inline fn mat34_identity()\n            mat34(\n                vec3(x: 1),\n                vec3(y: 1),\n                vec3(z: 1), vec3 /*point3*/);\n    "_fu, "\n        pub struct mat4 {\n            m0: f32; m1: f32; m2: f32; m3: f32;\n            m4: f32; m5: f32; m6: f32; m7: f32;\n            m8: f32; m9: f32; mA: f32; mB: f32;\n            mC: f32; mD: f32; mE: f32; mF: f32;\n        };\n\n        pub inline fn mat4(using m: _1::mat34)\n            mat4(\n                mx.x, mx.y, mx.z, 0,\n                my.x, my.y, my.z, 0,\n                mz.x, mz.y, mz.z, 0,\n                mo.x, mo.y, mo.z, 1);\n\n        pub fn determinant(using _: mat4)\n            + mC * m9 * m6 * m3 - m8 * mD * m6 * m3 - mC * m5 * mA * m3\n            + m4 * mD * mA * m3 + m8 * m5 * mE * m3 - m4 * m9 * mE * m3\n            - mC * m9 * m2 * m7 + m8 * mD * m2 * m7 + mC * m1 * mA * m7\n            - m0 * mD * mA * m7 - m8 * m1 * mE * m7 + m0 * m9 * mE * m7\n            + mC * m5 * m2 * mB - m4 * mD * m2 * mB - mC * m1 * m6 * mB\n            + m0 * mD * m6 * mB + m4 * m1 * mE * mB - m0 * m5 * mE * mB\n            - m8 * m5 * m2 * mF + m4 * m9 * m2 * mF + m8 * m1 * m6 * mF\n            - m0 * m9 * m6 * mF - m4 * m1 * mA * mF + m0 * m5 * mA * mF;\n    "_fu, "\n        pub fn main()\n        {\n            let m34 = _1::mat34_identity;\n            let m44 = _2::mat4(m34);\n\n            return m44.determinant.i32 - 1;\n        }\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        struct _0 { x?: f32; y?: f32 };\n        fn maxc(using vec: _0) x > y ? x : y;\n    "_fu, "\n        <alt>\n        import _0;\n        fn main() _0.maxc.i32;\n        <alt/>\n        fn main() ::_0.maxc.i32;\n        </alt>\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        pub fn _0(i: i32) i + 1;\n    "_fu, "\n        fn main() (-1).::_0;\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        pub fn add(ref to: $T[], item: $T) {\n            for (mut i = 0; i < to.len; i++) {\n                if (to[i] >= item) {\n                    if (to[i] != item)\n                        to.insert(i, item);\n\n                    return;\n                }\n            }\n\n            to.push(item);\n        }\n    "_fu, "\n        fn main() {\n            mut x = [1, 2, 3];\n            x._0::add(3); if (x.len != 3) return 33;\n            x._0::add(4); return x.len - x[3];\n        }\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        pub let pad0 = 0; pub let pad1 = 1; pub let pad2 = 2; pub let pad3 = 3; pub let pad4 = 4; pub let pad5 = 5; pub let pad6 = 6; pub let pad7 = 7; pub let pad8 = 8; pub let pad9 = 9;\n        pub let PAD0 = 0; pub let PAD1 = 1; pub let PAD2 = 2; pub let PAD3 = 3; pub let PAD4 = 4; pub let PAD5 = 5; pub let PAD6 = 6; pub let PAD7 = 7; pub let PAD8 = 8; pub let PAD9 = 9;\n\n        pub let A = \"hello\";\n        pub let B = \"world\";\n    "_fu, "\n        import _0;\n        fn test(i: i32) {\n            let v = i & 1 ? A : B;\n            return v.len;\n        }\n\n        fn main() 0.test - 1.test;\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        pub fn clone(a: $T)\n        case ($T.is::copy) a;\n        case ($T -> $T) {\n            mut res: $T;\n            for (fieldname i: $T) res.i = a.i.clone();\n            return res;\n        }\n    "_fu, "\n        pub nocopy struct Scope { x: i32; };\n\n        pub struct ModuleOutputs {\n            deps: i32[];\n            scope: Scope;\n        };\n\n        pub fn test(a: ModuleOutputs) {\n            let b = a._0::clone();\n            return a.deps.len - b.deps.len;\n        }\n\n        pub fn main() test(ModuleOutputs);\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        // a private fn\n        fn createShader(src: string) = src;\n\n        // inits a public let\n        pub let GEOMETRY_PASS_TEST = createShader(\"src\");       ;; ConstCast\n    "_fu, "\n        pub fn main() _0::GEOMETRY_PASS_TEST.len - 3;\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        struct List {\n            vals: string[];\n        };\n\n        fn add(using ref _: List, val: string)\n            vals ~= val;\n\n        fn [](using _: List, val: string) {\n            mut count = 0;\n            for (mut i = 0; i < vals.len; i++)\n                if (vals[i] == val)\n                    count++;\n\n            return count;\n        }\n    "_fu, "\n        fn main() {\n            mut list: _0::List;\n            for (mut i = 0; i < 3; i++)\n                list.add(i & 1 ? \"a\" : \"b\");\n\n            return list[\"b\"] - 2;\n        }\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        struct Int { i: i32; };\n        fn -(a: Int) Int(-a.i);\n        fn +(a: Int, b: Int) Int(a.i + b.i);\n        fn +=(ref a: Int, b: Int) { a.i += b.i; return a; };\n        postfix fn ++(ref a: Int) { a.i++; };\n    "_fu, "\n        fn main() {\n            mut x: _0::Int = [ 1 ];\n            x += -(x + x);\n            x++;\n            return x.i;\n        }\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<1, fu::str> { "\n        fn private(x)           x * 3;              // Scope_import is broken,\n        pub fn public(y)        private(y) * 2;     //  doesnt always import privates.\n        <split/>\n        fn main()               1.public - 6;\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        fn private(x: i32)      x * 3;              // cg fail:\n        pub fn public(y)        private(y) * 2;     //  fn private hidden in first translation unit.\n    "_fu, "\n        fn main()               1._0::public - 6;\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        let OPTOKENS = \"{}[]()!?~@#$%^&*/-+<=>,.;:|\";   // nowadays problem is OPTOKENS cgs to static in first translation unit\n\n        pub fn lex(src) // <- template\n        {\n            let end = src.len;\n            mut idx = 0;\n\n            while (idx < end) {\n                let c = src[idx++];\n                if (OPTOKENS.has(c)) // <- originally, no OPTOKENS in scope ...\n                    return idx - 1;\n            }\n\n            return src.len;\n        }\n    "_fu, "\n        fn main() _0::lex(\"3 - 3\") - 2; // <- from here\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        pub fn pubbed(a: i32) a * 2;\n        <fail not_pubbed not defined><pass/>\n        pub                          </fail>\n        fn not_pubbed(b: i32) b * 3;\n    "_fu, "\n        fn main() 1._0::pubbed._0::not_pubbed - 6;\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        let SELF_TEST           = true;\n        let NODEIDX_signbits    = SELF_TEST && 4;\n        let NODEIDX_signmask    = (1 << NODEIDX_signbits) - 1;\n    "_fu, "\n        fn main() _0::NODEIDX_signmask - 15;\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        struct Helpers { index: i32; }\n        fn +(a: Helpers, b: Helpers) a.index - b.index;\n    "_fu, "\n        import _0;\n        fn main() {\n            <fail ambig><pass/> // autoshadowing surprised me here\n            shadow      </fail> //  feels like this override should be explicit\n            infix fn +(a: Helpers, b: Helpers) a.index + b.index;\n            return Helpers(+1) + Helpers(-1);\n        }\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<4, fu::str> { "\n        struct Options { v: i32; };\n    "_fu, "\n        fn compile(o: _0::Options) = o.v;\n    "_fu, "\n        // Won't find Options if solving in reverse modid order.\n        fn compile_snippets(o: _0::Options) = o.v;\n    "_fu, "\n        import _1;\n        import _2;\n\n        fn main() {\n            let o = _0::Options(0);\n            return compile(o) + compile_snippets(o);\n        }\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<3, fu::str> { "\n        let x: i32 = 2;\n    "_fu, "\n        pub import _0;\n        let y: i32 = 3;\n    "_fu, "\n        import _1;\n        fn main() x + y - 5;\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        struct Profile {\n            a: i32;\n            b: i32;\n            c: i32;\n        };\n\n        fn incr(implicit ref p: Profile, which) {\n            p.which++;\n        }\n    "_fu, "\n        fn main() {\n            implicit mut p: _0::Profile;\n\n            _0::incr(fn _0::a);\n            _0::incr(|ref i| i._0::b);\n            _0::incr(|ref i| i.b);                              ;; DuplicateFunctions\n            _0::incr(._0::c);\n            _0::incr(.c);\n\n            return p._0::a + p.b * 10 + p.c * 100 == 221 ? 0 : 1;\n        }\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<4, fu::str> { "\n        inline fn isStruct(type: string) =\n            type.starts(with: '/');\n\n        inline fn isStructOrUnion(type: string) =\n            type.isStruct;\n    "_fu, "\n        fn lookupUserType(type: string) =\n            \"<\" ~ type.len ~ \">\";\n\n        fn tryLookupUserType(type: string) =\n            type._0::isStruct && lookupUserType(type);\n    "_fu, "\n        fn getFlatCount(type: string) =\n            type._0::isStructOrUnion\n                ? _1::tryLookupUserType(type).len\n                : 1;\n    "_fu, "\n        fn main() = \"/a\"._2::getFlatCount() == 3 ? 0 : 1;\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        noinline fn recA(x) x & 1 ? recB(x) : x;\n        noinline fn recB(x) recA(x + 1);\n\n        pub inline fn fun(x: i32) recB(x);\n    "_fu, "\n        fn main() _0::fun(0) == 2 ? 0 : 1;                      ;; GNUStmtExpr\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<3, fu::str> { "\n        fn add2(x: i32) x + 2;\n        fn times10(x: i32)\n            <fail import circ 2:9+6 5:23+2>\n                x * _1::add5(5)     <pass/>\n                x * 10              </fail>;\n    "_fu, "\n        import _0;\n        fn add5(x: i32) add2(x) + 3;\n    "_fu, "\n        fn main() _0::times10(_1::add5(8)) - 130;\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        fn hello(x: i32) x * 3;\n    "_fu, "\n        <fail could not resolve import _2 3:9+6>\n        import _2;                       <pass/>\n        import _0;                       </fail>\n        fn main() hello(4) - 12;\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        pub struct What { thing: i32 };\n\n        <fail must_be_public not defined 2:33+14><pass/>\n        pub </fail>\n        fn must_be_public(x: What) = x.thing * 11;\n    "_fu, "\n        fn main() = _0::What(3).must_be_public - 33;\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<3, fu::str> { "\n        struct Module { modid: i32; target: Target }\n        struct Target { _packed: u64 }\n\n        let modid = 2;\n        inline fn modid(t: Target) i32(t._packed);\n        inline fn index(t: Target) i32(t._packed >> 32);\n\n        fn Target(shadow modid: i32, index: i32) {\n            return Target(modid.u64 | index.u64 << 32);\n        }\n    "_fu, "\n        import _0;\n        fn inspect(m: Module) {\n            return modid + m.modid + m.target.modid;            ;; GNUStmtExpr\n        }\n    "_fu, "\n        import _0;\n        fn main() {\n            let m = Module(3, Target(5, 7));\n            return m._1::inspect() - 10;\n        }\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<3, fu::str> { "\n        struct Module { modid: i32; };\n        struct Target { _packed: u64; };\n\n        fn modid(t: Target) i32(t._packed & 0xffffff);\n\n        fn Target(modid: i32, index: i32, local: i32) {\n            return Target(modid.u64\n                        | index.u64 << 24\n                        | local.u64 << 44);\n        }\n    "_fu, "\n        import _0;\n        fn inspect(module: Module) = module.modid;\n    "_fu, "\n        fn main() _1::inspect([]);\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        struct Opts { b: i32 };\n    "_fu, "\n        fn main() {\n            fn muteRest(a, opts?: _0::Opts) a + opts.b;\n            return 0.muteRest;\n        }\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        noinline fn ifArray(type: string, hit) {\n            if (type.starts(with: \"[]\"))\n                hit(type.slice(2));\n        }\n\n        noinline fn tryClearArray(type: string, else!?) {\n            ifArray(type): |item|\n                return item;\n\n            return else();\n        }\n\n        inline fn clearArray(type: string) {\n            return tryClearArray(type, else: ||\n                throw(\"Not an array: \" ~ type));\n        }\n    "_fu, "\n        fn main() = _0::clearArray(\"[]int\").len - 3;            ;; GNUStmtExpr\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        fn Arr(type V) struct { items: V[] };\n        fn append !V(\n            using ref _:    <fail ARR is not defined 5:20+1>\n                ARR(V),     <pass/>\n                Arr(V),     </fail>\n            item: V) items ~= item;\n    "_fu, "\n        fn main() {\n            mut arr: _0::Arr(i32);\n            return arr.append(0).len - 1;\n        }\n    "_fu } }, PARZERO_queue);
    TODO_wUYWWjRs(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        <fail not defined X:X><pass/>\n        pub</fail>\n        fn not_public(x: i32) x * 2;\n        pub fn public(x: i32) x * 3;\n    "_fu, "\n        fn test(x, apply) apply(x);\n        fn main() test(5, fn _0::not_public) - 10;\n    "_fu } }, "BUG !isExtLinked but off-module 2:33+1"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        nocopy struct Target    { x: i32 }\n        nocopy struct Overload  { x: i32 };\n        nocopy struct Scope     { overloads: Overload[]; implicits: ScopeItem[] };\n\n        nocopy struct ScopeItem {\n            <fail Bad call globid expects Target got ScopeItem :50+6><pass/>\n            using </fail>\n            target: Target;\n        };\n\n        inline fn globid(.x: i32) x;\n\n        <split/>\n        fn Scope_exports(using implicit scope: Scope) {\n            for (mut i = 0; i < implicits.len; i++) {\n                let item        = implicits[i];                 ;; GNUStmtExpr\n                let overload    = overloads[item.globid - 1];   ;; PointlessLocal\n                if (overload) return overload.x;\n            }\n\n            return 0;\n        }\n\n        <split/>\n        fn main() {\n            implicit mut scope = Scope(overloads: [ Overload(3) ], implicits: [ ScopeItem(Target(1)) ]);\n            return Scope_exports() - 3;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let a = 1;\n        shadow let a = a + 1;\n        return a - 2;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        inline fn outer() inner(); // <- this reset root-scope\n        inline fn inner() {\n            // <- so main::i was visible here\n            for (mut i = 0; i < 10; i++) return i;\n            return 1;\n        }\n        fn main() {\n            for (mut i = 0; i < 10; i++) return outer();\n            return 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        pub struct Target { modid: i32; packed: u32; };\n\n        pub fn index(t: Target) i32(t.packed & 0x7fffffff);\n\n        pub fn local_eq(t: Target, index: i32, implicit modid: i32)\n            modid - t.modid || index - t.index;\n\n        fn main() {\n            let implicit modid = 1;\n            return local_eq(Target(1, 0x80000002), 7) - 5;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        nocopy struct P { secs: P[] };\n\n        fn matchImplicitArgByName_closuresAndShadowing(prims: P[]) {\n            struct Helper { idx: i32; };\n\n            using fn GET(using _: Helper) prims[idx];\n\n            shadow mut prims = {\n                mut res: Helper[];\n                for (mut i = 0; i < prims.len; i++)\n                    res ~= Helper(i);\n                res                                             ;; GNUStmtExpr\n            };\n\n            prims.sort(|a, b| a.secs.len < b.secs.len);\n\n            mut res = 101;\n            for (mut i = 0; i < prims.len; i++) {\n                let m = prims[i];\n                res += m.secs.len;\n                res *= m.secs.len;\n            }\n\n            return res;\n        }\n\n        fn main() {\n            let prims = [ P([ P, P, P ]), P, P([ P ]), P([ P, P ]) ];\n            let res = matchImplicitArgByName_closuresAndShadowing(prims);\n            return res == 27 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct HasInt { i: i32; };\n\n        fn test(s: HasInt): &i32 {\n            let i = s.i;\n            return i;\n        }\n\n        fn main() HasInt(-1).test + 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(x: i32): &i32 = x;\n        fn main() test(3) - 3;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(x: i32): &i32 {\n            fn inner() x;\n            return inner;\n        }\n\n        fn main() test(3) - 3;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct I { v: i32; };\n\n        fn test(x: I): &i32 {\n            fn inner() x.v;\n            return inner;\n        }\n\n        fn main() test(I(3)) - 3;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct I { v: i32[]; };\n\n        fn test(x: I): &i32 {\n            fn inner() x.v[0];\n            return inner;\n        }\n\n        fn main() test(I([3])) - 3;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct I { v: i32[]; };\n\n        fn test(x: I): &i32 {\n            fn inner() {\n                let v = x.v;\n                return v[0];\n            }\n\n            return inner;\n        }\n\n        fn main() test(I([3])) - 3;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn noReturn() throw (\"ex\");\n\n        fn doesReturn(a: i32) {\n            if (a > 0) return noReturn();\n            return a;\n        }\n\n        fn main() doesReturn(-3) + 3;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Context { modules: Module[]; };\n        struct Module  { fname: i32; };\n\n        fn test(implicit ctx: Context) {\n            fn findModule(fname: i32): &Module {\n                let modules = ctx.modules;\n                for (mut i = 0; i < modules.len; i++) {\n                    let module = modules[i];\n                    if (module.fname == fname)\n                        return module;\n                }\n\n                throw(\"Cannot locate: \" ~ fname);\n            }\n\n            return findModule(0);\n        }\n\n        fn main() {\n            let implicit ctx = Context([ Module ]);\n            return test.fname;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn noReturn() throw (\"ex\");\n\n        fn returnVoid(a: i32): void {\n            if (a > 0) return noReturn();\n        }\n\n        fn main() {\n            returnVoid(0);\n            return 0;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn parseQualifierChain(mut i: i32): i32 {\n            for (;;) {\n                if !(i & 15) return i;\n                i--;\n            }\n        }\n\n        fn main() parseQualifierChain(15);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main()\n        {\n            mut sum = 0;\n            fn compile(x: i32)\n            {\n                // 1. this throw contributed a 'never' ret_count.\n                x || throw (\"x=0\");\n                if (x & 1) compile(x + 1); // 2. then this recursion did something.\n                sum += x; // <- also this must be a closure.\n                // 3. finally no ret_actual but non-zero ret_count.\n            }\n\n            compile(2);\n            return sum - 2;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main()\n        {\n            mut sum = 0;\n            fn getModule(fname: string) fname.len;\n            fn compile(fname: string, via: string = \"\")\n            {\n                let module = getModule(fname) || throw (\"import circle: '\" ~ via ~ fname ~ \"'.\");\n                if (module & 1) {\n                    let fuzimports = fname.split(\"a\");\n                    for (mut i = 0; i < fuzimports.len; i++)\n                        compile(\n                            fname: fuzimports[i],\n                              via: fname ~ \" <- \" ~ via);\n                }\n\n                sum += module;\n            }\n\n            compile(\"ab\");\n            return sum - 2;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn A(implicit _A: i32[]) _A;\n        fn B(implicit _B:  u8[]) _B;\n\n        fn AB(x: i32) A[x] - B[x].i32;\n        fn BA(x: i32) B[x].i32 - A[x];\n\n        fn cycleA_inner(x: i32)\n            x & 1   ? either(x + 1) + AB(x)\n                    : BA(x);\n\n        fn cycleA_outer(x: i32)\n            x & 1   ? cycleA_inner(x + 1) + AB(x)\n                    : BA(x);\n\n        fn cycleB_inner(x: i32)\n            x & 2   ? either(x + 1) + BA(x)\n                    : AB(x);\n\n        fn cycleB_outer(x: i32)\n            x & 2   ? cycleB_inner(x + 1) + BA(x)\n                    : AB(x);\n\n        fn either(x: i32)\n            x & 4   ? cycleA_outer(x)\n                    : cycleB_outer(x);\n\n        fn main() {\n            let implicit _A = [ 0,    1,    2    ];\n            let implicit _B = [ 0.u8, 1.u8, 2.u8 ];\n\n            return either(0);\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn if0_ret101(x: i32) {\n            if      (x > 2) return x * 2;\n            else if (x > 1) return x + 1; // <- left branch seeded right with never\n            return x + 101;\n        }\n\n        fn main() 0.if0_ret101 - 101;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn hello(x: i32) {\n            if (x & 1)\n                return x * 2;\n\n            <fail missing return>\n            x;            <pass/>\n            return x;     </fail>\n        }\n\n        fn main() 0.hello;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn throws()         { throw(\"WHAT!\");   }\n        fn myfn(a = throws) { return a;         } // never in default argument position!\n        fn main() {\n            try             { return myfn();                }\n            catch (e)       { return e == \"WHAT!\" ? 0 : 1;  }\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn printus(parts: string[], implicit ref out: i32)\n            parts.each(|part| part.each(|c| out += c.i32 ));\n\n        <alt>\n        inline  <alt/>\n        lax     </alt>\n        fn silent(lax parts) {}\n\n        fn main() {\n            implicit mut out: i32;\n\n            printus([ \"Hel\",\"lo\" ]);\n            if (out != 500)\n                return 1;\n\n            // Tries to test dead array literals.\n            shadow let printus = fn silent;\n\n            printus([ \"Hel\",\"lo\" ]);\n            return out == 500 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test() [] => i32;\n        fn main() test;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            <alt>\n            if (true) return 0;     <alt/>\n            if (!false) return 0;   <alt/>\n            if !(false) return 0;   </alt>\n            DOESNT_EXIST();\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(a) {\n            if (typeof(a) -> _[:])\n                return a.len;\n\n            return a * 10;\n        }\n\n        fn main() {\n            let A = [ 0, 1 ].test;\n            let B = 4.test;\n            return A + B == 42 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn staticIfSymmetry(\n            <fail $T is not defined>\n            ref a: $U[], b)  <pass/>\n            ref a: $T[], b)  </fail>\n        {\n            let N = typeof(b) ->  $T   ? 1 : 2;\n            let M = typeof(b) -> [$T;] ? 2 : 1;\n            a ~= b;\n            return N == M ? 0 : 1;\n        }\n\n        fn main() {\n            mut arr = [ 0 ];\n            return staticIfSymmetry(arr, 0)\n                 + staticIfSymmetry(arr, [ 0, 0 ])\n                 + arr.len * 10 - 40;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            let a: <fail bad call unsigned 4:23+8>f32<pass/>i32</fail> = 1;\n            let b = a.unsigned;\n            let c = a.signed;\n            if (typeof(a) -> u32) return 1;\n            if (typeof(a) -> i32) {\n                if (typeof(b) -> i32) return 2;\n                if (typeof(b) -> u32) {\n                    if (typeof(c) -> i32) {\n                        if (typeof(0.i8.unsigned)   -> u8  &&\n                            typeof(0.i16.unsigned)  -> u16 &&\n                            typeof(0.i32.unsigned)  -> u32 &&\n                            typeof(0.i64.unsigned)  -> u64 &&\n                            typeof(0.i128.unsigned) -> u128)\n                        {\n                            return 0;\n                        }\n                        return 3;\n                    }\n                    return 4;\n                }\n            }\n            return 5;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            let a: <fail bad call signed 4:23+6>f64<pass/>u64</fail> = 1;\n            let b = a.signed;\n            let c = a.unsigned;\n            if (typeof(a) -> i64) return 1;\n            if (typeof(a) -> u64) {\n                if (typeof(b) -> u64) return 2;\n                if (typeof(b) -> i64) {\n                    if (typeof(c) -> u64) {\n                        if (typeof(0.u8.signed)   -> i8  &&\n                            typeof(0.u16.signed)  -> i16 &&\n                            typeof(0.u32.signed)  -> i32 &&\n                            typeof(0.u64.signed)  -> i64 &&\n                            typeof(0.u128.signed) -> i128)\n                        {\n                            return 0;\n                        }\n                        return 3;\n                    }\n                    return 4;\n                }\n            }\n            return 5;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            mut a = 1;\n            mut b = 0;\n            {\n                defer a++;\n                b = a;\n            }\n            return (b+1) - a;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            mut a = 1;\n            mut b = 0;\n            mut c = 0;\n            {\n                defer a++;\n                defer c = a;\n                b = a;\n            }\n            return (b*27) - (a*11 + c*5);\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test_defer_if_errok(throw_err: bool) {\n            mut x      = 1;\n            mut if_err = 0;\n            mut if_ok  = 0;\n            try {\n                defer x++;\n                defer:err if_err += x;\n                defer:ok  if_ok  += x;\n\n                if (throw_err)\n                    throw(\"len=5\");\n\n                x += 8; // 9 defer++ = 10\n            }\n            catch (e) {\n                x += e.len; // 6 defer++ = 7\n            }\n\n            return x * 3 + if_err * 5 + if_ok * 7;\n        }\n\n        fn main()   (test_defer_if_errok(true)  - 7 *3 - 1*5 - 0*7)\n            + 100 * (test_defer_if_errok(false) - 10*3 - 0*5 - 9*7);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(ref x: i32) {\n            x++;\n            <alt>\n            defer x++;      <alt/>\n            defer:ok x++;   </alt>\n        }\n\n        fn main() {\n            mut x = 0;\n            test(x);\n            return x == 2 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(ref x: i32) {\n            <fail missing final return 8:13+5>\n            if (x & 1)              // ------ currently highlights the defer\n                return x;           //         probably should highlight the semicollon\n            <pass/></fail>\n            x++;\n            defer:err x++;\n        }\n\n        fn main() {\n            mut x = 0;\n            test(x);\n            return x == 1 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn sum_amulb(a: i32[], b: i32[], ref sum: i32)\n            for (mut i = 0; i < a.len; i++)\n                sum += a[i] * b[i];\n\n        fn incrarr_by1(ref a: i32[])\n            for (mut i = 0; i < a.len; i++)\n                a[i] += 1;\n\n        fn test(ref a: i32[], ref sum: i32) {\n            let b = a;\n            defer sum_amulb(:a, :b, :sum);\n\n            <alt>\n            for (mut i = 0; i < a.len; i++) a[i] += 1;\n            return a[0] - 2;\n            <alt/>\n            defer for (mut i = 0; i < a.len; i++) a[i] += 1;\n            return a[0] - 1;\n            <alt/>\n            incrarr_by1(:a);\n            return a[0] - 2;\n            <alt/>\n            defer incrarr_by1(:a);\n            return a[0] - 1;\n            </alt>\n        }\n\n        fn main() {\n            mut a = [ 1 ];\n            mut sum = 0;\n            let ret = 100 * test(:a, :sum);\n            return sum - 2 + ret;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            mut res = 1;            // single statement blocks unwrap\n            { defer res--; }        //  fix by unwraping tailing defers\n            return res;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn unwraps_defer(ref x: i32) unwrap {\n            defer x++;\n        }\n\n        fn main() {\n            mut y = 0;\n            { unwraps_defer(y); }\n            mut x = 0;\n            unwraps_defer(x);\n            return y == 1 && x == 0 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        type Test = i8;\n        fn main() 256.Test.i32;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(a: $A, b: $B) b +   <fail bad call>\n            a;                      <pass/>\n            $B(a);                  </fail>\n\n        fn main() i8(-1).test(+1);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Test { v: u32 };\n        fn test(v   <fail bad call type Test expect u32 got i32 5:23+1 2:9+6>\n                        <pass/>\n                 : u32  </fail>\n            ): Test = [ v ];\n\n        fn main() test(2).v == 2 ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let x = { mut z = 0; z++; z };\n        return x - 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn mul2(a) a*2;\n        fn test(b, fn) fn(1 + fn(b));\n        fn main() 14 - test(3, fn mul2);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let overloaded = 1;\n        fn overloaded(a) a*2;\n        fn test(b, fn) fn(fn + fn(b));\n        fn main() 14 - test(3, fn overloaded);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn overloaded(a) a*2;\n        fn test(b, fn) fn(fn + fn(b));\n        fn main() {\n            let overloaded = 1;\n            return 14 - test(3, fn overloaded);\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn MAP(items: $T[], fn) {\n            mut result: typeof( fn(items[0]) )[];\n            for (mut i = 0; i < items.len; i++)\n                result.push(fn(items[i]));\n\n            return result;\n        }\n\n        fn sqr(x) x*x;\n\n        fn main() [2].MAP(fn sqr)[0] - 4;\n\n        ;; EXPECT (fu::slate<1, int> { 2 })\n        //  During the propagateType rework\n        //   the 'mut result: fn(items[0])[]' type annot\n        //    was found listed as a callsite for items,\n        //     but wasn't reachable for relax.\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn reduce(items: $T[], fn, init?: $T) {\n            mut result = init;\n            for (mut i = 0; i < items.len; i++)\n                result = fn(result, items[i]);\n\n            return result;\n        }\n\n        fn main() [1, 2].reduce(|a, b| a + b) - 3;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn Each(items: $T[], fn) {\n            for (mut i = 0; i < items.len; i++) // <- one i\n                fn(items[i]);\n        }\n\n        fn main() {\n            mut i = 0;                  // <- another i, i got them to shadow each other\n            [1, 2].Each: |x| i += x;    //      in the everything-a-free-function\n            return i - 3;               //      impl of closures\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        mut sum = 2;\n\n        fn FnDecl_update(parent_idx: i32) {\n            fn Each(fn) fn();\n            Each(|| makeDirty(:parent_idx));\n        }\n\n        fn makeDirty(parent_idx: i32): void {\n            sum += parent_idx;\n        }\n\n        FnDecl_update(1);\n\n        return sum - 3;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        // something complains about no final return\n        fn main() {\n            let addret = |a: i32, b: i32| {\n                return a + b;\n            };\n\n            let hey = |x: i32| {\n                if !(x & 1)\n                    return x;\n\n                // this complains about indentation\n                // TODO should work without the continue\n                <alt>\n                continue \"\".len                                 ;; GNUStmtExpr\n                <alt/>\n                \"\".len.addret(x)\n                </alt>\n            };\n\n            // and this complains about no match for *(void, void)\n            return hey(0) * hey(1);\n        }\n\n        // misfired during the removal of maybeCopyOrMove(isReturn)\n        ;; !*MustSeq\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        // something complains about no final return\n        fn main() {\n            let hey = |x: i32| {\n                if !(x & 1)\n                    return x;                                   ;; GNUStmtExpr\n\n                \"\".len + x\n            };\n\n            // and this complains about no match for *(void, void)\n            return hey(1) * hey(0);\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn check(a, b, compare! = infix fn <>)\n            compare(a, b);\n\n        fn main() check(0, 0);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn check(a, b, compare! = |aa, bb| aa <> bb)\n            compare(a, b);\n\n        fn main() check(0, 0);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct A { a: i32; };\n        struct B { b: i32; };\n\n        <alt>\n        using fn bananas(a: A)  B(a.a * 2); <alt/>\n        using fn bananas(a)     B(a.a * 2); <alt/>\n        using fn bananas(a.a)   B(  a * 2); </alt>\n\n        <split/>\n        fn main() 1.A.b - 2;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn sqr(a: i32) a * a;\n        fn woot(a.sqr) a + 1;\n        fn main() 2.woot - 5;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct A0 { a0: i32; };\n        struct A1 { a1: i32; };\n        struct B  { b:  i32; };\n\n        fn a0(a1: A1) a1.a1 * 100;\n        fn bananas(a) B(a.a0 * 2); // <- template\n        fn woot(a.bananas: B) a.b; // <- check\n\n        fn main() 1.A0.woot + 1.A1.woot - 202;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct A0 { a0: i32; };\n        struct A1 { a1: i32; };\n        struct B0 { b0: i32; };\n        struct B1 { b1: i32; };\n        struct C  { c:  i32; };\n\n        fn bananas(using _: A0) B0(a0 * 2);\n        fn bananas(using _: A1) B1(a1 * 3);\n        using fn c0(using _: B0) C(c: b0 * 5);\n        using fn c1(using _: B1) C(c: b1 * 7);\n        fn woot(using a.bananas: C) c; // extra conversion\n\n        fn main() 1.A0.woot + 1.A1.woot - 31;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct A0 { a0: i32; };\n        struct A1 { a1: i32; };\n        struct B0 { b:  i32; };\n        struct B1 { b:  i32; };\n\n        fn bananas(a0: A0) B0(a0.a0 * 2);\n        fn bananas(a1: A1) B1(a1.a1 * 3);\n        fn woot(a.bananas) a.b; // <- template\n\n        fn main() 1.A0.woot + 1.A1.woot - 5;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn times_implicit(x: i32, implicit y: i32) x * y;\n        fn times7(x: i32) x * 7;\n\n        fn woot(a.times_implicit, b: u32) a * b.i32;\n        fn woot(a: i32, b.times7: i32) a * b;\n\n        fn test0() 3.woot(2.i32);\n\n        fn test1() {\n            let implicit y = 7;\n            return 3.woot(2.u32);\n        }\n\n        fn main() test0 + test1 * 1000 - 42042;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct X { str: string; };\n        fn ~(a: X, b: X) X(a.str ~ b.str);          // currently: invalid operator~ cg\n        inline fn ~(a: X, b.to_debug_str) a ~ b;    // currently: pointless blocks\n\n        fn to_debug_str(a: i32) X(\"i\" ~ a);\n\n        fn main() {\n            let hey = X(\"Hey! \") ~ 5;                           ;; GNUStmtExpr\n            return hey.str == \"Hey! i5\" ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct vec32  { x: f32; };\n        struct conv32 { v: f32; };\n\n        <alt>\n        using inline fn convert(v: i32): conv32 = [ v.f32 ]; // no litfix\n        <alt/>\n        using inline fn convert(v: f32): conv32 = [ v ]; // litfix in a conv: i32 -> f32\n        </alt>\n\n        inline fn /(a: conv32, b: vec32) vec32(a.v / b.x);\n        fn main() i32 <| (1/vec32(1)).x - 1;                    ;; GNUStmtExpr\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct vec_u  { x: u32; };\n        struct vec32  { x: f32; };\n        struct vec64  { x: f64; };\n\n        struct conv_u { v: u32; };\n        struct conv32 { v: f32; };\n        struct conv64 { v: f64; };\n\n        using inline fn convert(v: u32): conv_u = [ v ]; // matchfail before\n        using inline fn convert(v: f32): conv32 = [ v ];\n        using inline fn convert(v: f64): conv64 = [ v ]; // matchfail after\n\n        inline fn /(a: conv_u, b: vec_u) vec_u(a.v / b.x);\n        inline fn /(a: conv32, b: vec32) vec32(a.v / b.x);\n        inline fn /(a: conv64, b: vec64) vec64(a.v / b.x);\n\n        fn main() i32 <| (1/vec32(1)).x - 1;                    ;; GNUStmtExpr\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        pub struct Module       { modid: i32; };\n        pub struct Target       { modid: i32; index: i32; };\n        pub struct Type         { using vtype: ValueType; };\n        pub struct ValueType    { modid: i32; canon: string; };\n        pub struct Overload     { kind: string; locals?: Overload[]; };\n\n        fn main() {\n            using fn GET(target: Target, implicit overloads: Overload[]) {\n                target.index > 0 || throw(\"Assertion failed.\");\n                if (target.modid < 0)\n                    return overloads[-target.modid - 1].locals[target.index - 1];\n                else\n                    return overloads[target.index - 1];\n            }\n\n            fn try_GET(target: Target)\n                target && GET(target);\n\n            implicit mut overloads: Overload[];\n            overloads ~= Overload(\"What\");\n            return try_GET(Target(0, 1)).kind.len - 4;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct RWEvent { rw_target!: i32 };\n        struct ReadID  { id: i32 };\n\n        fn main()\n        {\n            <fail ambig rw_target>\n            using   <pass/></fail>\n            fn RWEvent(read: ReadID)    RWEvent(rw_target: read.id);\n\n            fn rw_target(read: ReadID)  read.id;\n\n            return ReadID(0).rw_target;\n        }\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        fn a_len(a: [$T]) a.len; // a conversion could navigate this here\n        struct Test { using a: i32[]; };\n        fn main() Test.a_len;\n    "_fu, "Bad call to a_len 4:24+5"_fu, testdiffs);
    TODO_bvxMZmIw("\n        struct CodegenOutput { using src: string; };\n\n        fn test(ref str: string, out: CodegenOutput) {\n            str ~= out && \"b\";\n            return str ~ out;\n        }\n\n        fn main() {\n            mut str = \"a\";\n            return str.test(CodegenOutput(\"what\")).len - 6; // \"abwhat\".len;\n        }\n    "_fu, "Bad call to ~ 6:24+1"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        struct linearRGB    { r: i32; };\n        struct sRGB         { r: i32; };\n\n        <fail ambig conversion 14:18+1 lin2srgb 6:9+5 srgb2lin 9:9+5>\n        using    <pass/></fail>\n        fn lin2srgb(c: linearRGB): sRGB = [ c.r / 3 ];\n\n        using\n        fn srgb2lin(c: sRGB): linearRGB = [ c.r * 3 ];\n\n        fn RGB(linear: bool, r: i32) {\n            return linear\n                 ? linearRGB(r)\n                 :      sRGB(r);\n        }\n\n        fn main() {\n            mut c = RGB(linear: false, 7);\n            return c.r - 21;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct linearRGB    { r: i32; };\n        struct sRGB         { r: i32; };\n\n        <fail cannot convert><pass/>\n        using                </fail>\n        fn srgb2lin(c: sRGB): linearRGB = [ c.r * 7 ];\n\n        fn main() = (sRGB(r: 3) => linearRGB).r - 21;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Overload     { name: string; };\n        struct Target       { o_index: i32; };\n\n        struct Helpers      { hd_index: i32; };\n        struct HelpersData  { target: Target; };\n\n        fn solve(ref overloads: Overload[], ref helpers: HelpersData[])\n        {\n            using fn GET(h: Helpers)\n                helpers[h.hd_index];\n\n            fn qWHAT(o: Overload)\n                o.name;\n\n            using fn GET(t: Target) {\n                ref o = overloads[t.o_index];\n\n                // The qWHAT here tried to (pointlessly) solve qWHAT below,\n                //  but GET hadn't solved yet so it wasn't available.\n                return o.qWHAT ? o : GET(Target(t.o_index + 1));\n            }\n\n            fn qWHAT(hd: HelpersData)\n                hd.target.qWHAT;\n\n            return Helpers(0).qWHAT;\n        }\n\n        fn main() {\n            mut overloads: Overload[];\n            mut helpers: HelpersData[];\n\n            for (mut i = 0; i < 2; i++) {\n                overloads ~= Overload(i && \"o=\" ~ i);\n                helpers ~= HelpersData(Target(i));\n            }\n\n            return solve(overloads, helpers) == \"o=1\" ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Target       { index: int };\n        struct Overload     { name: string; };\n\n        fn solve(_overloads: Overload[], _targets: Target[]) {\n            fn fail(mut reason: string): never {\n                for (mut i = _targets.len; i --> 0; ) {\n                    let t = _targets[i];\n                    if (t)\n                        reason ~= GET(t).qWHAT;\n                }\n\n                return throw(reason);\n            }\n\n            fn qWHAT(o: Overload)\n                o.name;\n\n            using fn GET(target: Target) {\n                _overloads.len >= target.index || fail(\n                    GET(Target(_overloads.len - 1)).qWHAT);\n\n                return _overloads[target.index];\n            }\n\n            fn qWHAT(n: Target[]) {\n            <alt>\n                mut res = \"\";\n                for (mut i = 0; i < n.len; i++)\n                    res ~= n[i].qWHAT;\n\n                return res;\n            <alt/>\n                return n.map(|t| t.qWHAT).join();\n            </alt>\n            }\n\n            return _targets.qWHAT;\n        }\n\n        fn main() {\n            mut res = solve(\n                [ Overload(\"Hello\"), Overload(\", \"), Overload(\"! \"), Overload(\"World!\") ],\n                [ Target(0), Target(1), Target(3) ]);\n\n            return res == \"Hello, World!\" ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn a_slash_b(a: f32, b: f32) {\n            return a ~ \"/\" ~ b;                                 ;; DuplicateFunctions\n        }\n\n        fn main() {\n            return a_slash_b(1, 2) == \"1.000000/2.000000\" ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            let s: i32 = -3;\n            let u: u32 =  3;\n            <fail 6:22+1 9:10+1 T: incompatible types i32 u32>\n            return s + u;             <pass/>\n            return s + u.i32;         </fail>\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Start { s: i32 };\n        struct MidA { a: i32 };\n        struct MidB { b: i32 };\n        struct End { e: i32 };\n\n        using fn toMidA(start: Start) MidA(start.s * 2);\n        using fn toMidB(start: Start) MidB(start.s * 3);\n        using fn toEnd(mida: MidA) End(mida.a * 5);\n\n        <fail 18:26+1 multiple ways to conv Start into End toMidA 7:9+5 toEnd 9:9+5 toMidB 8:9+5 toEnd 12:9+5>\n        using <pass/></fail>\n        fn toEnd(midb: MidB) End(midb.b * 7);\n        <split/>\n\n        fn main() {\n            let start = Start(1);\n            return start.e - 2*5;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct vec3 { x: i32 };\n        fn woot(\n            using a: vec3,\n            <fail ambig using multiple ways to obtain vec3 9:20+1 4:13+5 6:13+5>\n            using <pass/></fail>\n            b: vec3)\n        {\n            return x + b.x;\n        }\n\n        fn main() vec3(1).woot(vec3(-1));\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct B { v: i32 };\n        struct C { v: i32 };\n\n        <fail ambig 7:31+1 6:20+1 3:20+1 using fn AC 8:9+5>\n        struct A { v: i32 };\n        using fn AB(a: A) B(a.v * 2);\n        using fn AC(a: A) C(a.v * 3);\n        <pass/>\n        struct A { a: i32 };\n        using fn AB(a: A) B(a.a * 2);\n        using fn AC(a: A) C(a.a * 3);\n        </fail>\n\n        fn main() {\n            let a = A(1);\n            let b: B = a;\n            let c: C = a;\n            return b.v * c.v - 6;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct A1 { v: i32 };\n        struct A2 { v: i32 };\n        struct B { v: i32 };\n\n        using fn A1B(a: A1) B(a.v * 2);\n        using fn A2B(a: A2) B(a.v * 3);\n\n        fn test(a): B = a;\n\n        fn main() A1(1).test.v * A2(1).test.v - 6;\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        struct A { a: i32 };\n        struct B { b: i32 };\n\n        // Currently this would have to be named fn A -\n        //  because we match by type *name*, instead of\n        //   attempting conversions to type A.\n        //\n        // We want to replace match-by-name by tryConvert.\n        //\n        using fn A2B(a: A): B = [ a.a + 3 ];\n\n        fn main() A(2)<alt>.B</alt>.b - 5;\n    "_fu, "Bad call to T A 13:24+1"_fu, testdiffs);
    TODO_bvxMZmIw("\n        fn Wrap(type T) =\n            struct { value!: T };\n\n        infix fn => !<A, B>\n            (from: Wrap(A), lax _: Wrap(B)): Into =\n                [ Into(from.value) + 4 ];\n    <alt>\n        fn main() =\n            (7.u32 => Wrap(int)).value - 14;\n    <alt/>\n        fn main() {\n            type T = Wrap(int);\n            return T(7.u32).value - 14;\n        }\n    </alt>\n    "_fu, "Bad call to T u32 11:21+1"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        struct A { target: i32; };\n        struct B { target: u32; };\n\n        fn definit()    <fail ambig call zeroes A:target B:target><pass/>\n            : A         </fail>\n                = [];\n\n        fn main() = definit.target;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct A { x: i32 };\n        struct C { a: A };\n                                    <fail C2A bad call a>\n        using fn C2A(ref a) a.a;    <pass/>\n        using fn C2A(ref a.a) a;    </fail>\n\n        using fn getX(ref x.x) x;\n        fn main(): i32 {\n            let c: C;\n            return c;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct A { x: i32 };\n        struct C { a: A };\n                                    <fail C2A bad call a>\n        using fn C2A(ref a) a.a;    <pass/>\n        using fn C2A(ref .a)  a;    </fail>\n\n        using fn getX(ref .x) x;\n        fn main(): i32 {\n            let c: C;\n            return c;\n        }\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        struct A { x: i32 };\n        struct B { using a: A };\n        struct C { b: B };\n<alt>\n        using fn C2B(ref .b) b;                             <alt/>\n        using fn C2B(using ref c: C, lax unused?: $T) b;    </alt>\n\n        <split/>\n        using fn generic_ref_x(using ref a: A, lax unused?: $T) x;\n<alt>\n        using fn val_x(using c: C) generic_ref_x;           <alt/>\n        using fn val_x(c: C)     c.generic_ref_x;           <alt/>\n        using fn val_x(ref c: C) c.generic_ref_x;           </alt>\n\n        <split/>\n        fn main() {\n            using mut c: C;\n            generic_ref_x++;\n            return val_x - 1;\n        }\n    "_fu, "val_x(C) generic_ref_x:a expects mutref 11:36+13"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        fn varargs(a[]) a[0] + a[1];\n        fn main() varargs(1, 2) - 3;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn to_debug_str(a: i32) a     * 2;\n        fn to_debug_str(b: u32) b.i32 * 3;\n\n        <alt>\n        inline                                                  ;; GNUStmtExpr\n        </alt>\n        fn inspect(items.to_debug_str[]) // <- varargs!\n        {\n            mut a = 0;\n            for (mut i = 0; i < items.len; i++)\n                a += items[i];\n\n            return a;\n        }\n\n        fn main() inspect(5.i32, 7.u32) - 31;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn va(args[]: i32[]) {\n            mut sum = 0;\n            for (mut i = 0; i < args.len; i++) sum += args[i];\n            return sum;\n        }\n\n        fn main() va(1, 2) - 3;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn Stringy(i: i32) \"i:\" ~ i;\n\n        inline fn Printy(x: string): string = x;                ;; PointlessLocal\n        inline fn Printy(x.Stringy): string = x;\n\n        fn Println(parts.Printy[]<alt>: [string]</alt>) {\n            mut total = 0;\n            for (mut i = 0; i < parts.len; i++) total += parts[i].len;\n            return total;\n        }\n\n        fn main() Println(\"str\", 10) - 7; // 'stri:10'.len\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1(" // inline fn empty retval on autocall                ;; GNUStmtExpr\n        inline fn concatable(a: bool)               a ? \"yes\" : \"no\";\n        inline fn concat(a.concatable, b: string)   a ~ b;\n        fn main()                                   concat(true, \"!\") == \"yes!\" ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1(" // inline fn empty retval on autocall\n        inline fn inl_print(a: byte)                a;          ;; PointlessLocal\n        fn inl_println(a.inl_print[]: string)       a.len;\n        fn main()                                   inl_println('a', 'b') == 2 ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct My { i: i32 };\n\n        fn test(oh: My)\n        {\n            // autocall(): never\n            let str = |my: My|: never {             ;; N_DeadConv\n                return my.i; // exits test() here\n            };\n\n            <alt>\n            let hello = \"Hello, \" ~ oh;     <alt/> // both mess up, this one emits a pointless overload,\n            let hello = oh ~ \"!\";           </alt> //  this one messes up earlier in the solver\n\n            return hello.len;\n        }\n\n        fn main() {\n            return test(My(3)) - 3;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn printlike(topic: string, stuff.print[]: [string], implicit ref out: string) {\n            out ~= topic ~ \": \" ~ stuff.join() ~ '\\n';\n        }\n\n        fn main() {\n            let topic = \"A\";\n            implicit mut out: string;\n            printlike(:topic, \"Hello, \", \"World\", \"!\");         ;; PointlessLocal\n            return out == \"A: Hello, World!\\n\" ? 0 : 1\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            mut out: string;                                    ;; PointlessLocal\n            fn lazywarn(prefix: string, inline stuff.print[]: [string]) {\n                out ||= prefix ~ stuff.join();\n            }\n\n            mut once = 0;\n            fn once(str: string) {\n                once++;\n                return str;                                     ;; ConstCast\n            }\n\n            lazywarn(once(\"Hello\"), \", \", \"World\", \"!\", prefix: \"X: \");\n            lazywarn(prefix: \"Y: \", once(\"Hello\"), \"!\");\n\n            return out == \"X: Hello, World!\" && once == 1 ? 0 : 1\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn ifThenElse(inline cond, inline cons, inline alt)\n            cond ? cons : alt;\n\n        fn main() {\n            mut cond = 0;\n            ifThenElse(cond++,\n                { return 10; },\n                { return cond == 1 ? 0 : 100; });\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn not_ambig !T(ref sum!: i32,\n            <alt>\n            inline                                              ;; GNUStmtExpr\n            </alt>\n            v[]: T[])\n        {\n            fn acc(inline x: string)    sum += x.len;\n            fn acc(inline x: i32)       sum += x;\n\n            for (mut i = 0; i < v.len; i++) acc(v[i]);\n            return sum;\n        }\n\n        fn not_ambig !T(ref sum: i32, a: i32, b: string) sum += (a + b.len);\n        fn not_ambig !T(ref sum: i32, a: string, b: i32) sum += (a.len + b);\n\n        fn main() {\n            mut sum = 0;\n\n            let a = not_ambig(:sum, 1, \"ab\");\n            let b = not_ambig(:sum, \"bc\", 2);\n            let c = not_ambig(:sum, \"abc\", \"de\");\n            let d = not_ambig(:sum, 3, 3);\n            let e = not_ambig(:sum, \"abcdef\",\n                <fail bad call to not_ambig 23:30>\n                                     'g'); <pass/>\n                                     \"g\"); </fail>\n\n            return a == 3 && b == 7 && c == 12 && d == 18 && e == 25 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        fn count_args!T (\n            <alt>\n            inline\n            </alt>\n            v[]: T[]) = v.len;\n\n        fn main() = count_args(\n            hello?: \"ignore me\",\n            1, 2, 3,\n            world?: \"ignore me too\")\n                == 3 ? 0 : 1;\n    "_fu, "optional argument ambiguity 6:31+1"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        inline fn descend_a(ref data: i32[], offset: i32, implicit ref TWO: i32) {\n            return TWO * will_relax_args_a(data, offset + 1);\n        }\n\n        noinline fn will_relax_args_a(ref data: i32[], offset: i32, implicit ref THREE: i32) {\n            if (offset < data.len) {\n                if (offset & 1)\n                    return descend_b(data, offset);\n        <alt>\n                if (offset & 2)\n                    return 2 * will_relax_args_a(data, offset + 1);\n        </alt>\n                return descend_a(:data, :offset);\n            }\n\n            return THREE * offset;\n        }\n\n        noinline fn will_relax_args_b(ref data: i32[], offset: i32, implicit ref FOUR: i32) {\n            if (offset < data.len) {\n                if (offset & 1)\n                    return descend_a(data, offset);\n        <alt>\n                if (offset & 2)\n                    return 5 * will_relax_args_b(data, offset + 1);\n        </alt>\n                return descend_b(:data, :offset);\n            }\n\n            return FOUR * offset;\n        }\n\n        inline fn descend_b(ref data: i32[], offset: i32, implicit ref FIVE: i32) {\n            return FIVE * will_relax_args_b(data, offset + 1);\n        }\n\n        fn main() {\n            implicit mut TWO    = 2;\n            implicit mut THREE  = 3;\n            implicit mut FOUR   = 4;\n            implicit mut FIVE   = 5;\n\n            mut data = [ 0, 0, 0, 0, 0 ];\n            let res = descend_b(data, 0);                       ;; GNUStmtExpr\n            return res == 10000 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Token { index: i32 };\n        struct Node  { token: Token };\n        <split/>\n        fn HERE(t.token<alt>: Token</alt>) t.index * 11;\n        <split/>\n        fn main = HERE(Node(Token(3))) - 33;\n    "_fu, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<3, fu::str> { "\n        struct Token { index: i32 };\n        struct Node  { token: Token };\n    "_fu, "\n        fn HERE(t.token<alt>: _0::Token</alt>) t.index * 11;\n    "_fu, "\n        fn main = _1::HERE(_0::Node(_0::Token(3))) - 33;\n    "_fu } }, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct A { a: i32 };\n        fn hello(.a: i32) a;\n        fn world(a.a: i32) a;\n        fn main() A(0).hello + A(0).world;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn fn_v(fn, v) fn(v);\n        struct XY { x: i32; y: i32; };  // fields weren't visible to addroffns\n        fn main() {\n            let v = XY(11, 13);\n            return fn_v(.x, v) + fn_v(.y, v) - 24;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn fn_v(x, v) x(v);             // same but name conflict - x arg and .x field\n        struct XY { x: i32; y: i32; };\n        fn main() {\n            let v = XY(11, 13);\n            return fn_v(.x, v) + fn_v(.y, v) - 24;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn fn_w(x, y) x(y);             // same thing but\n        fn fn_v(y, x) fn_w(fn y, x);    // extra nasty\n        struct XY { x: i32; y: i32; };\n        fn main() {\n            let v = XY(11, 13);\n            return fn_v(.x, v) + fn_v(.y, v) - 24;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn identity(x) x;\n        fn main() {\n            fn outer(depth1) {\n                let sum = depth1; return identity(|| sum);\n            }\n            let sum = 0; return outer(sum);\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn identity(x) x;\n        fn test(depth0) {\n            fn outer(depth1) {\n                let sum = depth1; inline fn lambda1() sum; return identity(fn lambda1);\n            }\n            let sum = depth0; inline fn lambda0() sum; return outer(fn lambda0);\n        }\n        fn main() test(0);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(depth0) {\n            fn identity(x) x;\n            fn outer(depth1) {\n                fn inner(depth2) {\n                    let sum = depth2; inline fn lambda2() sum; return identity(fn lambda2);\n                }\n                let sum = depth1; inline fn lambda1() sum; return inner(fn lambda1);\n            }\n            let sum = depth0; inline fn lambda0() sum; return outer(fn lambda0);\n        }\n        fn main() test(0);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(depth0)\n        {\n            fn first(depth1) {\n                fn first_inner(depth2) {\n                    let sum = depth0 + depth1 + depth2;\n                    return sum;\n                }\n\n                let sum = depth0 + depth1;\n                return first_inner(|| sum);                     ;; DuplicateFunctions\n            }\n\n            fn second(depth1) {\n                fn second_inner(depth2) {\n                    let sum = depth0 + depth1 + depth2;\n                    return sum + first(|| sum);\n                }\n\n                let sum = depth0 + depth1;\n                return second_inner(|| sum);\n            }\n\n            let sum = depth0 + depth0;\n            return second(|| sum);\n        }\n\n        fn main() test(0);\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        inline fn parseStuff(x: i32) descend(x);                ;; GNUStmtExpr\n\n        inline fn descend(x: i32) {\n            fn inner() x & 1 ? parseStuff(x / 2) : x;\n            return inner();\n        }\n\n        fn main() parseStuff(5) == 2 ? 0 : 1;\n    "_fu, "COMPILER BUG host_args.len != args.len"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        fn use_a(implicit a: i32) a * a;\n        fn use_b(implicit b: i32) b * b;\n        fn use_c(implicit c: i32) c * c;\n\n        <alt>\n        inline                                                  ;; GNUStmtExpr\n        </alt>\n        fn parseStuff(x: i32) {\n            fn doStuff(y: i32) doSomething(y * y);\n            return doStuff(x * x);\n        }\n\n        <alt>\n        inline </alt>\n        fn doSomething(x: i32) {\n            fn doSomething_inner(y: i32) y * use_a * descend(y * y);\n            return doSomething_inner(x * x);\n        }\n\n        <alt>\n        inline                                                  ;; GNUStmtExpr\n        </alt>\n        fn descend(x: i32) { // <- x here\n            fn descend_inner(y: i32)\n                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?\n                      : doSomethingElse(y * y) * use_c;\n\n            return descend_inner(x * x);\n        }\n\n        <alt>\n        inline                                                  ;; GNUStmtExpr\n        </alt>\n        fn doSomethingElse(x: i32) {\n            fn doSomethingElse_inner(y: i32) y * use_b;\n            return doSomethingElse_inner(x * x);\n        }\n\n        fn main() {\n            let implicit a = 0;\n            let implicit b = 0;\n            let implicit c = 0;\n            return parseStuff(0);\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            mut stuff = \"\";\n            fn doThing(thing)\n                try         stuff = \"continue \" ~ thing();\n                catch (e)   stuff = \"throw \" ~ e;\n\n            :DO_THING doThing: ||\n            {\n                fn cannotDoThing(inline reason: string)\n                    continue :DO_THING reason;\n            <alt>\n                cannotDoThing(throw(\"Reason\"));\n            };\n            return stuff.len - 12; // \"throw Reason\"\n            <alt/>\n                cannotDoThing(\"Reason\");\n            };\n            return stuff.len - 15; // \"continue Reason\"\n            </alt>\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn nested(ref index: i32)\n            return index++ && [];\n\n        fn Lifetime_each(ref lifetime: i32[], visit)\n            for (mut i = lifetime.len; i --> 0; )\n                visit(nested(lifetime[i]));\n\n        fn Lifetime_allowsMutrefReturn(ref lifetime: i32[])\n            Lifetime_each(:lifetime): |t|\n                return t;\n\n        fn main() {\n            mut arr: i32[] = [ 5, -2 ];\n            Lifetime_allowsMutrefReturn(arr);\n\n            mut sum = 0;\n            for (mut i = 0; i < arr.len; i++) sum += arr[i];\n            return sum - 4;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn Incr(ref x: i32) ++x;\n\n        struct N { v: i32 };\n\n        <alt>\n        inline\n        </alt>\n        fn +=(ref a: N, b: i32) {\n            a.v = a.v * 10 + b;\n            return a;\n        }\n\n        fn main() {\n            mut c: i32;\n            mut a: N;\n            (a = N(c.Incr)) += c.Incr;\n            return a.v - 21;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Lifetime { regions: i32[] };\n\n        let Region_STATIC = 0;\n\n        fn Region_asLocal(r: i32) r > 1000 ? r - 1000 : 0;\n\n        fn Lifetime_each !<S, A, L, E>(lt.regions,\n            static: S = [], argidx: A = [],\n            local:  L = [], else:   E = [])\n        {\n            for (mut i = 0; i < lt.len; i++)\n            {\n                let r = lt[i];\n\n                :ELSE {                                         ;; Goto\n                    if (r == Region_STATIC)\n                        S -> [] ? { break :ELSE; }\n                                : static(i?: i);\n                    else if (let locid = Region_asLocal(r))\n                        L -> [] ? { break :ELSE; }\n                                : local(:locid, i?: i);\n                    else\n                        A -> [] ? { break :ELSE; }\n                                : argidx(r, i?: i);\n\n                    continue;\n                }\n\n                else(i?: i);\n            }\n        }\n\n        fn isMovedFrom(locid: i32) locid & 1;\n\n    <alt>\n        fn main() {\n    <alt/>\n        fn main() = test();\n        fn test() {\n    </alt>\n            mut lt = Lifetime([ 1001, <alt>1002<alt/>1</alt>, 1003 ]);\n            mut locids = 0;\n            mut force_mut = true;\n\n            Lifetime_each(lt,\n                local: |locid| {\n                    if (!locid.isMovedFrom) {\n                        force_mut = false;\n                        break;\n                    }\n\n                    locids += locid;\n                },\n                else: || {\n                    force_mut = false;\n                    break;\n                });\n\n            return force_mut == false && locids == 1 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        struct Overload { name: string };\n        struct Target { globid: i32 };\n\n        fn solve(overloads: Overload[], target: Target, BUG)\n        {\n            using fn GET(t: Target)\n                overloads[t.globid];\n\n            fn BUG2(<alt>inline </alt>topic: string)\n                BUG(topic);\n\n            fn relaxBlockVar(t: Target)\n                BUG2(t.name.BUG2);\n\n            return target.relaxBlockVar();\n        }\n\n        fn main() {\n            try\n                solve([ Overload(\"hello\") ], Target(0), fn throw);\n            catch (e)\n                return e == \"hello\" ? 0 : 1;\n\n            return 2;\n        }\n    "_fu, "BUG reason not assignable string never 11:20+1"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        let SELF_TEST = <alt>true<alt/>false</alt>;\n\n        inline fn LT_each(lt: i32[:], each)\n            for (mut i = 0; i < lt.len; i++)\n                each(lt[i]);\n\n        lax fn assertPathsValid(lax lt: i32[:], lax minPathDepth)\n            if (SELF_TEST)\n                lt.LT_each: |value: i32|\n                    if (value < minPathDepth)\n                        throw(\"BAD: \" ~ value);\n\n        inline fn LT_op(lt: i32[], each, minPathDepth! = 1) {\n            mut result: i32[];\n\n            lt.LT_each: |value: i32| {\n                let result0 = result.len;\n                each(:result, :value);\n                assertPathsValid(result[result0 :], :minPathDepth);\n            }\n\n            return result;\n        }\n\n        fn LT_double(lt: i32[])\n            lt.LT_op(minPathDepth: 2): |value, ref result|  <alt>\n                result ~= value * 2;                        <alt/>\n              { result ~= value * 2; }                      </alt>\n\n        fn main() = [ 1, 2, 3 ].LT_double == [ 2, 4, 6 ] ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Target { _packed: u32 }\n        inline fn globid(t: Target) i32(t._packed);\n\n        fn solve(ref TRACE_out: string, a: Target, b: Target)\n        {\n            fn TRACE_BRACKET(inline msg: string) unwrap {\n                mut len0: int;\n                defer if (TRACE_out.len > len0) {\n                    shadow let msg = msg;                       ;; GNUStmtExpr\n                    TRACE_out.splice(len0, 0, \"<\" ~ msg ~ \">\");\n                    TRACE_out ~= \"</\" ~ msg ~ \">\";\n                }\n            }\n\n            fn TRACE(msg: string) TRACE_out ~= msg;\n\n            fn doTrySpecialize(mut target: Target, what) {\n                mut mul = 10;\n                TRACE_BRACKET(\"Hello \" ~ (target.globid * mul++));\n                what();\n            }\n\n            doTrySpecialize(a, || {});\n            doTrySpecialize(b, || TRACE(\"World!\"));\n        }\n\n        fn main() {\n            mut TRACE_out = \"\";\n            solve(:TRACE_out, Target(1), Target(2));\n            return TRACE_out == \"<Hello 20>World!</Hello 20>\" ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Target { _packed: u32 }\n        inline fn globid(t: Target) i32(t._packed);\n\n        fn TRACE_BRACKET(implicit ref TRACE_out: string, inline msg: string) unwrap {\n            mut len0: int;\n            defer if (TRACE_out.len > len0) {\n                // unlike the test above, we'll inline msg twice\n                TRACE_out.splice(len0, 0, \"<\" ~ msg ~ \">\");     ;; GNUStmtExpr\n                TRACE_out ~= \"</\" ~ msg ~ \">\";\n            }\n        }\n\n        fn TRACE(implicit ref TRACE_out: string, msg: string) TRACE_out ~= msg;\n\n        fn doTrySpecialize(mut target: Target, what) {\n            mut mul = 10;\n            TRACE_BRACKET(\"Hello \" ~ (target.globid * mul++));\n            what();\n        }\n\n        fn solve(a: Target, b: Target) {\n            doTrySpecialize(a, || {});\n            doTrySpecialize(b, || TRACE(\"World!\"));\n        }\n\n        fn main() {\n            implicit mut TRACE_out = \"\";\n            solve(          <fail wrong number of arguments 29:18+1>\n                :TRACE_out, <pass/></fail>\n                Target(1), Target(2));\n            return TRACE_out == \"<Hello 20>World!</Hello 22>\" ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn incr_do_incr(ref count: i32, inline do) {\n            count++;\n            count += do;\n            count++;\n        }\n\n        fn main() {\n            mut count = 0;\n            try         incr_do_incr(count, throw(\"what\"));\n            catch (e)   count += 10 * e.len;\n            return count - 41;\n        }\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        struct Struct { items: Target[] };\n        struct Target { index: i32 };\n        struct Scope { type: Type };\n        struct Type { canon: i32 };\n\n        noinline fn doNothingCreatively(_types: Struct[], _out: string, _type: Type)\n        {\n            using fn zeroInit(lax target: Target)\n                return [];\n\n            noinline fn noInline(type, ref out): string =\n                return type && inlineOuter(type, :out);\n\n            fn inlineOuter(inline type, ref out): string = {\n                inlineInner(_types[type.canon], :out);\n                return [];\n            }\n\n            fn inlineInner(inline s, ref out) {\n                let fields = s.items;\n                for (mut i = 0; i < fields.len; i++) {\n                    let field = zeroInit(fields[i]);\n                    lax let annot = noInline(field.type, :out);\n                }\n            }\n\n            fn cgCopyOrMove(type: Type, ref out: string)\n                inlineOuter(type, :out);\n\n            return cgCopyOrMove(_type, _out);\n        }\n\n        fn main() {\n            mut structs = [ Struct() ];\n            mut out: string;\n            doNothingCreatively(structs, out, []);\n            return out.len;\n        }\n    "_fu, "BUG ensureArgSeq host_args.len != args.len 24:45+1"_fu, testdiffs);
    PARZERO_EiSsO8S1("                                  <alt>\n        fn sA(_: $T) struct { hey: $T; };   <alt/>\n        fn sA(type T) struct { hey: T; };   <alt/>\n        struct sA(_: $T) { hey: $T; };      <alt/>\n        struct sA(type T) { hey: T; };      </alt>\n\n        fn fA(a: $T): sA($T) = [ a + 2 ];\n        fn main() 1.fA.hey - 3;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn sB(_: $T) struct { hey: $T; };\n\n        fn fB(a: $T): sB($T) = [ a + 2 ];\n        fn main() 1.fB.hey - 1.u32.fB.hey <fail bad call><pass/> .i32 </fail> ;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn sB(_: $T) struct { hey: $T; };\n\n        // Prep for the thing below.\n        fn test(x) x.hey - 1;\n\n        // 'a' must be callable.\n        type a = sB(i32);\n        fn main() a(1).test;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn setupOperators(i: i32) {\n            struct BINOP { i: i32; };\n            return BINOP(:i);\n        }\n\n        fn main() setupOperators(0).i;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn sB(_: $T) struct { hey: $T; };\n\n        fn setupOperators(i: i32) {\n            struct BINOP { i: sB(i32); };\n            mut s: sB(i32) = [ i ];\n            return BINOP(s);\n        }\n\n        fn main() setupOperators(0).i.hey;\n    "_fu, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        fn Hey = struct { i: i32 }; // fn Hey generated nonsense code\n        fn get(s: Hey) s.i;\n    "_fu, "\n        fn main() {\n            mut s: _0::Hey;\n            return s.get();\n        }\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        fn Hey(_: $T) = struct { i: $T };\n        fn get(s) s.i;\n    "_fu, "\n        fn main() {\n            mut s: _0::Hey(i32);\n            return s.get(); // get(): wasn't visible, the struct didnt remember its template origin module.\n        }\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<4, fu::str> { "\n        fn Hey(_: $T) = struct { v: $T };\n    "_fu, "\n        fn unwrap(h: _0::Hey(i32)) = h.v * 10;\n    "_fu, "\n        fn wrap(v: i32): _0::Hey(i32) = [ v + 3 ];\n    "_fu, "\n        fn main() = _1::unwrap(_2::wrap(4)) - 70;\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<4, fu::str> { "\n        fn Hello(_: $T) struct { world: $T };\n    "_fu, "\n        fn getHello(x: i32): _0::Hello(i32) = [ x * x ];\n    "_fu, "\n        fn hello(x: i32) _1::getHello(x + 3);\n    "_fu, "\n        fn main() _2::hello(2).world - 25;\n    "_fu } }, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn sB(_: $T) struct { hey: $T; };\n\n        // Pattern & partial spec, how?\n        fn test(x: sB($T)): $T = x.hey - 1;\n\n        type a = sB(i32);\n        fn main() a(1).test;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn M(lax k: $K, lax v: $V) =\n            struct { k: $K; v: $V };\n        <split/>\n\n        <alt>\n        fn add(a: M($K, $V), b: M($K, $V)): M($K, $V) = <alt/>\n        type Mu32 = M(u32, u32);\n        fn add(a: Mu32, b: Mu32): Mu32 =                </alt>\n            [ a.k + b.k, a.v + b.v ];\n\n        fn incr_by(ref a: $T, b: $T) =\n            a = add(a, b);\n\n        fn K(_: $K) = M($K, u32);\n        fn KK(k: $K, v: u32): K($K) = [ k, v ];\n        <split/>\n        fn V(_: $V) = M(u32, $V);\n        fn VV(k: u32, v: $V): V($V) = [ k, v ];\n        <split/>\n\n        fn main() {\n            mut a = KK(0x1, 2);\n            mut b = VV(3, 0x4);\n\n            a.incr_by(b);\n            b.incr_by(a);\n            return b.k * 100 + b.v == 710 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn Hey(_: $T) struct { hey: $T; };\n\n        fn hello(x: i32) x * 10;\n        fn hello(x: Hey(i32)) x.hey * 100;\n        fn hello(x: Hey($T)) case ($T.is::unsigned) x.hey * 1000;\n\n        fn main() hello(1)\n                + hello([ 1 ]   => Hey(i32))\n                + hello([ 0x1 ] => Hey(u32)).i32\n                    - 1110;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn Hey(_: $T) struct { hey: $T };\n\n        fn main() {\n            using let _ = Hey(i32[]);\n            return hey.len;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn Hey(type T) struct { hey: T };\n\n        fn main() {\n            using let _ = Hey(i32[]);\n            return hey.len;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn Hey !T(<alt>lax _: T<alt/>type T</alt>)\n            case (T.is::arithmetic) = struct { hello: T };\n            default                 = struct { world: T };\n\n        fn main() {\n            using let _a = Hey(i32);\n            using let _b = Hey(i32[]);\n            return hello + world.len;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn new(type T): T = [];\n        fn main() =\n            <fail arg T expects a type, got a value 2:12+3>\n            new(0)   <pass/>\n            new(i32) </fail>;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        type A = struct { x: i32 };\n        type B = struct { y: i32 };\n        fn main() {\n            mut a: A;\n            mut b: B;\n            return a.x + b.y;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn Hey(type T) {\n            <alt>\n            struct A { a: T };\n            struct B { b: T };\n            <alt/>\n            type A = struct { a: T };\n            type B = struct { b: T };\n            </alt>\n            return struct { a: A; b: B };\n        }\n\n        <alt>\n        fn fill(ref s, ref v: i32)\n            for (fieldname i: typeof(s))\n                if (typeof(s.i) -> i32)     s.i = v++;\n                else                        fill(s.i, v);\n        <alt/>\n        fn fill(ref s, ref v: i32) {\n            if (typeof(s) -> Hey(_)) {\n                fill(s.a, v);\n                fill(s.b, v);\n            }\n            else for (fieldname i: typeof(s)) {\n                s.i = v++;\n            }\n        }\n        <alt/>\n        fn fill(ref s, ref v: i32)\n        case (typeof(s) -> Hey(_)) {\n            fill(s.a, v);\n            fill(s.b, v);\n        }\n        default {\n            for (fieldname i: typeof(s))\n                s.i = v++;\n        }\n        </alt>\n\n        fn main() {\n            mut ab = Hey(i32);\n            mut v = 11;\n            fill(ab, v);\n            return ab.a.a + ab.b.b - 23;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        <fail not a type 4:23+1>\n        let  X = i32; <pass/>\n        type X = i32; </fail>\n        struct Y { x: X };\n\n        fn main() {\n            mut y = Y(1 + 2);\n            return y.x - 3;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Hello { a: i32; b: i32 };\n\n        fn Wrap(type T) = struct { using v: T };\n        fn incr_a1_b2 !T(using w: Wrap(T)) =\n            T(:a + 1, :b + 2);\n\n        fn main() {\n            mut zeroes: Wrap(Hello);\n            let ones = incr_a1_b2(zeroes);\n            return ones.a * 10 + ones.b * 100 - 210;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn typeArgRename(type Outer!Inner)\n            case (Inner.is::primitive)\n                = Inner;\n\n        fn main() {\n            mut x: typeArgRename(\n                <fail explicitly named 7:33+1><pass/>Outer: </fail>\n                    i32);\n\n            return x;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct HasData(type T) { data: T[] };\n\n        fn obfuscate !T(l.data: T[:], r.data: T[:], with_left, with_right) {\n            with_left (l0?: 0, l1?: l.len);\n            with_right(right: r[: r.len]);\n        }\n\n        fn concatAndFlatten !T(l: HasData(T), r: HasData(T)) {\n            mut result: T[];\n            obfuscate(l, r,\n                with_left:  |l0, l1| result ~= l.data[l0 : l1],\n                with_right: |right|  result ~= right);\n\n            return result.join(\"\");\n        }\n\n        fn main() {\n            let a: HasData(string) = [ [ \"Hello\", \", \" ] ];\n            let b: HasData(string) = [ [ \"World\", \"!\" ] ];\n\n            return concatAndFlatten(a, b).len - 13;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(x: i32) {\n            :OUTER {\n                :INNER {\n                    if (x > 1) break :OUTER;                    ;; Goto\n                    if (x > 0) break :INNER;\n                    return 2;\n                }\n                return 1;\n            }\n            return 0;\n        }\n\n        fn main() 2.test * 11 + (1.test - 1) * 13 + (0.test - 2) * 17;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(x: i32) {\n            return {\n                :BLOCK {\n                    if (x & 1) break :BLOCK 1;\n                    if (x & 2) return 2;\n                    3\n                }\n            };\n        }\n\n        fn main() 4.test - 5.test - 6.test; // 3-1-2\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn brkif(mut x: i32)\n        {\n            :WOOT\n            if (x & 1) {\n                if (x & 2) x++;\n                if (x & 4) break :WOOT;                         ;; Goto\n                x *= x;\n            }\n\n            return x;\n        }\n\n        fn main()\n            brkif(1) + brkif(3) * 10 + brkif(5) * 100 + brkif(9) * 1000\n                == 81541 ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(a: i32) {\n            mut w = 3;\n            :OUTER w += {                                       ;; GNUStmtExpr\n                :INNER {\n                    if (a & 1)  break :INNER;\n                    else        break :OUTER;                   ;; Goto\n                };\n                5\n            };\n            return w;\n        }\n        fn main() 0.test + 1.test - 11;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn ifbrk(a: i32) {\n            mut x = 0;\n            if (a & 3) {\n                x += a;\n\n                :IF_LABEL\n                if (a & 1) {\n                    mut incr    = a & 4 ? a * 2\n                                : a & 2 ? { break :IF_LABEL; }  ;; Goto\n                                        : a;                    ;; GNUStmtExpr\n                    x += incr;\n                }\n            }\n\n            return x;\n        }\n\n        fn main() 1.ifbrk + 3.ifbrk * 10 + 5.ifbrk * 100 - 1532;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(x: i32) {\n            return {\n                :BLOCK 2 * {\n                    if (x) break :BLOCK 3;                      ;; GNUStmtExpr\n                    1\n                }\n            };\n        }\n\n        fn main() = test(0) == 2 && test(1) == 3 ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn v(x: i32) {                                          ;; GNUStmtExpr\n            return {\n                :BLOCK                          5000 + { // *2:\n                    if (x == 9) continue :BLOCK 2000;    //   - here\n                    if (x == 8) return           300;\n                    if (x == 7) break :BLOCK      40;\n\n                    5                                    //   - and here!\n                }\n            }  // -----------------------------------\n        }\n        fn main() 9.v + 8.v + 7.v + 6.v      - 12345;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        pub fn test(x: i32[], y: i32[]) {\n            let z = {\n                :BLOCK {\n                    mut w: i32[] = x;\n                    if (y[0]) w ~= y;\n                    if (w[0] != 17)\n                        break :BLOCK w;\n                    x\n                }\n            };\n\n            return z[0] + z[z.len - 1];\n        }\n\n        fn main() test([ 1 ], [ 2 ]) - 3;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(mut x: i32) {\n            {\n                x++;\n                :CANT_FLATTEN { // naive block flattening\n                                //  can damage this label\n                    if (x & 1) break :CANT_FLATTEN;\n                    return x;\n                }\n            }\n            return x * 2;\n        }\n\n        fn main() test(1) + test(2) - 8;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn Each(arr, fn)\n            for (mut i = 0; i < arr.len; i++)\n                fn(arr[i]);\n\n        fn Some(arr, fn) {\n            arr.Each: |x| if (fn(x)) return x;\n            return 0;\n        }\n\n        fn main() [ 1, 2, 3 ].Some(|v| v & 1 == 0) - 2;\n\n        ;; EXPECT (fu::slate<3, int> { 1, 2, 3 })\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn outer() {\n            mut sum = 0;\n\n            inline fn inner(v: i32) {                           ;; GNUStmtExpr\n                for (mut i = 0; i < 10; i++) {\n                    sum += v;\n                    if (sum > 40)\n                        return :outer sum;\n                }\n\n                return v * 2;\n            }\n\n            mut x = 1;\n            for (;;) x = inner(x);\n        }\n\n        fn main() outer - 42; // extra points for style\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        inline fn Each(arr, fn)\n            for (mut i = 0; i < arr.len; i++)\n                fn(arr[i]);\n\n        fn main() {\n            mut sum = 0;\n            :OUTER [1, 2, 3, 4].Each(|x| {\n                sum += x;\n                for (mut i = 1; i--; ) // once\n                    if (sum == 6) break :OUTER;                 ;; Goto\n            });\n            return sum - 6;\n        }\n\n        ;; !N_NonTrivAutoCopy\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        inline fn hello(ref sum) {  //     when inlined into woot\n            if (sum > 2) return;    //      the hello block now looks like an expr\n            sum += 2;               // <-    with a diverging tail return here\n        }\n\n        fn woot(ref sum) hello(sum);\n\n        fn main() {\n            mut sum = -2;\n            sum.woot();\n            return sum;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn loop1d(i0, i1, fn)\n            for (mut i = i0; i < i1; i++)\n                fn(i);\n\n        fn main() {\n            mut x = 0;\n            loop1d(0, 10, |i| { if (x += i) break; });\n            return x - 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn loop1d(i0, i1, fn)\n            for (mut i = i0; i < i1; i++)\n                fn(i);\n\n        fn main() {\n            mut x = 0;\n            loop1d(0, 10, |i| { if (x += i) return x - 1; });\n            return 101;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn loop2d(x0, x1, y0, y1, fn) {\n            for (mut y = y0; y < y1; y++)\n            for (mut x = x0; x < x1; x++) fn(x, y);\n        }\n\n        fn main() {\n            mut sum = 0;\n            loop2d( x0:  0, x1: 10,\n                    y0: 10, y1: 12, |x, y|\n            {\n                if (y < 11) {\n                    sum++;          // for (x: 0, 10) so 10 times\n                    continue;       // <- inner loop\n                }\n\n                if (x == 1) break;  // <- outer loop\n                sum += (x + 1) * y; // once: (0+1)*(y=11)\n            });\n\n            return sum - 21;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn loop1d(i0, i1, fn)\n            for (mut i = i0; i < i1; i++)\n                fn(i);\n\n        fn loop2d(x0, x1, y0, y1, fn)\n            loop1d(y0, y1, |y|\n                loop1d(x0, x1, |x|\n                    fn (x, y)));\n\n        fn main() {\n            mut sum = 0;\n            loop2d( x0:  0, x1: 10,\n                    y0: 10, y1: 12, |x, y|\n            {\n                if (y < 11) {\n                    sum++;          // for (x: 0, 10) so 10 times\n                    continue;       // <- inner loop\n                }\n\n                if (x == 1) break;  // <- outer loop\n                sum += (x + 1) * y; // once: (0+1)*(y=11)\n            });\n\n            return sum - 21;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn next(implicit ref sum: i32, lifetime: [i32], locals_start: i32) {\n            sum += lifetime.len;\n            return lifetime[locals_start : lifetime.len];\n        }\n\n        fn Lifetime_each(lifetime: [i32], visit) {\n            for (mut i = 0; i < lifetime.len; i++)\n                visit(lifetime[i : lifetime.len]);\n        }\n\n        fn Lifetime_F_TODO_FIX_RRET(lifetime: [i32], locals_start: i32) {\n            Lifetime_each(:lifetime, visit: |l| {\n                if (l)\n                    Lifetime_F_TODO_FIX_RRET(l.next(locals_start), locals_start);\n            });\n        }\n\n        fn main() {\n            let lifetime = [ 1, 2 ];\n            implicit mut sum = 0;\n            Lifetime_F_TODO_FIX_RRET(lifetime, locals_start: 1);\n            return sum - 4;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(x: i32, ref odds: i32) {\n            return x & 1 ? { odds++; x } : x + 1;\n        }\n\n        fn main() {\n            let nums = [ 1, 2, 3 ];\n            mut odds = 0;\n            mut sum  = 0;\n            for (mut i = 0; i < nums.len; i++)\n                sum += test(nums[i], :odds);\n\n            return odds != 2 ? 100\n                 : sum  != 7 ? 200\n                 : 0;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(ref x: i32) {\n            return {\n                :BLOCK {\n                    if (x & 1)  break :BLOCK x++;\n                    else        break :BLOCK x * 2;\n                }\n            };\n        }\n\n        fn main() {\n            mut x = 1;\n            return test(x) == 1 && test(x) == 4 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn PASS_borrowCheck(ref x: i32[]) {\n            fn bck_node(add: i32) {\n                for (mut i = 0; i < x.len; i++) {\n                    x[i] *= x[i];\n                    x[i] += add;\n                }\n            }\n\n            bck_node(1);\n\n            :SOLVE_AAR {\n                if (x.len & 2)\n                    bck_node(2);\n\n                if (x.len & 1)\n                    break :SOLVE_AAR;\n\n                bck_node(3);\n            }\n        }\n\n        fn main() {\n            mut a = [ 1, 2, 3 ];\n            mut b = [ 1, 2 ];\n            PASS_borrowCheck(a);\n            PASS_borrowCheck(b);\n            return a[2] == 102 && b[1] == 732 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn rev(arr, fn) {\n            for (mut i = arr.len; i --> 0; ) {\n                if (!arr[i])\n                    break;\n                <alt>\n                else\n                    fn(arr[i], i?: i);\n                <alt/>\n                fn(arr[i], i?: i);\n                </alt>\n            }\n        }\n\n        fn test(arr) {\n            mut sum = 0;\n            arr.rev: |x| {\n                if (x & 1) continue;\n                sum += x;\n            }\n            return sum;\n        }\n\n        fn main() {\n            return test([2, 4, 6, 8]) == 20\n                && test([2, 4, 7, 8]) == 14\n                && test([2, 4, 0, 8]) ==  8 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            fn exit(code: i32) { return :main code; }\n            fn exitViaArgdef(what: i32 = exit(0)) = what;\n            exitViaArgdef();\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            fn exit(code: i32) { return :main code; }\n            fn exitViaArgdef(a: i32 = exit(0), b?) = a + b;\n            exitViaArgdef()\n        }\n    "_fu, PARZERO_queue);
    ZERO_SAME_oJfgtjf4((fu::slate<2, fu::str> { "\n        fn test(x: i32)\n        {\n            fn mayExitTest() {\n                return x & 1 ? { return :test x * x; }          ;; GNUStmtExpr\n                             : x * 2;\n            }\n\n            fn mayExitTestFromDefarg(y: i32 = mayExitTest) {\n                return y * x;\n            }\n\n            return x & 2 ? mayExitTestFromDefarg()\n                         : mayExitTestFromDefarg(x * 2);\n        }\n\n        fn main() {\n            return test(3) == 9 && test(4) == 32 ? 0 : 1;\n        }\n    "_fu, "\n        fn test(x: i32)\n        {\n            fn mayExitTest()\n                x & 1   ? { return :test x * x; }\n                        : x * 2;\n\n            fn mayExitTestFromDefarg(y: i32 = mayExitTest)\n                y * x;\n\n            return x & 2 ? mayExitTestFromDefarg()\n                         : mayExitTestFromDefarg(x * 2);\n        }\n\n        fn main()\n            test(3) == 9 && test(4) == 32 ? 0 : 1;\n    "_fu }), testdiffs);
    PARZERO_EiSsO8S1("\n        <alt>\n        inline                                                  ;; Goto\n        </alt>\n        fn test(mut x: i32) {\n            fn loopInsideInlineArg(inline theLoop = {\n                while (x) {\n                    if (x & 1)  return x;\n                    if (x & 2)  break;\n                    if (x & 8)  return :test x * 100;\n                    x /= 2;\n                }\n            }) {\n                theLoop();\n                return x * 10;\n            }\n\n            return loopInsideInlineArg() * 3;                   ;; GNUStmtExpr\n        }\n\n        fn main() {\n            let a = test(5);\n            let b = test(4);\n            let c = test(16);\n            return a == 5 && b == 60 && c == 800 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn UnusedArgError(arr: i32[], fn)\n            for (mut i = 0; i < arr.len; i++)\n                fn(hello: arr[i], i?: i);\n\n        fn main() {\n            mut sum = 0;\n            let arr = [ 1, 2, -3 ];\n            arr.UnusedArgError: |lax i, hello|\n                <fail unused arg hello 9:41+5>\n                sum += arr[i];         <pass/>\n                sum += hello;          </fail>\n\n            return sum;\n        }\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        fn test() {\n            <fail nothing to break>\n            break;   <pass/></fail>\n            return 0;\n        }\n        fn main() = test();\n    "_fu, "no label in scope 4:13+5"_fu, testdiffs);
    TODO_bvxMZmIw("\n        fn test() {\n            let hello = || {\n                <fail nothing to break>\n                break;   <pass/></fail>\n                return 0;\n            };\n\n            return hello;\n        }\n        fn main() = test();\n    "_fu, "does not match annotation i32 void 11:25+1"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        fn each(ref arr: i32[], even, odd)\n            for (mut i = 0; i < arr.len; i++)\n                if (!i) odd(i?: i, it?: arr[i]);\n                else   even(i?: i, it?: arr[i]);\n\n        fn main() {\n            mut arr = [ 1, 2, 3 ];\n            arr.each(odd: |ref it| it++, even: || { break; });\n\n            mut sum = 0;\n            for (mut i = 0; i < arr.len; i++) sum += arr[i];\n            return sum - 7;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn hello(a) a * a;          ;; EXPECT (const int a)\n        fn main() {\n            mut a = 3;\n            let b = hello(a);\n            return b - 9;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct AB { a: i32; b: i32; };\n        fn sqr   (ref x: i32) x * x;\n        fn outer (ref ab: AB) sqr(ab.a) + sqr(ab.b);        ;; EXPECT const s_AB&\n        fn main() {\n            mut ab = AB(3, 5);\n            return ab.outer - 34;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn ascii_lower(a: string): string\n        {\n            let offset = 'a'.i32 - 'A'.i32;\n\n            mut res = a;\n            for (mut i = 0; i < res.len; i++)\n            {\n                let c = res[i];\n                if (c >= 'A' && c <= 'Z')\n                    res[i] = byte(c.i32 + offset);\n            }\n\n            return res;\n        }\n\n        <split/>\n\n        fn main() \"WORLD!\".ascii_lower[2].i32 - 'r'.i32;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            mut a = [[ 7 ]];\n            return a[0][0] - 7;        ;; EXPECT a[0][0]\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        lax fn doNothing(pointlessArg: i32) {\n            if (pointlessArg == 1)\n                return;\n        }\n\n        fn main() {\n            doNothing(1);\n            return 0;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Target   { index: i32 };\n        struct Overload { uni0n: i32[] };\n\n        fn solve(all: Overload[], check: Target) {\n            fn GET(t: Target) {\n                if (t.index < 1 || t.index > all.len) throw(\"nope\");\n                return all[t.index - 1];\n            }\n\n            fn propagateType(t: Target) {\n                if (t.GET.uni0n.has(t.index)) {}\n                return t.index;\n            }\n\n            return propagateType(check);\n        }\n\n        fn main() solve([ Overload([ 1, 2, 3 ])], Target(1)) - 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Overload     { args: Argument[]; };\n        struct SolvedNode   { x: i32; };\n        struct Argument     { default: SolvedNode; };\n\n        pub fn test(overload: Overload, ref args: SolvedNode[])\n        {\n            let host_args = overload.args;          ;; EXPECT fu::view<s_Argument> /*overload*/ host_args\n\n            args.resize(host_args.len);             // .len didnt relax its arg\n            for (mut i = 0; i < args.len; i++)\n            {\n                if (!args[i])\n                {\n                    let host_arg = host_args[i];\n                    args[i] = host_arg.default;\n                }\n            }\n        }\n\n        fn main() {\n            mut o: Overload;\n            for (mut i = 0; i < 3; i++)\n                o.args ~= Argument(default: SolvedNode(x: i));\n\n            mut args: SolvedNode[];\n            test(o, args);\n            return args.len - args[args.len - 1].x - 1;\n        }\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        struct S { hey: i32[]; };\n\n        fn m_and_c_cant_alias_001(ref m!: S, c!: S) {\n            m.hey.clear();\n            return c.hey; // noalias\n        }\n\n        fn test(ref mc: S) {\n            return m_and_c_cant_alias_001(m:mc, c:mc);  // Can't return a ref into c!\n        }                                               //  But can be made to work by creating an intermediate copyvar\n                                                        //   and move-returning from there.\n        fn main() {\n            mut mc  = S([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]);\n            let hey = test(mc);\n            return hey.len - 10;\n        }\n    "_fu, "Both alias mc 10:51+2"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        // !!!! The m_and_c_cant_alias_001 test obsoletes this,\n        // !!!!  this is just detects what we definitely don't want to see -\n        // !!!!   returning a reference into a temporary copy.\n        //\n        struct S { hey: i32[]; };\n\n        fn m_and_c_cant_alias_002(ref m: S, c: S) {\n            m.hey.clear();\n            return c.hey; // noalias\n        }\n\n        fn main() {\n            mut mc  = S([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]);\n            <fail alias>\n            let hey = m_and_c_cant_alias_002(mc, mc);\n            <pass/>\n            mut bc  = mc;\n            let hey = m_and_c_cant_alias_002(mc, bc);\n            </fail>\n            return hey.len - 10;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn grow_if_oob(ref a: $T[], i: i32): &mut $T {\n            if (a.len <= i)\n                a.grow(i + 1);\n\n            return a[i];\n        }\n\n        struct BitSet { _data: u8[]; }\n\n        fn add_once(using ref _: BitSet, idx: i32): bool {\n            let no_neg = idx < 0 ? -1 : 0;\n            let bucket = idx / 8 | no_neg;\n            let bit    = idx % 8;\n            let mask   = 1 << bit.u8;\n\n            ref entry = _data.grow_if_oob(bucket);\n            if !(entry & mask) {\n                entry |= mask;\n                return true;\n            }\n\n            // Already there.\n            return false;\n        }\n\n        type BitSet2D = BitSet[];\n\n        fn add_once(ref bs: BitSet2D, i: i32, j: i32): bool {\n            return bs\n                .grow_if_oob(i)\n                .add_once(j);                                   ;; !*MustSeq\n        }\n\n        fn main() {\n            mut bs: BitSet2D;\n            bs.add_once(9, 9);\n            return bs.len + 1000 * bs[9]._data.len - 2010;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(mut _precedence = 0)\n        {\n            fn parseExpression(p1?: i32): i32 {\n                if !(_precedence = p1)\n                    return parseExpressionHead();\n\n                return _precedence;\n            }\n\n            fn parseExpressionHead()\n                parseExpression(_precedence * 101 + 1);\n\n            return parseExpression();\n        }\n\n        fn main() = test() - 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Overload {\n            is_var?: bool;\n            lifetime?: i32[];\n        }\n\n        fn GET(implicit overloads: Overload[], idx: i32) {\n            return overloads[idx];\n        }\n\n        <alt>\n        inline </alt>\n        fn Lifetime_each(mut lifetime: i32[], visit) {\n            for (mut i = 0; i < lifetime.len; i++) {\n                let r = lifetime[i];\n                let o = GET(r);\n                visit(:o, i?: i, lifetime?: lifetime);\n            }\n        }\n\n        fn Lifetime_ascend(mut lifetime: i32[], visit) {\n            Lifetime_each(:lifetime, visit: |o, shadow ref lifetime| {\n                visit(o);\n                lifetime ~= o.lifetime; // set::add\n            });\n        }\n\n        fn Lifetime_allowsMutrefReturn(lifetime: i32[]): bool {\n            Lifetime_ascend(:lifetime, visit: |o| {\n                if (o.is_var)\n                    return false; // ERR: propagateType(jump): h.ret_actual not available.\n            });\n\n            return true;\n        }\n\n        fn main() {\n            let implicit overloads = [\n                Overload,\n                Overload(lifetime: [ 0 ]),\n                Overload(lifetime: [ 1 ], is_var: true),\n                Overload(lifetime: [ 1 ]),\n                Overload(lifetime: [ 2 ]), /* the isvar */\n                Overload(lifetime: [ 3 ]), /* the non-isvar */\n            ];\n\n            let expect_false = Lifetime_allowsMutrefReturn([ 4 ]);\n            let expect_true  = Lifetime_allowsMutrefReturn([ 5 ]);\n\n            if (expect_false) return 20;\n            if (!expect_true) return 10;\n            return 0;\n        }\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        struct Overload { items: string[]; };\n\n        // This is a bit borderline -\n        //  the problem here is that a: $T[] doesn't relax to a: [$T] (not during prep) -\n        //   so we don't match at all. Still, that's what's written -\n        //    perhaps regular fns are what doesn't behave correctly,\n        //     since their relax can create ambiguity?\n        //\n        fn last(a: $T[])                    a[a.len - 1];\n        fn arg_lets(overload: Overload)     overload.items[0 : overload.items.len - 2];\n        fn test(overload: Overload)         overload.arg_lets.last.len;\n        fn main()                           Overload([ \"hello\", \"cruel\", \"world!\" ]).test - 5;\n    "_fu, "bad call to last 12:63+4 not an array"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        struct Helpers      { index: i32; };\n        struct HelpersData  { mask!: i16; };\n\n        let HM_Function     = 1.i16 << 3;\n        let HM_Struct       = 1.i16 << 5;\n\n        using inline fn GET(h: Helpers, implicit ref _helpers_data: HelpersData[]): HelpersData\n            _helpers_data[h.index];\n                                                            //////////////////\n        fn isFnOrType(h: Helpers): bool                     ;; EXPECT fu::view\n            !!(h.mask & (HM_Function | HM_Struct));         //////////////////\n\n        fn main() {\n            implicit mut _helpers_data = [ HelpersData(mask: 0) ];\n            return Helpers(0).isFnOrType.i32;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Helpers      { index: i32; };\n        struct HelpersData  { mask!: i16; };\n\n        let HM_Function     = 1.i16 << 3;\n        let HM_Struct       = 1.i16 << 5;\n\n        fn main() {\n            implicit mut _helpers_data = [ HelpersData(mask: 0) ];\n\n            using inline fn GET(h: Helpers): HelpersData\n                _helpers_data[h.index];\n                                                            //////////////////\n            fn isFnOrType(h: Helpers): bool                 ;; EXPECT fu::view\n                !!(h.mask & (HM_Function | HM_Struct));     //////////////////\n\n            return Helpers(0).isFnOrType.i32;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<3, fu::str> { "\n        pub fn ref(dest, item: $T, extras) {\n            for (mut i = 0; i < dest.len; i++) {\n                if (dest[i] >= item) {\n                    if (dest[i] != item) {\n                        dest.insert(i, item);\n                        extras.insert(i, []);\n                    }\n                    return extras[i];\n                }\n            }\n\n            dest.push(item);\n            extras.push([]);\n            return extras[extras.len - 1];\n        }\n    "_fu, "\n        fn Map(lax k: $K, lax v: $V) struct {\n            keys: $K[];\n            vals: $V[];\n        };\n\n        fn ref(using ref _, key)\n            _0::ref(\n                || keys, key,\n                || vals);\n    "_fu, "\n        fn main() {\n            mut _map: _1::Map(string, string);\n\n            fn upsert(k: string, v: string) _map._1::ref(k) = v;\n            upsert(\"hello\", \"world\");\n\n            // Relaxer failed here while I was trying to get rid of F_REFs from specTypes.\n            fn check(k: string) _map._1::ref(k) == \"world\" ? 0 : 1;\n            return check(\"hello\");\n        }\n    "_fu } }, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn useless_ref_lambda(ref sources: string[]) {\n            fn src = sources[sources.len / 2]; // didn't relax the ref, failed bck\n            return src[1 : src.len] ~ src[0 : 1];\n        }\n        fn main() {\n            mut sources = [ \"ab\" ];\n            return useless_ref_lambda(sources) == \"ba\" ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Node { items: Node[] };\n\n        pure fn rec_useless_ref_simple(ref n: Node, offset: i32)\n            offset < n.items.len\n                ? rec_useless_ref_simple(:n, offset + 1)\n                : offset;\n\n        fn main() {\n            mut n = Node([ Node(), Node() ]);\n            return rec_useless_ref_simple(:n, 0) - 2;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Node { items: Node[]; };\n\n        pure fn rec_useless_ref(ref n: Node) {\n            mut ret = n.items.len;\n            for (mut i = 0; i < n.items.len; i++)\n                ret += rec_useless_ref(n.items[i]);\n\n            return ret;\n        }\n\n        fn main() {\n            mut tree = Node([ Node(), Node() ]);\n            return rec_useless_ref(tree) - 2;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Node { items: Node[]; };\n\n        fn mrec_useless_ref_A(ref n: Node) {\n            mut ret = n.items.len;\n            for (mut i = 0; i < n.items.len; i++)\n                ret += i & 1\n                    ?      mrec_useless_ref_A(n.items[i])\n                    : 50 * mrec_useless_ref_B(n.items[i]);\n\n            return ret;\n        }\n\n        pure fn mrec_useless_ref_B(ref n: Node) {\n            mut ret = n.items.len;\n            for (mut i = 0; i < n.items.len; i++)\n                ret += i & 1\n                    ? 10 * mrec_useless_ref_A(n.items[i])\n                    :      mrec_useless_ref_B(n.items[i]);\n\n            return ret;\n        }\n\n        fn main() {\n            mut tree = Node([ Node([ Node, Node ]), Node([ Node ]) ]);\n            return mrec_useless_ref_A(tree) - 103;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn last(s: $T[])\n            s.len ? s[s.len - 1] : throw(\"len == 0\");\n\n        struct Node { kind: string; items: Node[] }\n\n        pure fn check(ref node: Node)\n            node.kind != \"block\" ||\n            node.items.last.kind == \"return\";\n\n        fn main() {\n            mut node: Node;\n            return node.check ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn relaxes_arr_to_slice_and_fails(ref arr) {\n            arr.pop();\n            return arr;\n        }\n\n        fn main() {\n            mut arr = [ 1 ];\n            relaxes_arr_to_slice_and_fails(arr);\n            return arr.len;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        type Context = string[];\n\n        fn compile_snippets(sources: string[], fnames?: string[]): Context {\n            return sources ~ fnames;\n        }\n\n        fn ZERO(implicit ref output: string, mut sources: string[]): Context {\n            for (mut i = 0; i < sources.len; i++) {\n                ref src = sources[i];\n                let idx = src.find('X');\n                if (idx >= 0) {\n                    let moduleA = src.slice(0, idx);\n                    let moduleB = src[idx : idx] ~ src[idx + 1 : src.len];\n                    let without = src[0 : idx] ~ src[idx + 1 : src.len];\n\n                    sources[i]  = without;\n                    ZERO(:sources);\n\n                    sources[i]  = moduleA;\n                    sources.insert(i + 1, moduleB);\n                    i--;\n                }\n            }\n\n            let ctx = compile_snippets(:sources);\n            output ~= sources.join(',') ~ \";\";\n            return ctx;\n        }\n\n        fn ZERO(src: string) ZERO(sources: [ src ]);\n\n        fn main() {\n            implicit mut output: string;\n            ZERO(\"aXbXc\");\n            return output == \"abc;ab,c;a,bc;a,b,c;\" ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn ZERO(mut sources: string[], implicit ref output: string) {\n            for (mut i = 0; i < sources.len; i++) {\n                ref src = sources[i];\n                mut idx = 0;\n                while ((idx = src.find(\"X\")) > 0) {\n                    let sources1 = sources[0 : i]\n                        ~ src.slice(0, idx)\n                        ~ src.slice(idx + 1, src.len)\n                        ~ sources[i + 1 : sources.len];\n\n                    ZERO(sources1);\n                    src = src[0 : idx] ~ src[idx + 1 : src.len];\n                }\n            }\n\n            output ~= sources.join(\",\") ~ \";\";\n        }\n\n        fn ZERO(src: string) {\n            return ZERO([ src ]);\n        }\n\n        fn main() {\n            implicit mut output: string;\n            ZERO(\"aXbXc\");\n            return output == \"a,b,c;a,bc;ab,c;abc;\" ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(str: [byte]) {\n            mut res = 1;\n            str.split('/'): |piece| res *= piece.len;\n            return res;\n        }\n\n        fn main() {\n            let res = test(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb/cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\");\n            if (mem::ALLOC_STAT_COUNT() != 0) return 101;\n            return res == 196608 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        fn test(str: string) {\n            mut res = 1;\n            str.split('/'): |piece| res *= piece.len;\n            return res;\n        }\n\n        fn main() {\n            let res = test(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb/cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\");\n            if (mem::ALLOC_STAT_COUNT() != 0) return 101;\n            return res == 196608 ? 0 : 1;\n        }\n    "_fu, "BUG incorrect exit code"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        novec fn doesnt_copy_arg(arg: string, suffix: byte) <alt>\n            arg     && arg ~ suffix;                        <alt/>\n            arg      ? arg ~ suffix : \"\";                   <alt/>\n            arg.len && arg ~ suffix;                        <alt/>\n            arg.len  ? arg ~ suffix : \"\";                   <alt/>\n            !!arg   && arg ~ suffix;                        <alt/>\n            !!arg    ? arg ~ suffix : \"\";                   </alt>\n\n        fn main() {\n            mut share = \"01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH\";\n            mut a = doesnt_copy_arg(share, '!');\n            mut b = doesnt_copy_arg(share, '?');\n            mut c = doesnt_copy_arg(\"\", '.');\n            return a.len == b.len && a.len == 49 && c.len == 0 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn loop(ref cond, body)     <alt>\n            while (cond) body();    <alt/>\n            do body();\n            while (cond);           </alt>\n\n        novec fn doesnt_copy_arg(ref nums: i32[]) {\n            loop(nums): || {\n                mut sum = 0;\n                for (mut i = 0; i < nums.len; i++)\n                    sum += nums[i]++;\n                if (sum >= 10)\n                    return sum;\n            }\n            return 0;\n        }\n\n        fn main() {\n            mut nums: i32[];\n            mut a = doesnt_copy_arg(nums);\n            nums ~= 1;\n            mut b = doesnt_copy_arg(nums);\n            nums ~= 2;\n            mut c = doesnt_copy_arg(nums);\n            return a == 0 && b == 10 && c == 13 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn grow_if_oob !T(ref a: T[], i: i32) {\n            if (a.len <= i) a.grow(i + 1);\n            return a[i];\n        }\n\n        struct Target { modid: i32; index: i32 }\n        struct Scope { overloads: Overload[]; extended: Extended[] };\n        struct Overload { modid: i32 };\n        struct Extended { min: i32; locals: Overload[] };\n\n        fn create(ref scope: Scope, modid: i32): Target {\n            ref overloads = modid\n                ? scope.extended.grow_if_oob(modid).locals\n                : scope.overloads;\n\n            let target = Target(:modid, index: overloads.len + 1);\n            overloads.push(Overload(:modid));\n            return target;\n        }\n\n        fn main() {\n            mut scope: Scope;\n            scope.create(0);\n            scope.create(1);\n            return scope.overloads.len == 1\n                && scope.extended .len == 2 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        using flags TPFlags { ArgSpec; Typename; NeedsConsumed };\n\n        struct TP { flags: TPFlags };\n\n        fn doTrySpec(ref typeParams: TP[]) {\n            fn useConsumedType(tp<alt>: TP</alt>)\n                tp.flags & (ArgSpec | Typename) == ArgSpec;\n\n            typeParams.each: |ref tp|\n                if (tp.useConsumedType)\n                    tp.flags |= NeedsConsumed;\n        }\n\n        fn main() {\n            mut typeParams: TP[] = [\n                [ ArgSpec ],\n                [ ArgSpec | Typename ],\n                [ Typename ],\n            ];\n\n            doTrySpec(typeParams);\n\n            mut count = 0;\n            typeParams.each: |tp|\n                if (tp.flags & NeedsConsumed)\n                    count++;\n\n            return count - 1;\n        }\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        struct Empty {};\n\n        fn main() {\n            mut e = [ Empty(), Empty() ];\n            fn GET(idx: i32) e.len > idx && e[idx];\n            return GET(0) == GET(1) ? 0 : 1;\n        }\n    "_fu, "BUG invalid c++ void[] 5:17+1"_fu, testdiffs);
    TODO_bvxMZmIw("\n        struct Module { modid: i32 };\n        struct Ephemeral { <alt>broke_when_zst?: i32</alt> };\n        struct SolverState { _ephemeral: Ephemeral[] };\n        struct Target { modid: i32; globid: i32 };\n\n        fn test(implicit ref module: Module, using ref ss: SolverState, target: Target): Ephemeral {\n    <alt>\n            fn EPH(shadow target: Target)\n                return target.modid == module.modid\n                    && _ephemeral[target.globid];\n\n            return EPH(target);\n    <alt/>\n            using fn EPH(shadow target: Target)\n                return target.modid == module.modid\n                    && _ephemeral[target.globid];\n\n            return target;\n    </alt>\n        }\n\n        fn main() {\n            implicit mut module = Module(1);\n            mut ss = SolverState([ Ephemeral(), Ephemeral(), Ephemeral() ]);\n            return test(ss, Target(modid: 1, globid: 2)) == [] ? 0 : 1;\n        }\n    "_fu, "BUG invalid c++ void[] 19:17+2"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        fn Map(type K, type V) struct {\n            keys: K[];\n            vals: V[];\n        };\n\n        fn ref !<K, V>(using ref _: Map(K, V), key: K) {\n            for (mut i = 0; i < keys.len; i++)\n                if (keys[i] == key)\n                    return vals[i];\n\n            keys.push(key);\n            vals.push([]);\n            return vals[vals.len - 1];\n        }\n\n        struct Type { using vtype: i32 };\n\n        fn find_if_odd(ref map: Map(i32, Type), key: i32)\n            key & 1\n                ? map.ref(key)\n                : key & 2 && throw(\"never\");\n\n        fn main() {\n            mut map: Map(i32, Type);\n            map.keys ~= 1;\n            map.vals ~= Type(2);\n            return find_if_odd(map, 1) - 2;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        lax                         <alt>\n        inline      ;; PointlessLocal   <alt/>\n        noinline    ;; ConstCast        </alt>\n        fn longer(                  <alt>\n            l: string, r: string,       <alt/>\n            l: $T[:], r: $T[:],         </alt>\n            pick!)\n        {\n            let longer = {                                      ;; GNUStmtExpr\n                :PICK {\n                    for (;;) {\n                        if (l.len > r.len)\n                            break :PICK l;                      ;; Goto\n\n                        break :PICK r;\n                    }\n                }\n            };\n\n            return pick(longer);\n        }\n\n        fn main() {\n            longer(\"does\", \"nothing\",\n                pick: |_| { break; });\n\n            let longer = longer(\"Hello\", \" World!\",\n                pick: |longer| { break longer; });\n\n            return longer.len - 7;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        noinline fn longer(             <fail cannot move from a slice 15:26+1>\n            l: byte[:], r: byte[:])     <pass/>\n            l: $T[:],   r: $T[:])       </fail>\n        {\n            return l.len > r.len ? l : r;\n        }\n\n        <split/>\n        noinline fn strsqr(mut str: string, n: i32) {\n            for (mut i = 1; i < n; i++) str ~= str;\n            return str;\n        }\n\n        noinline fn mightConstCast() {\n            return longer(\n                \"A---A\".strsqr(4),\n                \"B-BB-B\".strsqr(4));                            ;; ConstCast\n        }\n\n        fn main() {\n            let longer = mightConstCast();\n            shadow let longer = longer ~ longer;\n            return longer.split(\"BB\").len == 32 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Target   { index: i32 }\n        struct Lifetime { uni0n!: byte[] };\n        type Type = Lifetime;\n\n        fn is_ref(type: Type) = !!type;\n\n        fn Lifetime_process(lifetime: Lifetime, each) {\n            fn visit(shadow lifetime) {\n                do {\n                    fn continue_climb(mut parent: Lifetime) {\n                        visit(parent);\n                        continue;\n                    }\n\n                    each(lifetime, fn continue_climb);\n                }\n                while (false);\n            }\n\n            return visit(lifetime);\n        }\n\n        fn main() {\n            fn Lifetime_climbType(lax lifetime: Lifetime) return [];\n\n            mut count = 0;\n            Lifetime_process([], each: |lifetime, continue_climb| {\n                count++;\n\n                let init = lifetime.Lifetime_climbType;\n                if (init.is_ref)\n                    continue_climb(init);\n            });\n\n            return count - 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        using flags Flags { A; B }\n\n        fn parseExoticDecl(shadow mut flags: Flags) {\n            if (flags) {\n                fn add(flag) flags |= flag;\n                return add(B);\n            }\n\n            return flags;\n        }\n\n        fn main() = parseExoticDecl(A).i32 - 3;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Node { items: string };\n\n        pub fn solve(using ref _current_fn: Node, root) {\n            fn solveNode(node) {\n                if (_current_fn) {\n                    fn outItems(back) items[items.len - back];\n                    _current_fn.items ~= \"! \";\n                    return outItems(2);\n                }\n\n                _current_fn.items ~= node.items;\n                return [];\n            }\n\n            return solveNode(root);\n        }\n\n        fn main() {\n            mut n = Node(\"hello\");\n            return solve(n, n).i32 - '!'.i32;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Node { items: string };\n\n        pure fn closure_of_explicit_ref_cant_relax(ref n) {\n            fn solveNode(ref items) {\n                fn outItems(back) items[items.len - back];\n                if (n) return outItems(1);\n                return [];\n            }\n\n            return solveNode(n.items);\n        }\n\n        fn main() {\n            mut n = Node(\"hello\");\n            return closure_of_explicit_ref_cant_relax(n).i32 - 'o'.i32;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Node { items: string };\n\n        pure fn injected_args_ignore_relaxed_types(using ref n) {\n            fn solveNode(lax _) {\n                fn outItems(back) items[items.len - back];\n                if (n) return outItems(1);\n                return [];\n            }\n\n            return solveNode(0);\n        }\n\n        fn main() {\n            mut n = Node(\"hello\");\n            return injected_args_ignore_relaxed_types(n).i32 - 'o'.i32;\n        }\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        struct SolvedNode { value: string; items?: SolvedNode[] };\n\n        noinline fn blockTailHasLocals_but_blockTypeIsTemp(root: SolvedNode)\n        {\n            fn declareStruct(node: SolvedNode) {\n                mut def = \"\";\n                node.items.each: |item|\n                    def ~= item.value ~ cgCall(item);\n\n                return def;\n            }\n\n            fn cgCall(node: SolvedNode) {\n                mut item_src: string[] = [ \"\", \"\" ];\n                fn ooeWrap(src) src && [];\n                fn ARG(i) item_src[i];\n\n                let id = node.value;\n                if (id.len & 1)\n                    return ooeWrap((ARG(0)<alt> = \"\"</alt>) ~ \"\" ~ (ARG(1)<alt> = \"\"</alt>));\n                else if (!id)\n                    return \"\" ~ id;\n                else\n                    return [];\n            }\n\n            return declareStruct(root);\n        }\n\n        fn main() {\n            return blockTailHasLocals_but_blockTypeIsTemp(\n                SolvedNode(\"none of this does anything\")).len;\n        }\n    "_fu, "BUG block.tail not listed in block.type lifetime"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        fn no_fx() {\n            mut res = 0;\n            pragma clock(`\n                static int counter;\n                `res`  = counter++;\n            `);\n            return res;\n        }\n\n        struct X { a: i32[]; b: i32[] };\n        fn test(x: X, ref y: i32[])\n            y ~= x.a;\n\n        fn main() {\n            mut x = X(\n                [ no_fx(), 2, 3, 4, 5, 6, 7, 8 ],\n                [ no_fx(), 3, 4, 5, 6, 7, 8, 9 ]);\n\n            test(x, x.a);\n            return x.a.len + no_fx * 1000 - 1016;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct A { a: X[] };\n        struct B { b: X[] };\n        struct C { c: X[] };\n        struct X { a: A[]; b: B[]; c?: C[]; };\n\n        fn GET(implicit ref x: X[], idx: int) {\n            return x[idx];\n        }\n\n        fn DUPE(implicit ref x: X[], idx: int) {\n            let src = GET(idx);                                 ;; GNUStmtExpr\n            let idx1 = x.len;\n\n            x.grow(idx1 + 1)\n            ref dest = x[idx1];\n            dest.a = src.a;\n            dest.b = src.b;\n        }\n\n        fn main() {\n            implicit mut x = [ X([ A(), A() ], [ B(), B(), B() ], [ C(), C(), C(), C(), C() ]) ];\n            DUPE(0);\n            mut sum = 0;\n            for (mut i = 0; i < x.len; i++) {\n                shadow let x = x[i];\n                sum *= x.a.len || 1; sum += x.a.len;\n                sum *= x.b.len || 1; sum += x.b.len;\n                sum *= x.c.len || 1; sum += x.c.len;\n            }\n            return sum - 309;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<3, fu::str> { "\n        noinline fn hello(x: i32) x;\n    "_fu, "\n        noinline fn hello(x: i32) x;\n    "_fu, "\n        fn main() 0._0::hello + 0._1::hello;\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<3, fu::str> { "\n        noinline fn hello(x) x;\n    "_fu, "\n        noinline fn hello(x) x;\n    "_fu, "\n        fn main() 0._0::hello + 0._1::hello;                    ;; DuplicateFunctions\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<3, fu::str> { "\n        noinline fn hello(x: i32) x;\n    "_fu, "\n        noinline fn hello(x) x;\n    "_fu, "\n        fn main() 0._0::hello + 0._1::hello;\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<3, fu::str> { "\n        fn Each(y<alt>: i32</alt>)\n            y & 1   ? y\n                    : y / 2 + Each(y / 2);\n    "_fu, "\n        fn Each(y<alt>: i32</alt>)\n            y & 1   ? y / 2\n                    : y / 2 + Each(y / 2);\n    "_fu, "\n        fn main() {\n            let a = _0::Each(100);\n            let b = _1::Each(8);\n\n            return a+b - 107;\n        }\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<3, fu::str> { "\n        fn find(keys: $T[], item: $T) {\n            for (mut i = 0; i < keys.len; i++) {\n                if (keys[i] >= item) {\n                    if (keys[i] != item)\n                        return -1;\n\n                    return i;\n                }\n            }\n\n            return -1;\n        }\n    "_fu, "\n        fn Set(_: $K) struct { keys: $K[]; };\n\n        fn has(using _, key)\n            _0::find(keys, key) >= 0;\n    "_fu, "\n        fn use_Set(a: string) {\n            mut set: _1::Set(string);\n            set.keys ~= a;\n            return set._1::has(a);\n        }\n\n        fn dont_use_Set(a: string, b: string) {\n            mut keys: string[];\n            keys ~= b;\n            keys ~= a;\n            return keys.find(a);\n        }\n\n        fn main() {\n            if (!use_Set(\"a\"))\n                return -1;\n\n            return dont_use_Set(\"a\", \"b\") - 1;\n        }\n    "_fu } }, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(tokens: i32[]) {\n            mut lidx = 0;\n            mut sum  = 0;\n\n            fn token(idx: i32, col!: i32)       = sum += idx * col;\n            fn token(idx: i32)                  = token(:idx, col: lidx - idx);\n\n            for (mut i = 0; i < tokens.len; i++)\n                token(tokens[i]);\n\n            return sum;\n        }\n\n        fn main() [ 1 ].test + 1;\n    "_fu, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        fn sum_each(a, b, Each)     a.Each + b.Each;\n\n        fn hello(x) {\n            if (x & 1) {\n                fn Each(y) y    ? y * Each(y - 1)\n                                : 100;\n\n                return sum_each(x, x, fn Each);\n            }\n            else {\n                fn Each(y) y    ? y * Each(y - 1)\n                                : 10000;\n\n                return sum_each(x, x, fn Each);\n            }\n        }\n    "_fu, "\n        fn Each(y) y & 1    ? y\n                            : y / 2 + Each(y / 2);\n\n        fn main() _0::hello(1) - 2 * Each(100)\n                + _0::hello(2) - 2 * Each(20000);\n    "_fu } }, PARZERO_queue);
    TODO_wUYWWjRs(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        fn sum_each(a, b)       // Same as above,\n            a.Each + b.Each;    //  but we don't explicitly pass the fn Each in.\n\n        fn hello(x) {\n            if (x & 1) {\n                fn Each(a) a    ? a * Each(a - 1)   // These get ignored?\n                                : 100;              //  sum_each goes and selects the one from _1.\n\n                return sum_each(x, x);\n            }\n            else {\n                fn Each(b) b    ? b * Each(b - 1)\n                                : 10000;\n\n                return sum_each(x, x);\n            }\n        }\n    "_fu, "\n        fn Each(c) c & 1    ? c\n                            : c / 2 + Each(c / 2);\n\n        fn main() _0::hello(1) - 2 * Each(100)\n                + _0::hello(2) - 2 * Each(20000);\n    "_fu } }, "BUG exit code"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        fn a        = \"aaa\";\n        fn shorter  = \"bb\";\n        fn greater  = \"aac\";\n\n        return a <> shorter == +1\n            && a <> greater == -1 ? 0 : 101;\n    "_fu, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        fn &(a, b) {\n            mut res = a;\n            for (fieldname i: typeof(a)) res.i &= b.i;\n            return res;\n        }\n\n        struct XY  { x: i32; y: i32 };\n        struct UVW { u: i32; v: i32; w: i32 };\n    "_fu, "\n        import _0;\n\n        fn main() {\n            mut xy  =  XY(1, 2)    &  XY(2, 3);\n            mut uvw = UVW(1, 2, 3) & UVW(2, 3, 4);\n            return xy.y - uvw.v;\n        }\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        struct Projection { x: i32; y: i32 };\n        fn Projection(a: i32, b: i32) = Projection(x: a*a, y: b*b);\n        fn Projection(c: i32, d: i32) = Projection(x: c+c, y: d+d);\n    "_fu, "\n        import _0;\n\n        fn main() {\n            let p0 = Projection(a: 3,  4);\n            let p1 = Projection(c: 20, 30);\n            return p0.x + p1.x - 49;\n        }\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<4, fu::str> { "\n        struct Woot { i: i32 };\n        fn sqr(v) = mul(v, v);\n    "_fu, "\n        import _0;\n        noinline fn mul(x: Woot, y: Woot) = x.i * y.i;\n        inline fn use_sqr(a: Woot) = sqr(a);\n    "_fu, "\n        import _0;\n        noinline fn mul(x: Woot, y: Woot) = 2 * x.i * y.i;\n        inline fn use_sqr(a: Woot) = sqr(a);\n    "_fu, "\n        fn main() {\n            let x = _0::Woot(2);\n            let a = _1::use_sqr(x);\n            let b = _2::use_sqr(x);\n            return a == 4 && b == 8 ? 0 : 1;\n        }\n    "_fu } }, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        pragma emit(`\n            void ccIncrX2(int& a, int b) {\n                a += b * 2;\n            }\n        `);\n\n        fn main() {\n            mut a = 0;\n            pragma emit(\"ccIncrX2(\", a, \", 5);\");\n            return a - 10;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        pragma emit(\"// needs newline\");\n        pragma emit(`\n            namespace {\n            }\n        `);\n        fn main() 0;\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        fn apply(num: i32, func: fn (i32): i32) = func(num);\n        fn main()                               = apply([1], |i| i - 1);\n    "_fu, "expected , got . 2:42+1"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        fn desc(a: i32, b: i32) b < a;\n\n        fn main() {\n            mut vals = [ 1, 2 ];\n            vals.sort(fn desc);\n            return vals[0] - 2;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            mut vals = [ 1, 2 ];\n            vals.sort(|a: i32, b: i32| b < a);\n            return vals[0] - 2;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            mut vals = [ 1, 2 ];\n            vals.sort(|a, b| b < a);\n            return vals[0] - 2;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(ref vals: i32[], xor: i32)\n            vals.sort(\n                |a: i32, b: i32|\n                    a^xor < b^xor);\n\n        fn main() {\n            mut vals = [ 1, 2 ];\n            vals.test(xor: 3); // xor:3 descs 1 and 2.\n            return vals[0] - 2;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            mut arr = [ 1, 2, 3, 4 ];\n\n            arr.par::each: |ref it| it *= 2;\n\n            mut sum = 0;\n            for (mut i = 0; i < arr.len; i++)\n                sum += arr[i];\n\n            return sum - 2 - 4 - 6 - 8;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn seq__each(ref a: [$T], fn)\n            for (mut i = 0; i < a.len; i++)\n                fn(a[i]);\n\n        fn main() {\n            mut arr = [ 1, 2, 3, 4 ];\n            mut sum = 0;\n\n            <fail purectx writes to implicit sum>\n            arr.par::each: |ref it| <pass/>\n            arr.seq__each: |ref it| </fail>\n                sum += it *= 2;                                 ;; PointlessMustSeq\n\n            return sum - 2 - 4 - 6 - 8;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn seq__each(ref a: [$T], fn)\n            for (mut i = 0; i < a.len; i++)\n                fn(a[i]);\n\n        fn main() {\n            mut arr = [ 1, 2, 3, 4 ];\n\n            <fail noflow non local control flow>\n            arr.par::each: |ref it| <pass/>\n            arr.seq__each: |ref it| </fail>\n                if ((it *= 2) > 4)\n                    break;\n\n            mut sum = 0;\n            for (mut i = 0; i < arr.len; i++)\n                sum += arr[i];\n\n            return sum - 2 - 4 - 6 - 4/*unchanged after break*/;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(ref arr: i32[])\n            arr.par::each: |ref v, i| v += i;\n\n        fn main() {\n            let N = 1087 * 1091;\n\n            mut orig: i32[];\n            orig.resize(N);\n\n            mut arr = orig;\n            arr.test();\n\n            if (arr.len != N || arr.len != orig.len)\n                return 1;\n\n            for (mut i = 0; i < N; i++)\n                if (orig[i] != 0)\n                    return 2;\n\n            for (mut i = 0; i < N; i++)\n                if (arr[i] != i)\n                    return 3;\n\n            return 0;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            let i: i8 = 0;\n            <fail return type annot>\n            return i;        <pass/>\n            return i.i32;    </fail>\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        primitive s32: i32;\n\n        fn main() {\n            let i: s32 = 0;\n            <fail return type annot>\n            return i;        <pass/>\n            return i.i32;    </fail>\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        enum Enum { None = 0 };\n\n        fn main() {\n            let e = Enum.None;\n            <fail return type annot>\n            return e;        <pass/>\n            return e.i32;    </fail>\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        using enum Test { A = 5; B; C };\n        fn main()\n            <fail - bad call>\n            C - 7;      <pass/>\n            C.i32 - 7;  </fail>\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        using\n        <alt>\n        primitive <alt/>\n        enum      </alt> Test: i32 { A1; A2; M5 = 5; A6 };\n\n        fn main()\n            A1.i32 + A2.i32 * 10 + M5.i32 * 100 + A6.i32 * 1000\n                == 6521 ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        using\n        <fail bad call to ->\n        enum         <pass/>\n        primitive    </fail> Test: i32 { A; B };\n        fn main() (B - A).i32 - 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        enum EnumA: i32;\n        enum EnumB: EnumA { Zero = 0 };\n        fn main() EnumB.Zero.i32;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        primitive PrimA: i32;\n        using primitive PrimB: PrimA { Zero = 0; One };\n        fn main() (One - 1).i32;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        primitive PrimA: i32;\n        primitive PrimB: PrimA { Zero = 0; One };\n\n    <alt>\n        fn and_decr(ref prim: PrimB)\n            prim &&= prim - 1;\n    <alt/>\n        fn and_decr(ref prim: PrimB)\n        {\n            mut res = prim - 1;\n            prim &&= res;\n            return prim;\n        }\n    </alt>\n\n        fn main() {\n            mut r = PrimB.One;\n            return r.and_decr.i32;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        enum Hey { foo; };\n        fn test(hey: Hey) hey.i32;\n        fn main() test(\"foo\") - 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        using enum Greet { hello; world };\n        fn main()\n            hello ~ \" \" ~ world == \"hello world\"                ;; DuplicateFunctions\n                ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        enum Greet { hello; world };\n        fn woot(hi: Greet) hi == \"hello\";\n        fn main() Greet.hello.woot ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        using enum Greet { hello; world };\n        fn h() Greet.hello;\n        fn w() Greet.world;\n    "_fu, "\n        fn main()\n            _0::h() ~ \" \" ~ _0::w() == \"hello world\"            ;; DuplicateFunctions\n                ? 0 : 1;\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        using enum _0 { A; B };\n    "_fu, "\n        fn test(::_0) _0.i32;\n        fn main() \"A\".test - _0::A.i32;\n    "_fu } }, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        enum _0 { A; B };\n    "_fu, "\n        fn test(x: ::_0 = \"B\") x.i32;\n        fn main() test - ::_0.B.i32;\n    "_fu } }, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        enum Enum { A = 0; B };\n        fn inner(x: Enum) x.i32;\n        fn outer(x: i32) inner(x & 1 ? \"B\" : \"A\");\n        fn main() outer(0);\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        enum Test { A; B = A; C; };\n        fn main() Test.C.i32 - 1;\n    "_fu, "A is not defined here 2:28+1"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        using flags Flags { A; B; C; D };\n\n        fn main() {\n            mut flags = A | C;\n            return flags.i32 == 5 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        flags Flags: i32 { A; B };\n\n        fn main() {\n            mut hello = 5;\n            mut world = hello.Flags;\n            return world.i32 - 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        using flags Hey: u8 { A; B };\n        fn main() {\n            mut flags = A | B;\n            flags &= ~B;\n            return flags.i32 - 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        enum thing { i32; int; bool }\n\n        // So the problem is the retval annotation for fn ==(template): bool\n        //  fails to resolve as it conflicts with enumv from thing here.\n        //\n        // I'm not terribly sure what we want to do about it,\n        //  it's the ambiguity thing again - template sees the enum on expansion,\n        //   so it does kinda make sense for thing not to compile,\n        //    otherwise imagine the original bool goes away,\n        //     it'd fallback to the enumv here, which is exactly not what we want.\n        //\n        // Perhaps the scoping rules for templates don't make so much sense,\n        //  if we didn't make everything from local scope visible\n        //   they'll also compile faster.\n        //\n        fn isInt (k: thing) k == \"i32\" || k == \"int\";\n        fn isBool(k: thing) k == \"bool\";\n        fn main() isInt(\"i32\") && isBool(\"bool\") ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        enum ID: u64 {\n            // clang warned with -Wimplicitly-unsigned-literal\n            CustomIDs = 0x8000_0000_0000_0000;\n            BitmapFontAtlas;\n        };\n\n        fn main() {\n            mut id: u64 = ID.BitmapFontAtlas.u64;\n            // meawhile this outputted the underscores\n            return id == 0x8000_0000_0000_0001 ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        using enum ID: u32 {\n            SecondLast = 0xffff_fffe;\n            Last;\n            <fail exhaust range>\n            NoRoom; <pass/></fail>\n        };\n\n        fn main() {\n            return Last.u32 == 0xffff_ffff ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        enum ID: u64 {\n            SecondLast = 0xffff_ffff_ffff_fffe;\n            Last;\n            <fail exhaust range>\n            NoRoom; <pass/></fail>\n        };\n\n        fn main() {\n            return ID.Last.u64 == 0xffff_ffff_ffff_ffff ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_ELAwpNeF(fu::vec<fu::str> { fu::slate<2, fu::str> { "\n        enum ID { A = 1 };\n        using enum IDOffset { B = 10 };\n        fn offset(a: ID, b: IDOffset) = a.i32 + b.i32;\n    "_fu, "\n        fn main() = _0::ID.A.offset(\n            _0::<alt>B<alt/>IDOffset.B</alt>) - 11;\n    "_fu } }, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        enum ABC { A; B; C };\n\n        fn isAorB(x: ABC)\n            x == \"A\" ||     <fail 6:15+2 incompatible types for T>\n            x == \"b\";       <pass/>\n            x == \"B\";       </fail>\n\n        fn main() isAorB(\"A\") && isAorB(\"B\") && !isAorB(\"C\") ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        <alt>\n        using </alt>\n        enum Hello { str; b };\n\n        <split/>\n        fn main() {\n            mut out = \"str\";\n            return (out ~ \"b\").len - 4;\n        };\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        enum world { world; };\n        fn type_vs_value(type X) = \"NO!\";\n        fn type_vs_value(str: string) = str ~ \"!\";\n        fn hello(.type_vs_value) = \"Hello \" ~ type_vs_value;\n        fn main() = hello(\"world\") == \"Hello world!\" ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        enum world { world; };\n        fn world(str: string) = str ~ \"!\";\n        fn hello(.world) = \"Hello \" ~ world;\n        fn main() = hello(\"world\") == \"Hello world!\" ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        union union_ui {\n            i: i32;\n            u: u32;\n        }\n\n        fn main() {\n            mut ui = union_ui(i: -1);\n            return (ui.u - 0xffffffff).i32;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn does_throw(mut x: i32) {\n            if (x & 1)          return x;\n            mut str = \"\";\n            while (x--)         str ~= x;\n            throw(str);\n        }\n\n        nothrow fn does_catch(mut y: i32) {\n            try                 return does_throw(y);\n            catch (e)           return e.len;\n        }\n\n        <fail does_throw throws>\n        nothrow <pass/></fail>\n        fn doesnt_catch(mut z: i32) {\n            if (z & 2)          return does_throw(z);\n            else                return does_catch(z);\n        }\n\n        fn main() = doesnt_catch(1) - 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn has_fx() {\n            mut res = 0;\n            pragma output(`\n                static int counter;\n                `res`  = counter++;\n            `);\n            return res;\n        }\n\n        fn not_dead_mutually_rec_a(x: i32) {\n            if (x > 0) {\n                not_dead_mutually_rec_b(x - 1);\n                has_fx();\n            }\n        }\n\n        fn not_dead_mutually_rec_b(x: i32) {\n            if (x > 0) {\n                not_dead_mutually_rec_a(x - 1);\n                has_fx();\n            }\n        }\n\n        fn main() {\n            <alt>\n            not_dead_mutually_rec_a(2); <alt/>\n            not_dead_mutually_rec_b(2); </alt>\n            return has_fx() - 2;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn no_fx() {\n            mut res = 0;\n            pragma clock(`\n                static int counter;\n                `res`  = counter++;\n            `);\n            return res;\n        }\n\n        fn test(lax x: i32) {\n            x & 1 && no_fx();\n            x & 2 || no_fx();\n            if (!no_fx) no_fx(); else no_fx();\n            for (mut i = 1; i--> 0; no_fx()) no_fx();\n\n            // the idea is that everything above should go,\n            //  and just this one call to no_fx will remain.\n            return no_fx();\n        }\n\n        fn main() = test(1);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn lex(src: string) {\n            mut idx = 0;\n            let end = src.len;\n            while (idx < end) {\n                let c = src[idx++]; // bug in discard(if) unused this var\n                if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z' || c == '_' || c >= '0' && c <= '9') {\n                    //\n                }\n                else {\n                    idx--;\n                    break;\n                }\n            }\n            return idx;\n        }\n\n        fn main() = \"hello!\".lex - 5;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let se_global_false = false;\n        <split/>\n        fn main() {\n            if (se_global_false) return THIS_DOESNT_EXIST();\n            return 0;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let se_global_true = true;\n        <split/>\n        fn main() {\n            if (!se_global_true) return THIS_DOESNT_EXIST();\n            return 0;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        let se_global_let_from_closure = false;\n        <split/>\n        fn main() {\n            fn test() {\n                if (se_global_let_from_closure) return THIS_DOESNT_EXIST();\n                return 0;\n            }\n            return test();\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            <fail not defined 5:55+1>\n            mut <pass/>\n            let </fail> se_local_let = false;\n            if (se_local_let) return THIS_DOESNT_EXIST();\n            return 0;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        // 'v' got mistagged as VFacts.AlwaysFalse\n        struct Hello { v?: bool; }\n        fn main() = Hello(true).v ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        // 'v' got mistagged as VFacts.AlwaysFalse\n        struct Hello { v?: bool; }\n\n        fn main() {\n            let yes = Hello(true);\n            let no  = Hello(false);\n\n            let expect_true = yes.v;\n            let expect_false = no.v;\n\n            if (!expect_true) return 20;\n            if (expect_false) return 10;\n            return 0;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn main() {\n            <fail not defined 6:61+1>\n            mut <pass/>\n            let </fail> se_closure_let = false;\n            fn test() {\n                if (se_closure_let) return THIS_DOESNT_EXIST();\n                return 0;\n            }\n            return test();\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test(x: i32) {\n            let val =                                       <alt>\n                x & 1 ? { return 0 } : { return 1 };        <alt/>\n                x & 1 && { return 0 } || { return 1 };      <alt/>\n                (x & 1 || { return 1 }) && { return 0 };    </alt>\n\n            return UNREACHABLE(val);\n        }\n\n        fn main() test(1);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        noinline fn alwaysFalse() false;\n        fn main() alwaysFalse.i32;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn typeParamsMusntPickUpVFacts(x: i32) {\n            let y = x || throw(\"x == 0\"); // Now y is always true.\n            if (y & 1) // & 1 is not always true though.\n                return y * 10;\n            else\n                return y * 100;\n        }\n\n        fn main() typeParamsMusntPickUpVFacts(3)\n                + typeParamsMusntPickUpVFacts(2) == 230 ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn test() <fail return does not match annotation never 4:23+2>\n                : never <pass/></fail>\n                    = [];\n\n        fn main() {\n            mut x: i32 = test();\n            return x;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn checkPalindrome(host: string, guest: string)\n            return host == guest || throw(\":(\");\n\n        fn palindrome(value: string) {\n            mut rev = value;\n            rev.reverse();\n            <alt>\n            checkPalindrome(value, rev);\n            return rev;\n            <alt/>\n            return checkPalindrome(value, rev)\n                && rev;\n            </alt>\n        }\n\n        fn main() {\n            mut n = \"opera-arepo\";\n            return n.palindrome.len - 11;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Node         { value: string };\n        struct Target       { index: i32    };\n        struct SolvedNode   { value: string };\n\n        fn solve(n_root: Node)\n        {\n            fn solveNode(node: Node)\n                return CallerNode(node.value);\n\n            fn checkAssignable(host: string, guest: string)\n                return host == guest || throw(\":(\");\n\n            fn CallerNode(value: string) {\n                <alt>\n                checkAssignable(value, n_root.value);\n                return SolvedNode(:value);\n                <alt/>\n                return checkAssignable(value, n_root.value)\n                    && SolvedNode(:value);\n                </alt>\n            }\n\n            return solveNode(n_root);\n        }\n\n        fn main() {\n            mut n = Node(\"hello!\");\n            return n.solve.value.len - 6;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        struct Postdom { a: i32; b?: i32[] };\n\n        fn clear(ref p: Postdom)\n            for (fieldname i: Postdom)\n                if (typeof(p.i) -> i32[])\n                    p.i.clear();\n\n        fn main() {\n            mut a = Postdom(a: 3);\n            mut b = Postdom(a: 3, b: [ 1 ]);\n            if (a == b) return 1;\n            b.clear();\n            return a == b ? 0 : 1;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        novec fn build(ref a: string, b: string) {\n            let cmake       = false;\n            <alt>\n            let CMakeLists  = cmake && (a ~= b);\n            <alt/>\n            let OPAQUE      = a.len + b.len;\n            let CMakeLists  = cmake && OPAQUE && (a ~= b);\n            </alt>\n            if (CMakeLists) DOESNT_EXIST();\n            return CMakeLists;\n        }\n\n        fn main() {\n            mut a = \"hello, \";\n            let b = \"world!\";\n            return build(a, b).len;\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn doesntSkipIfWithTrailingFalse(x: i32) {\n            if (x && false)\n                return DOESNT_EXIST;\n            else\n                return x;\n        }\n\n        fn main() = doesntSkipIfWithTrailingFalse(0);\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        noinline fn add(ref a: i32, ref b: i32) a + b;\n        fn main() = add(1, 2) - 3;\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        noinline fn add(ref a: i32, ref b: i32) a || b;\n        fn main() = add(1, 2) - 1;\n    "_fu, "Bad call to add 3:24+1 expects mutref"_fu, testdiffs);
    TODO_bvxMZmIw("\n        noinline fn at(ref a: i32[], i: i32) a[i];\n        fn main() = [ 1 ].at(0) - 1;\n    "_fu, "Bad call to at 3:29+1 expects mutref"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        fn PreIncr( <fail bad call ++ mutref 3:20+2><pass/>\n            ref     </fail>\n                x) ++x;\n\n        fn main() {\n            mut res = -1;\n            return PreIncr(res);\n        }\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn val_keyword(val a, val b) {\n            val c = a + b;\n            return c;\n        }\n\n        fn main() val_keyword(2, 3) - 5;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn val_keyword(const ref a, const ref b) {\n            const ref c = a || b;\n            return c;\n        }\n\n        fn main() val_keyword(2, 3) - 2;\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        <fail explicit_arg closure_arg both alias use val or ref 9:25+14>\n        fn foreach_modify(    explicit_arg: int[], foreach)     <pass/>\n        fn foreach_modify(ref explicit_arg: int[], foreach)     </fail>\n            for (mut i = explicit_arg.len; i --> 0; )\n                foreach(explicit_arg[i], i?: i);\n\n        fn main() {\n            mut closure_arg = [ 2 ];\n            closure_arg.foreach_modify: |item, ref i| {\n                while (item > i) {\n                    closure_arg.insert(i, i);\n                    i++;\n                }\n            }\n\n            return closure_arg == [ 0, 1, 2 ] ? 0 : 1;\n        }\n    "_fu, "cannot resolve by temporary copy explicit_arg is ref 8:17+11"_fu, testdiffs);
    PARZERO_EiSsO8S1("\n        fn pretend_pure(mut res = 0) {\n            pragma emit(`\n                static int counter = 100;\n                `res` += counter++;\n            `);\n            return res;\n        }\n\n        fn validate_looks_pure() {\n            pretend_pure(1);\n            return pretend_pure(2);\n        }\n\n        fn main() validate_looks_pure() == 102 ? 0 : 1;\n    "_fu, PARZERO_queue);
    PARZERO_EiSsO8S1("\n        fn pretend_pure(mut res = 0) {\n            pragma emit(`\n                static int counter = 100;\n                `res` += counter++;\n            `);\n            return res;\n        }\n\n        fn licm_loop_preheader(n: i32) {\n            mut res = 0;\n            for (mut i = 0; i < n; i++)\n            on enter {\n                let must_hoist = pretend_pure(n);\n            }\n            then {\n                res += must_hoist;\n            }\n            return res;\n        }\n\n        fn main() licm_loop_preheader(2) == 204 ? 0 : 1;\n    "_fu, PARZERO_queue);
    TODO_bvxMZmIw("\n        fn pretend_pure(mut res = 0) {\n            pragma emit(`\n                static int counter = 100;\n                `res` += counter++;\n            `);\n            return res;\n        }\n\n        fn licm_hoist_var(n: i32) {\n            mut res = 0;\n            for (mut i = 0; i < n; i++) {\n                let must_hoist = pretend_pure(n);\n                res += must_hoist;\n            }\n            return res;\n        }\n\n        fn main() licm_hoist_var(2) == 204 ? 0 : 1;\n    "_fu, "BUG exit code"_fu, testdiffs);
}

#endif
