
pub struct BitSet
{
    _data: u8[];
};

pub fn size(using _: BitSet)
{
    return _data.len * 8;
}

pub fn add_once(using _: &mut BitSet, idx: i32): bool
{
    let no_neg = idx & 0x80000000.i32;
    let bucket = idx >> 3 | no_neg;
    let bit    = idx & 7;
    let mask   = 1 << bit.u8;

    ref entry = _data.helpers::grow_if_oob(bucket);
    if !(entry & mask)
    {
        entry |= mask;
        return true;
    }

    // Already there.
    return false;
}

pub fn add(using _: &mut BitSet, idx: i32)
{
    let no_neg = idx & 0x80000000.i32;
    let bucket = idx >> 3 | no_neg;
    let bit    = idx & 7;
    let mask   = 1 << bit.u8;

    _data.helpers::grow_if_oob(bucket) |= mask;
}

pub fn add(using _: &mut BitSet, other: BitSet)
{
    for (mut i1 = other._data.len; i1 --> 0; )
    {
        if (other._data[i1])
        {
            _data.helpers::grow_if_oob(i1);

            // TODO zip over in u64s first.
            for (mut i = 0; i <= i1; i++)
                _data[i] |= other._data[i];

            break;
        }
    }
}

pub fn has(using _: BitSet, idx: i32)
{
    let no_neg = idx & 0x80000000.i32;
    let bucket = idx >> 3 | no_neg;
    let bit    = idx & 7;
    let mask   = 1 << bit.u8;

    return _data.len > bucket
        && _data[bucket] & mask != 0;
}

pub fn rem(using _: &mut BitSet, idx: i32)
{
    let no_neg = idx & 0x80000000.i32;
    let bucket = idx >> 3 | no_neg;
    let bit    = idx & 7;
    let mask   = 1 << bit.u8;

    if (_data.len > bucket)
        _data[bucket] &= ~mask;
}

pub fn rem_once(using _: &mut BitSet, idx: i32)
{
    let no_neg = idx & 0x80000000.i32;
    let bucket = idx >> 3 | no_neg;
    let bit    = idx & 7;
    let mask   = 1 << bit.u8;

    if (_data.len > bucket && _data[bucket] & mask)
    {
        _data[bucket] &= ~mask;
        return true;
    }

    return false;
}

pub fn add_range(using _: &mut BitSet, end!: i32)
{
    let no_neg      =  end & 0x80000000.i32;

    let floorBytes  =  end      >> 3 | no_neg;
    let ceilBytes   = (end + 7) >> 3 | no_neg;

    _data.grow(ceilBytes);
    for (mut i = 0; i < floorBytes; i++)
        _data[i] = 0xff;

    if (ceilBytes > floorBytes)
    {
        mut tail: u8;

        mut i = floorBytes << 3;
        do  tail |= 1 << (i & 7).u8;
        while (i++ < end);

        _data[floorBytes] = tail;
    }
}

pub fn popcount(using _: BitSet)
{
    mut sum = 0;

    let N = _data.len >> 3;
    let u64s = _data[0, N << 3].view(u64);
    for (mut i = 0; i < u64s.len; i++)
        sum += bit::popcount(u64s[i]);

    mut tail: u64;
    for (mut i = N << 3; i < _data.len; i++) {
        tail <<= 8;
        tail |= _data[i].u64;
    }

    sum += bit::popcount(tail);
    return sum;
}

pub fn each(using _: BitSet, visit)
{
    for (mut i = 0; i < _data.len; i++)
    {
        let item = _data[i];
        if (item) for (mut b = 0; b < 8; b++)
        {
            let mask = 1 << b.u8;
            if (item & mask)
                visit(i << 3 | b.i32);
        }
    }
}
