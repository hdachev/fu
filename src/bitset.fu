
pub struct BitSet
{
    _data: u8[];
};

pub fn add_once(using _: &mut BitSet, idx: i32): bool
{
    let no_neg = idx < 0 ? -1 : 0;
    let bucket = idx / 8 | no_neg;
    let bit    = idx % 8;
    let mask   = 1 << bit.u8;

    ref entry = _data.helpers::grow_if_oob(bucket);
    if !(entry & mask)
    {
        entry |= mask;
        return true;
    }

    // Already there.
    return false;
}

pub fn add(using _: &mut BitSet, idx: i32)
{
    let no_neg = idx < 0 ? -1 : 0;
    let bucket = idx / 8 | no_neg;
    let bit    = idx % 8;
    let mask   = 1 << bit.u8;

    _data.helpers::grow_if_oob(bucket) |= mask;
}

pub fn add(using _: &mut BitSet, other: BitSet)
{
    for (mut i1 = other._data.len; i1 --> 0; )
    {
        if (other._data[i1])
        {
            _data.helpers::grow_if_oob(i1);

            // TODO zip over in u64s first.
            for (mut i = 0; i <= i1; i++)
                _data[i] |= other._data[i];

            break;
        }
    }
}

pub fn has(using _: BitSet, idx: i32)
{
    let no_neg = idx < 0 ? -1 : 0;
    let bucket = idx / 8 | no_neg;
    let bit    = idx % 8;
    let mask   = 1 << bit.u8;

    return _data.len > bucket
        && _data[bucket] & mask != 0;
}

pub fn rem(using _: &mut BitSet, idx: i32)
{
    let no_neg = idx < 0 ? -1 : 0;
    let bucket = idx / 8 | no_neg;
    if (_data.len > bucket)
    {
        let bit  = idx % 8;
        let mask = 1 << bit.u8;

        _data[bucket] &= ~mask;
    }
}

pub fn add_range(using _: &mut BitSet, start: i32, end: i32)
{
    // TODO FIX !!!!!!!!!!!!!!!!!!!!!
    for (mut i = start; i < end; i++)
        add(i);
}

pub fn popcount(using _: BitSet)
{
    mut sum = 0;

    let N = _data.len >> 3;
    let u64s = _data[0, N << 3].view(u64);
    for (mut i = 0; i < u64s.len; i++)
        sum += bit::popcount(u64s[i]);

    mut tail: u64;
    for (mut i = N << 3; i < _data.len; i++) {
        tail <<= 8;
        tail |= _data[i].u64;
    }

    sum += bit::popcount(tail);
    return sum;
}
