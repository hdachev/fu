import helpers;
import module;
import types;
import fail;

pub struct Flow
{
    // Any ref.
    parents:        i32[][];
    invalidates:    i32[][];        // Non-disjoint siblings and children.

    // Arguments at risk.
    arg_parents:    i32[][];        // is_arg targets each target refers to.
    at_soft_risk:   i32[][];        // ARG USES at risk from previous ARG WRITES.
    at_hard_risk:   i32[][];

    // AAR: helpers.
    is_arg:         bitset::BitSet; // acceleration structure.
    arg_targets:    i32[];          // argument targets at each position.

    // TODO FIX redundant
    // COW - direct children.
    children:       i32[][];
};

pub fn clear(ref flow: Flow)
    for (fieldname i: Flow)
        flow.i.clear();

pub fn Reference_trackArgument(ref flow: Flow, target: i32, position: i32)
{
    // Argument position -> target,
    //  this is only needed for collecting the outcomes at the end.
    flow.arg_targets.len <= position || BUG("Reference_trackArgument: positions out of order.");
    flow.arg_targets.grow(position + 1);
    flow.arg_targets[position] = target;

    // Speed up memberships checks.
    flow.is_arg.add(target);
}

pub fn Reference_trackLocalRef(ref flow: Flow, left: i32, right: Lifetime)
{
    // trackLocalRef during bck:
    //  defers lead to out-of-order bck,
    //   so this doesn't hold.
    //
    // If defers solved in the right order
    //  it'd be nice to run this back on,
    //   now we're running with scissors.
    //
    // flow.invalidates.len <= left || assert();

    mut parents: i32[];

    right.Lifetime_each: |shadow locid!right|
    {
        if !(right)
            continue;

        flow.children.grow_if_oob(right).set::add(left);

        //
        parents.set::add(right);
        parents.set::add(flow.parents.unless_oob(right));

        // For each lifetime on the right of the assignment,
        //  the invals are the stuff it kills on write.
        mut siblings = flow.invalidates.unless_oob(right);

        // LEFT can show up in the inval lists
        //  after we process the first lifetime.
        siblings.set::rem(left);

        // So, if:
        //  LEFT = &RIGHT;
        if (siblings)
        {
            // Siblings rule:
            //  LEFT invalidates everything RIGHT invalidates.
            //
            // Same thing backward:
            //  Everything that RIGHT invalidates potentially invalidates LEFT.
            //
            flow.invalidates .grow_if_oob(left).set::add(siblings);

            for (shadow mut i = 0; i < siblings.len; i++)
            {
                shadow let sibling = siblings[i];
                flow.invalidates .grow_if_oob(sibling).set::add(left);
            }
        }

        // Propagate alised arguments.
        if (flow.is_arg.has(right))
        {
            flow.is_arg.add(left);
            flow.arg_parents.grow_if_oob(left).set::add(right);
        }
    }

    if (parents)
    {
        // Parent rule, one-sided:
        //  Finally, RIGHT invalidates LEFT.
        for (mut i = 0; i < parents.len; i++)
            flow.invalidates.grow_if_oob(parents[i]).set::add(left);

        // This is the same as the parents set.
        flow.parents.grow_if_oob(left) = parents;
    }
}
