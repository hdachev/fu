import helpers;
import module;
import types;

pub struct Flow
{
    // Any ref.
    parents:        i32[][];
    invalidates:    i32[][];        // Non-disjoint siblings and children.

    // Arguments at risk.
    arg_parents:    i32[][];        // is_arg targets each target refers to.
    at_soft_risk:   i32[][];        // ARG USES at risk from previous ARG WRITES.
    at_hard_risk:   i32[][];

    // AAR: helpers.
    is_arg:         bitset::BitSet; // acceleration structure.
    arg_targets:    i32[];          // argument targets at each position.
    arg_positions:  i32[];          // arguments (position + 1) at each target.
};

pub fn Reference_trackArgument(ref flow: Flow, target: i32, position: i32)
{
    // Argument position -> target,
    //  this is only needed for collecting the outcomes at the end.
    flow.arg_targets.len <= position || assert();
    flow.arg_targets.grow(position + 1);
    flow.arg_targets[position] = target;

    flow.arg_positions.len <= target || assert();
    flow.arg_positions.grow(target + 1);
    flow.arg_positions[target] = position + 1;

    // Speed up memberships checks.
    flow.is_arg.add(target);
}

pub fn Reference_trackLocalRef(ref flow: Flow, left: i32, right: Lifetime)
{
    // trackLocalRef during bck:
    //  defers lead to out-of-order bck,
    //   so this doesn't hold.
    //
    // If defers solved in the right order
    //  it'd be nice to run this back on,
    //   now we're running with scissors.
    //
    // flow.invalidates.len <= left || assert();

    mut parents: i32[];

    for (mut i = 0; i < right.uni0n.len; i++)
    {
        shadow let right = Region_asLocal(right.uni0n[i]);
        if !(right)
            continue;

        //
        parents.set::add(right);
        parents.set::add(flow.parents.unless_oob(right));

        // For each lifetime on the right of the assignment,
        //  the invals are the stuff it kills on write.
        mut siblings = flow.invalidates.unless_oob(right);

        // LEFT can show up in the inval lists
        //  after we process the first lifetime.
        !siblings.set::rem(left) || i > 0 || assert();

        // So, if:
        //  LEFT = &RIGHT;
        if (siblings)
        {
            // Siblings rule:
            //  LEFT invalidates everything RIGHT invalidates.
            //
            // Same thing backward:
            //  Everything that RIGHT invalidates potentially invalidates LEFT.
            //
            flow.invalidates .grow_if_oob(left).set::add(siblings);

            for (shadow mut i = 0; i < siblings.len; i++)
            {
                shadow let sibling = siblings[i];

                // TODO failcase without the grow_if_oobs, suite doesn't catch it
                flow.invalidates .grow_if_oob(sibling).set::add(left);
            }
        }

        // Propagate alised arguments.
        if (flow.is_arg.has(right))
        {
            flow.is_arg.add(left);
            flow.arg_parents.grow_if_oob(left).set::add(right);
        }
    }

    if (parents)
    {
        // Parent rule, one-sided:
        //  Finally, RIGHT invalidates LEFT.
        for (mut i = 0; i < parents.len; i++)
            flow.invalidates.grow_if_oob(parents[i]).set::add(left);

        // This is the same as the parents set.
        flow.parents.grow_if_oob(left) = parents;
    }
}

pub fn Reference_untrackLocalRef(ref flow: Flow, left: i32, right: Lifetime)
{
    // Unlist parents.
    for (mut i = 0; i < right.uni0n.len; i++)
    {
        shadow let right = Region_asLocal(right.uni0n[i]);
        if (!right)
            continue;

        flow.invalidates[right].set::rem(left) || assert();
    }

    let invals = flow.invalidates.try_steal(left);

    // Unlist any surviving backrefs.
    for (mut i = 0; i < invals.len; i++)
    {
        let idx = flow.invalidates.unless_oob(invals[i]).find(left);
        if (idx >= 0)
            flow.invalidates[invals[i]].splice(idx, 1);
    }
}


//

pub fn ArgsAtRisk_list(
    ref out: bitset::BitSet,
        flow: Flow, position: i32, at_risk: i32[][])
{
    let target          = flow.arg_targets.unless_oob(position);
    let at_risk_from    = at_risk.unless_oob(target);

    for (mut i = 0; i < at_risk_from.len; i++)
    {
        let other           = at_risk_from[i];
        let other_position  = flow.arg_positions.unless_oob(other) - 1;
        if (other_position >= 0)
            out.add(other_position);
    }
}
