import helpers;
import module;
import fail;
import quals;
import canon;

let q_mutref            = Quals(1) << 0;
let q_rx_copy           = Quals(1) << 1;
let q_rx_resize         = Quals(1) << 2;

pub let q_TAGS          = q_mutref | q_rx_copy | q_rx_resize;
pub let q_USAGE         = ~q_TAGS;

let q_TAGS_bitsize      = 3;
pub let q_USAGE_bitsize = Quals_bitsize - q_TAGS_bitsize;

let q_non_compund       = Quals(1) << Quals(q_TAGS_bitsize);

let TAGS =
[
    "mutref",
    "copy",
    "resize",
];


//

pub let RELAX_before_bck    = q_mutref  | q_USAGE;
pub let RELAX_all           = q_TAGS    | q_USAGE;


// Lifetimes.

pub let Region_TEMP     = Region(_regpack: 0xfffff000);
pub let Region_STATIC   = Region(_regpack: 0x00000fff);

pub fn Region_isTemp(region: Region) {
    return region == Region_TEMP;
}

pub fn Region_isStatic(region: Region) {
    return region == Region_STATIC;
}

pub fn Region_isArgPosition(region: Region) {
    let id = region._regpack >> 12;
    return id >= 1000001 && id < 0xfffff;
}

pub fn Region_toArgPosition(region: Region) {
    let id = region._regpack >> 12;
    return (id - 1000001).i32;
}

pub fn Region_fromArgPosition(position: i32) {
    return Region(_regpack: (position.u32 + 1000001) << 12);
}

pub fn Region_asLocal(region: Region) {
    let id = region._regpack >> 12;
    return id < 1000001 && id.i32;
}

pub fn Region_fromLocal(index: i32) {
    return Region(_regpack: (index.u32 << 12));
}


//

pub let Lifetime_static =
    Lifetime(uni0n: [ Region_STATIC ]);

pub let Lifetime_temporary =
    Lifetime(uni0n: [ Region_TEMP ]);

pub fn Lifetime_union(a: Lifetime, b: Lifetime): Lifetime =
    Lifetime(uni0n: set::union(a.uni0n, b.uni0n));

pub fn Lifetime_inter(a: Lifetime, b: Lifetime): Lifetime =
    Lifetime(uni0n: set::inter(a.uni0n, b.uni0n));

pub fn Lifetime_diff(from: Lifetime, remove: Lifetime): Lifetime =
    Lifetime(uni0n: set::diff(from: from.uni0n, remove: remove.uni0n));

pub fn Lifetime_makeShared(lifetime: Lifetime): Lifetime =
    Lifetime_union(lifetime, Lifetime_static);


//

pub fn Lifetime_some(lifetime: Lifetime, some)
{
    Lifetime_each(:lifetime):
        |lax locid, lax argidx, lax isStatic, lax isTemp, lax isArgIdx|
    {
        if (some(locid?:    locid,    argidx?: argidx,
                 isStatic?: isStatic, isTemp?: isTemp,
                 isArgIdx?: isArgIdx))
        {
            return true;
        }
    }

    return false;
}

pub fn Lifetime_each(lifetime: Lifetime, each)
{
    for (mut i = lifetime.uni0n.len; i --> 0; )
    {
        let r = lifetime.uni0n[i];

        each(
            locid?:     Region_asLocal(r),
            argidx?:    Region_toArgPosition(r),

            isStatic?:  r == Region_STATIC,
            isTemp?:    r == Region_TEMP,
            isArgIdx?:  Region_isArgPosition(r));
    }
}

pub fn Lifetime_process(lifetime: Lifetime, each)
{
    mut result: Lifetime;

    lax mut dedupe: Region[];

    fn visit(shadow lifetime: Lifetime)
    {
        for (mut i = lifetime.uni0n.len; i --> 0; )
        {
            let r = lifetime.uni0n[i];

            :TEST
            {
                fn continue_climb(mut parent: Lifetime)
                {
                    // Init the deduper lazily,
                    //  we want this to compile away if noone uses it.
                    if (!dedupe)
                        dedupe = lifetime.uni0n;

                    parent.uni0n.set::rem(dedupe);

                    // Don't visit any of these again.
                    dedupe.set::add(parent.uni0n);

                    visit(parent);
                    continue;
                }

                fn continue_replace(replacement: Lifetime)
                {
                    result.uni0n.set::add(replacement.uni0n);
                    continue;
                }

                fn continue_keep()
                {
                    // Doing this in a convoluted way so that
                    //  you can inline this multiple times at no cost.
                    break :TEST;
                }

                each(continue_keep?: fn continue_keep,
                    continue_climb?: fn continue_climb,
                  continue_replace?: fn continue_replace,

                    // Same as above.
                    locid?:     Region_asLocal(r),
                    argidx?:    Region_toArgPosition(r),

                    isStatic?:  r == Region_STATIC,
                    isTemp?:    r == Region_TEMP,
                    isArgIdx?:  Region_isArgPosition(r));

                continue;
            }

            result.uni0n.set::add(r);
        }
    }

    visit(lifetime);

    return result;
}

pub fn Lifetime_if_only(lifetime: Lifetime, if_only)
{
    if (lifetime.uni0n.len != 1)
        return [];

    let r = lifetime.uni0n[0];

    return if_only(
        locid?:     Region_asLocal(r),
        argidx?:    Region_toArgPosition(r),

        isStatic?:  r == Region_STATIC,
        isTemp?:    r == Region_TEMP,
        isArgIdx?:  Region_isArgPosition(r));
}

pub fn hasTemporary(lifetime: Lifetime): bool
{
    return lifetime.uni0n.if_last == Region_TEMP;
}

pub fn hasStatic(lifetime: Lifetime): bool
{
    return lifetime.uni0n.if_first == Region_STATIC;
}

pub fn Lifetime_replace(ref lifetime: Lifetime,
    locid!: i32, with_argidx!: i32)
{
    if (!lifetime.uni0n.set::rem(Region_fromLocal(locid)))
        return false;

    lifetime.uni0n.set::add(Region_fromArgPosition(with_argidx))
        || BUG("Lifetime_replace(with_argidx): argidx was already present");

    return true;
}


//

fn Primitive(canon: string)
    Type(ValueType(:canon, quals: q_rx_copy | q_non_compund));

pub let t_i8        = Primitive("i8");
pub let t_i16       = Primitive("i16");
pub let t_i32       = Primitive("i32");
pub let t_i64       = Primitive("i64");
pub let t_i128      = Primitive("i128");

pub let t_u8        = Primitive("u8");
pub let t_u16       = Primitive("u16");
pub let t_u32       = Primitive("u32");
pub let t_u64       = Primitive("u64");
pub let t_u128      = Primitive("u128");

pub let t_f32       = Primitive("f32");
pub let t_f64       = Primitive("f64");

pub let t_bool      = Primitive("b8");
pub let t_byte      = Primitive("c8");


// The type required by if (...), while(...) and co,
//  trying to distinguish it from bools by making it non-copiable,
//   also using it for relax, which helps relax if (vec) into if (view).

pub let t_proposition   = Type(ValueType(quals: q_USAGE, canon: t_bool.canon));

pub fn propositionOK(type: Type) {
    return  !type.lifetime
        && (!type.vfacts || BUG("propositionOK seeing vfacts: " ~ type.vfacts))
        &&   type.canon == t_bool.canon;
}


// I think these should also be non-refereable?

fn NotSure(canon: string, quals?: Quals)
    Type(ValueType(:canon, :quals));

pub let t_void      = NotSure("void");
pub let t_never     = NotSure("never");
pub let t_zeroes    = NotSure("zeroes");

pub fn is_void  (t: Type) t.canon == t_void  .canon;
pub fn is_never (t: Type) t.canon == t_never .canon;
pub fn is_zeroes(t: Type) t.canon == t_zeroes.canon;


//

pub let t_AssumeNever_WhileSolvingRecursion =
    NotSure("never", q_rx_resize);

pub fn is_AssumeNever_WhileSolvingRecursion(t: Type) =
    t.canon == "never" && t.quals & q_rx_resize;


//

pub fn is_rx_copy   (t: Type) !!(t.quals & q_rx_copy);
pub fn is_rx_resize (t: Type) !!(t.quals & q_rx_resize);


//

fn areVFactsAssignable(host: VFacts, guest: VFacts)
{
    if (SELF_TEST)
    {
        let h = host  &~ Typename;
        let g = guest &~ Typename;
        if !(h & g == h)
            BUG("areVFactsAssignable: vfacts mismatch: " ~ host ~ " != " ~ guest);
    }

    return host & guest == host;
}

fn areQualsAssignable(host: Quals, guest: Quals)
    host & guest == host;

fn isLifetimeAssignable(host: Lifetime, guest: Lifetime)
    !host || !!guest; // TODO FIX this only checks if `!h.is_ref || !!g.is_ref`


//

pub let CANNOT_definit_mutrefs = true;

pub fn isAssignableAsArgument(host: Type, guest: Type, DONT_match_zeroes!?: bool): bool
{
    return areVFactsAssignable(host: host.vfacts, guest.vfacts)
        && ( areQualsAssignable(host: host.quals, guest.quals)
          &&  isCanonAssignable(host: host.canon, guest.canon)
          || !DONT_match_zeroes && guest.is_zeroes
                                && !(CANNOT_definit_mutrefs && host.quals & q_mutref)
                                && !host.is_never
           );
}

pub fn isAssignable(host: Type, guest: Type, DONT_match_zeroes!?: bool, asArgument!?: bool): bool
{
    return isAssignableAsArgument(:host, :guest, :DONT_match_zeroes)
        && (asArgument || isLifetimeAssignable(host.lifetime, guest.lifetime));
}


//

pub fn is_ref(type: Type): bool
{
    return !!type.lifetime;
}

pub fn is_mutref(type: Type): bool
{
    let is_mutref = !!(type.quals & q_mutref);

    if (SELF_TEST && is_mutref && !type.is_ref)
        BUG("is_mutref: Empty lifetime, but q_mutref set");

    return is_mutref;
}

pub fn add_ref(mut type: Type, lifetime: Lifetime): Type
{
    type.lifetime = Lifetime_union(type.lifetime, lifetime) || BUG("add_ref: Empty lifetime");
    return type;
}

pub fn add_mutref(mut type: Type, lifetime: Lifetime): Type
{
    type.quals |= q_mutref;
    type.lifetime = Lifetime_union(type.lifetime, lifetime) || BUG("add_mutref: Empty lifetime");
    return type;
}

pub fn ref_anonymize(ref type: Type)
{
    if (type.is_ref)
        type.lifetime = Lifetime_temporary;
}


//

pub fn clear_vfacts(mut type: Type): Type
{
    type.vfacts = [];
    return type;
}

pub fn clear_refs(mut type: Type): Type
{
    type.quals &= ~q_mutref;
    type.lifetime = Lifetime(); // <- discard lifetime
    return type;
}

pub fn clear_mutref(mut type: Type)
{
    type.quals &= ~q_mutref;
    return type;
}

pub fn definitType(mut type: Type)
{
    if (!type || type.is_never)
        type = t_zeroes;

    if (CANNOT_definit_mutrefs)
        type.quals &= ~q_mutref;

    if (type.is_ref)
        type.lifetime = Lifetime_static;

    if (SELF_TEST && type.is_never)
        BUG("Cannot definit type never.");

    type.vfacts = AlwaysFalse;
    return type;
}

fn tryClearRefs(type: Type, mutref?: bool): Type
{
    return (mutref ? type.is_mutref : type.is_ref)
        && clear_refs(type);
}

pub fn tryClear_mutref(type: Type)
{
    return tryClearRefs(:type, mutref: true);
}

pub fn tryClear_ref(type: Type)
{
    return tryClearRefs(:type);
}

pub fn add_refs(from: Type, mut to: Type)
{
    to.quals |= from.quals & q_mutref;
    to.lifetime = Lifetime_union(from.lifetime, to.lifetime);
    return to;
}

pub fn make_copyable(mut type: Type)
{
    type.quals |= q_rx_copy;
    return type;
}

pub fn make_non_copyable(mut type: Type)
{
    type.quals &= ~q_rx_copy;
    return type;
}


// Type serialization:
//  `modid` `+quals` `canon`: a very compact repr.

pub fn serializeType(type: Type, debug!: string)
{
    type || throw("COMPILER BUG: serializeType: Falsy type in: " ~ debug);

    mut prefix: string;

    if (type.quals)
        prefix.append09AV(type.quals.u32);

    return prefix ~ (type.canon || throw("COMPILER BUG: serializeType: No type.canon in: " ~ debug));
}

pub fn humanizeQuals(quals: Quals)
{
    mut result: string;
    for (mut i = 0; i < TAGS.len; i++)
        if (quals & (1 << Quals(i)))
            result ~= " " ~ TAGS[i];

    return result;
}

pub fn parseType(str: [byte]): ValueType
{
    mut offset: i32;

    let quals = parse09AV(offset, str).Quals;
    let canon = clone(str.slice(offset)); // TODO FIX SLICES the clone here

    return ValueType(:canon, :quals);
}


// Experimental -
//  Slices are refs to arrays,
//   with revoked copy & resize priviledges.

pub fn createSlice(item: Type, lifetime = Lifetime_temporary): Type
{
    mut out = createArray(item);
    out.quals &= ~(q_rx_copy | q_rx_resize);
    return add_ref(out, lifetime);
}

pub fn tryClear_sliceable(type: ValueType): Type
{
    if (!is_sliceable(type))
        return Type();

    let vtype = parseType(type.canon.slice(1, type.canon.len - 1));
    return Type(:vtype/*, :type.lifetime*/);
}

pub fn clear_sliceable(type: Type): Type
{
    return tryClear_sliceable(type)
        || BUG("Not sliceable: " ~ type.canon);
}


//

pub fn createArray(item: Type): Type
{
    let canon = "[" ~ serializeType(item, debug: "createArray") ~ "]";
    let quals = (item.quals & q_rx_copy) | q_rx_resize | q_non_compund;

    return Type(
        ValueType(:canon, :quals),
            :item.lifetime);
}

pub fn tryClear_array(type: Type): Type
{
    let q = q_rx_resize;
    if (type.quals & q_rx_resize != q_rx_resize)
        return Type();

    return tryClear_sliceable(type);
}

pub fn TODO_FIX_isArray(type: Type): bool
{
    // TODO FIX: isArray doesn't match the tryClear_array, which requires q_rx_resize
    //  this is only used in cg, which is post-relax so perhaps we should just move it over there,
    //   naming it impossibly right now to disambiguate
    return type.quals & (q_rx_resize | q_rx_copy)
        && type.is_sliceable();
}

pub let t_string = createArray(t_byte);


//

pub fn type_trySuper(a: Type, b: Type, DONT_match_zeroes!?: bool)
{
    let canon = canon_trySuper(a.canon, b.canon);
    if (!canon)
        return a.is_zeroes && !DONT_match_zeroes ? type_trySuper(definitType(b), b)
             : b.is_zeroes && !DONT_match_zeroes ? type_trySuper(definitType(a), a)
             : [];

    let quals   = a.quals  & b.quals;
    let vfacts  = a.vfacts & b.vfacts;

    let lifetime = a.lifetime && b.lifetime
                && Lifetime_union(a.lifetime, b.lifetime);

    return Type(
        ValueType(:canon, :quals),
        :lifetime, :vfacts);
}

pub fn type_tryIntersect(a: Type, b: Type)
{
    // Can't intersect with never or any -
    //  you can't use a value as `never` or `any`.
    let canon = canon_tryIntersect(a.canon, b.canon);
    if (!canon)
        return [];

    let quals   = a.quals  | b.quals;
    let vfacts  = a.vfacts | b.vfacts;

    // TODO FIX what is this, what's the principle here?
    //  I think we should just lose the lifetime
    //   which will convert us to a value, no?
    let lifetime = Lifetime_inter(a.lifetime, b.lifetime);

    if (!lifetime && (a.lifetime || b.lifetime))
        return [];

    //
    return Type(
        ValueType(:canon, :quals),
        :lifetime, :vfacts);
}


//

pub fn isAddrOfFn(type: Type): bool =
    type.canon.starts(with: '@');

pub fn packAddrOfFn(targets: Target[], modid: i32)
{
    mut res = "";
    for (mut i = 0; i < targets.len; i++)
    {
        res ~= '@';
        let target = targets[i];

        // TODO FIX we don't want this after we switch to absolute Targets.
        let locid = target.locid;
        shadow let modid = locid ? modid : target.modid;

        res.appendMi(:modid, :target.globid, :locid);
    }

    return res;
}

pub fn unpackAddrOfFn(canon: string, fn)
{
    mut offset = 0;
    while (offset < canon.len)
    {
        canon[offset++] == '@' || throw("unpackAddrOfFn: No leading @ in `" ~ canon ~ "`.");
        let mi = parseMi(offset, canon);
        fn(Target(:mi.modid, :mi.globid, :mi.locid));
    }
}


//

pub fn speculateStruct(asserts: flags::DeclAsserts, flatCount!: i32)
{
    return (!(asserts & flags::A_NOCOPY) && q_rx_copy)
         | (flatCount != -1 && q_non_compund);
}

pub fn despeculateStruct(mut type: Type)
{
    type.quals &= ~(q_rx_copy | q_USAGE);
    type.vfacts = [];

    // TODO FIX SPECPAT removing generic labels -
    //  currently we dump every struct's fields in field_items,
    //   which can accumulate fields for the same template struct
    //    BUT FROM DIFFERENT MODULES - which messes us up pretty badly
    //
    canon::trimPattern(type.canon);

    return type;
}



//

pub fn will_relax(ref type: Type, slot!: Type, relax_mask!: Quals): bool
{
    return (type.quals &~ slot.quals) & relax_mask != 0;
}

pub fn try_relax(ref type: Type, slot!: Type, relax_mask!: Quals): bool
{
    if (!will_relax(type, :slot, :relax_mask))
        return false;

    type.quals &= slot.quals | ~relax_mask;
    return true;
}

pub fn force_relax(ref type: Type, relax_mask!: Quals)
{
    type.quals &= ~relax_mask;
}

pub fn into_Typename(mut type: Type)
{
    type = clear_refs(type);
    type.vfacts = Typename;
    return type;
}

pub fn relax_typeParam(mut type: Type)
{
    return into_Typename(type);
}

pub fn clear_Typename(mut type: Type)
{
    type.vfacts &= ~Typename;
    return type;
}


//

pub inline fn usage(type: Type): Quals
{
    return type.quals & q_USAGE;
}

fn USAGE_shiftRight(quals: Quals, mut memberFlatOffset!offset: i32): Quals
{
    let keep    = quals & q_TAGS;
    mut usage   = quals & q_USAGE;

    while (offset >= q_USAGE_bitsize)
        offset -= q_USAGE_bitsize;

    usage = usage >>                    offset .Quals
          | usage << (q_USAGE_bitsize - offset).Quals;

    return keep | (usage & q_USAGE);
}

fn USAGE_shiftLeft(quals: Quals, mut memberFlatOffset!offset: i32): Quals
{
    let keep    = quals & q_TAGS;
    mut usage   = quals & q_USAGE;

    while (offset >= q_USAGE_bitsize)
        offset -= q_USAGE_bitsize;

    usage = usage <<                    offset .Quals
          | usage >> (q_USAGE_bitsize - offset).Quals;

    return keep | (usage & q_USAGE);
}

pub fn USAGE_structUsageFromFieldUsage(mut slot: Type, memberFlatOffset!: i32): Type
{
    slot.quals = USAGE_shiftLeft(:slot.quals, :memberFlatOffset);
    return slot;
}

pub fn USAGE_fieldUsageFromStructUsage(mut fieldType!slot: Type, structUsage: Quals, memberFlatOffset!: i32, memberFlatCount!: i32): Type
{
    slot.quals &= ~q_USAGE;
    slot.quals |=  structUsage;
    slot.quals  =  USAGE_shiftRight(:slot.quals, :memberFlatOffset);
    slot.quals &=  q_TAGS | getMaxUsage(memberFlatCount);

    return slot;
}

pub fn getMaxUsage(flatCount: i32)
{
    if (flatCount >= q_USAGE_bitsize)
        return q_USAGE;

    return Quals(q_USAGE >> (q_USAGE_bitsize - flatCount).u32) & q_USAGE;
}

pub fn USAGE_setMaxUsage(ref type: Type, flatCount: i32)
{
    type.quals = type.quals & q_TAGS | getMaxUsage(:flatCount);
}

pub fn isIrrelevant(type: Type)
{
    return !type.usage

        ////////////////////
        && !type.is_never // TODO should be workable without this
        ////////////////////
        //
        // Two things that currently fail:
        //
        //  (1) propagateType(block)
        //        if (h.ret_actual)
        //          if (canDiscard)
        //            h.ret_actual = t_void;    // <- discards nevers
        //          else
        //            h.ret_actual.try_relax(...)
        //
        //    > Ideally the if (canDiscard) should not be necessary,
        //       and we could only go for try_relax, which should always discard types.
        //
        //  (2) cpp codegen emits noreturn stmt expressions
        //        that infer void instead of fu::never.
}

pub fn USAGE_justOneThing(usage: Quals, flatCount!: i32)
{
    return flatCount <= q_USAGE_bitsize
        && usage.bit::popcount == 1;
}
