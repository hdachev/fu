import helpers;
import module;
import fail;
import quals;

let q_mutref            = 1 << 0;
pub let q_rx_copy       = 1 << 1;
let q_rx_resize         = 1 << 2;
let q_rx_move           = 1 << 3;

let TAGS =
[
    "mutref",
    "copy",
    "resize",
    "move",
];


//

pub let RELAX_before_bck    = q_mutref             | q_rx_resize            ;
pub let RELAX_all           = q_mutref | q_rx_copy | q_rx_resize | q_rx_move;


//

// let e_exit      = 1 <<  0;
// let e_crash     = 1 <<  1;
// let e_div0      = 1 <<  2;
// let e_segv      = 1 <<  3;

// let e_throw     = 1 <<  4;

// let e_io        = 1 <<  8;

// let e_malloc    = 1 << 12;
// let e_memcpy    = 1 << 13;


//

pub fn ==(a: Target, b: Target)
    a.modid == b.modid &&
    a.index == b.index;


// LIFETIMES
//
// static      = int min
// arguments   = int neg
// fn frame    = 0
// locals      = int pos
// temporary   = int max

pub fn > (a: Region, b: Region) a.index >  b.index;
pub fn >=(a: Region, b: Region) a.index >= b.index;
pub fn !=(a: Region, b: Region) a.index != b.index;
pub fn ==(a: Region, b: Region) a.index == b.index;

pub fn Region_toLocalIndex(region: Region) region.index;
pub fn Region_fromLocalIndex(index: i32) Region(:index);

pub fn Region_isArg(region: Region) region.index < 0;

pub fn Region_toArgIndex(region: Region) -region.Region_toLocalIndex;
pub fn Region_fromArgIndex(index: i32) Region_fromLocalIndex(-index);

let Region_TEMP     = Region_fromLocalIndex(0x7fffffff.i32);
let Region_STATIC   = Region_fromLocalIndex(0x80000001.i32); // not 0x80000000, overflows when negated

pub fn Region_isTemp(region: Region)    region == Region_TEMP;
pub fn Region_isStatic(region: Region)  region == Region_STATIC;

pub fn Region_asIndex(using r: Region)
{
    return r == Region_TEMP || r == Region_STATIC ? 0 : index < 0 ? -index : index;
}

pub fn Region_asArgIndex(using r: Region)
{
    return r == Region_STATIC || r.index > 0 ? 0 : -index;
}


//

pub fn Lifetime_union(a: Lifetime, b: Lifetime): Lifetime =
    Lifetime(uni0n: set::union(a.uni0n, b.uni0n));

pub fn Lifetime_inter(a: Lifetime, b: Lifetime): Lifetime =
    Lifetime(uni0n: set::inter(a.uni0n, b.uni0n));

pub fn Lifetime_makeShared(lifetime: Lifetime): Lifetime =
    Lifetime_union(lifetime, Lifetime_static);

pub fn Lifetime_static(): Lifetime =
    Lifetime(uni0n: [ Region_STATIC ]);

pub fn Lifetime_temporary(): Lifetime =
    Lifetime(uni0n: [ Region_TEMP ]);


// TODO FIX Need something that looks like a lifetime whilst reworking block returns.

pub fn Lifetime_placeholder(): Lifetime =
    Lifetime(uni0n: [ Region(index: 0) ]);

pub fn Lifetime_placeholder_remove(ref lt: Lifetime) {
    for (mut i = 0; i < lt.uni0n.len; i++) {
        let r = lt.uni0n[i].index;
        if (r >= 0) {
            if (r == 0)
                lt.uni0n.splice(i, 1);

            break;
        }
    }
}


//

fn ==(a: ValueType, b: ValueType)
    a.quals == b.quals &&
    a.modid == b.modid &&
    a.canon == b.canon;

pub fn ==(a: Lifetime, b: Lifetime)
    a.uni0n.view(i32) == b.uni0n.view(i32);

pub fn ==(a: Type, b: Type)
    a.vtype    == b.vtype    &&
    a.lifetime == b.lifetime;


//

pub let Primitive   = q_rx_copy;

pub let t_i8        = Type(ValueType(modid: 0, canon: "i8",  quals: Primitive));
pub let t_i16       = Type(ValueType(modid: 0, canon: "i16", quals: Primitive));
pub let t_i32       = Type(ValueType(modid: 0, canon: "i32", quals: Primitive));
pub let t_i64       = Type(ValueType(modid: 0, canon: "i64", quals: Primitive));

pub let t_u8        = Type(ValueType(modid: 0, canon: "u8",  quals: Primitive));
pub let t_u16       = Type(ValueType(modid: 0, canon: "u16", quals: Primitive));
pub let t_u32       = Type(ValueType(modid: 0, canon: "u32", quals: Primitive));
pub let t_u64       = Type(ValueType(modid: 0, canon: "u64", quals: Primitive));

pub let t_f32       = Type(ValueType(modid: 0, canon: "f32", quals: Primitive));
pub let t_f64       = Type(ValueType(modid: 0, canon: "f64", quals: Primitive));

pub let t_void      = Type(ValueType(modid: 0, canon: "void",   quals: 0));
pub let t_bool      = Type(ValueType(modid: 0, canon: "bool",   quals: Primitive));
pub let t_never     = Type(ValueType(modid: 0, canon: "never",  quals: 0));
pub let t_zeroes    = Type(ValueType(modid: 0, canon: "zeroes", quals: 0));

pub let t_byte      = Type(ValueType(modid: 0, canon: "byte",   quals: Primitive));


//

pub fn is_void  (t: Type) t.canon == t_void  .canon;
pub fn is_bool  (t: Type) t.canon == t_bool  .canon;
pub fn is_byte  (t: Type) t.canon == t_byte  .canon;
pub fn is_never (t: Type) t.canon == t_never .canon;
pub fn is_zeroes(t: Type) t.canon == t_zeroes.canon;


//

pub fn is_rx_copy(t: Type) !!(t.quals & q_rx_copy);


// TODO non zsts, non-empty structs, etc.

pub fn maybe_nonzero(t: Type) t.is_never || t.is_void;


//

fn isCanonAssignable(host: string, guest: string)
    host == guest;

fn areQualsAssignable(host: i32, guest: i32)
    host & guest == host;

fn isLifetimeAssignable(host: Lifetime, guest: Lifetime)
    !host || !!guest; // TODO FIX this only checks if `!h.is_ref || !!g.is_ref`


//

pub let CANNOT_definit_mutrefs = true;

pub fn isAssignableAsArgument(host: Type, guest: Type): bool
{
    return host.modid == guest.modid
        && isCanonAssignable(host: host.canon, guest.canon)
        && areQualsAssignable(host: host.quals, guest.quals)
        || guest.is_never
        || guest.is_zeroes && !(CANNOT_definit_mutrefs && host.quals & q_mutref);
}

pub fn isAssignable(host: Type, guest: Type): bool
{
    return isAssignableAsArgument(:host, :guest)
        && isLifetimeAssignable(host.lifetime, guest.lifetime);
}


//

let q_mutref_or_move = q_mutref | q_rx_move;

pub fn is_ref(type: Type): bool
{
    return !!type.lifetime;
}

pub fn is_mutref(type: Type): bool
{
    let a = type.quals & q_mutref != 0;
    let b = type.is_ref;
    a && !b && BUG("MutRef&&!Ref");

    return a;
}

pub fn add_ref(mut type: Type, lifetime: Lifetime): Type
{
    type.lifetime = Lifetime_union(type.lifetime, lifetime) || BUG("add_ref: falsy lifetime");
    return type;
}

pub fn add_mutref(mut type: Type, lifetime: Lifetime): Type
{
    type.quals |= q_mutref;
    type.lifetime = Lifetime_union(type.lifetime, lifetime) || BUG("add_mutref: falsy lifetime");
    return type;
}

pub fn is_ref2temp(type: Type): bool
{
    return type.lifetime.uni0n.if_last == Region_TEMP
        && (type.is_ref || BUG("is_ref2temp: has lts but isnt ref"));
}


//

pub fn clear_refs(mut type: Type): Type
{
    type.quals &= ~q_mutref_or_move;
    type.lifetime = Lifetime(); // <- discard lifetime
    return type;
}

pub fn clear_mutref(mut type: Type)
{
    type.quals &= ~q_mutref;
    return type;
}

fn tryClearRefs(type: Type, mutref?: bool): Type
{
    return (mutref ? type.is_mutref : type.is_ref)
        && clear_refs(type);
}


//

pub fn tryClear_mutref(type: Type)
{
    return tryClearRefs(:type, mutref: true);
}

pub fn tryClear_ref(type: Type)
{
    return tryClearRefs(:type);
}

pub fn add_refs(from: Type, mut to: Type)
{
    to.quals |= from.quals & q_mutref_or_move;
    to.lifetime = Lifetime_union(from.lifetime, to.lifetime);
    return to;
}

pub fn make_copyable(mut type: Type)
{
    type.quals |= q_rx_copy;
    return type;
}


// Type serialization:
//  `modid` `+quals` `canon`: a very compact repr.

pub fn serializeType(type: Type, debug!: string)
{
    type || BUG("serializeType: Falsy type in: " ~ debug);

    mut prefix: string;

    if (type.modid)
        prefix ~= type.modid;
    if (type.quals)
        prefix ~= "+" ~ type.quals;

    return prefix ~ (type.canon || BUG("serializeType: No type.canon in: " ~ debug));
}

pub fn humanizeQuals(type: Type)
{
    mut result = ":";

    for (mut i = 0; i < TAGS.len; i++)
        if (type.quals & (1 << i))
            result ~= " " ~ TAGS[i];

    return result;
}

pub fn parseType(str: string): ValueType
{
    mut offset: i32;

    let modid = parse10i32(offset, str);
    mut quals = 0;
    if (str[offset] == '+')
    {
        offset++;
        quals = parse10i32(offset, str);
    }

    let canon = str.slice(offset);

    return ValueType(
        :modid, :canon, :quals);
}


//

pub fn type_isArray(type: Type): bool
{
    return type.quals & (q_rx_resize | q_rx_copy)
        && type.canon.starts(with: "[]");
}

pub fn createArray(item: Type): Type
{
    let canon = "[]" ~ serializeType(item, debug: "createArray");
    let quals = (item.quals & q_rx_copy) | q_rx_resize;
    let modid = 0;

    return Type(
        ValueType(:canon, :quals, :modid),
            :item.lifetime);
}

pub fn tryClear_array(type: Type): Type
{
    let q = q_rx_resize;
    if (type.quals & q_rx_resize != q_rx_resize || !type_isArray(type))
        return Type();

    let vtype = parseType(type.canon.slice(2));
    return Type(:vtype/*, :type.lifetime*/);
}


// Experimental -
//  Slices are refs to arrays,
//   with revoked copy & resize priviledges.

pub fn type_isSliceable(type: Type): bool
{
    return type.canon.starts(with: "[]");
}

pub fn createSlice(item: Type, lifetime: Lifetime): Type
{
    mut out = createArray(item);
    out.quals &= ~(q_rx_copy | q_rx_resize);
    return add_ref(out, lifetime);
}

pub fn tryClear_sliceable(type: Type): Type
{
    if (!type_isSliceable(type))
        return Type();

    let vtype = parseType(type.canon.slice(2));
    return Type(:vtype/*, :type.lifetime*/);
}

pub fn clear_sliceable(type: Type): Type
{
    return tryClear_sliceable(type)
        || BUG("Not sliceable: " ~ type.canon);
}


//

pub fn type_trySuper(a: Type, b: Type)
{
    if (a.canon != b.canon || a.modid != b.modid)
        return a.is_never  ? b
             : b.is_never  ? a
             : a.is_zeroes ? CANNOT_definit_mutrefs ? clear_mutref(b) : b
             : b.is_zeroes ? CANNOT_definit_mutrefs ? clear_mutref(a) : a
             : Type;

    let quals = a.quals & b.quals;
    let lifetime = a.lifetime && b.lifetime
                && Lifetime_union(a.lifetime, b.lifetime);

    return Type(
        ValueType(:a.canon, :quals, :a.modid),
        :lifetime);
}

pub fn type_tryIntersect(a: Type, b: Type)
{
    // Can't intersect with never or any -
    //  you can't use a value as `never` or `any`.
    if (a.canon != b.canon || a.modid != b.modid)
        return Type;

    let quals = a.quals | b.quals;

    // TODO FIX what is this, what's the principle here?
    //  I think we should just lose the lifetime
    //   which will convert us to a value, no?
    let lifetime = Lifetime_inter(a.lifetime, b.lifetime);

    if (!lifetime && (a.lifetime || b.lifetime))
        return Type;

    //
    return Type(
        ValueType(:a.canon, :quals, :a.modid),
        :lifetime);
}


//

pub fn will_relax(ref type: Type, slot!: Type, mut relax_mask!: i32): bool
{
    return (type.quals &~ slot.quals) & relax_mask != 0;
}

pub fn try_relax(ref type: Type, slot!: Type, mut relax_mask!: i32): bool
{
    if (!will_relax(type, :slot, :relax_mask))
        return false;

    type.quals &= slot.quals | ~relax_mask;
    return true;
}

pub fn relax_typeParam(mut type: Type)
{
    return clear_refs(type);
}
