import lifetimes;

pub let q_mutref        = 1 << 0;
pub let q_ref           = 1 << 1;

pub let q_rx_copy       = 1 << 2;

pub let q_trivial       = 1 << 3;
pub let q_primitive     = 1 << 4;

pub let q_arithmetic    = 1 << 5;
pub let q_integral      = 1 << 6;
pub let q_signed        = 1 << 7;
pub let q_unsigned      = 1 << 8;
pub let q_floating_pt   = 1 << 9;

pub let q_rx_resize     = 1 << 10;

let TAGS =
[
    "mutref",
    "ref",

    "copy",

    "trivial",
    "primitive",

    "arithmetic",
    "integral",
    "signed",
    "unsigned",
    "floating_point",

    "resize",
];


//

pub let q_REF_EXTENSIONS
    = q_rx_copy
    | q_rx_resize;

pub let q_MUTINVAR = ~q_REF_EXTENSIONS;


//

pub let e_exit      = 1 <<  0;
pub let e_crash     = 1 <<  1;
pub let e_div0      = 1 <<  2;
pub let e_segv      = 1 <<  3;

pub let e_throw     = 1 <<  4;

pub let e_io        = 1 <<  8;

pub let e_malloc    = 1 << 12;
pub let e_memcpy    = 1 << 13;


//

pub struct ValueType
{
    quals: i32;
    modid: i32;
    canon: string;
};

pub struct Effects
{
    raw: i32;
};

pub struct Type
{
    using value:    ValueType;
    lifetime?:      Lifetime;
    effects?:       Effects;
};

fn type_inter(a: Effects, b: Effects)
    Effects( raw: a.raw | b.raw );


//

pub fn ==(a: ValueType, b: ValueType)
    a.quals == b.quals &&
    a.modid == b.modid &&
    a.canon == b.canon;


//

pub let Trivial     = q_rx_copy  | q_trivial     ;
pub let Primitive   = Trivial    | q_primitive   ;
pub let Arithmetic  = Primitive  | q_arithmetic  ;
pub let Integral    = Arithmetic | q_integral    ;
pub let SignedInt   = Integral   | q_signed      ;
pub let UnsignedInt = Integral   | q_unsigned    ;
pub let FloatingPt  = Arithmetic | q_floating_pt | q_signed;

pub let t_i8        = Type(ValueType(modid: 0, canon: "i8",  quals: SignedInt));
pub let t_i16       = Type(ValueType(modid: 0, canon: "i16", quals: SignedInt));
pub let t_i32       = Type(ValueType(modid: 0, canon: "i32", quals: SignedInt));
pub let t_i64       = Type(ValueType(modid: 0, canon: "i64", quals: SignedInt));

pub let t_u8        = Type(ValueType(modid: 0, canon: "u8",  quals: UnsignedInt));
pub let t_u16       = Type(ValueType(modid: 0, canon: "u16", quals: UnsignedInt));
pub let t_u32       = Type(ValueType(modid: 0, canon: "u32", quals: UnsignedInt));
pub let t_u64       = Type(ValueType(modid: 0, canon: "u64", quals: UnsignedInt));

pub let t_f32       = Type(ValueType(modid: 0, canon: "f32", quals: FloatingPt));
pub let t_f64       = Type(ValueType(modid: 0, canon: "f64", quals: FloatingPt));

pub let t_void      = Type(ValueType(modid: 0, canon: "void",  quals: 0));
pub let t_bool      = Type(ValueType(modid: 0, canon: "bool",  quals: Primitive));
pub let t_never     = Type(ValueType(modid: 0, canon: "never", quals: 0));

pub let t_byte      = Type(ValueType(modid: 0, canon: "byte",     quals: Primitive));


//

pub fn is_never(t: Type) t.value == t_never.value;
pub fn is_void (t: Type) t.value == t_void .value;
pub fn is_bool (t: Type) t.value == t_bool .value;


// https://doc.rust-lang.org/nomicon/subtyping.html:

// Re: covariance of `T` in `Box<T>`:
//
// As it turns out, the argument for why it's ok for Box
//  (and Vec, Hashmap, etc.) to be covariant is pretty similar
//   to the argument for why it's ok for lifetimes to be covariant:
//    as soon as you try to stuff them in something like a mutable
//     reference, they inherit invariance and you're prevented
//      from doing anything bad.

pub fn isAssignable(host: Type, guest: Type)
{
    return host.canon == guest.canon
        && host.modid == guest.modid
            && host.quals & guest.quals == host.quals
            && (!(host.quals & q_mutref) ||
                  host.quals & q_MUTINVAR == guest.quals & q_MUTINVAR)
        || guest.is_never;
}


//

pub fn isAssignableAsArgument(
    host: Type, mut guest: Type)
{
    guest.quals |= q_ref;
    return isAssignable(host, guest);
}


//

pub fn qsub(type: Type, q: i32): Type
{
    mut t = type;
        t.quals &= ~q;

    return t;
}

pub fn qhas(type: Type, q: i32): bool
{
    return type.quals & q == q;
}

fn tryClear(type: Type, q: i32): Type
{
    if (!type || !qhas(type, q))
        return Type();

    return qsub(type, q);
}


//

pub fn add_ref(type: Type, lifetime: Lifetime): Type
{
    mut t = type || throw("falsy type");
        t.quals |= q_ref;
        t.lifetime = type_inter(lifetime, t.lifetime);

    return t;
}

pub fn add_mutref(type: Type, lifetime: Lifetime): Type
{
    mut t = type || throw("falsy type");
        t.quals   |= q_mutref | q_ref;
        t.lifetime = type_inter(t.lifetime, lifetime);

    return t;
}


//

pub fn tryClear_mutref(type: Type)
{
    return tryClear(type, q_ref | q_mutref);
}

pub fn tryClear_ref(type: Type)
{
    let t = tryClear(type, q_ref);

    return t
         ? qsub(t, q_mutref)
         : t;
}

pub fn clear_refs(type: Type): Type
{
    mut t = type;
        t.quals &= ~q_ref;
        t.quals &= ~q_mutref;

    return t;
}

pub fn clear_mutref(type: Type)
{
    mut t = type;
        t.quals &= ~q_mutref;

    return t;
}

pub fn add_refs(from: Type, mut to: Type)
{
    to.quals   |= from.quals & (q_ref | q_mutref);
    to.lifetime = type_inter(from.lifetime, to.lifetime);
    return to;
}


// Type serialization:
//  `modid` `+quals` `canon`: a very compact repr.

pub fn serializeType(type: Type)
{
    mut prefix: string;

    if (type.modid)
        prefix ~= type.modid;
    if (type.quals)
        prefix ~= "+" ~ type.quals;

    return prefix ~ type.canon;
}

pub fn humanizeType(type: Type)
{
    mut result: string = type.canon;

    if (type.modid)
        result = type.modid ~ ":" ~ result;

    if (type.quals)
    {
        result ~= ":";
        for (mut i = 0; i < TAGS.len; i++)
            if (type.quals & (1 << i))
                result ~= " " ~ TAGS[i];
    }

    return result;
}

fn parse10i32(offset: &mut i32, str: string): i32
{
    mut result: i32;
    for (;;)
    {
        let c = offset < str.len && str[offset];
        if (c < '0' || c > '9')
            break;

        offset++;
        result = result * 10 + (c.i32 - '0'.i32);
    }

    return result;
}

pub fn parseType(str: string): ValueType
{
    mut offset: i32;

    let modid = parse10i32(offset, str);
    mut quals = 0;
    if (str[offset] == '+')
    {
        offset++;
        quals = parse10i32(offset, str);
    }

    let canon = str.slice(offset);

    return ValueType(
        :modid, :canon, :quals);
}


//

pub fn type_isArray(type: Type): bool
{
    return type.quals & q_rx_resize
        && type.canon.starts(with: "[]");
}

pub fn createArray(item: Type): Type
{
    let canon = "[]" ~ serializeType(item);
    let quals = (item.quals & q_rx_copy) | q_rx_resize;
    let modid = 0;

    return Type(
        ValueType(:canon, :quals, :modid),
            :item.lifetime);
}

pub fn tryClear_array(type: Type): Type
{
    if (!type_isArray(type))
        return Type();

    let value = parseType(type.canon.slice(2));
    return Type(:value, :type.lifetime);
}


// Experimental -
//  Slices are refs to arrays,
//   with revoked copy & resize priviledges.

pub fn type_isSlice(type: Type): bool
{
    return type.quals & q_ref
        && type.canon.starts(with: "[]");
}

pub fn createSlice(item: Type): Type
{
    mut out = createArray(item);
    out.quals &= ~(q_rx_copy | q_rx_resize);
    out.quals |= q_ref;
    return out;
}

pub fn tryClear_slice(type: Type): Type
{
    if (!type_isSlice(type))
        return Type();

    let value = parseType(type.canon.slice(2));
    return Type(:value, :type.lifetime);
}


//

pub fn type_isMap(type: Type): bool
{
    return type.canon.starts(with: '{');
}

pub fn createMap(key: Type, value: Type): Type
{
    let canon = "{" ~ serializeType(key) ~ "}"
                    ~ serializeType(value);

    let quals = key.quals & value.quals & q_rx_copy;
    let modid = 0;

    return Type(
        ValueType(:canon, :quals, :modid),
            lifetime: type_inter(key.lifetime, value.lifetime));
}

pub struct MapFields
{
    key:   Type;
    value: Type;
}

pub fn tryClear_map(type: Type): MapFields
{
    if (!type_isMap(type))
        return MapFields();

    mut depth = 0;
    for (mut i = 1; i < type.canon.len; i++)
    {
        let c = type.canon[i];
        if (c == '{')
        {
            depth++;
        }
        else if (c == '}')
        {
            if (depth--)
                continue;

            let ckey = type.canon.slice(1,  i);
            let cval = type.canon.slice(i + 1);

            return MapFields(
                key:   Type(value: parseType(ckey), :type.lifetime),
                value: Type(value: parseType(cval), :type.lifetime));
        }
    }

    assert();
}


//

pub fn type_has(type: Type, tag: string)
{
    let idx = TAGS.find(tag);
    idx >= 0 || throw("Unknown type tag: `" ~ tag ~ "`.");
    let mask = 1 << idx;
    return (type.quals & mask) == mask;
}


//

pub fn type_tryInter(a: Type, b: Type)
{
    if (a.canon != b.canon || a.modid != b.modid)
        return a.is_never ? b
             : b.is_never ? a
             : Type();

    return Type(
        ValueType(
            :a.canon,
            :a.quals & b.quals,
            :a.modid),
        type_inter(a.lifetime, b.lifetime),
        type_inter(a.effects,  b.effects ));
}


//

pub struct Target
{
    modid:  i32;
    index:  i32;
};
