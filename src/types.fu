import helpers;
import module;
import fail;
import quals;

let q_mutref            = 1 << 0;
pub let q_rx_copy       = 1 << 1;
let q_rx_resize         = 1 << 2;

let TAGS =
[
    "mutref",
    "copy",
    "resize",
];


//

pub let RELAX_before_bck    = q_mutref;
pub let RELAX_all           = q_mutref | q_rx_copy | q_rx_resize;


// Lifetimes.

pub fn Region_toLocal(region: Region) region.index;
pub fn Region_fromLocal(index: i32) Region(:index);

let Region_TEMP     = Region_fromLocal(0x7fffffff.i32);
let Region_STATIC   = Region_fromLocal(0x80000001.i32); // not 0x80000000, overflows when negated

pub fn Region_isTemp(region: Region)    region == Region_TEMP;
pub fn Region_isStatic(region: Region)  region == Region_STATIC;

pub fn Region_isArgPosition(region: Region)
    region.index < 0 // && !region.Region_isStatic; // TODO FIX wtf

pub fn Region_toArgPosition(region: Region)     -(region.index + 1);
pub fn Region_fromArgPosition(position: i32)    Region(index: -(position + 1));

pub fn Region_asLocal(using r: Region)
    r == Region_TEMP || index < 0 ? 0 : index;


//

pub fn Lifetime_union(a: Lifetime, b: Lifetime): Lifetime =
    Lifetime(uni0n: set::union(a.uni0n, b.uni0n));

pub fn Lifetime_inter(a: Lifetime, b: Lifetime): Lifetime =
    Lifetime(uni0n: set::inter(a.uni0n, b.uni0n));

pub fn Lifetime_makeShared(lifetime: Lifetime): Lifetime =
    Lifetime_union(lifetime, Lifetime_static);

pub fn Lifetime_static(): Lifetime =
    Lifetime(uni0n: [ Region_STATIC ]);

pub fn Lifetime_temporary(): Lifetime =
    Lifetime(uni0n: [ Region_TEMP ]);


//

fn Primitive(canon: string)
    Type(ValueType(:canon, quals: q_rx_copy));

pub let t_i8        = Primitive("i8");
pub let t_i16       = Primitive("i16");
pub let t_i32       = Primitive("i32");
pub let t_i64       = Primitive("i64");
pub let t_i128      = Primitive("i128");

pub let t_u8        = Primitive("u8");
pub let t_u16       = Primitive("u16");
pub let t_u32       = Primitive("u32");
pub let t_u64       = Primitive("u64");
pub let t_u128      = Primitive("u128");

pub let t_f32       = Primitive("f32");
pub let t_f64       = Primitive("f64");

pub let t_bool      = Primitive("b8");
pub let t_byte      = Primitive("c8");


// I think these should also be non-refereable?

fn NotSure(canon: string)
    Type(ValueType(:canon, quals: 0));

pub let t_void      = NotSure("void");
pub let t_never     = NotSure("never");
pub let t_zeroes    = NotSure("zeroes");

pub fn is_void  (t: Type) t.canon == t_void  .canon;
pub fn is_never (t: Type) t.canon == t_never .canon;
pub fn is_zeroes(t: Type) t.canon == t_zeroes.canon;


//

pub fn is_rx_copy   (t: Type) !!(t.quals & q_rx_copy);
pub fn is_rx_resize (t: Type) !!(t.quals & q_rx_resize);


//

pub fn isPassByValue(t: Type)   = t.is_primitive;


//

fn isCanonAssignable(host: string, guest: string)
    host == guest;

fn areQualsAssignable(host: i32, guest: i32)
    host & guest == host;

fn isLifetimeAssignable(host: Lifetime, guest: Lifetime)
    !host || !!guest; // TODO FIX this only checks if `!h.is_ref || !!g.is_ref`


//

pub let CANNOT_definit_mutrefs = true;

pub fn isAssignableAsArgument(host: Type, guest: Type, DONT_match_zeroes!?: bool): bool
{
    return areQualsAssignable(host: host.quals, guest.quals)
        &&  isCanonAssignable(host: host.canon, guest.canon)

        || guest.is_zeroes && !DONT_match_zeroes && !(CANNOT_definit_mutrefs && host.quals & q_mutref);
}

pub fn isAssignable(host: Type, guest: Type, DONT_match_zeroes!?: bool, asArgument!?: bool): bool
{
    return isAssignableAsArgument(:host, :guest, :DONT_match_zeroes)
        && (asArgument || isLifetimeAssignable(host.lifetime, guest.lifetime));
}


//

pub fn is_ref(type: Type): bool
{
    return !!type.lifetime;
}

pub fn is_mutref(type: Type): bool
{
    let a = type.quals & q_mutref != 0;
    let b = type.is_ref;
    a && !b && BUG("MutRef&&!Ref");

    return a;
}

pub fn add_ref(mut type: Type, lifetime: Lifetime): Type
{
    type.lifetime = Lifetime_union(type.lifetime, lifetime) || BUG("add_ref: falsy lifetime");
    return type;
}

pub fn add_mutref(mut type: Type, lifetime: Lifetime): Type
{
    type.quals |= q_mutref;
    type.lifetime = Lifetime_union(type.lifetime, lifetime) || BUG("add_mutref: falsy lifetime");
    return type;
}

pub fn is_ref2temp(type: Type): bool
{
    return type.lifetime.uni0n.if_last == Region_TEMP
        && (type.is_ref || BUG("is_ref2temp: has lts but isnt ref"));
}


//

pub fn clear_refs(mut type: Type): Type
{
    type.quals &= ~q_mutref;
    type.lifetime = Lifetime(); // <- discard lifetime
    return type;
}

pub fn clear_mutref(mut type: Type)
{
    type.quals &= ~q_mutref;
    return type;
}

fn tryClearRefs(type: Type, mutref?: bool): Type
{
    return (mutref ? type.is_mutref : type.is_ref)
        && clear_refs(type);
}


//

pub fn tryClear_mutref(type: Type)
{
    return tryClearRefs(:type, mutref: true);
}

pub fn tryClear_ref(type: Type)
{
    return tryClearRefs(:type);
}

pub fn add_refs(from: Type, mut to: Type)
{
    to.quals |= from.quals & q_mutref;
    to.lifetime = Lifetime_union(from.lifetime, to.lifetime);
    return to;
}

pub fn make_copyable(mut type: Type)
{
    type.quals |= q_rx_copy;
    return type;
}


// Type serialization:
//  `modid` `+quals` `canon`: a very compact repr.

pub fn serializeType(type: Type, debug!: string)
{
    type || throw("COMPILER BUG: serializeType: Falsy type in: " ~ debug);

    mut prefix: string;

    if (type.quals)
        prefix ~= type.quals;

    return prefix ~ (type.canon || throw("COMPILER BUG: serializeType: No type.canon in: " ~ debug));
}

pub fn humanizeQuals(type: Type)
{
    mut result = ":";

    for (mut i = 0; i < TAGS.len; i++)
        if (type.quals & (1 << i))
            result ~= " " ~ TAGS[i];

    return result;
}

pub fn parseType(str: string): ValueType
{
    mut offset: i32;

    let quals = parse10u32(offset, str).i32;
    let canon = str.slice(offset);
    return ValueType(:canon, :quals);
}


// Experimental -
//  Slices are refs to arrays,
//   with revoked copy & resize priviledges.

pub fn type_isSliceable(type: Type): bool
{
    return type.canon.starts(with: '[');
}

pub fn createSlice(item: Type, lifetime: Lifetime): Type
{
    mut out = createArray(item);
    out.quals &= ~(q_rx_copy | q_rx_resize);
    return add_ref(out, lifetime);
}

pub fn tryClear_sliceable(type: Type): Type
{
    if (!type_isSliceable(type))
        return Type();

    let vtype = parseType(type.canon.slice(1, type.canon.len - 1));
    return Type(:vtype/*, :type.lifetime*/);
}

pub fn clear_sliceable(type: Type): Type
{
    return tryClear_sliceable(type)
        || BUG("Not sliceable: " ~ type.canon);
}


//

pub fn createArray(item: Type): Type
{
    let canon = "[" ~ serializeType(item, debug: "createArray") ~ "]";
    let quals = (item.quals & q_rx_copy) | q_rx_resize;

    return Type(
        ValueType(:canon, :quals),
            :item.lifetime);
}

pub fn tryClear_array(type: Type): Type
{
    let q = q_rx_resize;
    if (type.quals & q_rx_resize != q_rx_resize)
        return Type();

    return tryClear_sliceable(type);
}

pub fn TODO_FIX_isArray(type: Type): bool
{
    // TODO FIX: isArray doesn't match the tryClear_array, which requires q_rx_resize
    //  this is only used in cg, which is post-relax so perhaps we should just move it over there,
    //   naming it impossibly right now to disambiguate
    return type.quals & (q_rx_resize | q_rx_copy)
        && type.type_isSliceable();
}

pub let t_string = createArray(t_byte);


//

pub fn type_trySuper(a: Type, b: Type, DONT_match_zeroes!?: bool)
{
    if (a.canon != b.canon)
        return a.is_zeroes && !DONT_match_zeroes ? CANNOT_definit_mutrefs ? clear_mutref(b) : b
             : b.is_zeroes && !DONT_match_zeroes ? CANNOT_definit_mutrefs ? clear_mutref(a) : a
             : [];

    let quals   = a.quals  & b.quals;
    let vfacts  = a.vfacts & b.vfacts;

    let lifetime = a.lifetime && b.lifetime
                && Lifetime_union(a.lifetime, b.lifetime);

    return Type(
        ValueType(:a.canon, :quals),
        :lifetime, :vfacts);
}

pub fn type_tryIntersect(a: Type, b: Type)
{
    // Can't intersect with never or any -
    //  you can't use a value as `never` or `any`.
    if (a.canon != b.canon)
        return [];

    let quals   = a.quals  | b.quals;
    let vfacts  = a.vfacts | b.vfacts;

    // TODO FIX what is this, what's the principle here?
    //  I think we should just lose the lifetime
    //   which will convert us to a value, no?
    let lifetime = Lifetime_inter(a.lifetime, b.lifetime);

    if (!lifetime && (a.lifetime || b.lifetime))
        return [];

    //
    return Type(
        ValueType(:a.canon, :quals),
        :lifetime, :vfacts);
}


//

pub fn isAddrOfFn(type: Type): bool =
    type.canon.starts(with: '@');

pub fn packAddrOfFn(targets: Target[])
{
    mut res = "@";
    for (mut i = 0; i < targets.len; i++)
    {
        let target = targets[i];
        res.appendMi(:target.modid, :target.index);
    }

    return res;
}

pub fn unpackAddrOfFn(canon: string, fn)
{
    canon[0] == '@' || throw("unpackAddrOfFn: No leading @ in `" ~ canon ~ "`.");

    mut offset = 1;
    while (offset < canon.len)
    {
        let mi = parseMi(offset, canon);
        fn(Target(:mi.modid, :mi.index));
    }
}


//

pub fn will_relax(ref type: Type, slot!: Type, mut relax_mask!: i32): bool
{
    return (type.quals &~ slot.quals) & relax_mask != 0;
}

pub fn try_relax(ref type: Type, slot!: Type, mut relax_mask!: i32): bool
{
    if (!will_relax(type, :slot, :relax_mask))
        return false;

    type.quals &= slot.quals | ~relax_mask;
    return true;
}

pub fn relax_typeParam(mut type: Type)
{
    return clear_refs(type);
}
