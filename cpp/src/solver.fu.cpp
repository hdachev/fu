#include <cstdint>
#include <utility>
#include <fu/int.h>
#include <fu/str.h>
#include <fu/vec.h>
#include <algorithm>
#include <fu/view.h>
#include <fu/defer.h>
#include <fu/never.h>
#include <fu/print.h>
#include <fu/assert.h>
#include <fu/decstr.h>
#include <fu/default.h>
#include <fu/vec_range.h>
#include <fu/static_ref.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/view_swap.h>
#include <fu/vec/concat_one.h>
#include <fu/move_or_default.h>
#include <fu/vec/view_assign.h>

struct SolverOutput_hA3T;
struct SolvedNode_efhg;
enum Kind_Idfg: fu::u8;
struct Helpers_DyqV;
typedef unsigned Flags_Lzg8;
struct TokenIdx_5581;
struct Type_OiTm;
struct ValueType_JtNg;
typedef fu::u8 VFacts_xhRf;
struct Lifetime_llCF;
struct Target_VZrr;
struct Scope_blWT;
struct Overload_aO3i;
typedef uint16_t SolverStatus_h9em;
typedef uint16_t DeclAsserts_taUG;
struct Extended_z0HS;
struct Argument_bbKc;
struct BitSet_mmp7;
struct COWInside_qvly;
typedef unsigned MayEscapeVia_5nki;
typedef fu::u8 ExitPaths_UXHs;
struct Template_SsLx;
struct Node_JjyR;
typedef fu::u8 ParseSyntax_Lay2;
struct TEA_0Daz;
typedef uint16_t FxMask_2dRz;
struct ScopeItem_xiLD;
typedef int SolverNotes_LSla;
struct Context_noPA;
struct Module_wo7O;
struct ModuleInputs_iQIg;
struct LexerOutput_DN4p;
struct Token_6M7a;
struct LineColChars_6JiM;
struct ParserOutput_d14k;
struct Import_7CIJ;
struct ModuleOrder_HMNg;
struct ModuleOutputs_WMGM;
struct Struct_LDkB;
struct Set_qOJY;
struct Shape_fvCX;
struct CodegenOutput_qIMB;
struct Set_XshD;
struct BuildHacks_sqc0;
typedef fu::u8 CGDefects_2L18;
struct ModuleStats_ANTR;
struct ModuleStat_sTmh;
struct Profile_4UPJ;
struct Sample_Time_cblj;
struct NukeOnRebuild_TLE7;
struct Map_Umhk;
struct Options_TBgD;
struct Lint_Q9R1;
typedef fu::u8 DevOptions_QEya;
struct CurrentFn_QbLp;
struct ScopeMemo_9hVQ;
struct Flow_oKsD;
struct LocidMap_JYql;
struct LocidMap_oyma;
struct Set_qOJY;
struct LocidMap_DNUT;
struct LocidSet_iAWt;
struct Effects_bbOX;
struct Events_SbUb;
struct EventsSnap_elmt;
struct LocidMap_m07i;
struct Set_LKfa;
struct WriteID_LxbZ;
struct PrecedingRefArg_Bnyy;
struct VarUsage_IMaS;
struct LocidMap_X0gN;
struct Postdom_Vy5u;
struct PostdomSnap_cfaM;
struct LocidMap_IP5H;
struct RevSpecPrototype_vWbr;
struct SolverState_aGlN;
struct ScopeSkipMemos_0CE6;
struct ScopeSkip_iozY;
struct HelpersData_uG6I;
enum SolverPass_zVQ2: fu::u8;
typedef uint16_t HelpersMask_w1sv;
struct Ephemeral_xhb4;
struct SpecExtras_JI9K;
struct Map_qY9d;
struct Set_XshD;
struct CountedSet_C7kV;
struct Map_99Lz;
struct ChildTarget_FjNI;
struct Map_BZ38;
struct ReverseSpecialization_xE3F;
struct RevSpecInstance_Td5T;
struct RevSpecOutput_pbkT;
struct Map_OMJS;
struct Set_X4pj;
struct ConvCache_ColsAndBakes_2n47;
struct ConvCacheColumns_qe99;
struct Warning_9p8u;
struct Map_v4nV;
struct TypeParam_Lrcu;
typedef fu::u8 TypeParamFlags_vSpZ;
enum DeadBreak_Z4ob: fu::u8;
enum StaticEval_IZio: fu::u8;
struct ClosureID_qHEW;
struct UnpackedOffset_f7kz;
typedef fu::u8 CodeFmt_snPx;
struct Reorder_0MNg;
struct NamedArgs_UjiQ;
struct Set_pEwD;
struct StructCanon_TixV;
struct Intlit_tw2d;
struct Map_iaWx;
struct Set_R8IU;
typedef unsigned UsedAgain_5DsR;
enum UsedAgainReason_wQO7: fu::u8;
struct RetypeOrder_6uAI;
struct NamedArgs_UjiQ;
struct NativeQualities_5Qbp;
enum ArgQuery_O2xW: fu::u8;
enum ArgRationale_mffC: fu::u8;
enum BorrowCheckPass_i0wt: fu::u8;
struct RWQuals_ELUY;
struct SubRegion_jsU3;
struct Map_ZxRu;
struct Unsequenced_MqaY;
struct Regions_9N5a;
fu::vec_range<char> getShortModuleName_1qjp(fu::vec_range<char>, const Context_noPA&, const TokenIdx_5581&);
Type_OiTm into_Typename_9CJm(Type_OiTm&&);
Target_VZrr Scope_create_z0Qq(Scope_blWT&, Kind_Idfg, fu::vec_range<char>, const Type_OiTm&, Flags_Lzg8, DeclAsserts_taUG, SolverStatus_h9em, int, bool, const Module_wo7O&);
void Scope_set_z0Qq(Scope_blWT&, fu::vec_range<char>, const Target_VZrr&, bool);
static SolvedNode_efhg solveNode_gDsn(const Node_JjyR&, const Type_OiTm&, CurrentFn_QbLp&, SolverState_aGlN&, const Context_noPA&, TokenIdx_5581&, Module_wo7O&, const Options_TBgD&, fu::vec<Helpers_DyqV>&);
bool is_never_9CJm(const ValueType_JtNg&);
unsigned is_AssumeNever_WhileSolvingRecursion_9CJm(const ValueType_JtNg&);
fu::str qBAD_e44U(fu::view<char>);
const Token_6M7a& _token_xQNS(const TokenIdx_5581&, const Context_noPA&);
[[noreturn]] fu::never BUG_u9Gb(fu::view<char>, const Context_noPA&, const TokenIdx_5581&);
fu::str qDIM_e44U(fu::view<char>);
bool is_mutref_9CJm(const Type_OiTm&, const Context_noPA&, const TokenIdx_5581&);
ClosureID_qHEW tryParseClosureID_UvH3(fu::view<char>, const Context_noPA&, const TokenIdx_5581&);
fu::vec_range<char> trim_V5Iu(fu::vec_range<char>);
Target_VZrr Target_xQNS(int, int, int);
fu::str qID_e44U(fu::view<char>);
fu::str qKW_e44U(fu::view<char>);
const Struct_LDkB& tryLookupUserType_1qjp(const ValueType_JtNg&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&);
Type_OiTm tryClear_sliceable_1qjp(const ValueType_JtNg&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&);
static fu::str explainTypeName_gDsn(const Type_OiTm&, bool, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&, const Options_TBgD&);
bool TODO_FIX_isArray_9CJm(const Type_OiTm&);
bool is_zeroes_9CJm(const ValueType_JtNg&);
fu::str formatTokenCoord_u9Gb(const TokenIdx_5581&, int, const Context_noPA&);
[[noreturn]] fu::never FAIL_u9Gb(fu::view<char>, fu::vec_range<TokenIdx_5581>, const Context_noPA&);
bool isIrrelevant_9CJm(const Type_OiTm&);
bool isCanonAssignable_Ot6w(fu::view<char>, fu::view<char>, const Context_noPA&, const TokenIdx_5581&);
fu::str explainVFacts_9CJm(VFacts_xhRf);
fu::str explainQuals_9CJm(unsigned, const Lifetime_llCF&);
unsigned parse7bit_7Yz9(fu::view<char>, int&);
fu::str qLT_e44U(fu::view<char>);
Target_VZrr target_z0Qq(const ScopeItem_xiLD&);
bool is_sliceable_hxWW(const ValueType_JtNg&);
Type_OiTm clear_sliceable_1qjp(const ValueType_JtNg&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&);
fu::view<char> tryGetPattern_Ot6w(fu::view<char>);
Target_VZrr parseGlobal_xQNS(fu::view<char>, int&);
bool scan_Ot6w(fu::view<char>, char, int&, bool&);
ValueType_JtNg parseType_1qjp(fu::view<char>, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&);
static fu::str explainType_gDsn(const Type_OiTm&, bool, bool, bool, bool, bool, const Type_OiTm&, const SolverState_aGlN&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&, const Options_TBgD&);
unsigned USAGE_fieldUsageFromStructUsage_CaGD(unsigned, unsigned, int, int);
unsigned getMaxUsage_CaGD(int);
static void appendUsage_gDsn(const Type_OiTm&, unsigned, fu::str&, const SolverState_aGlN&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&, const Options_TBgD&);
fu::str formatCodeSnippet_k53p(fu::vec<TokenIdx_5581>&&, int, CodeFmt_snPx, const Context_noPA&);
static fu::str explainWhichFn_gDsn(Target_VZrr&&, fu::view<fu::vec<Target_VZrr>>, fu::view<char>, CodeFmt_snPx, const CurrentFn_QbLp&, const SolverState_aGlN&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&, const Options_TBgD&);
fu::str packAddrOfFn_9CJm(fu::view<Target_VZrr>);
bool hasStatic_7Yz9(const Lifetime_llCF&);

                                #ifndef DEF_STRUCT_MEMBERS
                                #define DEF_STRUCT_MEMBERS
inline constexpr int STRUCT_MEMBERS = 1;
                                #endif

                                #ifndef DEF_STRUCT_BASE
                                #define DEF_STRUCT_BASE
inline constexpr int STRUCT_BASE = 0;
                                #endif
static Type_OiTm evalTypeAnnot_gDsn(const Node_JjyR&, bool, CurrentFn_QbLp&, SolverState_aGlN&, const Context_noPA&, TokenIdx_5581&, Module_wo7O&, const Options_TBgD&, fu::vec<Helpers_DyqV>&);
Type_OiTm add_ref_9CJm(Type_OiTm&&, const Lifetime_llCF&, const Context_noPA&, const TokenIdx_5581&);
Type_OiTm add_mutref_9CJm(Type_OiTm&&, const Lifetime_llCF&, const Context_noPA&, const TokenIdx_5581&);
Type_OiTm createArray_9CJm(const Type_OiTm&);
Type_OiTm createSlice_9CJm(const Type_OiTm&, const Lifetime_llCF&, const Context_noPA&, const TokenIdx_5581&);
bool is_Typename_9CJm(const Type_OiTm&);
Type_OiTm relax_typeParam_9CJm(Type_OiTm&&);
Type_OiTm clear_Typename_9CJm(Type_OiTm&&, bool);
unsigned parseVarint_V5Iu(int&, fu::view<char>);
bool add_ZwXY(BitSet_mmp7&, int);
bool isStruct_p1TN(const ValueType_JtNg&);
static Target_VZrr tryMatchCall_gDsn(fu::str&&, Reorder_0MNg&, fu::vec_range_mut<fu::vec<Target_VZrr>>, fu::vec_range_mut<char>, bool, const Scope_blWT&, fu::view<SolvedNode_efhg>, Flags_Lzg8, fu::view<Target_VZrr>, CurrentFn_QbLp&, SolverState_aGlN&, const Context_noPA&, TokenIdx_5581&, Module_wo7O&, const Options_TBgD&, fu::vec<Helpers_DyqV>&);
Type_OiTm make_field_reference_9CJm(unsigned, const Lifetime_llCF&, Type_OiTm&&, int, int, const Context_noPA&, const TokenIdx_5581&);
static void descend_gDsn(const Type_OiTm&, bool, bool, ConvCache_ColsAndBakes_2n47&, Reorder_0MNg&, fu::vec<fu::vec<Target_VZrr>>&, fu::vec<Target_VZrr>&, fu::vec<int>&, CurrentFn_QbLp&, SolverState_aGlN&, const Context_noPA&, TokenIdx_5581&, Module_wo7O&, const Options_TBgD&, fu::vec<Helpers_DyqV>&);
StructCanon_TixV tryParseStructCanon_1qjp(const ValueType_JtNg&);
const Struct_LDkB& lookupUserType_1qjp(const StructCanon_TixV&, const Module_wo7O&, const Context_noPA&, const TokenIdx_5581&);
const Set_qOJY& lookupTypeImports_1qjp(const ValueType_JtNg&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&);
int modidOfOrigin_p1TN(const Type_OiTm&);
bool has_ZwXY(const BitSet_mmp7&, int);
const Target_VZrr& search_FjkY(fu::view<Target_VZrr>, int&);
Target_VZrr search_z0Qq(fu::view_mut<ScopeItem_xiLD>, fu::view<char>, int&, fu::view<ScopeSkip_iozY>, bool&, fu::view<Target_VZrr>, fu::view<ScopeItem_xiLD>, const Context_noPA&, const TokenIdx_5581&);
Target_VZrr search_KHWe(fu::view<ScopeItem_xiLD>, fu::view<char>, int&, fu::view<ScopeItem_xiLD>);
static void relinkNode_gDsn(SolvedNode_efhg&, const Target_VZrr&, const Target_VZrr&, fu::view_mut<Overload_aO3i>, int, fu::vec<Helpers_DyqV>&, int&, const CurrentFn_QbLp&, SolverState_aGlN&, const Context_noPA&, const TokenIdx_5581&, fu::vec<Helpers_DyqV>&);
void force_relax_9CJm(Type_OiTm&, unsigned);
unsigned try_relax_9CJm(Type_OiTm&, const Type_OiTm&, unsigned);

                                #ifndef DEF_FN_RET_BACK
                                #define DEF_FN_RET_BACK
inline constexpr int FN_RET_BACK = -2;
                                #endif

                                #ifndef DEF_FN_ARGS_BACK
                                #define DEF_FN_ARGS_BACK
inline constexpr int FN_ARGS_BACK = FN_RET_BACK;
                                #endif
static void TEST_node_gDsn(SolvedNode_efhg&, SolverPass_zVQ2, bool, const CurrentFn_QbLp&, SolverState_aGlN&, const Context_noPA&, TokenIdx_5581&, const Module_wo7O&, const Options_TBgD&, fu::view<Helpers_DyqV>);
bool is_ref_9CJm(const Type_OiTm&);
bool isAssignableAsArgument_9CJm(const ValueType_JtNg&, const ValueType_JtNg&, bool, const Context_noPA&, const TokenIdx_5581&);

                                #ifndef DEF_LET_INIT
                                #define DEF_LET_INIT
inline constexpr int LET_INIT = 1;
                                #endif
static fu::str tryExplainWell_gDsn(const Type_OiTm&, const CurrentFn_QbLp&, const SolverState_aGlN&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&, const Options_TBgD&);
Type_OiTm clear_refs_9CJm(Type_OiTm&&);
Type_OiTm clear_vfacts_9CJm(Type_OiTm&&);
bool isAssignable_9CJm(const Type_OiTm&, const Type_OiTm&, bool, bool, const Context_noPA&, const TokenIdx_5581&);
fu::str serializeType_1qjp(const ValueType_JtNg&, fu::view<char>);
Lifetime_llCF Lifetime_union_7Yz9(const Lifetime_llCF&, const Lifetime_llCF&, bool, const Context_noPA&, const TokenIdx_5581&);
bool is_void_or_propositionOK_9CJm(const Type_OiTm&, bool, const Context_noPA&, const TokenIdx_5581&);
bool hasTemporary_7Yz9(const Lifetime_llCF&);

                                #ifndef DEF_TRY_ERR
                                #define DEF_TRY_ERR
inline constexpr int TRY_ERR = 1;
                                #endif
bool is_trivial_1qjp(const ValueType_JtNg&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&);
static void check_gDsn(const Lifetime_llCF&, bool&, const SolverState_aGlN&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&, const Options_TBgD&, fu::view<Helpers_DyqV>);

                                #ifndef DEF_NO_LOOP
                                #define DEF_NO_LOOP
inline constexpr int NO_LOOP = -1000001;
                                #endif

                                #ifndef DEF_CANNOT_definit_mutrefs
                                #define DEF_CANNOT_definit_mutrefs
inline constexpr bool CANNOT_definit_mutrefs = true;
                                #endif
static void definitWrap_gDsn(SolvedNode_efhg&, const Type_OiTm&, const SolverState_aGlN&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&, const Options_TBgD&, fu::view<Helpers_DyqV>);
bool isImmediatelyDiscardable_UVY6(Kind_Idfg);
bool is_rx_copy_9CJm(const ValueType_JtNg&);
bool is_zst_1qjp(const ValueType_JtNg&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&);
Type_OiTm type_tryIntersect_9CJm(const Type_OiTm&, const Type_OiTm&, const Context_noPA&, const TokenIdx_5581&);
static void propagateType_gDsn(SolvedNode_efhg&, const Type_OiTm&, unsigned, const Helpers_DyqV&, CurrentFn_QbLp&, SolverState_aGlN&, const Context_noPA&, TokenIdx_5581&, Module_wo7O&, const Options_TBgD&, fu::vec<Helpers_DyqV>&);
bool is_boolean_hxWW(const ValueType_JtNg&);
BitSet_mmp7& operator|=(BitSet_mmp7&, const BitSet_mmp7&);
bool propositionOK_9CJm(const Type_OiTm&, bool, const Context_noPA&, const TokenIdx_5581&);
Type_OiTm type_trySuper_9CJm(const Type_OiTm&, const Type_OiTm&, bool, const Context_noPA&, const TokenIdx_5581&);
static SolvedNode_efhg createAnd_gDsn(fu::vec<SolvedNode_efhg>&&, Type_OiTm&&, CurrentFn_QbLp&, SolverState_aGlN&, const Context_noPA&, TokenIdx_5581&, Module_wo7O&, const Options_TBgD&, fu::vec<Helpers_DyqV>&);
Type_OiTm definitType_9CJm(Type_OiTm&&, bool, const Context_noPA&, const TokenIdx_5581&);
static int couldRetype_gDsn(const SolvedNode_efhg&);
bool is_void_9CJm(const ValueType_JtNg&);
bool is_arithmetic_hxWW(const ValueType_JtNg&);
Intlit_tw2d Intlit_u8re(fu::view<char>);
bool is_primitive_hxWW(const ValueType_JtNg&);
int basePrimPrefixLen_hxWW(fu::view<char>);
static Type_OiTm tryRetyping_gDsn(const SolvedNode_efhg&, const Type_OiTm&, const SolverState_aGlN&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&, const Options_TBgD&, fu::view<Helpers_DyqV>);
static void applyRetype_gDsn(SolvedNode_efhg&, const Type_OiTm&, const SolverState_aGlN&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&, const Options_TBgD&, fu::view<Helpers_DyqV>);
Type_OiTm clear_all_9CJm(Type_OiTm&&);
static bool applyConversion_gDsn(SolvedNode_efhg&, fu::view<Target_VZrr>, CurrentFn_QbLp&, SolverState_aGlN&, const Context_noPA&, TokenIdx_5581&, Module_wo7O&, const Options_TBgD&, fu::vec<Helpers_DyqV>&);
bool isRTL_xQNS(const Overload_aO3i&);
static void visitNode_gDsn(SolvedNode_efhg&, int, const Target_VZrr&, fu::view_mut<SolvedNode_efhg>, Map_iaWx&, const Target_VZrr&, int, fu::vec<Helpers_DyqV>&, CurrentFn_QbLp&, SolverState_aGlN&, const Context_noPA&, TokenIdx_5581&, Module_wo7O&, const Options_TBgD&, fu::vec<Helpers_DyqV>&);
bool isStaticOrZeroes_7Yz9(const Lifetime_llCF&);
int getFlatCount_1qjp(const ValueType_JtNg&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&);
Lifetime_llCF Lifetime_from_7Yz9(int, int, const Context_noPA&, const TokenIdx_5581&);
static SolvedNode_efhg CallerNode_gDsn(fu::vec_range<char>, Target_VZrr&&, fu::vec<SolvedNode_efhg>&&, const Reorder_0MNg&, fu::view<fu::vec<Target_VZrr>>, CurrentFn_QbLp&, SolverState_aGlN&, const Context_noPA&, TokenIdx_5581&, Module_wo7O&, const Options_TBgD&, fu::vec<Helpers_DyqV>&);
static fu::str qSTACK_implicit_FDl5(const Target_VZrr&, const SolvedNode_efhg&, fu::vec_range<char>, const Type_OiTm&, fu::view<Target_VZrr>, const CurrentFn_QbLp&, SolverState_aGlN&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&, const Options_TBgD&);
Type_OiTm clear_mutref_9CJm(Type_OiTm&&);
fu::vec_range<char> cleanID_V5Iu(fu::vec_range<char>);
bool isAddrOfFn_9CJm(const Type_OiTm&);
Target_VZrr parseLocalOrGlobal_xQNS(fu::view<char>, int&);
void Scope_set_FjkY(fu::vec_range_mut<ScopeItem_xiLD>, fu::vec_range<char>, const Target_VZrr&, bool);
fu::str serialize_UvH3(const ClosureID_qHEW&, const Context_noPA&, const TokenIdx_5581&);
static bool Lifetime_allowsMutrefReturn_gDsn(const Lifetime_llCF&, int, const SolverState_aGlN&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&, const Options_TBgD&, fu::view<Helpers_DyqV>);
Lifetime_llCF Lifetime_op_join_7Yz9(const Lifetime_llCF&, fu::view<char>, const Context_noPA&, const TokenIdx_5581&);
void Lifetime_add_7Yz9(Lifetime_llCF&, const Lifetime_llCF&, bool, const Context_noPA&, const TokenIdx_5581&);
void assertPathsValid_7Yz9(fu::view<char>, int, int, bool, int, const Context_noPA&, const TokenIdx_5581&);

                                #ifndef DEF_TRY_CATCH
                                #define DEF_TRY_CATCH
inline constexpr int TRY_CATCH = 2;
                                #endif

                                #ifndef DEF_TRY_TRY
                                #define DEF_TRY_TRY
inline constexpr int TRY_TRY = 0;
                                #endif

                                #ifndef DEF_LOOP_POST_COND
                                #define DEF_LOOP_POST_COND
inline constexpr int LOOP_POST_COND = 5;
                                #endif

                                #ifndef DEF_LOOP_POST
                                #define DEF_LOOP_POST
inline constexpr int LOOP_POST = 4;
                                #endif

                                #ifndef DEF_LOOP_BODY
                                #define DEF_LOOP_BODY
inline constexpr int LOOP_BODY = 3;
                                #endif

                                #ifndef DEF_LOOP_PRE
                                #define DEF_LOOP_PRE
inline constexpr int LOOP_PRE = 2;
                                #endif

                                #ifndef DEF_LOOP_PRE_COND
                                #define DEF_LOOP_PRE_COND
inline constexpr int LOOP_PRE_COND = 1;
                                #endif
void clear_Na55(BitSet_mmp7&, int);

                                #ifndef DEF_LOOP_INIT
                                #define DEF_LOOP_INIT
inline constexpr int LOOP_INIT = 0;
                                #endif
Type_OiTm USAGE_structUsageFromFieldUsage_GgXY(Type_OiTm&&, int);
static UsedAgain_5DsR descend_FDl5(const Lifetime_llCF&, LocidSet_iAWt&, LocidSet_iAWt&, const CurrentFn_QbLp&, const SolverState_aGlN&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&, const Options_TBgD&, fu::view<Helpers_DyqV>);
unsigned mask_retval_relaxable_9CJm(const Type_OiTm&, unsigned, const Context_noPA&, const TokenIdx_5581&);
static void ensureLazySolved_gDsn(const Target_VZrr&, CurrentFn_QbLp&, SolverState_aGlN&, const Context_noPA&, TokenIdx_5581&, Module_wo7O&, const Options_TBgD&, fu::vec<Helpers_DyqV>&);
static Type_OiTm conversionTailType_gDsn(const Type_OiTm&, fu::view<Target_VZrr>, const SolverState_aGlN&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&);

                                #ifndef DEF_LET_TYPE
                                #define DEF_LET_TYPE
inline constexpr int LET_TYPE = 0;
                                #endif
static Type_OiTm Scope_lookupType_gDsn(fu::vec_range<char>, Flags_Lzg8, CurrentFn_QbLp&, SolverState_aGlN&, const Context_noPA&, TokenIdx_5581&, Module_wo7O&, const Options_TBgD&, fu::vec<Helpers_DyqV>&);
void ref_anonymize_9CJm(Type_OiTm&);

                                #ifndef DEF_DONT_match_zeroes
                                #define DEF_DONT_match_zeroes
inline constexpr bool DONT_match_zeroes = true;
                                #endif
Type_OiTm tryClear_ref_9CJm(const Type_OiTm&, const Context_noPA&, const TokenIdx_5581&);
Type_OiTm tryClear_mutref_9CJm(const Type_OiTm&, const Context_noPA&, const TokenIdx_5581&);
Type_OiTm tryClear_array_9CJm(const Type_OiTm&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&);
static bool trySolveTypeParams_gDsn(const Node_JjyR&, Type_OiTm&&, fu::vec_range_mut<char>, bool, CurrentFn_QbLp&, SolverState_aGlN&, const Context_noPA&, TokenIdx_5581&, Module_wo7O&, const Options_TBgD&, fu::vec<Helpers_DyqV>&);
bool remove_Na55(BitSet_mmp7&, int);
int popcount_ZwXY(const BitSet_mmp7&);
fu::str qBAD_KW_e44U(fu::view<char>);
static void intoTombstone_gDsn(const Target_VZrr&, SolverState_aGlN&, const Module_wo7O&);

                                #ifndef DEF_FN_BODY_BACK
                                #define DEF_FN_BODY_BACK
inline constexpr int FN_BODY_BACK = -1;
                                #endif
static bool evalTypePattern_gDsn(const Node_JjyR&, CurrentFn_QbLp&, SolverState_aGlN&, const Context_noPA&, TokenIdx_5581&, Module_wo7O&, const Options_TBgD&, fu::vec<Helpers_DyqV>&);
bool is_bitfield_hxWW(const ValueType_JtNg&);
bool is_integral_hxWW(const ValueType_JtNg&);
bool is_unsigned_hxWW(const ValueType_JtNg&);
bool is_floating_pt_hxWW(const ValueType_JtNg&);
bool is_enum_hxWW(const ValueType_JtNg&);
bool is_flags_hxWW(const ValueType_JtNg&);
bool is_reinterpretable_1qjp(const ValueType_JtNg&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&);
static fu::vec<SolvedNode_efhg> solveNodes_gDsn(fu::view<Node_JjyR>, DeadBreak_Z4ob, const Type_OiTm&, const Type_OiTm&, bool, StaticEval_IZio, bool, CurrentFn_QbLp&, SolverState_aGlN&, const Context_noPA&, TokenIdx_5581&, Module_wo7O&, const Options_TBgD&, fu::vec<Helpers_DyqV>&);
static SolvedNode_efhg solveCall_FDl5(fu::str&&, fu::vec<SolvedNode_efhg>&&, Flags_Lzg8, fu::view<Target_VZrr>, CurrentFn_QbLp&, SolverState_aGlN&, const Context_noPA&, TokenIdx_5581&, Module_wo7O&, const Options_TBgD&, fu::vec<Helpers_DyqV>&);
static void TODO_FIX_partialEvalTypeAnnot_gDsn(Node_JjyR&, CurrentFn_QbLp&, SolverState_aGlN&, const Context_noPA&, TokenIdx_5581&, Module_wo7O&, const Options_TBgD&, fu::vec<Helpers_DyqV>&);
Lifetime_llCF Lifetime_makeShared_7Yz9(const Lifetime_llCF&, int, const Context_noPA&, const TokenIdx_5581&);
NativeQualities_5Qbp NativeQualities_UvH3(fu::view<char>);
void add_xQNS(MayEscapeVia_5nki&, int);
void add_range_ZwXY(BitSet_mmp7&, int);
void remove_ZwXY(BitSet_mmp7&, const BitSet_mmp7&);
bool is_rx_resize_9CJm(const ValueType_JtNg&);
inline static void visit_8CGM(const Lifetime_llCF&, bool&, int, bool&, const SolverState_aGlN&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&, const Options_TBgD&, fu::view<Helpers_DyqV>);
static fu::str qSTACK_local_FDl5(const Target_VZrr&, const SolvedNode_efhg&, int, fu::view<Target_VZrr>, ArgQuery_O2xW, const CurrentFn_QbLp&, SolverState_aGlN&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&, const Options_TBgD&, fu::view<Helpers_DyqV>);
BitSet_mmp7 negated_ZwXY(const BitSet_mmp7&, int);
Lifetime_llCF Lifetime_from_UkiI(int, fu::view<char>, const Context_noPA&, const TokenIdx_5581&);
bool isPassByValue_hxWW(const ValueType_JtNg&);
static fu::str qSTACK_effect_gDsn(const Target_VZrr&, const SolvedNode_efhg&, FxMask_2dRz, fu::view<Target_VZrr>, const CurrentFn_QbLp&, SolverState_aGlN&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&, const Options_TBgD&);
bool hasAssignment_vRqJ(fu::view<char>);
void isRTL_set_xQNS(Overload_aO3i&, bool);
static bool astChange_gDsn(const SolvedNode_efhg&, const SolvedNode_efhg&);
bool isIrrelevantOrNever_9CJm(const Type_OiTm&);
inline static void visit_lQfI(const Lifetime_llCF&, Lifetime_llCF&, bool&, bool, const SolverState_aGlN&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&, const Options_TBgD&, fu::view<Helpers_DyqV>);
static void runAllPasses_gDsn(SolvedNode_efhg&, CurrentFn_QbLp&, SolverState_aGlN&, const Context_noPA&, TokenIdx_5581&, Module_wo7O&, const Options_TBgD&, fu::vec<Helpers_DyqV>&);
static bool lazySolveStart_gDsn(const Target_VZrr&, CurrentFn_QbLp&, SolverState_aGlN&, const Context_noPA&, TokenIdx_5581&, Module_wo7O&, const Options_TBgD&, fu::vec<Helpers_DyqV>&);
static void cannotCOW_climbParents_gDsn(const Lifetime_llCF&, fu::view<int>, const SolvedNode_efhg&, const TokenIdx_5581&, const Target_VZrr&, const Argument_bbKc&, bool, CurrentFn_QbLp&, SolverState_aGlN&, const Context_noPA&, TokenIdx_5581&, const Module_wo7O&, const Options_TBgD&, fu::view<Helpers_DyqV>);
Lifetime_llCF Lifetime_inter_7Yz9(const Lifetime_llCF&, const Lifetime_llCF&, const Context_noPA&, const TokenIdx_5581&);
Shape_fvCX getShape_1qjp(const ValueType_JtNg&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&);
inline static bool type_maybeInside_8aZ0(const ValueType_JtNg&, const ValueType_JtNg&, uint64_t, Set_pEwD&, const SolverState_aGlN&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&);
StructCanon_TixV parseStructCanon_p1TN(fu::view<char>);
inline static bool type_maybeInside_KAHl(const ValueType_JtNg&, unsigned, const ValueType_JtNg&, uint64_t, Set_pEwD&, const SolverState_aGlN&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&);
bool Lifetime_has_7Yz9(const Lifetime_llCF&, int);
static fu::str qSTACK_cow_inside_gDsn(const Target_VZrr&, const SolvedNode_efhg&, const Argument_bbKc&, const TokenIdx_5581&, fu::view<Target_VZrr>, const CurrentFn_QbLp&, SolverState_aGlN&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&, const Options_TBgD&, fu::view<Helpers_DyqV>);
static void cannotCOW_descendChildren_gDsn(int, const Lifetime_llCF&, fu::view<int>, const SolvedNode_efhg&, const TokenIdx_5581&, const Target_VZrr&, const Argument_bbKc&, bool, const CurrentFn_QbLp&, SolverState_aGlN&, const Context_noPA&, TokenIdx_5581&, const Module_wo7O&, const Options_TBgD&, fu::view<Helpers_DyqV>);
inline static int needsHardRisk_sScE(int, const Overload_aO3i&, const SolvedNode_efhg&, const Target_VZrr&, const Argument_bbKc&, bool, const CurrentFn_QbLp&, const SolverState_aGlN&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&);
Type_OiTm USAGE_fieldUsageFromStructUsage_GgXY(Type_OiTm&&, unsigned, int, int);
unsigned Lifetime_shiftUsage_7Yz9(fu::view<char>, unsigned, const Context_noPA&, const TokenIdx_5581&);
static void callarg_trackWrites_gDsn(const Lifetime_llCF&, unsigned, const SolvedNode_efhg&, CurrentFn_QbLp&, SolverState_aGlN&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&, const Options_TBgD&, fu::view<Helpers_DyqV>);
bool USAGE_justOneThing_9CJm(unsigned, int);
static bool isFieldChain_gDsn(const SolvedNode_efhg&, const SolverState_aGlN&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&);
bool is_rx_move_9CJm(const Type_OiTm&);
Type_OiTm make_copyable_9CJm(Type_OiTm&&);
Type_OiTm make_moveable_9CJm(Type_OiTm&&);
static void Lifetime_F_MOVED_FROM_gDsn(const Lifetime_llCF&, SolverState_aGlN&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&, const Options_TBgD&, fu::view<Helpers_DyqV>);
static bool tryInjectJumps_gDsn(SolvedNode_efhg&, const Helpers_DyqV&, const SolverState_aGlN&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&, const Options_TBgD&, fu::view<Helpers_DyqV>);

                                #ifndef DEF_TODO_FIX_static_ZSTs
                                #define DEF_TODO_FIX_static_ZSTs
inline constexpr bool TODO_FIX_static_ZSTs = true;
                                #endif
static bool RESOLVE_byAAR_gDsn(int, int, bool, BorrowCheckPass_i0wt, CurrentFn_QbLp&, const SolverState_aGlN&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&, const Options_TBgD&, fu::view<Helpers_DyqV>);
static void bck_node_gDsn(SolvedNode_efhg&, const SolvedNode_efhg&, BorrowCheckPass_i0wt, CurrentFn_QbLp&, SolverState_aGlN&, const Context_noPA&, TokenIdx_5581&, const Module_wo7O&, const Options_TBgD&, fu::view<Helpers_DyqV>);
RWQuals_ELUY USAGE_structUsageFromFieldUsage_z5tF(const RWQuals_ELUY&, int);
unsigned getRegionUsage_CaGD(int, int);
fu::vec<int> Lifetime_interLocids_7Yz9(const Lifetime_llCF&, const Lifetime_llCF&, const Context_noPA&, const TokenIdx_5581&);
void add_Na55(BitSet_mmp7&, const BitSet_mmp7&);
inline static void verifyCopyNotRedundant_PNkz(const Lifetime_llCF&, bool&, const CurrentFn_QbLp&, const SolverState_aGlN&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&);
Lifetime_llCF Lifetime_AAR_7Yz9(int, const Context_noPA&, const TokenIdx_5581&);
void clear_ZwXY(BitSet_mmp7&);
bool has_missing_ZwXY(const BitSet_mmp7&, const BitSet_mmp7&);
static SolvedNode_efhg __solveStruct_gDsn(bool, const Node_JjyR&, const Target_VZrr&, bool, CurrentFn_QbLp&, SolverState_aGlN&, const Context_noPA&, TokenIdx_5581&, Module_wo7O&, const Options_TBgD&, fu::vec<Helpers_DyqV>&);
TEA_0Daz hash_s9RC(fu::vec_range<char>);
void hash_l6RU(TEA_0Daz&, fu::vec_range<char>);
void appendGlobal_xQNS(fu::vec_range_mut<char>, const Target_VZrr&);
fu::str createStructCanon_p1TN(Kind_Idfg, fu::view<char>, int, int, fu::view<char>, uint64_t);
unsigned speculateStruct_9CJm(DeclAsserts_taUG, int);
Struct_LDkB& lookupUserType_mut_1qjp(fu::view<char>, Module_wo7O&, const Context_noPA&, const TokenIdx_5581&);
Type_OiTm despeculateStruct_9CJm(Type_OiTm&&);
void hash_qRo1(TEA_0Daz&, uint64_t);

                                #ifndef DEF_Quals_bitsize
                                #define DEF_Quals_bitsize
inline constexpr int Quals_bitsize = 32;
                                #endif

                                #ifndef DEF_q_TAGS_bitsize
                                #define DEF_q_TAGS_bitsize
inline constexpr int q_TAGS_bitsize = 3;
                                #endif

                                #ifndef DEF_q_USAGE_bitsize
                                #define DEF_q_USAGE_bitsize
inline constexpr int q_USAGE_bitsize = (Quals_bitsize - q_TAGS_bitsize);
                                #endif
static fu::str TODO_FIX_getRecursionError_gDsn(const Struct_LDkB&, const Type_OiTm&, const CurrentFn_QbLp&, const SolverState_aGlN&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&, const Options_TBgD&, fu::view<Helpers_DyqV>);
Intlit_tw2d Intlit_MpuZ(uint64_t, bool, fu::str&&, bool, bool, uint64_t);
Type_OiTm make_non_copyable_9CJm(Type_OiTm&&);
void USAGE_setMaxUsage_CaGD(Type_OiTm&, int);
static void visit_gDsn(int, SolverState_aGlN&, const Context_noPA&, const TokenIdx_5581&);
inline static void walk_w5Bw(Node_JjyR&, fu::view<char>, fu::view<char>, fu::view<char>, fu::view<char>, const ScopeItem_xiLD&);
void hash_lweH(TEA_0Daz&, const TEA_0Daz&);
static void sighashNode_gDsn(const SolvedNode_efhg&, const Target_VZrr&, TEA_0Daz&, Map_ZxRu&, fu::vec<Target_VZrr>&, Set_R8IU&, const CurrentFn_QbLp&, SolverState_aGlN&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&, const Options_TBgD&, const fu::vec<Helpers_DyqV>&);
static const TEA_0Daz& computeFnSighash_gDsn(const Target_VZrr&, Map_ZxRu&, fu::vec<Target_VZrr>&, Set_R8IU&, const CurrentFn_QbLp&, SolverState_aGlN&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&, const Options_TBgD&, const fu::vec<Helpers_DyqV>&);
void hash_qw8S(TEA_0Daz&, unsigned);
TEA_0Daz& non_zero_lweH(TEA_0Daz&);
static void flag_gDsn(Regions_9N5a&, const Lifetime_llCF&, bool, fu::view<BitSet_mmp7>, fu::view<int>, const CurrentFn_QbLp&, const SolverState_aGlN&, const Context_noPA&, const TokenIdx_5581&, const Module_wo7O&, const Options_TBgD&, fu::view<Helpers_DyqV>);
static void visit_FDl5(SolvedNode_efhg&, fu::view<BitSet_mmp7>, fu::view<int>, int&, Unsequenced_MqaY&, const CurrentFn_QbLp&, SolverState_aGlN&, const Context_noPA&, TokenIdx_5581&, const Module_wo7O&, const Options_TBgD&, fu::view<Helpers_DyqV>);
bool has_inter_ZwXY(const BitSet_mmp7&, const BitSet_mmp7&);
Scope_blWT Scope_exports_z0Qq(const Scope_blWT&, int, fu::vec_range<int>);

                                #ifndef DEF_Kind_Idfg
                                #define DEF_Kind_Idfg
enum Kind_Idfg: fu::u8
{
    Kind_Idfg_sof = 1u,
    Kind_Idfg_err = 2u,
    Kind_Idfg_eof = 3u,
    Kind_Idfg_id = 4u,
    Kind_Idfg_op = 5u,
    Kind_Idfg_int = 6u,
    Kind_Idfg_real = 7u,
    Kind_Idfg_char = 8u,
    Kind_Idfg_str = 9u,
    Kind_Idfg_bool = 10u,
    Kind_Idfg_definit = 11u,
    Kind_Idfg_empty = 12u,
    Kind_Idfg_struct = 13u,
    Kind_Idfg_union = 14u,
    Kind_Idfg_primitive = 15u,
    Kind_Idfg_flags = 16u,
    Kind_Idfg_enum = 17u,
    Kind_Idfg_fn = 18u,
    Kind_Idfg_copy = 19u,
    Kind_Idfg_move = 20u,
    Kind_Idfg_arrlit = 21u,
    Kind_Idfg_not = 22u,
    Kind_Idfg_call = 23u,
    Kind_Idfg_call_indir = 24u,
    Kind_Idfg_argid = 25u,
    Kind_Idfg_root = 26u,
    Kind_Idfg_block = 27u,
    Kind_Idfg_if = 28u,
    Kind_Idfg_or = 29u,
    Kind_Idfg_and = 30u,
    Kind_Idfg_loop = 31u,
    Kind_Idfg_jump = 32u,
    Kind_Idfg___far_jump = 33u,
    Kind_Idfg_defer = 34u,
    Kind_Idfg_try = 35u,
    Kind_Idfg_let = 36u,
    Kind_Idfg_letdef = 37u,
    Kind_Idfg_typecast = 38u,
    Kind_Idfg_typeassert = 39u,
    Kind_Idfg_typeparam = 40u,
    Kind_Idfg_unwrap = 41u,
    Kind_Idfg_pragma = 42u,
    Kind_Idfg_break = 43u,
    Kind_Idfg_return = 44u,
    Kind_Idfg_continue = 45u,
    Kind_Idfg_import = 46u,
    Kind_Idfg_addroffn = 47u,
    Kind_Idfg_forfieldsof = 48u,
    Kind_Idfg_members = 49u,
    Kind_Idfg_fnbranch = 50u,
    Kind_Idfg_pattern = 51u,
    Kind_Idfg_typeunion = 52u,
    Kind_Idfg_typetag = 53u,
    Kind_Idfg___relaxed = 54u,
    Kind_Idfg___convert = 55u,
    Kind_Idfg___preceding_ref_arg = 56u,
    Kind_Idfg___serialized_type = 57u,
    Kind_Idfg___serialized_addrof_type_fn = 58u,
    Kind_Idfg___litfix_bound = 59u,
    Kind_Idfg___no_kind_yet = 60u,
    Kind_Idfg___tombstone = 61u,
    Kind_Idfg_type = 62u,
    Kind_Idfg_var = 63u,
    Kind_Idfg_field = 64u,
    Kind_Idfg_enumv = 65u,
    Kind_Idfg_template = 66u,
    Kind_Idfg___native = 67u,
    Kind_Idfg_inline = 68u,
};
                                #endif

                                #ifndef DEF_Flags_Lzg8
                                #define DEF_Flags_Lzg8
inline constexpr Flags_Lzg8 Flags_Lzg8_F_CALL_HAS_DOT = 1u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_CALL_HAS_ARGPARENS = 2u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_CALL_HAS_NAMED_ARGS = 4u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_OPERATOR = 8u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_TYPENAME = 16u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_COMPOUND_ID = 32u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_ARGID_IS_OPTIONAL = 64u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_LAX = 128u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_SHADOW = 256u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_MUSTNAME = 512u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_MUT = 1024u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_CONST = 2048u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_VAL = 4096u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_REF = 8192u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_IMPLICIT = 16384u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_USING = 32768u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_CONVERSION = 65536u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_TEST_painted = 131072u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_PUB = 262144u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_EXTERN = 524288u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_HOTSWAP = 1048576u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_PREDICATE = 2097152u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_LT_RETURNED = 4194304u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_REST_ARG = 8388608u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_INJECTED = 16777216u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_TEMPLATE = 33554432u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_INLINE = 67108864u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_LAMBDA = 134217728u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_COW_INSIDE = 268435456u;

inline constexpr Flags_Lzg8 MASK_Flags_Lzg8
    = Flags_Lzg8_F_CALL_HAS_DOT
    | Flags_Lzg8_F_CALL_HAS_ARGPARENS
    | Flags_Lzg8_F_CALL_HAS_NAMED_ARGS
    | Flags_Lzg8_F_OPERATOR
    | Flags_Lzg8_F_TYPENAME
    | Flags_Lzg8_F_COMPOUND_ID
    | Flags_Lzg8_F_ARGID_IS_OPTIONAL
    | Flags_Lzg8_F_LAX
    | Flags_Lzg8_F_SHADOW
    | Flags_Lzg8_F_MUSTNAME
    | Flags_Lzg8_F_MUT
    | Flags_Lzg8_F_CONST
    | Flags_Lzg8_F_VAL
    | Flags_Lzg8_F_REF
    | Flags_Lzg8_F_IMPLICIT
    | Flags_Lzg8_F_USING
    | Flags_Lzg8_F_CONVERSION
    | Flags_Lzg8_F_TEST_painted
    | Flags_Lzg8_F_PUB
    | Flags_Lzg8_F_EXTERN
    | Flags_Lzg8_F_HOTSWAP
    | Flags_Lzg8_F_PREDICATE
    | Flags_Lzg8_F_LT_RETURNED
    | Flags_Lzg8_F_REST_ARG
    | Flags_Lzg8_F_INJECTED
    | Flags_Lzg8_F_TEMPLATE
    | Flags_Lzg8_F_INLINE
    | Flags_Lzg8_F_LAMBDA
    | Flags_Lzg8_F_COW_INSIDE;
                                #endif

                                #ifndef DEF_VFacts_xhRf
                                #define DEF_VFacts_xhRf
inline constexpr VFacts_xhRf VFacts_xhRf_AlwaysTrue = VFacts_xhRf(1u);
inline constexpr VFacts_xhRf VFacts_xhRf_AlwaysFalse = VFacts_xhRf(2u);
inline constexpr VFacts_xhRf VFacts_xhRf_Typename = VFacts_xhRf(4u);
inline constexpr VFacts_xhRf VFacts_xhRf_LeftAligned = VFacts_xhRf(8u);
inline constexpr VFacts_xhRf VFacts_xhRf_RightAligned = VFacts_xhRf(16u);

inline constexpr VFacts_xhRf MASK_VFacts_xhRf
    = VFacts_xhRf_AlwaysTrue
    | VFacts_xhRf_AlwaysFalse
    | VFacts_xhRf_Typename
    | VFacts_xhRf_LeftAligned
    | VFacts_xhRf_RightAligned;
                                #endif

                                #ifndef DEF_SolverStatus_h9em
                                #define DEF_SolverStatus_h9em
inline constexpr SolverStatus_h9em SolverStatus_h9em_SS_LAZY = SolverStatus_h9em(1u);
inline constexpr SolverStatus_h9em SolverStatus_h9em_SS_DID_START = SolverStatus_h9em(2u);
inline constexpr SolverStatus_h9em SolverStatus_h9em_SS_DIRTY = SolverStatus_h9em(4u);
inline constexpr SolverStatus_h9em SolverStatus_h9em_SS_FINALIZED = SolverStatus_h9em(8u);
inline constexpr SolverStatus_h9em SolverStatus_h9em_SS_UPDATED = SolverStatus_h9em(16u);
inline constexpr SolverStatus_h9em SolverStatus_h9em_SS_TYPE_RECUR = SolverStatus_h9em(32u);
inline constexpr SolverStatus_h9em SolverStatus_h9em_SS_FN_RECUR = SolverStatus_h9em(64u);
inline constexpr SolverStatus_h9em SolverStatus_h9em_SS_FN_OOE_RTL = SolverStatus_h9em(128u);
inline constexpr SolverStatus_h9em SolverStatus_h9em_SS_NAME_UNUSED = SolverStatus_h9em(256u);
inline constexpr SolverStatus_h9em SolverStatus_h9em_SS_UNUSED = SolverStatus_h9em(512u);
inline constexpr SolverStatus_h9em SolverStatus_h9em_SS_MATCHED = SolverStatus_h9em(1024u);
inline constexpr SolverStatus_h9em SolverStatus_h9em_SS_MOVED_FROM = SolverStatus_h9em(2048u);
inline constexpr SolverStatus_h9em SolverStatus_h9em_SS_EXTERNAL_LINKAGE = SolverStatus_h9em(4096u);
inline constexpr SolverStatus_h9em SolverStatus_h9em_SS_OBSERVED_BY_CONV_CACHE = SolverStatus_h9em(8192u);
inline constexpr SolverStatus_h9em SolverStatus_h9em_SS_TODO_FIX_was_rx_resize = SolverStatus_h9em(16384u);
inline constexpr SolverStatus_h9em SolverStatus_h9em_SS_Debug_AllPassesComplete = SolverStatus_h9em(32768u);

inline constexpr SolverStatus_h9em MASK_SolverStatus_h9em
    = SolverStatus_h9em_SS_LAZY
    | SolverStatus_h9em_SS_DID_START
    | SolverStatus_h9em_SS_DIRTY
    | SolverStatus_h9em_SS_FINALIZED
    | SolverStatus_h9em_SS_UPDATED
    | SolverStatus_h9em_SS_TYPE_RECUR
    | SolverStatus_h9em_SS_FN_RECUR
    | SolverStatus_h9em_SS_FN_OOE_RTL
    | SolverStatus_h9em_SS_NAME_UNUSED
    | SolverStatus_h9em_SS_UNUSED
    | SolverStatus_h9em_SS_MATCHED
    | SolverStatus_h9em_SS_MOVED_FROM
    | SolverStatus_h9em_SS_EXTERNAL_LINKAGE
    | SolverStatus_h9em_SS_OBSERVED_BY_CONV_CACHE
    | SolverStatus_h9em_SS_TODO_FIX_was_rx_resize
    | SolverStatus_h9em_SS_Debug_AllPassesComplete;
                                #endif

                                #ifndef DEF_DeclAsserts_taUG
                                #define DEF_DeclAsserts_taUG
inline constexpr DeclAsserts_taUG DeclAsserts_taUG_A_NOCOPY = DeclAsserts_taUG(1u);
inline constexpr DeclAsserts_taUG DeclAsserts_taUG_A_NOVEC = DeclAsserts_taUG(2u);
inline constexpr DeclAsserts_taUG DeclAsserts_taUG_A_TRIVIAL = DeclAsserts_taUG(4u);
inline constexpr DeclAsserts_taUG DeclAsserts_taUG_A_NODISCARD = DeclAsserts_taUG(8u);
inline constexpr DeclAsserts_taUG DeclAsserts_taUG_A_PURE = DeclAsserts_taUG(16u);
inline constexpr DeclAsserts_taUG DeclAsserts_taUG_A_PURE_CTX = DeclAsserts_taUG(32u);
inline constexpr DeclAsserts_taUG DeclAsserts_taUG_A_PURE_FX = DeclAsserts_taUG(64u);
inline constexpr DeclAsserts_taUG DeclAsserts_taUG_A_NOFLOW = DeclAsserts_taUG(128u);
inline constexpr DeclAsserts_taUG DeclAsserts_taUG_A_NOTHROW = DeclAsserts_taUG(256u);
inline constexpr DeclAsserts_taUG DeclAsserts_taUG_A_NOCRASH = DeclAsserts_taUG(512u);
inline constexpr DeclAsserts_taUG DeclAsserts_taUG_A_NOIO = DeclAsserts_taUG(1024u);
inline constexpr DeclAsserts_taUG DeclAsserts_taUG_A_FAST = DeclAsserts_taUG(2048u);
inline constexpr DeclAsserts_taUG DeclAsserts_taUG_A_NOINLINE = DeclAsserts_taUG(4096u);

inline constexpr DeclAsserts_taUG MASK_DeclAsserts_taUG
    = DeclAsserts_taUG_A_NOCOPY
    | DeclAsserts_taUG_A_NOVEC
    | DeclAsserts_taUG_A_TRIVIAL
    | DeclAsserts_taUG_A_NODISCARD
    | DeclAsserts_taUG_A_PURE
    | DeclAsserts_taUG_A_PURE_CTX
    | DeclAsserts_taUG_A_PURE_FX
    | DeclAsserts_taUG_A_NOFLOW
    | DeclAsserts_taUG_A_NOTHROW
    | DeclAsserts_taUG_A_NOCRASH
    | DeclAsserts_taUG_A_NOIO
    | DeclAsserts_taUG_A_FAST
    | DeclAsserts_taUG_A_NOINLINE;
                                #endif

                                #ifndef DEF_MayEscapeVia_5nki
                                #define DEF_MayEscapeVia_5nki
                                #endif

                                #ifndef DEF_ExitPaths_UXHs
                                #define DEF_ExitPaths_UXHs
inline constexpr ExitPaths_UXHs ExitPaths_UXHs_XP_NonEmptyReturn = ExitPaths_UXHs(1u);
inline constexpr ExitPaths_UXHs ExitPaths_UXHs_XP_EmptyReturn = ExitPaths_UXHs(2u);
inline constexpr ExitPaths_UXHs ExitPaths_UXHs_XP_NoReturn = ExitPaths_UXHs(4u);

inline constexpr ExitPaths_UXHs MASK_ExitPaths_UXHs
    = ExitPaths_UXHs_XP_NonEmptyReturn
    | ExitPaths_UXHs_XP_EmptyReturn
    | ExitPaths_UXHs_XP_NoReturn;
                                #endif

                                #ifndef DEF_ParseSyntax_Lay2
                                #define DEF_ParseSyntax_Lay2
inline constexpr ParseSyntax_Lay2 ParseSyntax_Lay2_PS_PARENS = ParseSyntax_Lay2(1u);
inline constexpr ParseSyntax_Lay2 ParseSyntax_Lay2_PS_DISCARD_IF_BLOCK_TAIL = ParseSyntax_Lay2(2u);
inline constexpr ParseSyntax_Lay2 ParseSyntax_Lay2_PS_ALWAYS_DISCARD = ParseSyntax_Lay2(4u);
inline constexpr ParseSyntax_Lay2 ParseSyntax_Lay2_PS_NOT_AN_EXPRESSION = ParseSyntax_Lay2(8u);
inline constexpr ParseSyntax_Lay2 ParseSyntax_Lay2_PS_USING_EXPRESSION = ParseSyntax_Lay2(16u);

inline constexpr ParseSyntax_Lay2 MASK_ParseSyntax_Lay2
    = ParseSyntax_Lay2_PS_PARENS
    | ParseSyntax_Lay2_PS_DISCARD_IF_BLOCK_TAIL
    | ParseSyntax_Lay2_PS_ALWAYS_DISCARD
    | ParseSyntax_Lay2_PS_NOT_AN_EXPRESSION
    | ParseSyntax_Lay2_PS_USING_EXPRESSION;
                                #endif

                                #ifndef DEF_FxMask_2dRz
                                #define DEF_FxMask_2dRz
inline constexpr FxMask_2dRz FxMask_2dRz_Fx_NotDeadCode = FxMask_2dRz(1u);
inline constexpr FxMask_2dRz FxMask_2dRz_Fx_NonDeterministic = FxMask_2dRz(2u);
inline constexpr FxMask_2dRz FxMask_2dRz_Fx_DontMoveUp = FxMask_2dRz(4u);
inline constexpr FxMask_2dRz FxMask_2dRz_Fx_DontMoveDown = FxMask_2dRz(8u);
inline constexpr FxMask_2dRz FxMask_2dRz_Fx_Input = FxMask_2dRz(16u);
inline constexpr FxMask_2dRz FxMask_2dRz_Fx_Output = FxMask_2dRz(32u);
inline constexpr FxMask_2dRz FxMask_2dRz_Fx_Throws = FxMask_2dRz(64u);
inline constexpr FxMask_2dRz FxMask_2dRz_Fx_Crashes = FxMask_2dRz(128u);
inline constexpr FxMask_2dRz FxMask_2dRz_Fx_Crashes_Div0 = FxMask_2dRz(256u);
inline constexpr FxMask_2dRz FxMask_2dRz_Fx_Crashes_OOB = FxMask_2dRz(512u);
inline constexpr FxMask_2dRz FxMask_2dRz_Fx_Crashes_Assert = FxMask_2dRz(1024u);
inline constexpr FxMask_2dRz FxMask_2dRz_Fx_Crashes_Exit = FxMask_2dRz(2048u);
inline constexpr FxMask_2dRz FxMask_2dRz_Fx_Syscall = FxMask_2dRz(4096u);
inline constexpr FxMask_2dRz FxMask_2dRz_Fx_Blocks = FxMask_2dRz(8192u);
inline constexpr FxMask_2dRz FxMask_2dRz_Fx_Blocks_Alloc = FxMask_2dRz(16384u);
inline constexpr FxMask_2dRz FxMask_2dRz_Fx_Blocks_Await = FxMask_2dRz(32768u);

inline constexpr FxMask_2dRz MASK_FxMask_2dRz
    = FxMask_2dRz_Fx_NotDeadCode
    | FxMask_2dRz_Fx_NonDeterministic
    | FxMask_2dRz_Fx_DontMoveUp
    | FxMask_2dRz_Fx_DontMoveDown
    | FxMask_2dRz_Fx_Input
    | FxMask_2dRz_Fx_Output
    | FxMask_2dRz_Fx_Throws
    | FxMask_2dRz_Fx_Crashes
    | FxMask_2dRz_Fx_Crashes_Div0
    | FxMask_2dRz_Fx_Crashes_OOB
    | FxMask_2dRz_Fx_Crashes_Assert
    | FxMask_2dRz_Fx_Crashes_Exit
    | FxMask_2dRz_Fx_Syscall
    | FxMask_2dRz_Fx_Blocks
    | FxMask_2dRz_Fx_Blocks_Alloc
    | FxMask_2dRz_Fx_Blocks_Await;
                                #endif

                                #ifndef DEF_SolverNotes_LSla
                                #define DEF_SolverNotes_LSla
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_FnRecursion = 1;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_FnResolve = 2;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_FnReopen = 4;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_TypeRecursion = 8;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_TypeResolve = 16;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_TypeReopen = 32;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_DeadCode = 64;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_DeadCall = 128;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_DeadLet = 256;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_DeadArrlit = 512;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_DeadLoopInit = 1024;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_DeadConv = 2048;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_NonTrivAutoCopy = 4096;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_RelaxRespec = 8192;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_UnusedImplicit = 16384;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_UnusedCall = 32768;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_UnusedDefer = 65536;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_UnusedTry = 131072;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_UnusedAndOr = 262144;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_UnusedIfElse = 524288;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_UnusedArrlit = 1048576;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_UnusedLet = 2097152;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_BckMustSeq = 4194304;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_AARMustSeq = 8388608;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_AARSoftRisk = 16777216;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_MoveMustSeq = 33554432;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_McomUnwrapsLetdef = 67108864;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_SD_HasStaticInit = 134217728;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_SD_ExternPrivates = 268435456;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_COWRestrict = 536870912;

inline constexpr SolverNotes_LSla MASK_SolverNotes_LSla
    = SolverNotes_LSla_N_FnRecursion
    | SolverNotes_LSla_N_FnResolve
    | SolverNotes_LSla_N_FnReopen
    | SolverNotes_LSla_N_TypeRecursion
    | SolverNotes_LSla_N_TypeResolve
    | SolverNotes_LSla_N_TypeReopen
    | SolverNotes_LSla_N_DeadCode
    | SolverNotes_LSla_N_DeadCall
    | SolverNotes_LSla_N_DeadLet
    | SolverNotes_LSla_N_DeadArrlit
    | SolverNotes_LSla_N_DeadLoopInit
    | SolverNotes_LSla_N_DeadConv
    | SolverNotes_LSla_N_NonTrivAutoCopy
    | SolverNotes_LSla_N_RelaxRespec
    | SolverNotes_LSla_N_UnusedImplicit
    | SolverNotes_LSla_N_UnusedCall
    | SolverNotes_LSla_N_UnusedDefer
    | SolverNotes_LSla_N_UnusedTry
    | SolverNotes_LSla_N_UnusedAndOr
    | SolverNotes_LSla_N_UnusedIfElse
    | SolverNotes_LSla_N_UnusedArrlit
    | SolverNotes_LSla_N_UnusedLet
    | SolverNotes_LSla_N_BckMustSeq
    | SolverNotes_LSla_N_AARMustSeq
    | SolverNotes_LSla_N_AARSoftRisk
    | SolverNotes_LSla_N_MoveMustSeq
    | SolverNotes_LSla_N_McomUnwrapsLetdef
    | SolverNotes_LSla_N_SD_HasStaticInit
    | SolverNotes_LSla_N_SD_ExternPrivates
    | SolverNotes_LSla_N_COWRestrict;
                                #endif

                                #ifndef DEF_Helpers_DyqVC1yXPkj
                                #define DEF_Helpers_DyqVC1yXPkj
struct Helpers_DyqV
{
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_Target_VZrrYUw5Awd
                                #define DEF_Target_VZrrYUw5Awd
struct Target_VZrr
{
    uint64_t _packed;
    explicit operator bool() const noexcept
    {
        return false
            || _packed
        ;
    }
};
                                #endif

                                #ifndef DEF_Lifetime_llCFAn7rdDl
                                #define DEF_Lifetime_llCFAn7rdDl
struct Lifetime_llCF
{
    fu::str uni0n;
    explicit operator bool() const noexcept
    {
        return false
            || uni0n
        ;
    }
};
                                #endif

                                #ifndef DEF_BitSet_mmp7xBZ4kaf
                                #define DEF_BitSet_mmp7xBZ4kaf
struct BitSet_mmp7
{
    fu::vec<fu::u8> _data;
    explicit operator bool() const noexcept
    {
        return false
            || _data
        ;
    }
};
                                #endif

                                #ifndef DEF_TEA_0DazMLEH01f
                                #define DEF_TEA_0DazMLEH01f
struct TEA_0Daz
{
    unsigned v0;
    unsigned v1;
    explicit operator bool() const noexcept
    {
        return false
            || v0
            || v1
        ;
    }
};
                                #endif

                                #ifndef DEF_ScopeItem_xiLD4Gix9jd
                                #define DEF_ScopeItem_xiLD4Gix9jd
struct ScopeItem_xiLD
{
    fu::str id;
    uint64_t _packed;
    explicit operator bool() const noexcept
    {
        return false
            || id
        ;
    }
};
                                #endif

                                #ifndef DEF_TokenIdx_5581Mdn3MDd
                                #define DEF_TokenIdx_5581Mdn3MDd
struct TokenIdx_5581
{
    int modid;
    int tokidx;
    explicit operator bool() const noexcept
    {
        return false
            || modid
            || tokidx
        ;
    }
};
                                #endif

                                #ifndef DEF_ValueType_JtNg3Yu4fH2
                                #define DEF_ValueType_JtNg3Yu4fH2
struct ValueType_JtNg
{
    unsigned quals;
    VFacts_xhRf vfacts;
    fu::str canon;
    explicit operator bool() const noexcept
    {
        return false
            || quals
            || vfacts
            || canon
        ;
    }
};
                                #endif

                                #ifndef DEF_Scope_blWT6MMEi3a
                                #define DEF_Scope_blWT6MMEi3a
struct Scope_blWT
{
    fu::vec<Overload_aO3i> overloads;
    fu::vec<Extended_z0HS> extended;
    fu::vec<ScopeItem_xiLD> items;
    fu::vec<ScopeItem_xiLD> implicits;
    fu::vec<ScopeItem_xiLD> globals;
    fu::vec<int> imports;
    fu::vec<int> privates;
    fu::vec<Target_VZrr> usings;
    fu::vec<Target_VZrr> converts;
    int pub_items;
    int pub_implicits;
    int pub_globals;
    int pub_converts;
    Scope_blWT(const Scope_blWT&) = delete;
    Scope_blWT(Scope_blWT&&) = default;
    Scope_blWT& operator=(const Scope_blWT&) = delete;
    Scope_blWT& operator=(Scope_blWT&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || overloads
            || extended
            || items
            || implicits
            || globals
            || imports
            || privates
            || usings
            || converts
            || pub_items
            || pub_implicits
            || pub_globals
            || pub_converts
        ;
    }
};
                                #endif

                                #ifndef DEF_Type_OiTmZNVtrhg
                                #define DEF_Type_OiTmZNVtrhg
struct Type_OiTm
{
    ValueType_JtNg vtype;
    Lifetime_llCF lifetime;
    explicit operator bool() const noexcept
    {
        return false
            || vtype
            || lifetime
        ;
    }
};
                                #endif

                                #ifndef DEF_COWInside_qvlyaYROKmj
                                #define DEF_COWInside_qvlyaYROKmj
struct COWInside_qvly
{
    ValueType_JtNg vtype;
    TokenIdx_5581 token;
    int argTarget;
    MayEscapeVia_5nki mayEscapeVia;
    ExitPaths_UXHs exitPaths;
    explicit operator bool() const noexcept
    {
        return false
            || vtype
            || token
            || argTarget
            || mayEscapeVia
            || exitPaths
        ;
    }
};
                                #endif

                                #ifndef DEF_Node_JjyRxwEqS5g
                                #define DEF_Node_JjyRxwEqS5g
struct Node_JjyR
{
    Kind_Idfg kind;
    DeclAsserts_taUG asserts;
    ParseSyntax_Lay2 syntax;
    Flags_Lzg8 flags;
    fu::str value;
    fu::vec<Node_JjyR> items;
    TokenIdx_5581 token;
    Node_JjyR(const Node_JjyR&) = default;
    Node_JjyR(Node_JjyR&&) = default;
    Node_JjyR& operator=(Node_JjyR&&) = default;
    Node_JjyR& operator=(const Node_JjyR& selfrec) { return *this = Node_JjyR(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || kind
        ;
    }
};
                                #endif

                                #ifndef DEF_Template_SsLxhvAKrZc
                                #define DEF_Template_SsLxhvAKrZc
struct Template_SsLx
{
    Node_JjyR node;
    fu::vec<int> imports;
    explicit operator bool() const noexcept
    {
        return false
            || node
        ;
    }
};
                                #endif

                                #ifndef DEF_SolvedNode_efhg6mFAbn1
                                #define DEF_SolvedNode_efhg6mFAbn1
struct SolvedNode_efhg
{
    Kind_Idfg kind;
    Helpers_DyqV helpers;
    Flags_Lzg8 flags;
    int _loop_start;
    fu::str value;
    fu::vec<SolvedNode_efhg> items;
    TokenIdx_5581 token;
    Type_OiTm type;
    Target_VZrr target;
    SolvedNode_efhg(const SolvedNode_efhg&) = default;
    SolvedNode_efhg(SolvedNode_efhg&&) = default;
    SolvedNode_efhg& operator=(SolvedNode_efhg&&) = default;
    SolvedNode_efhg& operator=(const SolvedNode_efhg& selfrec) { return *this = SolvedNode_efhg(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || kind
        ;
    }
};
                                #endif

                                #ifndef DEF_Overload_aO3iBmOu2tl
                                #define DEF_Overload_aO3iBmOu2tl
struct Overload_aO3i
{
    Kind_Idfg kind;
    Flags_Lzg8 flags;
    SolverStatus_h9em status;
    DeclAsserts_taUG asserts;
    fu::str name;
    Type_OiTm type;
    SolvedNode_efhg solved;
    explicit operator bool() const noexcept
    {
        return false
            || kind
        ;
    }
};
                                #endif

                                #ifndef DEF_Extended_z0HSOEPqb07
                                #define DEF_Extended_z0HSOEPqb07
struct Extended_z0HS
{
    int min;
    int max;
    fu::vec<Argument_bbKc> args;
    fu::vec<COWInside_qvly> cows_inside;
    Target_VZrr spec_of;
    Template_SsLx tEmplate;
    fu::vec<Overload_aO3i> args_n_locals;
    TEA_0Daz sighash;
    FxMask_2dRz fx_mask;
    int args_neg;
    explicit operator bool() const noexcept
    {
        return false
            || tEmplate
        ;
    }
};
                                #endif

                                #ifndef DEF_SolverOutput_hA3TAuh8W27
                                #define DEF_SolverOutput_hA3TAuh8W27
struct SolverOutput_hA3T
{
    SolvedNode_efhg root;
    Scope_blWT scope;
    SolverNotes_LSla notes;
    SolverOutput_hA3T(const SolverOutput_hA3T&) = delete;
    SolverOutput_hA3T(SolverOutput_hA3T&&) = default;
    SolverOutput_hA3T& operator=(const SolverOutput_hA3T&) = delete;
    SolverOutput_hA3T& operator=(SolverOutput_hA3T&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || root
            || scope
            || notes
        ;
    }
};
                                #endif

                                #ifndef DEF_Argument_bbKcjdTxEug
                                #define DEF_Argument_bbKcjdTxEug
struct Argument_bbKc
{
    fu::str name;
    fu::str autocall;
    Type_OiTm type;
    SolvedNode_efhg dEfault;
    Target_VZrr target;
    Flags_Lzg8 flags;
    unsigned written_to;
    BitSet_mmp7 may_invalidate;
    BitSet_mmp7 may_alias;
    explicit operator bool() const noexcept
    {
        return false
            || name
            || autocall
            || type
            || dEfault
            || target
            || flags
            || written_to
            || may_invalidate
            || may_alias
        ;
    }
};
                                #endif

                                #ifndef DEF_CGDefects_2L18
                                #define DEF_CGDefects_2L18
inline constexpr CGDefects_2L18 CGDefects_2L18_GNUStmtExpr = CGDefects_2L18(1u);
inline constexpr CGDefects_2L18 CGDefects_2L18_Goto = CGDefects_2L18(2u);
inline constexpr CGDefects_2L18 CGDefects_2L18_PointlessMustSeq = CGDefects_2L18(4u);
inline constexpr CGDefects_2L18 CGDefects_2L18_LocalConstBool = CGDefects_2L18(8u);
inline constexpr CGDefects_2L18 CGDefects_2L18_ConstCast = CGDefects_2L18(16u);
inline constexpr CGDefects_2L18 CGDefects_2L18_PointlessLocal = CGDefects_2L18(32u);
inline constexpr CGDefects_2L18 CGDefects_2L18_IrrelevantLiteral = CGDefects_2L18(64u);
inline constexpr CGDefects_2L18 CGDefects_2L18_DuplicateFunctions = CGDefects_2L18(128u);

inline constexpr CGDefects_2L18 MASK_CGDefects_2L18
    = CGDefects_2L18_GNUStmtExpr
    | CGDefects_2L18_Goto
    | CGDefects_2L18_PointlessMustSeq
    | CGDefects_2L18_LocalConstBool
    | CGDefects_2L18_ConstCast
    | CGDefects_2L18_PointlessLocal
    | CGDefects_2L18_IrrelevantLiteral
    | CGDefects_2L18_DuplicateFunctions;
                                #endif

                                #ifndef DEF_Set_qOJYtbQKZe4
                                #define DEF_Set_qOJYtbQKZe4
struct Set_qOJY
{
    fu::vec<int> keys_asc;
    explicit operator bool() const noexcept
    {
        return false
            || keys_asc
        ;
    }
};
                                #endif

                                #ifndef DEF_Set_XshDfC0Mim3
                                #define DEF_Set_XshDfC0Mim3
struct Set_XshD
{
    fu::vec<fu::str> keys_asc;
    explicit operator bool() const noexcept
    {
        return false
            || keys_asc
        ;
    }
};
                                #endif

                                #ifndef DEF_Sample_Time_cblj5KsY6d7
                                #define DEF_Sample_Time_cblj5KsY6d7
struct Sample_Time_cblj
{
    double time;
    explicit operator bool() const noexcept
    {
        return false
            || time
        ;
    }
};
                                #endif

                                #ifndef DEF_ModuleOrder_HMNgkDis85k
                                #define DEF_ModuleOrder_HMNgkDis85k
struct ModuleOrder_HMNg
{
    int dep_depth;
    explicit operator bool() const noexcept
    {
        return false
            || dep_depth
        ;
    }
};
                                #endif

                                #ifndef DEF_LexerOutput_DN4p6bz8JN7
                                #define DEF_LexerOutput_DN4p6bz8JN7
struct LexerOutput_DN4p
{
    fu::vec<Token_6M7a> tokens;
    explicit operator bool() const noexcept
    {
        return false
            || tokens
        ;
    }
};
                                #endif

                                #ifndef DEF_LineColChars_6JiMQvLXJS2
                                #define DEF_LineColChars_6JiMQvLXJS2
struct LineColChars_6JiM
{
    int line;
    int col;
    int chars;
    explicit operator bool() const noexcept
    {
        return false
            || line
            || col
            || chars
        ;
    }
};
                                #endif

                                #ifndef DEF_ModuleStat_sTmhPzQmjMb
                                #define DEF_ModuleStat_sTmhPzQmjMb
struct ModuleStat_sTmh
{
    double time;
    int alloc_count;
    int alloc_bytes;
    explicit operator bool() const noexcept
    {
        return false
            || time
            || alloc_count
            || alloc_bytes
        ;
    }
};
                                #endif

                                #ifndef DEF_Shape_fvCXSyBvLeh
                                #define DEF_Shape_fvCXSyBvLeh
struct Shape_fvCX
{
    fu::str basePrim;
    uint64_t non_triv_mask;
    uint64_t hash;
    int flatCount;
    int declDepth;
    explicit operator bool() const noexcept
    {
        return false
            || basePrim
            || non_triv_mask
            || hash
            || flatCount
            || declDepth
        ;
    }
};
                                #endif

                                #ifndef DEF_Profile_4UPJX2Ekm31
                                #define DEF_Profile_4UPJX2Ekm31
struct Profile_4UPJ
{
    Sample_Time_cblj now;
    explicit operator bool() const noexcept
    {
        return false
            || now
        ;
    }
};
                                #endif

                                #ifndef DEF_Map_Umhkk3Q7ESc
                                #define DEF_Map_Umhkk3Q7ESc
struct Map_Umhk
{
    Set_XshD keys;
    fu::vec<fu::str> vals;
    explicit operator bool() const noexcept
    {
        return false
            || keys
            || vals
        ;
    }
};
                                #endif

                                #ifndef DEF_Token_6M7a5ObuiN2
                                #define DEF_Token_6M7a5ObuiN2
struct Token_6M7a
{
    Kind_Idfg kind;
    LineColChars_6JiM lcc;
    fu::str value;
    explicit operator bool() const noexcept
    {
        return false
            || kind
        ;
    }
};
                                #endif

                                #ifndef DEF_Import_7CIJGVi8Ybg
                                #define DEF_Import_7CIJGVi8Ybg
struct Import_7CIJ
{
    TokenIdx_5581 token;
    fu::str pattern;
    int modid;
    explicit operator bool() const noexcept
    {
        return false
            || token
            || pattern
            || modid
        ;
    }
};
                                #endif

                                #ifndef DEF_BuildHacks_sqc0iR8AO8j
                                #define DEF_BuildHacks_sqc0iR8AO8j
struct BuildHacks_sqc0
{
    Set_XshD link;
    Set_XshD include_dirs;
    Set_XshD extra_sources;
    explicit operator bool() const noexcept
    {
        return false
            || link
            || include_dirs
            || extra_sources
        ;
    }
};
                                #endif

                                #ifndef DEF_ModuleStats_ANTRP1S5xh9
                                #define DEF_ModuleStats_ANTRP1S5xh9
struct ModuleStats_ANTR
{
    ModuleStat_sTmh lex;
    ModuleStat_sTmh parse;
    ModuleStat_sTmh solve;
    ModuleStat_sTmh codegen;
    explicit operator bool() const noexcept
    {
        return false
            || lex
            || parse
            || solve
            || codegen
        ;
    }
};
                                #endif

                                #ifndef DEF_Struct_LDkBleMfVWj
                                #define DEF_Struct_LDkBleMfVWj
struct Struct_LDkB
{
    Kind_Idfg kind;
    fu::str name;
    Target_VZrr target;
    fu::vec<ScopeItem_xiLD> items;
    fu::vec<ScopeItem_xiLD> implicits;
    Set_qOJY imports;
    fu::vec<Target_VZrr> converts;
    Shape_fvCX shape;
    explicit operator bool() const noexcept
    {
        return false
            || kind
        ;
    }
};
                                #endif

                                #ifndef DEF_NukeOnRebuild_TLE7j3PsyGg
                                #define DEF_NukeOnRebuild_TLE7j3PsyGg
struct NukeOnRebuild_TLE7
{
    Map_Umhk files;
    Map_Umhk fuzzy;
    explicit operator bool() const noexcept
    {
        return false
            || files
            || fuzzy
        ;
    }
};
                                #endif

                                #ifndef DEF_ParserOutput_d14kSKCxwSg
                                #define DEF_ParserOutput_d14kSKCxwSg
struct ParserOutput_d14k
{
    Node_JjyR root;
    fu::vec<Import_7CIJ> imports;
    fu::vec<fu::str> warnings;
    explicit operator bool() const noexcept
    {
        return false
            || root
            || imports
            || warnings
        ;
    }
};
                                #endif

                                #ifndef DEF_CodegenOutput_qIMBO7608c0
                                #define DEF_CodegenOutput_qIMBO7608c0
struct CodegenOutput_qIMB
{
    fu::str src;
    Set_XshD includes_headers;
    BuildHacks_sqc0 hacks;
    Set_qOJY testsuite_modids;
    CGDefects_2L18 defects;
    explicit operator bool() const noexcept
    {
        return false
            || src
            || includes_headers
            || hacks
            || testsuite_modids
            || defects
        ;
    }
};
                                #endif

                                #ifndef DEF_ModuleInputs_iQIgWAk3ys1
                                #define DEF_ModuleInputs_iQIgWAk3ys1
struct ModuleInputs_iQIg
{
    fu::str src;
    LexerOutput_DN4p lex;
    ParserOutput_d14k parse;
    explicit operator bool() const noexcept
    {
        return false
            || src
            || lex
            || parse
        ;
    }
};
                                #endif

                                #ifndef DEF_Context_noPAKWUf0xa
                                #define DEF_Context_noPAKWUf0xa
struct Context_noPA
{
    fu::str fudir;
    fu::str base_dir;
    fu::vec<Module_wo7O> modules;
    fu::vec<int> dep_order;
    NukeOnRebuild_TLE7 nuke;
    Context_noPA(const Context_noPA&) = delete;
    Context_noPA(Context_noPA&&) = default;
    Context_noPA& operator=(const Context_noPA&) = delete;
    Context_noPA& operator=(Context_noPA&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || fudir
            || base_dir
            || modules
            || dep_order
            || nuke
        ;
    }
};
                                #endif

                                #ifndef DEF_ModuleOutputs_WMGMpooiIO2
                                #define DEF_ModuleOutputs_WMGMpooiIO2
struct ModuleOutputs_WMGM
{
    fu::vec<Struct_LDkB> types;
    SolverOutput_hA3T solve;
    CodegenOutput_qIMB cpp;
    ModuleOutputs_WMGM(const ModuleOutputs_WMGM&) = delete;
    ModuleOutputs_WMGM(ModuleOutputs_WMGM&&) = default;
    ModuleOutputs_WMGM& operator=(const ModuleOutputs_WMGM&) = delete;
    ModuleOutputs_WMGM& operator=(ModuleOutputs_WMGM&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || types
            || solve
            || cpp
        ;
    }
};
                                #endif

                                #ifndef DEF_Module_wo7O6EZDQyh
                                #define DEF_Module_wo7O6EZDQyh
struct Module_wo7O
{
    int modid;
    fu::str fname;
    ModuleInputs_iQIg in;
    ModuleOrder_HMNg order;
    ModuleOutputs_WMGM out;
    ModuleStats_ANTR stats;
    Profile_4UPJ profile;
    Module_wo7O(const Module_wo7O&) = delete;
    Module_wo7O(Module_wo7O&&) = default;
    Module_wo7O& operator=(const Module_wo7O&) = delete;
    Module_wo7O& operator=(Module_wo7O&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || modid
            || fname
            || in
            || order
            || out
            || stats
            || profile
        ;
    }
};
                                #endif

                                #ifndef DEF_DevOptions_QEya
                                #define DEF_DevOptions_QEya
inline constexpr DevOptions_QEya DevOptions_QEya_DEV_Print = DevOptions_QEya(1u);
inline constexpr DevOptions_QEya DevOptions_QEya_DEV_Parallel = DevOptions_QEya(2u);
inline constexpr DevOptions_QEya DevOptions_QEya_DEV_ExpectFail = DevOptions_QEya(4u);
inline constexpr DevOptions_QEya DevOptions_QEya_DEV_HappyPathOnly = DevOptions_QEya(8u);
inline constexpr DevOptions_QEya DevOptions_QEya_DEV_DontFoldLiterals = DevOptions_QEya(16u);
inline constexpr DevOptions_QEya DevOptions_QEya_DEV_IgnoreDefects = DevOptions_QEya(32u);
inline constexpr DevOptions_QEya DevOptions_QEya_DEV_CG_LifetimeAnnots = DevOptions_QEya(64u);

inline constexpr DevOptions_QEya MASK_DevOptions_QEya
    = DevOptions_QEya_DEV_Print
    | DevOptions_QEya_DEV_Parallel
    | DevOptions_QEya_DEV_ExpectFail
    | DevOptions_QEya_DEV_HappyPathOnly
    | DevOptions_QEya_DEV_DontFoldLiterals
    | DevOptions_QEya_DEV_IgnoreDefects
    | DevOptions_QEya_DEV_CG_LifetimeAnnots;
                                #endif

                                #ifndef DEF_Lint_Q9R1a2Yzb4c
                                #define DEF_Lint_Q9R1a2Yzb4c
struct Lint_Q9R1
{
    int maxwarn;
    explicit operator bool() const noexcept
    {
        return false
            || maxwarn
        ;
    }
};
                                #endif

                                #ifndef DEF_Options_TBgDoLC1XOk
                                #define DEF_Options_TBgDoLC1XOk
struct Options_TBgD
{
    Lint_Q9R1 lint;
    SolverNotes_LSla break_notes;
    CGDefects_2L18 break_defects;
    DevOptions_QEya dev;
    unsigned shuffle;
    explicit operator bool() const noexcept
    {
        return false
            || lint
            || break_notes
            || break_defects
            || dev
            || shuffle
        ;
    }
};
                                #endif

                                #ifndef DEF_Set_qOJYtbQKZe4
                                #define DEF_Set_qOJYtbQKZe4
struct Set_qOJY
{
    fu::vec<int> keys_asc;
    explicit operator bool() const noexcept
    {
        return false
            || keys_asc
        ;
    }
};
                                #endif

                                #ifndef DEF_Effects_bbOXHsS5GSj
                                #define DEF_Effects_bbOXHsS5GSj
struct Effects_bbOX
{
    FxMask_2dRz fx_mask;
    explicit operator bool() const noexcept
    {
        return false
            || fx_mask
        ;
    }
};
                                #endif

                                #ifndef DEF_Set_LKfa3hiFE1i
                                #define DEF_Set_LKfa3hiFE1i
struct Set_LKfa
{
    fu::vec<WriteID_LxbZ> keys_asc;
    explicit operator bool() const noexcept
    {
        return false
            || keys_asc
        ;
    }
};
                                #endif

                                #ifndef DEF_LocidMap_IP5HE4tKmrk
                                #define DEF_LocidMap_IP5HE4tKmrk
struct LocidMap_IP5H
{
    fu::vec<unsigned> _values;
    explicit operator bool() const noexcept
    {
        return false
            || _values
        ;
    }
};
                                #endif

                                #ifndef DEF_LocidMap_m07iJizjLI4
                                #define DEF_LocidMap_m07iJizjLI4
struct LocidMap_m07i
{
    fu::vec<Set_LKfa> _values;
    explicit operator bool() const noexcept
    {
        return false
            || _values
        ;
    }
};
                                #endif

                                #ifndef DEF_LocidMap_oymasvsfnL3
                                #define DEF_LocidMap_oymasvsfnL3
struct LocidMap_oyma
{
    fu::vec<Set_qOJY> _values;
    explicit operator bool() const noexcept
    {
        return false
            || _values
        ;
    }
};
                                #endif

                                #ifndef DEF_LocidMap_X0gNiSnkKW7
                                #define DEF_LocidMap_X0gNiSnkKW7
struct LocidMap_X0gN
{
    fu::vec<Type_OiTm> _values;
    explicit operator bool() const noexcept
    {
        return false
            || _values
        ;
    }
};
                                #endif

                                #ifndef DEF_WriteID_LxbZF1IzBA9
                                #define DEF_WriteID_LxbZF1IzBA9
struct WriteID_LxbZ
{
    unsigned _locid_and_hash;
    explicit operator bool() const noexcept
    {
        return false
            || _locid_and_hash
        ;
    }
};
                                #endif

                                #ifndef DEF_LocidMap_DNUTVWagrUh
                                #define DEF_LocidMap_DNUTVWagrUh
struct LocidMap_DNUT
{
    fu::vec<LocidSet_iAWt> _values;
    explicit operator bool() const noexcept
    {
        return false
            || _values
        ;
    }
};
                                #endif

                                #ifndef DEF_LocidMap_JYqlPcBX9Wc
                                #define DEF_LocidMap_JYqlPcBX9Wc
struct LocidMap_JYql
{
    fu::vec<Lifetime_llCF> _values;
    explicit operator bool() const noexcept
    {
        return false
            || _values
        ;
    }
};
                                #endif

                                #ifndef DEF_ScopeMemo_9hVQpUFPgy3
                                #define DEF_ScopeMemo_9hVQpUFPgy3
struct ScopeMemo_9hVQ
{
    int items_len;
    int implicits_len;
    int imports_len;
    int privates_len;
    int usings_len;
    int converts_len;
    int helpers_len;
    explicit operator bool() const noexcept
    {
        return false
            || items_len
            || implicits_len
            || imports_len
            || privates_len
            || usings_len
            || converts_len
            || helpers_len
        ;
    }
};
                                #endif

                                #ifndef DEF_LocidSet_iAWtyfSxZUl
                                #define DEF_LocidSet_iAWtyfSxZUl
struct LocidSet_iAWt
{
    BitSet_mmp7 _bitset;
    explicit operator bool() const noexcept
    {
        return false
            || _bitset
        ;
    }
};
                                #endif

                                #ifndef DEF_EventsSnap_elmt5K6554c
                                #define DEF_EventsSnap_elmt5K6554c
struct EventsSnap_elmt
{
    LocidMap_m07i invalidated_by;
    explicit operator bool() const noexcept
    {
        return false
            || invalidated_by
        ;
    }
};
                                #endif

                                #ifndef DEF_VarUsage_IMaSmqWYxmh
                                #define DEF_VarUsage_IMaSmqWYxmh
struct VarUsage_IMaS
{
    LocidSet_iAWt done_relaxing;
    LocidMap_X0gN var_usage;
    explicit operator bool() const noexcept
    {
        return false
            || done_relaxing
            || var_usage
        ;
    }
};
                                #endif

                                #ifndef DEF_PostdomSnap_cfaMzQRnrx5
                                #define DEF_PostdomSnap_cfaMzQRnrx5
struct PostdomSnap_cfaM
{
    LocidSet_iAWt used_again;
    LocidMap_IP5H ever_written;
    MayEscapeVia_5nki mayEscapeVia;
    ExitPaths_UXHs exitPaths;
    explicit operator bool() const noexcept
    {
        return false
            || used_again
            || ever_written
            || mayEscapeVia
            || exitPaths
        ;
    }
};
                                #endif

                                #ifndef DEF_Events_SbUbTf9DjZg
                                #define DEF_Events_SbUbTf9DjZg
struct Events_SbUb
{
    EventsSnap_elmt snap;
    LocidSet_iAWt used_in_a_loop;
    fu::vec<PrecedingRefArg_Bnyy> preceding_ref_args;
    fu::vec<COWInside_qvly> cows_inside;
    explicit operator bool() const noexcept
    {
        return false
            || snap
            || used_in_a_loop
            || preceding_ref_args
            || cows_inside
        ;
    }
};
                                #endif

                                #ifndef DEF_Flow_oKsDxZF7xnj
                                #define DEF_Flow_oKsDxZF7xnj
struct Flow_oKsD
{
    LocidMap_JYql rg_parents;
    LocidMap_JYql rg_invalidates;
    LocidMap_oyma rg_children;
    LocidMap_DNUT at_soft_risk;
    LocidMap_DNUT at_hard_risk;
    LocidSet_iAWt bck_consider_copy;
    LocidSet_iAWt is_arg;
    LocidMap_oyma arg_parents;
    fu::vec<int> arg_targets;
    explicit operator bool() const noexcept
    {
        return false
            || rg_parents
            || rg_invalidates
            || rg_children
            || at_soft_risk
            || at_hard_risk
            || bck_consider_copy
            || is_arg
            || arg_parents
            || arg_targets
        ;
    }
};
                                #endif

                                #ifndef DEF_RevSpecPrototype_vWbrakkaPLa
                                #define DEF_RevSpecPrototype_vWbrakkaPLa
struct RevSpecPrototype_vWbr
{
    SolvedNode_efhg solved;
    fu::vec<Overload_aO3i> args_n_locals;
    int args_neg;
    explicit operator bool() const noexcept
    {
        return false
            || solved
        ;
    }
};
                                #endif

                                #ifndef DEF_Postdom_Vy5uVSIzlD7
                                #define DEF_Postdom_Vy5uVSIzlD7
struct Postdom_Vy5u
{
    PostdomSnap_cfaM snap;
    int write_loop_start;
    int read_loop_start;
    explicit operator bool() const noexcept
    {
        return false
            || snap
            || write_loop_start
            || read_loop_start
        ;
    }
};
                                #endif

                                #ifndef DEF_PrecedingRefArg_BnyyOOggiQ8
                                #define DEF_PrecedingRefArg_BnyyOOggiQ8
struct PrecedingRefArg_Bnyy
{
    TokenIdx_5581 callsite_token;
    Target_VZrr target;
    int r;
    int w;
    SolvedNode_efhg arg;
    explicit operator bool() const noexcept
    {
        return false
            || callsite_token
            || target
            || r
            || w
            || arg
        ;
    }
};
                                #endif

                                #ifndef DEF_CurrentFn_QbLpiHTyu0h
                                #define DEF_CurrentFn_QbLpiHTyu0h
struct CurrentFn_QbLp
{
    SolvedNode_efhg out;
    ScopeMemo_9hVQ scope0;
    DeclAsserts_taUG asserts;
    Flow_oKsD flow;
    Set_qOJY far_jumps;
    Effects_bbOX effects;
    Events_SbUb events;
    int autoshadow_ok;
    VarUsage_IMaS relaxed;
    bool TODO_FIX_isInline;
    int TODO_FIX_catches;
    fu::vec<Target_VZrr> already_inlined;
    int conv_safety;
    int args_neg;
    Postdom_Vy5u postdom;
    LocidMap_oyma TODO_FIX_children;
    RevSpecPrototype_vWbr rev_spec_proto;
    int TODO_FIX_bckCantDealWithNestedDefers;
    int TODO_FIX_unique;
    explicit operator bool() const noexcept
    {
        return false
            || out
        ;
    }
};
                                #endif

                                #ifndef DEF_SolverPass_zVQ2
                                #define DEF_SolverPass_zVQ2
enum SolverPass_zVQ2: fu::u8
{
    SolverPass_zVQ2_Solving = 0u,
    SolverPass_zVQ2_RelaxMut = 1u,
    SolverPass_zVQ2_BorrowCheck = 2u,
    SolverPass_zVQ2_ArgumentsAtRisk = 3u,
    SolverPass_zVQ2_MaybeCopyOrMove = 4u,
    SolverPass_zVQ2_RelaxCopyResize = 5u,
};
                                #endif

                                #ifndef DEF_HelpersMask_w1sv
                                #define DEF_HelpersMask_w1sv
inline constexpr HelpersMask_w1sv HelpersMask_w1sv_HM_CanBreak = HelpersMask_w1sv(1u);
inline constexpr HelpersMask_w1sv HelpersMask_w1sv_HM_CanReturn = HelpersMask_w1sv(2u);
inline constexpr HelpersMask_w1sv HelpersMask_w1sv_HM_Anon = HelpersMask_w1sv(4u);
inline constexpr HelpersMask_w1sv HelpersMask_w1sv_HM_Function = HelpersMask_w1sv(8u);
inline constexpr HelpersMask_w1sv HelpersMask_w1sv_HM_Lambda = HelpersMask_w1sv(16u);
inline constexpr HelpersMask_w1sv HelpersMask_w1sv_HM_Struct = HelpersMask_w1sv(32u);
inline constexpr HelpersMask_w1sv HelpersMask_w1sv_HM_LabelUsed = HelpersMask_w1sv(64u);
inline constexpr HelpersMask_w1sv HelpersMask_w1sv_HM_LoopPreheader = HelpersMask_w1sv(128u);
inline constexpr HelpersMask_w1sv HelpersMask_w1sv_HM_LoopBody = HelpersMask_w1sv(256u);

inline constexpr HelpersMask_w1sv MASK_HelpersMask_w1sv
    = HelpersMask_w1sv_HM_CanBreak
    | HelpersMask_w1sv_HM_CanReturn
    | HelpersMask_w1sv_HM_Anon
    | HelpersMask_w1sv_HM_Function
    | HelpersMask_w1sv_HM_Lambda
    | HelpersMask_w1sv_HM_Struct
    | HelpersMask_w1sv_HM_LabelUsed
    | HelpersMask_w1sv_HM_LoopPreheader
    | HelpersMask_w1sv_HM_LoopBody;
                                #endif

                                #ifndef DEF_TypeParamFlags_vSpZ
                                #define DEF_TypeParamFlags_vSpZ
inline constexpr TypeParamFlags_vSpZ TypeParamFlags_vSpZ_TP_isArgSpec = TypeParamFlags_vSpZ(1u);
inline constexpr TypeParamFlags_vSpZ TypeParamFlags_vSpZ_TP_isTypenameArgSpec = TypeParamFlags_vSpZ(2u);
inline constexpr TypeParamFlags_vSpZ TypeParamFlags_vSpZ_TP_needsConsumedTypes = TypeParamFlags_vSpZ(4u);

inline constexpr TypeParamFlags_vSpZ MASK_TypeParamFlags_vSpZ
    = TypeParamFlags_vSpZ_TP_isArgSpec
    | TypeParamFlags_vSpZ_TP_isTypenameArgSpec
    | TypeParamFlags_vSpZ_TP_needsConsumedTypes;
                                #endif

                                #ifndef DEF_Warning_9p8uyVBUuXi
                                #define DEF_Warning_9p8uyVBUuXi
struct Warning_9p8u
{
    int locid;
    explicit operator bool() const noexcept
    {
        return false
            || locid
        ;
    }
};
                                #endif

                                #ifndef DEF_Set_XshDfC0Mim3
                                #define DEF_Set_XshDfC0Mim3
struct Set_XshD
{
    fu::vec<fu::str> keys_asc;
    explicit operator bool() const noexcept
    {
        return false
            || keys_asc
        ;
    }
};
                                #endif

                                #ifndef DEF_Set_X4pja6NH2Pc
                                #define DEF_Set_X4pja6NH2Pc
struct Set_X4pj
{
    fu::vec<ValueType_JtNg> keys_asc;
    explicit operator bool() const noexcept
    {
        return false
            || keys_asc
        ;
    }
};
                                #endif

                                #ifndef DEF_ScopeSkip_iozYP9lEHXh
                                #define DEF_ScopeSkip_iozYP9lEHXh
struct ScopeSkip_iozY
{
    int start;
    int end;
    explicit operator bool() const noexcept
    {
        return false
            || start
            || end
        ;
    }
};
                                #endif

                                #ifndef DEF_ConvCacheColumns_qe992Xnu5D5
                                #define DEF_ConvCacheColumns_qe992Xnu5D5
struct ConvCacheColumns_qe99
{
    fu::vec<ValueType_JtNg> types;
    fu::vec<fu::vec<Target_VZrr>> paths;
    fu::vec<fu::vec<int>> must_see;
    explicit operator bool() const noexcept
    {
        return false
            || types
            || paths
            || must_see
        ;
    }
};
                                #endif

                                #ifndef DEF_ScopeSkipMemos_0CE6tALLTDh
                                #define DEF_ScopeSkipMemos_0CE6tALLTDh
struct ScopeSkipMemos_0CE6
{
    fu::vec<ScopeSkip_iozY> items;
    fu::vec<ScopeSkip_iozY> implicits;
    fu::vec<ScopeSkip_iozY> imports;
    fu::vec<ScopeSkip_iozY> privates;
    fu::vec<ScopeSkip_iozY> usings;
    fu::vec<ScopeSkip_iozY> converts;
    fu::vec<ScopeSkip_iozY> helpers;
    explicit operator bool() const noexcept
    {
        return false
            || items
            || implicits
            || imports
            || privates
            || usings
            || converts
            || helpers
        ;
    }
};
                                #endif

                                #ifndef DEF_Map_99LzmZuTJ45
                                #define DEF_Map_99LzmZuTJ45
struct Map_99Lz
{
    Set_qOJY keys;
    fu::vec<int> vals;
    explicit operator bool() const noexcept
    {
        return false
            || keys
            || vals
        ;
    }
};
                                #endif

                                #ifndef DEF_Map_qY9dKwvRwHe
                                #define DEF_Map_qY9dKwvRwHe
struct Map_qY9d
{
    Set_XshD keys;
    fu::vec<Type_OiTm> vals;
    explicit operator bool() const noexcept
    {
        return false
            || keys
            || vals
        ;
    }
};
                                #endif

                                #ifndef DEF_Map_BZ38h0satxl
                                #define DEF_Map_BZ38h0satxl
struct Map_BZ38
{
    Set_XshD keys;
    fu::vec<Target_VZrr> vals;
    explicit operator bool() const noexcept
    {
        return false
            || keys
            || vals
        ;
    }
};
                                #endif

                                #ifndef DEF_Map_v4nVu8huslj
                                #define DEF_Map_v4nVu8huslj
struct Map_v4nV
{
    Set_XshD keys;
    fu::vec<TypeParam_Lrcu> vals;
    explicit operator bool() const noexcept
    {
        return false
            || keys
            || vals
        ;
    }
};
                                #endif

                                #ifndef DEF_Map_OMJSOZzV0E3
                                #define DEF_Map_OMJSOZzV0E3
struct Map_OMJS
{
    Set_X4pj keys;
    fu::vec<ConvCache_ColsAndBakes_2n47> vals;
    explicit operator bool() const noexcept
    {
        return false
            || keys
            || vals
        ;
    }
};
                                #endif

                                #ifndef DEF_RevSpecInstance_Td5Th1ouDW1
                                #define DEF_RevSpecInstance_Td5Th1ouDW1
struct RevSpecInstance_Td5T
{
    Target_VZrr original;
    unsigned relaxed_quals;
    explicit operator bool() const noexcept
    {
        return false
            || original
        ;
    }
};
                                #endif

                                #ifndef DEF_RevSpecOutput_pbkTFqr4AL5
                                #define DEF_RevSpecOutput_pbkTFqr4AL5
struct RevSpecOutput_pbkT
{
    unsigned relaxed_quals;
    Target_VZrr instance_targ;
    explicit operator bool() const noexcept
    {
        return false
            || relaxed_quals
            || instance_targ
        ;
    }
};
                                #endif

                                #ifndef DEF_ChildTarget_FjNINrJxGK7
                                #define DEF_ChildTarget_FjNINrJxGK7
struct ChildTarget_FjNI
{
    TokenIdx_5581 token;
    unsigned parent_rev;
    Target_VZrr target;
    explicit operator bool() const noexcept
    {
        return false
            || token
            || parent_rev
            || target
        ;
    }
};
                                #endif

                                #ifndef DEF_ConvCache_ColsAndBakes_2n47KFwQf10
                                #define DEF_ConvCache_ColsAndBakes_2n47KFwQf10
struct ConvCache_ColsAndBakes_2n47
{
    ConvCacheColumns_qe99 columns;
    fu::vec<ScopeItem_xiLD> field_items;
    fu::vec<ScopeItem_xiLD> field_implicits;
    explicit operator bool() const noexcept
    {
        return false
            || columns
            || field_items
            || field_implicits
        ;
    }
};
                                #endif

                                #ifndef DEF_CountedSet_C7kV0qdw744
                                #define DEF_CountedSet_C7kV0qdw744
struct CountedSet_C7kV
{
    Map_99Lz counts;
    explicit operator bool() const noexcept
    {
        return false
            || counts
        ;
    }
};
                                #endif

                                #ifndef DEF_SpecExtras_JI9KYFvR5Aa
                                #define DEF_SpecExtras_JI9KYFvR5Aa
struct SpecExtras_JI9K
{
    fu::vec<ScopeItem_xiLD> scope_items;
    Map_qY9d arg_spec_types;
    explicit operator bool() const noexcept
    {
        return false
            || scope_items
            || arg_spec_types
        ;
    }
};
                                #endif

                                #ifndef DEF_TypeParam_LrcuL5W8Il9
                                #define DEF_TypeParam_LrcuL5W8Il9
struct TypeParam_Lrcu
{
    Type_OiTm matched;
    Type_OiTm invariant;
    Type_OiTm consumed;
    TypeParamFlags_vSpZ flags;
    explicit operator bool() const noexcept
    {
        return false
            || matched
            || invariant
            || consumed
            || flags
        ;
    }
};
                                #endif

                                #ifndef DEF_SolverState_aGlNKJni9Lg
                                #define DEF_SolverState_aGlNKJni9Lg
struct SolverState_aGlN
{
    Scope_blWT _scope;
    ScopeMemo_9hVQ _root_scope;
    ScopeSkipMemos_0CE6 _ss;
    Set_qOJY _pub_imports;
    fu::vec<HelpersData_uG6I> _helpers_data;
    fu::vec<Ephemeral_xhb4> _ephemeral;
    Map_OMJS _conv_cache;
    int _solver_safety;
    int _qstack_safety;
    SolverNotes_LSla _notes;
    fu::vec<Warning_9p8u> _warnings;
    fu::str shortModuleName;
    fu::vec<SolvedNode_efhg> TODO_FIX_convert_args;
    int TODO_FIX_inline_safety;
    Map_v4nV _typeParams;
    Target_VZrr _solvingFnort;
    Target_VZrr _nestingFnort;
    SolverState_aGlN(const SolverState_aGlN&) = delete;
    SolverState_aGlN(SolverState_aGlN&&) = default;
    SolverState_aGlN& operator=(const SolverState_aGlN&) = delete;
    SolverState_aGlN& operator=(SolverState_aGlN&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || _scope
            || _root_scope
            || _ss
            || _pub_imports
            || _helpers_data
            || _ephemeral
            || _conv_cache
            || _solver_safety
            || _qstack_safety
            || _notes
            || _warnings
            || shortModuleName
            || TODO_FIX_convert_args
            || TODO_FIX_inline_safety
            || _typeParams
            || _solvingFnort
            || _nestingFnort
        ;
    }
};
                                #endif

                                #ifndef DEF_ReverseSpecialization_xE3FlZqaEMh
                                #define DEF_ReverseSpecialization_xE3FlZqaEMh
struct ReverseSpecialization_xE3F
{
    RevSpecPrototype_vWbr prototype;
    RevSpecInstance_Td5T instance;
    fu::vec<RevSpecOutput_pbkT> outputs;
    explicit operator bool() const noexcept
    {
        return false
            || prototype
            || instance
            || outputs
        ;
    }
};
                                #endif

                                #ifndef DEF_HelpersData_uG6IrsXErw9
                                #define DEF_HelpersData_uG6IrsXErw9
struct HelpersData_uG6I
{
    Target_VZrr target;
    SolverPass_zVQ2 pass;
    HelpersMask_w1sv mask;
    fu::str id;
    int local_of;
    int locals_start;
    Type_OiTm ret_expect;
    Type_OiTm ret_actual;
    Postdom_Vy5u postdom;
    Postdom_Vy5u loop_PREVITER;
    EventsSnap_elmt postevt;
    Helpers_DyqV kills;
    explicit operator bool() const noexcept
    {
        return false
            || target
            || pass
            || mask
            || id
            || local_of
            || locals_start
            || ret_expect
            || ret_actual
            || postdom
            || loop_PREVITER
            || postevt
            || kills
        ;
    }
};
                                #endif

                                #ifndef DEF_Ephemeral_xhb4ZFsXLJ3
                                #define DEF_Ephemeral_xhb4ZFsXLJ3
struct Ephemeral_xhb4
{
    int local_of;
    unsigned revision;
    ScopeMemo_9hVQ scope_memo;
    ScopeSkipMemos_0CE6 scope_skip;
    SpecExtras_JI9K spec_extras;
    CountedSet_C7kV callers;
    CountedSet_C7kV calls;
    fu::vec<ChildTarget_FjNI> children;
    Map_BZ38 specs;
    Set_qOJY far_jumps;
    ReverseSpecialization_xE3F rev_spec;
    explicit operator bool() const noexcept
    {
        return false
            || local_of
            || revision
            || scope_memo
            || scope_skip
            || spec_extras
            || callers
            || calls
            || children
            || specs
            || far_jumps
            || rev_spec
        ;
    }
};
                                #endif

                                #ifndef DEF_DeadBreak_Z4ob
                                #define DEF_DeadBreak_Z4ob
enum DeadBreak_Z4ob: fu::u8
{
    DeadBreak_Z4ob_DeadBreak_Dont = 0u,
    DeadBreak_Z4ob_DeadBreak_Always = 1u,
    DeadBreak_Z4ob_DeadBreak_Only_WhileSolvingRecursion = 2u,
};
                                #endif

                                #ifndef DEF_StaticEval_IZio
                                #define DEF_StaticEval_IZio
enum StaticEval_IZio: fu::u8
{
    StaticEval_IZio_SE_Unknown = 0u,
    StaticEval_IZio_SE_False = 1u,
    StaticEval_IZio_SE_True = 2u,
};
                                #endif

                                #ifndef DEF_ClosureID_qHEWBYspmy6
                                #define DEF_ClosureID_qHEWBYspmy6
struct ClosureID_qHEW
{
    Target_VZrr target;
    unsigned revision;
    explicit operator bool() const noexcept
    {
        return false
            || target
        ;
    }
};
                                #endif

                                #ifndef DEF_UnpackedOffset_f7kzG0t87Lb
                                #define DEF_UnpackedOffset_f7kzG0t87Lb
struct UnpackedOffset_f7kz
{
    int memberFlatOffset;
    int memberFlatCount;
    explicit operator bool() const noexcept
    {
        return false
            || memberFlatOffset
            || memberFlatCount
        ;
    }
};
                                #endif

                                #ifndef DEF_CodeFmt_snPx
                                #define DEF_CodeFmt_snPx
inline constexpr CodeFmt_snPx CodeFmt_snPx_FullContext = CodeFmt_snPx(1u);
inline constexpr CodeFmt_snPx CodeFmt_snPx_NoLeadContext = CodeFmt_snPx(2u);
inline constexpr CodeFmt_snPx CodeFmt_snPx_NoTailContext = CodeFmt_snPx(4u);
inline constexpr CodeFmt_snPx CodeFmt_snPx_NoContext = CodeFmt_snPx(8u);

inline constexpr CodeFmt_snPx MASK_CodeFmt_snPx
    = CodeFmt_snPx_FullContext
    | CodeFmt_snPx_NoLeadContext
    | CodeFmt_snPx_NoTailContext
    | CodeFmt_snPx_NoContext;
                                #endif

                                #ifndef DEF_Reorder_0MNgYD5XJY9
                                #define DEF_Reorder_0MNgYD5XJY9
struct Reorder_0MNg
{
    bool applicable;
    fu::vec<int> map;
    explicit operator bool() const noexcept
    {
        return false
            || applicable
        ;
    }
};
                                #endif

                                #ifndef DEF_NamedArgs_UjiQapxU9dh
                                #define DEF_NamedArgs_UjiQapxU9dh
struct NamedArgs_UjiQ
{
    fu::vec<fu::str> names;
    BitSet_mmp7 optional;
    explicit operator bool() const noexcept
    {
        return false
            || names
            || optional
        ;
    }
};
                                #endif

                                #ifndef DEF_Set_pEwDiO8iN3b
                                #define DEF_Set_pEwDiO8iN3b
struct Set_pEwD
{
    fu::vec<StructCanon_TixV> keys_asc;
    explicit operator bool() const noexcept
    {
        return false
            || keys_asc
        ;
    }
};
                                #endif

                                #ifndef DEF_StructCanon_TixVhPbpah2
                                #define DEF_StructCanon_TixVhPbpah2
struct StructCanon_TixV
{
    int modid;
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || modid
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_Intlit_tw2dbMaP9o3
                                #define DEF_Intlit_tw2dbMaP9o3
struct Intlit_tw2d
{
    fu::u8 base;
    fu::u8 minsize_i;
    fu::u8 minsize_u;
    fu::u8 minsize_f;
    bool sIgned;
    bool uNsigned;
    bool negative;
    uint64_t absval;
    fu::str error;
    explicit operator bool() const noexcept
    {
        return false
            || base
            || minsize_i
            || minsize_u
            || minsize_f
            || sIgned
            || uNsigned
            || negative
            || absval
            || error
        ;
    }
};
                                #endif

                                #ifndef DEF_Set_R8IUVvFh4H7
                                #define DEF_Set_R8IUVvFh4H7
struct Set_R8IU
{
    fu::vec<Target_VZrr> keys_asc;
    explicit operator bool() const noexcept
    {
        return false
            || keys_asc
        ;
    }
};
                                #endif

                                #ifndef DEF_Map_iaWxSyPCa6g
                                #define DEF_Map_iaWxSyPCa6g
struct Map_iaWx
{
    Set_R8IU keys;
    fu::vec<Target_VZrr> vals;
    explicit operator bool() const noexcept
    {
        return false
            || keys
            || vals
        ;
    }
};
                                #endif

                                #ifndef DEF_UsedAgain_5DsR
                                #define DEF_UsedAgain_5DsR
                                #endif

                                #ifndef DEF_UsedAgainReason_wQO7
                                #define DEF_UsedAgainReason_wQO7
enum UsedAgainReason_wQO7: fu::u8
{
    UsedAgainReason_wQO7_None = 0u,
    UsedAgainReason_wQO7_WrongPass = 1u,
    UsedAgainReason_wQO7_UsedAgain = 2u,
    UsedAgainReason_wQO7_UsedInALoop = 3u,
    UsedAgainReason_wQO7_ArgReference = 4u,
    UsedAgainReason_wQO7_StaticReference = 5u,
};
                                #endif

                                #ifndef DEF_RetypeOrder_6uAI1u80ZS2
                                #define DEF_RetypeOrder_6uAI1u80ZS2
struct RetypeOrder_6uAI
{
    int retype_score;
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || retype_score
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_NamedArgs_UjiQapxU9dh
                                #define DEF_NamedArgs_UjiQapxU9dh
struct NamedArgs_UjiQ
{
    fu::vec<fu::str> names;
    BitSet_mmp7 optional;
    explicit operator bool() const noexcept
    {
        return false
            || names
            || optional
        ;
    }
};
                                #endif

                                #ifndef DEF_NativeQualities_5Qbpl3VGNb6
                                #define DEF_NativeQualities_5Qbpl3VGNb6
struct NativeQualities_5Qbp
{
    int name_start_idx;
    bool MayAlias;
    explicit operator bool() const noexcept
    {
        return false
            || name_start_idx
            || MayAlias
        ;
    }
};
                                #endif

                                #ifndef DEF_ArgQuery_O2xW
                                #define DEF_ArgQuery_O2xW
enum ArgQuery_O2xW: fu::u8
{
    ArgQuery_O2xW_AQ_WhyNotNovec = 1u,
};
                                #endif

                                #ifndef DEF_ArgRationale_mffC
                                #define DEF_ArgRationale_mffC
enum ArgRationale_mffC: fu::u8
{
    ArgRationale_mffC_CantTempCopy_HostArg_Ref = 1u,
    ArgRationale_mffC_CantTempCopy_HostArg_MutRef = 2u,
    ArgRationale_mffC_CantTempCopy_HostArg_Implicit = 3u,
    ArgRationale_mffC_CantTempCopy_FastFn = 4u,
    ArgRationale_mffC_CantTempCopy_NonCopiable = 5u,
    ArgRationale_mffC_CantTempCopy_ReturnedFromFn = 6u,
    ArgRationale_mffC_RequireVal_AliasesMutatedInjectedArgument = 7u,
};
                                #endif

                                #ifndef DEF_BorrowCheckPass_i0wt
                                #define DEF_BorrowCheckPass_i0wt
enum BorrowCheckPass_i0wt: fu::u8
{
    BorrowCheckPass_i0wt_BCK_bck = 1u,
    BorrowCheckPass_i0wt_BCK_aar = 2u,
    BorrowCheckPass_i0wt_BCK_ooe = 3u,
};
                                #endif

                                #ifndef DEF_RWQuals_ELUYKV31mz2
                                #define DEF_RWQuals_ELUYKV31mz2
struct RWQuals_ELUY
{
    unsigned usage;
    unsigned written_to;
    explicit operator bool() const noexcept
    {
        return false
            || usage
            || written_to
        ;
    }
};
                                #endif

                                #ifndef DEF_SubRegion_jsU3ktb89d5
                                #define DEF_SubRegion_jsU3ktb89d5
struct SubRegion_jsU3
{
    int flatCount;
    int flatOffset;
    explicit operator bool() const noexcept
    {
        return false
            || flatCount
            || flatOffset
        ;
    }
};
                                #endif

                                #ifndef DEF_Map_ZxRuo4xw2xc
                                #define DEF_Map_ZxRuo4xw2xc
struct Map_ZxRu
{
    Set_XshD keys;
    fu::vec<unsigned> vals;
    explicit operator bool() const noexcept
    {
        return false
            || keys
            || vals
        ;
    }
};
                                #endif

                                #ifndef DEF_Regions_9N5a3gYCiob
                                #define DEF_Regions_9N5a3gYCiob
struct Regions_9N5a
{
    LocidSet_iAWt locids;
    BitSet_mmp7 arguments;
    explicit operator bool() const noexcept
    {
        return false
            || locids
            || arguments
        ;
    }
};
                                #endif

                                #ifndef DEF_Unsequenced_MqaYqGqfS12
                                #define DEF_Unsequenced_MqaYqGqfS12
struct Unsequenced_MqaY
{
    Regions_9N5a writes;
    Regions_9N5a moves;
    Regions_9N5a reads;
    explicit operator bool() const noexcept
    {
        return false
            || writes
            || moves
            || reads
        ;
    }
};
                                #endif

                                #ifndef STR_Q1K0BNOSjWk
                                #define STR_Q1K0BNOSjWk
static const fu::str str_Q1K0BNOSjWk fu_INIT_PRIORITY(1011) { "i8"_fu };
                                #endif

                                #ifndef STR_9e92J9C60Ob
                                #define STR_9e92J9C60Ob
static const fu::str str_9e92J9C60Ob fu_INIT_PRIORITY(1011) { "i16"_fu };
                                #endif

                                #ifndef STR_K8KxoYxA7Xl
                                #define STR_K8KxoYxA7Xl
static const fu::str str_K8KxoYxA7Xl fu_INIT_PRIORITY(1011) { "i32"_fu };
                                #endif

                                #ifndef STR_nXBW7I7egP9
                                #define STR_nXBW7I7egP9
static const fu::str str_nXBW7I7egP9 fu_INIT_PRIORITY(1011) { "i64"_fu };
                                #endif

                                #ifndef STR_T4nNVV0oHGc
                                #define STR_T4nNVV0oHGc
static const fu::str str_T4nNVV0oHGc fu_INIT_PRIORITY(1011) { "i128"_fu };
                                #endif

                                #ifndef STR_YhTgzC21Rp2
                                #define STR_YhTgzC21Rp2
static const fu::str str_YhTgzC21Rp2 fu_INIT_PRIORITY(1011) { "u8"_fu };
                                #endif

                                #ifndef STR_2fAchhueS6b
                                #define STR_2fAchhueS6b
static const fu::str str_2fAchhueS6b fu_INIT_PRIORITY(1011) { "u16"_fu };
                                #endif

                                #ifndef STR_AXDdcKHr29k
                                #define STR_AXDdcKHr29k
static const fu::str str_AXDdcKHr29k fu_INIT_PRIORITY(1011) { "u32"_fu };
                                #endif

                                #ifndef STR_bDPbEUy6W2b
                                #define STR_bDPbEUy6W2b
static const fu::str str_bDPbEUy6W2b fu_INIT_PRIORITY(1011) { "u64"_fu };
                                #endif

                                #ifndef STR_BWBehL8bqk0
                                #define STR_BWBehL8bqk0
static const fu::str str_BWBehL8bqk0 fu_INIT_PRIORITY(1011) { "u128"_fu };
                                #endif

                                #ifndef STR_1QwvpsHdfu3
                                #define STR_1QwvpsHdfu3
static const fu::str str_1QwvpsHdfu3 fu_INIT_PRIORITY(1011) { "f32"_fu };
                                #endif

                                #ifndef STR_gz4KnAfW2Ug
                                #define STR_gz4KnAfW2Ug
static const fu::str str_gz4KnAfW2Ug fu_INIT_PRIORITY(1011) { "f64"_fu };
                                #endif

                                #ifndef STR_1cD5td1eMvl
                                #define STR_1cD5td1eMvl
static const fu::str str_1cD5td1eMvl fu_INIT_PRIORITY(1011) { "bool"_fu };
                                #endif

                                #ifndef STR_gj1KpRoPVn2
                                #define STR_gj1KpRoPVn2
static const fu::str str_gj1KpRoPVn2 fu_INIT_PRIORITY(1011) { "byte"_fu };
                                #endif

                                #ifndef STR_KiGuEGIuqEg
                                #define STR_KiGuEGIuqEg
static const fu::str str_KiGuEGIuqEg fu_INIT_PRIORITY(1011) { "void"_fu };
                                #endif

                                #ifndef STR_scsjXZQ1yH3
                                #define STR_scsjXZQ1yH3
static const fu::str str_scsjXZQ1yH3 fu_INIT_PRIORITY(1011) { "never"_fu };
                                #endif

                                #ifndef STR_onytfN8TIli
                                #define STR_onytfN8TIli
static const fu::str str_onytfN8TIli fu_INIT_PRIORITY(1011) { "__preceding_ref_arg"_fu };
                                #endif

                                #ifndef STR_QeWEBnJGbog
                                #define STR_QeWEBnJGbog
static const fu::str str_QeWEBnJGbog fu_INIT_PRIORITY(1011) { "__serialized_type"_fu };
                                #endif

                                #ifndef STR_QiuEJjR3RB9
                                #define STR_QiuEJjR3RB9
static const fu::str str_QiuEJjR3RB9 fu_INIT_PRIORITY(1011) { "__serialized_addrof_type_fn"_fu };
                                #endif

                                #ifndef STR_yehShWCF68e
                                #define STR_yehShWCF68e
static const fu::str str_yehShWCF68e fu_INIT_PRIORITY(1011) { "DEV_HappyPathOnly: we ended up on a slow path."_fu };
                                #endif

                                #ifndef STR_0ea6zET6IM5
                                #define STR_0ea6zET6IM5
static const fu::str str_0ea6zET6IM5 fu_INIT_PRIORITY(1011) { ", not meaningful in a boolean context."_fu };
                                #endif

                                #ifndef STR_yabg9ydVki8
                                #define STR_yabg9ydVki8
static const fu::str str_yabg9ydVki8 fu_INIT_PRIORITY(1011) { "EPH_mut: modid is off."_fu };
                                #endif

                                #ifndef STR_gRoMTrquoqa
                                #define STR_gRoMTrquoqa
static const fu::str str_gRoMTrquoqa fu_INIT_PRIORITY(1011) { "GET_mut: bad modid/globid"_fu };
                                #endif

                                #ifndef STR_tL0MTx4Z4n2
                                #define STR_tL0MTx4Z4n2
static const fu::str str_tL0MTx4Z4n2 fu_INIT_PRIORITY(1011) { "EXT_mut: bad modid/globid/locid"_fu };
                                #endif

                                #ifndef STR_6Ccun4v3P95
                                #define STR_6Ccun4v3P95
static const fu::str str_6Ccun4v3P95 fu_INIT_PRIORITY(1011) { "Anon"_fu };
                                #endif

                                #ifndef STR_t1l2m4rwGi0
                                #define STR_t1l2m4rwGi0
static const fu::str str_t1l2m4rwGi0 fu_INIT_PRIORITY(1011) { "Falsy type param id."_fu };
                                #endif

                                #ifndef STR_Jn0k1IbEIo4
                                #define STR_Jn0k1IbEIo4
static const fu::str str_Jn0k1IbEIo4 fu_INIT_PRIORITY(1011) { "Self-referential qualified id."_fu };
                                #endif

                                #ifndef STR_2n6EmQmnc7k
                                #define STR_2n6EmQmnc7k
static const fu::str str_2n6EmQmnc7k fu_INIT_PRIORITY(1011) { "Explicitly marked inline."_fu };
                                #endif

                                #ifndef STR_mF5LBrIw797
                                #define STR_mF5LBrIw797
static const fu::str str_mF5LBrIw797 fu_INIT_PRIORITY(1011) { "Contains non-local control flow."_fu };
                                #endif

                                #ifndef STR_W2TNfRWjQyj
                                #define STR_W2TNfRWjQyj
static const fu::str str_W2TNfRWjQyj fu_INIT_PRIORITY(1011) { "Bad int literal."_fu };
                                #endif

                                #ifndef STR_5UZMuQGyOB0
                                #define STR_5UZMuQGyOB0
static const fu::str str_5UZMuQGyOB0 fu_INIT_PRIORITY(1011) { "__using.a"_fu };
                                #endif

                                #ifndef STR_FaWEciPaRMe
                                #define STR_FaWEciPaRMe
static const fu::str str_FaWEciPaRMe fu_INIT_PRIORITY(1011) { "Cannot infer empty arraylit."_fu };
                                #endif

                                #ifndef STR_rSRZRLyoFVb
                                #define STR_rSRZRLyoFVb
static const fu::str str_rSRZRLyoFVb fu_INIT_PRIORITY(1011) { "Array items cannot be refs. TODO Why an error? Should this not just clear_refs?"_fu };
                                #endif

                                #ifndef STR_LRHKEAVNik7
                                #define STR_LRHKEAVNik7
static const fu::str str_LRHKEAVNik7 fu_INIT_PRIORITY(1011) { "__closure"_fu };
                                #endif

                                #ifndef STR_cE12d2VNpS7
                                #define STR_cE12d2VNpS7
static const fu::str str_cE12d2VNpS7 fu_INIT_PRIORITY(1011) { "__implicit"_fu };
                                #endif

                                #ifndef STR_x5wTngZiZL0
                                #define STR_x5wTngZiZL0
static const fu::str str_x5wTngZiZL0 fu_INIT_PRIORITY(1011) { "__def_arg_ref"_fu };
                                #endif

                                #ifndef STR_3guUkNyDiR9
                                #define STR_3guUkNyDiR9
static const fu::str str_3guUkNyDiR9 fu_INIT_PRIORITY(1011) { "Inline arguments can only be inlined once."_fu };
                                #endif

                                #ifndef STR_qJhjdVVOTZ0
                                #define STR_qJhjdVVOTZ0
static const fu::str str_qJhjdVVOTZ0 fu_INIT_PRIORITY(1011) { "Bad jump expression"_fu };
                                #endif

                                #ifndef STR_id6aIsm0eRi
                                #define STR_id6aIsm0eRi
static const fu::str str_id6aIsm0eRi fu_INIT_PRIORITY(1011) { "__using.b"_fu };
                                #endif

                                #ifndef STR_HtGuB8H8tX5
                                #define STR_HtGuB8H8tX5
static const fu::str str_HtGuB8H8tX5 fu_INIT_PRIORITY(1011) { "Falsy type tag."_fu };
                                #endif

                                #ifndef STR_yf9vetBDKP3
                                #define STR_yf9vetBDKP3
static const fu::str str_yf9vetBDKP3 fu_INIT_PRIORITY(1011) { "typeassert intersect fail."_fu };
                                #endif

                                #ifndef STR_9wi5bbjWhR5
                                #define STR_9wi5bbjWhR5
static const fu::str str_9wi5bbjWhR5 fu_INIT_PRIORITY(1011) { "Invalid type pattern."_fu };
                                #endif

                                #ifndef STR_Rsr05MN8ZAi
                                #define STR_Rsr05MN8ZAi
static const fu::str str_Rsr05MN8ZAi fu_INIT_PRIORITY(1011) { "Type annotations on type aliases are not supported."_fu };
                                #endif

                                #ifndef STR_vevxISs7fYh
                                #define STR_vevxISs7fYh
static const fu::str str_vevxISs7fYh fu_INIT_PRIORITY(1011) { "Type aliases must be initialized."_fu };
                                #endif

                                #ifndef STR_KgyUI9xCo7c
                                #define STR_KgyUI9xCo7c
static const fu::str str_KgyUI9xCo7c fu_INIT_PRIORITY(1011) { "Multiple ref arguments, cannot infer what the returned reference points to."_fu };
                                #endif

                                #ifndef STR_lPIs9JAS638
                                #define STR_lPIs9JAS638
static const fu::str str_lPIs9JAS638 fu_INIT_PRIORITY(1011) { "Missing ref argument lifetime."_fu };
                                #endif

                                #ifndef STR_cff6zKl3Fj7
                                #define STR_cff6zKl3Fj7
static const fu::str str_cff6zKl3Fj7 fu_INIT_PRIORITY(1011) { "No ref arguments, cannot infer what the returned reference points to."_fu };
                                #endif

                                #ifndef STR_NbejPnXqD7k
                                #define STR_NbejPnXqD7k
static const fu::str str_NbejPnXqD7k fu_INIT_PRIORITY(1011) { "A copy is needed, but "_fu };
                                #endif

                                #ifndef STR_lCD7BgjpDp0
                                #define STR_lCD7BgjpDp0
static const fu::str str_lCD7BgjpDp0 fu_INIT_PRIORITY(1011) { "__partcopy_ref"_fu };
                                #endif

                                #ifndef STR_xRMjr6luuKd
                                #define STR_xRMjr6luuKd
static const fu::str str_xRMjr6luuKd fu_INIT_PRIORITY(1011) { "__partcopy_f"_fu };
                                #endif

                                #ifndef STR_Indt9JqHbva
                                #define STR_Indt9JqHbva
static const fu::str str_Indt9JqHbva fu_INIT_PRIORITY(1011) { "__partcopy_s"_fu };
                                #endif

                                #ifndef STR_ySWbqrCfvec
                                #define STR_ySWbqrCfvec
static const fu::str str_ySWbqrCfvec fu_INIT_PRIORITY(1011) { "references a static."_fu };
                                #endif

                                #ifndef STR_27qCj4870pa
                                #define STR_27qCj4870pa
static const fu::str str_27qCj4870pa fu_INIT_PRIORITY(1011) { "`unwrap` doesn't currently support early returns."_fu };
                                #endif

                                #ifndef STR_oI6kwP1Lao1
                                #define STR_oI6kwP1Lao1
static const fu::str str_oI6kwP1Lao1 fu_INIT_PRIORITY(1011) { ", both operands alias:\n"_fu };
                                #endif

                                #ifndef STR_dmj5RVL83Ti
                                #define STR_dmj5RVL83Ti
static const fu::str str_dmj5RVL83Ti fu_INIT_PRIORITY(1011) { "Temporary copies not allowed in fast fns."_fu };
                                #endif

                                #ifndef STR_Vczw5Cti8xf
                                #define STR_Vczw5Cti8xf
static const fu::str str_Vczw5Cti8xf fu_INIT_PRIORITY(1011) { "Flow.clear(): Non-empty at-risk tables."_fu };
                                #endif

                                #ifndef STR_ZKTh9Sexw6k
                                #define STR_ZKTh9Sexw6k
static const fu::str str_ZKTh9Sexw6k fu_INIT_PRIORITY(1011) { "Optional argument ambiguity:"_fu };
                                #endif

                                #ifndef STR_enZrSJzQdHb
                                #define STR_enZrSJzQdHb
static const fu::str str_enZrSJzQdHb fu_INIT_PRIORITY(1011) { "Cannot auto-increment, please provide an explicit value."_fu };
                                #endif

                                #ifndef STR_K6dO536A7u6
                                #define STR_K6dO536A7u6
static const fu::str str_K6dO536A7u6 fu_INIT_PRIORITY(1011) { "Previous constant is negative, not sure how to increment, please specify an explicit value."_fu };
                                #endif

                                #ifndef STR_6z696lkGred
                                #define STR_6z696lkGred
static const fu::str str_6z696lkGred fu_INIT_PRIORITY(1011) { "Failed to auto-increment, range exhausted."_fu };
                                #endif

                                #ifndef STR_ytIqXmnhNJh
                                #define STR_ytIqXmnhNJh
static const fu::str str_ytIqXmnhNJh fu_INIT_PRIORITY(1011) { "Noreturn during static init: this program will never finish booting."_fu };
                                #endif

                                #ifndef STR_vfStRkdMxK7
                                #define STR_vfStRkdMxK7
static const fu::str str_vfStRkdMxK7 fu_INIT_PRIORITY(1011) { "TODO: solveArrlit: tryMatch by [ argnames: ... ] without function name."_fu };
                                #endif

                                #ifndef STR_OzCq7wxwyT6
                                #define STR_OzCq7wxwyT6
static const fu::str str_OzCq7wxwyT6 fu_INIT_PRIORITY(1011) { "true"_fu };
                                #endif

                                #ifndef STR_5ReVUUJ8X27
                                #define STR_5ReVUUJ8X27
static const fu::str str_5ReVUUJ8X27 fu_INIT_PRIORITY(1011) { "false"_fu };
                                #endif

                                #ifndef STR_UwlyW7OQ2E0
                                #define STR_UwlyW7OQ2E0
static const fu::str str_UwlyW7OQ2E0 fu_INIT_PRIORITY(1011) { "Cannot pub import from here."_fu };
                                #endif

                                #ifndef STR_UkSW0DUvQBi
                                #define STR_UkSW0DUvQBi
static const fu::str str_UkSW0DUvQBi fu_INIT_PRIORITY(1011) { "[[[ BREAKPOINT HERE ]]]"_fu };
                                #endif

#ifndef fu_NO_fdefs

static Helpers_DyqV push_gDsn(const HelpersData_uG6I& data, SolverState_aGlN& ss, fu::vec<Helpers_DyqV>& _helpers)
{
    const Helpers_DyqV ret = Helpers_DyqV { ss._helpers_data.size() };
    _helpers += Helpers_DyqV(ret);
    ss._helpers_data += HelpersData_uG6I(data);
    return ret;
}

                                #ifndef DEF_clear_jCLVoOFw9Dc
                                #define DEF_clear_jCLVoOFw9Dc
inline void clear_jCLV(Map_OMJS& _)
{

    {
        Set_X4pj& __1 = _.keys;
        __1.keys_asc.clear();
    };
    _.vals.clear();
}
                                #endif

                                #ifndef DEF_x3Cx3E_Rgh3ARpn2a3
                                #define DEF_x3Cx3E_Rgh3ARpn2a3
inline int x3Cx3E_Rgh3(const unsigned a, const unsigned b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_IKCCJmNwJx2
                                #define DEF_x3Cx3E_IKCCJmNwJx2
inline int x3Cx3E_IKCC(const VFacts_xhRf a, const VFacts_xhRf b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_9721bzHlge0
                                #define DEF_x3Cx3E_9721bzHlge0
inline int x3Cx3E_9721(const ValueType_JtNg& a, const ValueType_JtNg& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_Rgh3(a.quals, b.quals)))
        return cmp;
    else if ((cmp = x3Cx3E_IKCC(a.vfacts, b.vfacts)))
        return cmp;

    if ((cmp = x3Cx3E_j5CR(a.canon, b.canon)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_remove_47QuRHDA3P1
                                #define DEF_remove_47QuRHDA3P1
inline static void remove_47Qu(const int i, Set_X4pj& _, fu::vec_range_mut<ConvCache_ColsAndBakes_2n47> values)
{
    _.keys_asc.splice(i, 1);
    values.splice(i, 1);
}
                                #endif

                                #ifndef DEF_remove_mVkeLDQk942
                                #define DEF_remove_mVkeLDQk942
inline bool remove_mVke(Map_OMJS& _, const ValueType_JtNg& key)
{

    {
        Set_X4pj& __1 = _.keys;
        fu::vec<ConvCache_ColsAndBakes_2n47>& values = _.vals;
        fu::view<ValueType_JtNg> keys_asc = __1.keys_asc;
        int lo = 0;
        int hi = keys_asc.size();
        while (lo < hi)
        {
            const int i = ((hi + lo) >> 1);
            const int cmp = x3Cx3E_9721(keys_asc[i], key);
            if (cmp == 0)
            {
                remove_47Qu(i, __1, values);
                return true;
            }
            else if (cmp < 0)
                lo = (i + 1);
            else
                hi = i;

        };
    };
    return false;
}
                                #endif

static void _Scope_import__forceCopy_gDsn(const int modid, const bool pRivate, SolverState_aGlN& ss, const Context_noPA& ctx)
{
    const Scope_blWT& s = ctx.modules[modid].out.solve.scope;
    const int usings0 = ss._scope.usings.size();
    const int converts0 = ss._scope.converts.size();
    fu::view<ScopeItem_xiLD> what {};
    int pub_count;
    int N;
    ss._scope.items += (what.ptr_reassign(s.items), pub_count = s.pub_items, N = what.size(), fu::get_view(what, (pRivate ? pub_count : 0), (pRivate ? N : pub_count)));
    fu::view<Target_VZrr> what_1 {};
    int pub_count_1;
    int N_1;
    ss._scope.converts += (what_1.ptr_reassign(s.converts), pub_count_1 = s.pub_converts, N_1 = what_1.size(), fu::get_view(what_1, (pRivate ? pub_count_1 : 0), (pRivate ? N_1 : pub_count_1)));
    fu::view<ScopeItem_xiLD> what_2 {};
    int pub_count_2;
    int N_2;
    ss._scope.implicits += (what_2.ptr_reassign(s.implicits), pub_count_2 = s.pub_implicits, N_2 = what_2.size(), fu::get_view(what_2, (pRivate ? pub_count_2 : 0), (pRivate ? N_2 : pub_count_2)));
    fu::view<ScopeItem_xiLD> what_3 {};
    int pub_count_3;
    int N_3;
    ss._scope.globals += (what_3.ptr_reassign(s.globals), pub_count_3 = s.pub_globals, N_3 = what_3.size(), fu::get_view(what_3, (pRivate ? pub_count_3 : 0), (pRivate ? N_3 : pub_count_3)));
    const int converts1 = ss._scope.converts.size();
    if (converts1 != converts0)
        clear_jCLV(ss._conv_cache);

    const int usings1 = ss._scope.usings.size();
    if (usings1 != usings0)
    {
        remove_mVke(ss._conv_cache, ValueType_JtNg{});
    };
}

extern const Type_OiTm t_i8;
static Target_VZrr createRawTypedef_gDsn(fu::vec_range<char> id, Type_OiTm&& type, const Flags_Lzg8 flags, fu::vec_range<char> name, const SolverStatus_h9em status, SolverState_aGlN& ss, const Module_wo7O& module)
{
    type = into_Typename_9CJm(Type_OiTm(type));
    const Target_VZrr target = Scope_create_z0Qq(ss._scope, Kind_Idfg_type, (name ? name : id), type, flags, DeclAsserts_taUG{}, status, 0, false, module);
    if (id)
        Scope_set_z0Qq(ss._scope, id, target, !!(flags & Flags_Lzg8_F_SHADOW));

    return target;
}

extern const Type_OiTm t_i16;
extern const Type_OiTm t_i32;
extern const Type_OiTm t_i64;
extern const Type_OiTm t_i128;
extern const Type_OiTm t_u8;
extern const Type_OiTm t_u16;
extern const Type_OiTm t_u32;
extern const Type_OiTm t_u64;
extern const Type_OiTm t_u128;
extern const Type_OiTm t_f32;
extern const Type_OiTm t_f64;
extern const Type_OiTm t_bool;
extern const Type_OiTm t_byte;
extern const Type_OiTm t_void;
extern const Type_OiTm t_never;
                                #ifndef DEF_steal_9ubkcOYnu8h
                                #define DEF_steal_9ubkcOYnu8h
inline Node_JjyR steal_9ubk(Node_JjyR& v)
{
    /*MOV*/ Node_JjyR ret {};
    std::swap(v, ret);
    return /*NRVO*/ ret;
}
                                #endif

static bool isTypeDecl_gDsn(const Kind_Idfg kind)
{
    return (kind == Kind_Idfg_struct) || (kind == Kind_Idfg_union) || (kind == Kind_Idfg_primitive) || (kind == Kind_Idfg_enum) || (kind == Kind_Idfg_flags);
}

static int unorderedClassify_gDsn(const Kind_Idfg kind)
{
    if (kind == Kind_Idfg_fn)
        return 1;
    else if (isTypeDecl_gDsn(kind))
        return 10;
    else
        return 0;

}

                                #ifndef DEF_str_kJvrhvMrGwi
                                #define DEF_str_kJvrhvMrGwi
inline fu::str str_kJvr(const SolverNotes_LSla n)
{
    /*MOV*/ fu::str res {};

    {
        if (n & SolverNotes_LSla_N_FnRecursion)
            res += ("N_FnRecursion"_view + ", "_view);

        if (n & SolverNotes_LSla_N_FnResolve)
            res += ("N_FnResolve"_view + ", "_view);

        if (n & SolverNotes_LSla_N_FnReopen)
            res += ("N_FnReopen"_view + ", "_view);

        if (n & SolverNotes_LSla_N_TypeRecursion)
            res += ("N_TypeRecursion"_view + ", "_view);

        if (n & SolverNotes_LSla_N_TypeResolve)
            res += ("N_TypeResolve"_view + ", "_view);

        if (n & SolverNotes_LSla_N_TypeReopen)
            res += ("N_TypeReopen"_view + ", "_view);

        if (n & SolverNotes_LSla_N_DeadCode)
            res += ("N_DeadCode"_view + ", "_view);

        if (n & SolverNotes_LSla_N_DeadCall)
            res += ("N_DeadCall"_view + ", "_view);

        if (n & SolverNotes_LSla_N_DeadLet)
            res += ("N_DeadLet"_view + ", "_view);

        if (n & SolverNotes_LSla_N_DeadArrlit)
            res += ("N_DeadArrlit"_view + ", "_view);

        if (n & SolverNotes_LSla_N_DeadLoopInit)
            res += ("N_DeadLoopInit"_view + ", "_view);

        if (n & SolverNotes_LSla_N_DeadConv)
            res += ("N_DeadConv"_view + ", "_view);

        if (n & SolverNotes_LSla_N_NonTrivAutoCopy)
            res += ("N_NonTrivAutoCopy"_view + ", "_view);

        if (n & SolverNotes_LSla_N_RelaxRespec)
            res += ("N_RelaxRespec"_view + ", "_view);

        if (n & SolverNotes_LSla_N_UnusedImplicit)
            res += ("N_UnusedImplicit"_view + ", "_view);

        if (n & SolverNotes_LSla_N_UnusedCall)
            res += ("N_UnusedCall"_view + ", "_view);

        if (n & SolverNotes_LSla_N_UnusedDefer)
            res += ("N_UnusedDefer"_view + ", "_view);

        if (n & SolverNotes_LSla_N_UnusedTry)
            res += ("N_UnusedTry"_view + ", "_view);

        if (n & SolverNotes_LSla_N_UnusedAndOr)
            res += ("N_UnusedAndOr"_view + ", "_view);

        if (n & SolverNotes_LSla_N_UnusedIfElse)
            res += ("N_UnusedIfElse"_view + ", "_view);

        if (n & SolverNotes_LSla_N_UnusedArrlit)
            res += ("N_UnusedArrlit"_view + ", "_view);

        if (n & SolverNotes_LSla_N_UnusedLet)
            res += ("N_UnusedLet"_view + ", "_view);

        if (n & SolverNotes_LSla_N_BckMustSeq)
            res += ("N_BckMustSeq"_view + ", "_view);

        if (n & SolverNotes_LSla_N_AARMustSeq)
            res += ("N_AARMustSeq"_view + ", "_view);

        if (n & SolverNotes_LSla_N_AARSoftRisk)
            res += ("N_AARSoftRisk"_view + ", "_view);

        if (n & SolverNotes_LSla_N_MoveMustSeq)
            res += ("N_MoveMustSeq"_view + ", "_view);

        if (n & SolverNotes_LSla_N_McomUnwrapsLetdef)
            res += ("N_McomUnwrapsLetdef"_view + ", "_view);

        if (n & SolverNotes_LSla_N_SD_HasStaticInit)
            res += ("N_SD_HasStaticInit"_view + ", "_view);

        if (n & SolverNotes_LSla_N_SD_ExternPrivates)
            res += ("N_SD_ExternPrivates"_view + ", "_view);

        if (n & SolverNotes_LSla_N_COWRestrict)
            res += ("N_COWRestrict"_view + ", "_view);

    };
    if (res)
        res.shrink((res.size() - 2));

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

static TokenIdx_5581 tryBacktrack_gDsn(const TokenIdx_5581& from, fu::view<char> v, const Kind_Idfg k, const Context_noPA& ctx)
{
    TokenIdx_5581 here = from;
    while (here.tokidx-- > 0)
    {
        const Token_6M7a& token = _token_xQNS(here, ctx);
        if (token.kind != k)
            break;
        else if (token.value == v)
            return here;

    };
    return TokenIdx_5581{};
}

                                #ifndef DEF_MAX_GzC5uMH53i1
                                #define DEF_MAX_GzC5uMH53i1
inline int MAX_GzC5()
{
    return 2147483647;
}
                                #endif

static bool isFnOrType_gDsn(const Helpers_DyqV& h, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here)
{
    return !!HelpersMask_w1sv(((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).mask & HelpersMask_w1sv((HelpersMask_w1sv_HM_Function | HelpersMask_w1sv_HM_Struct))));
}

static const Overload_aO3i& GET_gDsn(const Target_VZrr& target, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    const int modid = int(unsigned(((target._packed >> 40ull) & 0xfffffull)));
    const int globid = int(unsigned(((target._packed >> 20ull) & 0xfffffull)));
    unsigned v;
    const int locid = (v = unsigned((target._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
    const Scope_blWT& _scope = ((modid == module.modid) ? ss._scope : ctx.modules[modid].out.solve.scope);
    if ((globid > 0) && (_scope.overloads.size() >= globid))
    {
        if (locid)
        {
            if ((_scope.extended.size() <= globid))
                BUG_u9Gb("Invalid local target -modid."_view, ctx, _here);
            else
            {
                const Extended_z0HS& ext = _scope.extended[globid];
                return ext.args_n_locals[((ext.args_neg - ((locid > 0) ? 1 : 0)) + locid)];
            };
        }
        else
            return _scope.overloads[(globid - 1)];

    }
    else
        BUG_u9Gb("GET: bad globid"_view, ctx, _here);

}

static const Extended_z0HS& EXT_gDsn(const Target_VZrr& target, const SolverState_aGlN& ss, const Context_noPA& ctx, const Module_wo7O& module)
{
    unsigned v;
    if ((v = unsigned((target._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))))
        return (*(Extended_z0HS*)fu::NIL);
    else
    {
        const int modid = int(unsigned(((target._packed >> 40ull) & 0xfffffull)));
        const int globid = int(unsigned(((target._packed >> 20ull) & 0xfffffull)));
        const Scope_blWT& _scope = ((modid == module.modid) ? ss._scope : ctx.modules[modid].out.solve.scope);
        return _scope.extended[globid];
    };
}

                                #ifndef DEF_uNsigned_40Hlp3Rl5Y4
                                #define DEF_uNsigned_40Hlp3Rl5Y4
inline unsigned uNsigned_40Hl(const int v)
{
    return unsigned(v);
}
                                #endif

                                #ifndef DEF_iF_Xs5l3REeBb4
                                #define DEF_iF_Xs5l3REeBb4
inline const Ephemeral_xhb4& iF_Xs5l(fu::view<Ephemeral_xhb4> a, const int i)
{
    if (uNsigned_40Hl(i) < uNsigned_40Hl(a.size()))
        return a[i];
    else
        return (*(Ephemeral_xhb4*)fu::NIL);

}
                                #endif

static const Ephemeral_xhb4& EPH_gDsn(const Target_VZrr& target, const SolverState_aGlN& ss, const Module_wo7O& module)
{
    if (int(unsigned(((target._packed >> 40ull) & 0xfffffull))) == module.modid)
        return iF_Xs5l(ss._ephemeral, int(unsigned(((target._packed >> 20ull) & 0xfffffull))));
    else
        return (*(Ephemeral_xhb4*)fu::NIL);

}

                                #ifndef DEF_str_TMAshOI1dva
                                #define DEF_str_TMAshOI1dva
inline fu::str str_TMAs(const SolverPass_zVQ2 n)
{
    if (n == SolverPass_zVQ2_Solving)
        return fu::str("Solving"_fu);
    else if (n == SolverPass_zVQ2_RelaxMut)
        return fu::str("RelaxMut"_fu);
    else if (n == SolverPass_zVQ2_BorrowCheck)
        return fu::str("BorrowCheck"_fu);
    else if (n == SolverPass_zVQ2_ArgumentsAtRisk)
        return fu::str("ArgumentsAtRisk"_fu);
    else if (n == SolverPass_zVQ2_MaybeCopyOrMove)
        return fu::str("MaybeCopyOrMove"_fu);
    else if (n == SolverPass_zVQ2_RelaxCopyResize)
        return fu::str("RelaxCopyResize"_fu);

    return fu::i64dec(int64_t(n));
}
                                #endif

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(fu::view<char> a, fu::view<char> b)
{
    return a + b;
}
                                #endif

                                #ifndef DEF_max_BjFAioWEpjb
                                #define DEF_max_BjFAioWEpjb
inline int max_BjFA(const int a, const int b)
{
    if ((a >= b))
        return a;
    else
        return b;

}
                                #endif

                                #ifndef DEF_str_eN8kTaMKJA9
                                #define DEF_str_eN8kTaMKJA9
inline fu::str str_eN8k(const Kind_Idfg n)
{
    if (n == Kind_Idfg_sof)
        return fu::str("sof"_fu);
    else if (n == Kind_Idfg_err)
        return fu::str("err"_fu);
    else if (n == Kind_Idfg_eof)
        return fu::str("eof"_fu);
    else if (n == Kind_Idfg_id)
        return fu::str("id"_fu);
    else if (n == Kind_Idfg_op)
        return fu::str("op"_fu);
    else if (n == Kind_Idfg_int)
        return fu::str("int"_fu);
    else if (n == Kind_Idfg_real)
        return fu::str("real"_fu);
    else if (n == Kind_Idfg_char)
        return fu::str("char"_fu);
    else if (n == Kind_Idfg_str)
        return fu::str("str"_fu);
    else if (n == Kind_Idfg_bool)
        return fu::str("bool"_fu);
    else if (n == Kind_Idfg_definit)
        return fu::str("definit"_fu);
    else if (n == Kind_Idfg_empty)
        return fu::str("empty"_fu);
    else if (n == Kind_Idfg_struct)
        return fu::str("struct"_fu);
    else if (n == Kind_Idfg_union)
        return fu::str("union"_fu);
    else if (n == Kind_Idfg_primitive)
        return fu::str("primitive"_fu);
    else if (n == Kind_Idfg_flags)
        return fu::str("flags"_fu);
    else if (n == Kind_Idfg_enum)
        return fu::str("enum"_fu);
    else if (n == Kind_Idfg_fn)
        return fu::str("fn"_fu);
    else if (n == Kind_Idfg_copy)
        return fu::str("copy"_fu);
    else if (n == Kind_Idfg_move)
        return fu::str("move"_fu);
    else if (n == Kind_Idfg_arrlit)
        return fu::str("arrlit"_fu);
    else if (n == Kind_Idfg_not)
        return fu::str("not"_fu);
    else if (n == Kind_Idfg_call)
        return fu::str("call"_fu);
    else if (n == Kind_Idfg_call_indir)
        return fu::str("call_indir"_fu);
    else if (n == Kind_Idfg_argid)
        return fu::str("argid"_fu);
    else if (n == Kind_Idfg_root)
        return fu::str("root"_fu);
    else if (n == Kind_Idfg_block)
        return fu::str("block"_fu);
    else if (n == Kind_Idfg_if)
    {
        return fu::str("if"_fu);
    }
    else if (n == Kind_Idfg_or)
        return fu::str("or"_fu);
    else if (n == Kind_Idfg_and)
        return fu::str("and"_fu);
    else if (n == Kind_Idfg_loop)
        return fu::str("loop"_fu);
    else if (n == Kind_Idfg_jump)
        return fu::str("jump"_fu);
    else if (n == Kind_Idfg___far_jump)
        return fu::str("__far_jump"_fu);
    else if (n == Kind_Idfg_defer)
        return fu::str("defer"_fu);
    else if (n == Kind_Idfg_try)
        return fu::str("try"_fu);
    else if (n == Kind_Idfg_let)
        return fu::str("let"_fu);
    else if (n == Kind_Idfg_letdef)
        return fu::str("letdef"_fu);
    else if (n == Kind_Idfg_typecast)
        return fu::str("typecast"_fu);
    else if (n == Kind_Idfg_typeassert)
        return fu::str("typeassert"_fu);
    else if (n == Kind_Idfg_typeparam)
        return fu::str("typeparam"_fu);
    else if (n == Kind_Idfg_unwrap)
        return fu::str("unwrap"_fu);
    else if (n == Kind_Idfg_pragma)
        return fu::str("pragma"_fu);
    else if (n == Kind_Idfg_break)
        return fu::str("break"_fu);
    else if (n == Kind_Idfg_return)
        return fu::str("return"_fu);
    else if (n == Kind_Idfg_continue)
        return fu::str("continue"_fu);
    else if (n == Kind_Idfg_import)
        return fu::str("import"_fu);
    else if (n == Kind_Idfg_addroffn)
        return fu::str("addroffn"_fu);
    else if (n == Kind_Idfg_forfieldsof)
        return fu::str("forfieldsof"_fu);
    else if (n == Kind_Idfg_members)
        return fu::str("members"_fu);
    else if (n == Kind_Idfg_fnbranch)
        return fu::str("fnbranch"_fu);
    else if (n == Kind_Idfg_pattern)
        return fu::str("pattern"_fu);
    else if (n == Kind_Idfg_typeunion)
        return fu::str("typeunion"_fu);
    else if (n == Kind_Idfg_typetag)
        return fu::str("typetag"_fu);
    else if (n == Kind_Idfg___relaxed)
        return fu::str("__relaxed"_fu);
    else if (n == Kind_Idfg___convert)
        return fu::str("__convert"_fu);
    else if (n == Kind_Idfg___preceding_ref_arg)
        return fu::str(str_onytfN8TIli);
    else if (n == Kind_Idfg___serialized_type)
        return fu::str(str_QeWEBnJGbog);
    else if (n == Kind_Idfg___serialized_addrof_type_fn)
        return fu::str(str_QiuEJjR3RB9);
    else if (n == Kind_Idfg___litfix_bound)
        return fu::str("__litfix_bound"_fu);
    else if (n == Kind_Idfg___no_kind_yet)
        return fu::str("__no_kind_yet"_fu);
    else if (n == Kind_Idfg___tombstone)
        return fu::str("__tombstone"_fu);
    else if (n == Kind_Idfg_type)
        return fu::str("type"_fu);
    else if (n == Kind_Idfg_var)
        return fu::str("var"_fu);
    else if (n == Kind_Idfg_field)
        return fu::str("field"_fu);
    else if (n == Kind_Idfg_enumv)
        return fu::str("enumv"_fu);
    else if (n == Kind_Idfg_template)
        return fu::str("template"_fu);
    else if (n == Kind_Idfg___native)
        return fu::str("__native"_fu);
    else if (n == Kind_Idfg_inline)
        return fu::str("inline"_fu);

    return fu::i64dec(int64_t(n));
}
                                #endif

static const Target_VZrr& field_getParentStruct_gDsn(const Overload_aO3i& o, const Context_noPA& ctx, const TokenIdx_5581& _here)
{
    return o.solved.target ? o.solved.target : BUG_u9Gb("field_getParentStruct: solved.target not set."_view, ctx, _here);
}

static void PERF_slowPath_gDsn(const Options_TBgD& options)
{
    if (options.dev & DevOptions_QEya_DEV_HappyPathOnly)
    {
        const fu::str* x;
        fu::println(fu::view<fu::str> {{ fu::str((x = &(str_yehShWCF68e), (*x))) }});
    };
}

                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_has_Mnu2KTFEuhg
                                #define DEF_has_Mnu2KTFEuhg
inline bool has_Mnu2(fu::view<char> a, const char b)
{
    return (find_ZKsG(a, b) >= 0);
}
                                #endif

                                #ifndef DEF_find_rkz0SQgq7mk
                                #define DEF_find_rkz0SQgq7mk
inline int find_rkz0(fu::view<char> haystack, const char needle, const int start)
{
    fu::view<char> slice = fu::get_view(haystack, start);
    const int res = find_ZKsG(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF_replace_nuahYODApY2
                                #define DEF_replace_nuahYODApY2
inline fu::str replace_nuah(fu::vec_range<char> str, const char all, const char with)
{
    /*MOV*/ fu::str result {};

    {
        int last = 0;
        int next = 0;
        const int N = 1;
        while (((next = find_rkz0(str, all, last)) >= 0))
        {

            {
                fu::view<char> substr = fu::get_view(str, last, next);
                const bool first = !last;
                if (!first)
                    result += with;

                result += substr;
            };
            last = (next + N);
        };
        if (last)
        {
            fu::view<char> substr = fu::get_view(str, last);
            result += with;
            result += substr;
        }
        else
            return fu::str(str);

    };
    return /*NRVO*/ result;
}
                                #endif

static bool isLocal_gDsn(const Target_VZrr& target)
{
    unsigned v;
    return !!(v = unsigned((target._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
}

static Target_VZrr parent_gDsn(const Target_VZrr& target, const Context_noPA& ctx, const TokenIdx_5581& _here)
{
    if (isLocal_gDsn(target))
        return Target_xQNS(int(unsigned(((target._packed >> 40ull) & 0xfffffull))), int(unsigned(((target._packed >> 20ull) & 0xfffffull))), 0);
    else
        BUG_u9Gb("Using .parent on a non-local"_view, ctx, _here);

}

static fu::str human_gDsn(fu::vec_range<char> id, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    PERF_slowPath_gDsn(options);
    const Target_VZrr t = tryParseClosureID_UvH3(id, ctx, _here).target;
    if (!t)
    {
        if (has_Mnu2(id, '\n'))
            return trim_V5Iu(replace_nuah(id, '\n', ' ')).const_cast_mut().destructive_move_or_default();
        else
            return fu::str(id);

    }
    else
        return (GET_gDsn(parent_gDsn(t, ctx, _here), ss, ctx, _here, module).name + ":"_view) + GET_gDsn(t, ss, ctx, _here, module).name;

}

static fu::str str_IDns_gDsn(const Target_VZrr& from, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    if (from)
        return qID_e44U(human_gDsn(GET_gDsn(from, ss, ctx, _here, module).name, ss, ctx, _here, module, options)) + ":"_view;
    else
    {
        return fu::str{};
    };
}

static fu::str str_FDl5(const Target_VZrr& t, const bool brief, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    const Overload_aO3i& o = GET_gDsn(t, ss, ctx, _here, module);
    const Kind_Idfg kind = o.kind;
    fu::str prefix {};
    if (!brief)
    {
        prefix = str_eN8k(kind);
        if (kind == Kind_Idfg_var)
        {
            unsigned v;
            fu::str _0 {};
            prefix = ((_0 = ((((((((o.flags & Flags_Lzg8_F_INJECTED) ? "injected "_view : fu::view<char>{}) + ((o.flags & Flags_Lzg8_F_IMPLICIT) ? "implicit "_view : fu::view<char>{})) + ((o.flags & Flags_Lzg8_F_CONST) ? "const "_view : fu::view<char>{})) + ((o.flags & Flags_Lzg8_F_MUT) ? "mut "_view : fu::view<char>{})) + (((o.flags & ((Flags_Lzg8_F_REF | Flags_Lzg8_F_MUT) | Flags_Lzg8_F_CONST)) == Flags_Lzg8_F_REF) ? (is_mutref_9CJm(o.type, ctx, _here) ? "mut "_view : "const "_view) : fu::view<char>{})) + ((o.flags & Flags_Lzg8_F_REF) ? "ref "_view : fu::view<char>{})) + (((v = unsigned((t._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))) < 0) ? "arg "_view : fu::view<char>{}))) ? static_cast<fu::str&&>(_0) : fu::str("let "_fu));
            prefix.pop();
        };
    };
    fu::str ns {};
    if (kind == Kind_Idfg_field)
        ns = str_IDns_gDsn(field_getParentStruct_gDsn(o, ctx, _here), ss, ctx, _here, module, options);

    return ((prefix ? (qKW_e44U(prefix) + " "_view) : fu::str{}) + ns) + qID_e44U(human_gDsn(o.name, ss, ctx, _here, module, options));
}

                                #ifndef DEF_x7Ex3D_w1zac9Uldqj
                                #define DEF_x7Ex3D_w1zac9Uldqj
inline fu::view<char> x7Ex3D_w1za(fu::vec_range_mut<char> a, fu::view<char> b)
{
    return (a += b);
}
                                #endif

                                #ifndef DEF_x3Cx3E_EUmeLS7Aet5
                                #define DEF_x3Cx3E_EUmeLS7Aet5
inline int x3Cx3E_EUme(const Lifetime_llCF& a, const Lifetime_llCF& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_j5CR(a.uni0n, b.uni0n)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_PqSDPA95vvf
                                #define DEF_x3Cx3E_PqSDPA95vvf
inline int x3Cx3E_PqSD(const Type_OiTm& a, const Type_OiTm& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_9721(a.vtype, b.vtype)))
        return cmp;
    else if ((cmp = x3Cx3E_EUme(a.lifetime, b.lifetime)))
        return cmp;

    return 0;
}
                                #endif

                                #ifndef DEF_x3Dx3D_yMzO4dqUUO5
                                #define DEF_x3Dx3D_yMzO4dqUUO5
inline bool operator==(const Type_OiTm& a, const Type_OiTm& b)
{
    return !x3Cx3E_PqSD(a, b);
}
                                #endif

static fu::str explainTypeName_gDsn(const Type_OiTm& type, const bool brief, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    PERF_slowPath_gDsn(options);
    const Struct_LDkB& s = tryLookupUserType_1qjp(type.vtype, ctx, _here, module);
    Type_OiTm itemType {};
    if (s.kind)
    {
        return (!brief ? (qKW_e44U(str_eN8k(s.kind)) + " "_view) : fu::str{}) + qID_e44U(s.name);
    }
    else if ((itemType = tryClear_sliceable_1qjp(type.vtype, ctx, _here, module)))
    {
        if (itemType == t_byte)
            return qKW_e44U("string"_view);
        else
            return explainTypeName_gDsn(itemType, brief, ctx, _here, module, options) + qKW_e44U((TODO_FIX_isArray_9CJm(type) ? "[]"_view : "[..]"_view));

    }
    else if (is_zeroes_9CJm(type.vtype))
        return qKW_e44U("[]"_view);
    else
        return qKW_e44U(((type.vtype.canon == t_bool.vtype.canon) ? "bool"_view : ((type.vtype.canon == t_byte.vtype.canon) ? "byte"_view : type.vtype.canon)));

}

                                #ifndef DEF___Klt4cZr5Bpa
                                #define DEF___Klt4cZr5Bpa
inline static void _Klt4(const Argument_bbKc& arg, const int i, fu::vec_range_mut<char> reason, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    if (i)
        reason += ", "_view;

    reason += explainTypeName_gDsn(arg.type, true, ctx, _here, module, options);
}
                                #endif

                                #ifndef DEF_each_bwcCC2sStB3
                                #define DEF_each_bwcCC2sStB3
inline void each_bwcC(fu::view<Argument_bbKc> a, fu::vec_range_mut<char> reason, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    for (int i = 0; i < a.size(); i++)
        _Klt4(a[i], i, reason, ctx, _here, module, options);

}
                                #endif

static fu::str fail_appendStack_gDsn(/*MOV*/ fu::str&& reason, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    SolverPass_zVQ2 pass0 {};
    int callstack = 0;
    int skip_if_local_of = MAX_GzC5();
    bool ellipsis = false;
    for (int i = _helpers.size(); i-- > 0; )
    {
        const Helpers_DyqV& h = _helpers[i];
        if (isFnOrType_gDsn(h, ss, ctx, _here))
        {
            const Overload_aO3i& o = GET_gDsn((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).target, ss, ctx, _here, module);
            const Extended_z0HS& ext = EXT_gDsn((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).target, ss, ctx, module);
            const Ephemeral_xhb4& eph = EPH_gDsn((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).target, ss, module);
            if (o.kind == Kind_Idfg_fn)
            {
                if ((eph.local_of >= skip_if_local_of))
                {
                    if (!ellipsis)
                    {
                        ellipsis = true;
                        reason += ("\n                "_view + qDIM_e44U("..."_view));
                    };
                    continue;
                }
                else
                {
                    ellipsis = false;
                    if (!ext.spec_of)
                    {
                        skip_if_local_of = eph.local_of;
                    };
                };
            };
            if (!callstack++)
                reason += "\n"_view;

            SolverPass_zVQ2 _0;
            fu::str pass = (((_0 = pass0, (_0 != (pass0 = (((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).pass))) || (callstack == 1)) ? x7E_rA00(str_TMAs((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).pass), " "_view) : fu::str{});
            reason += (fu::get_view_start0("\n                "_view, max_BjFA((17 - pass.size()), 1)) + pass);
            x7Ex3D_w1za(reason, str_FDl5((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).target, false, ss, ctx, _here, module, options));
            if (ext.args)
            {
                reason += "("_view;
                each_bwcC(ext.args, reason, ctx, _here, module, options);
                reason += ")"_view;
            };
            const TokenIdx_5581& token = o.solved.token;
            if (token)
                reason += (" at "_view + formatTokenCoord_u9Gb(token, module.modid, ctx));

        };
    };
    return reason.destructive_move();
}

[[noreturn]] static fu::never fail_gDsn(fu::vec_range<char> reason, fu::view<char> backtrack, TokenIdx_5581&& token, fu::view<TokenIdx_5581> highlight, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (reason)
    {
        if (backtrack)
        {
            TokenIdx_5581 _0;
            token = ((_0 = tryBacktrack_gDsn(token, backtrack, Kind_Idfg_id, ctx)) ? static_cast<TokenIdx_5581&&>(_0) : TokenIdx_5581(token));
        };
        FAIL_u9Gb(fail_appendStack_gDsn(fu::str(reason), ss, ctx, _here, module, options, _helpers), (token + highlight), ctx);
    }
    else
        BUG_u9Gb("fail(): No reason."_view, ctx, _here);

}

[[noreturn]] static fu::never BUG_gDsn(fu::view<char> reason, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    fail_gDsn(("COMPILER BUG:\n\n\t"_view + (reason ? reason : "Assertion failed."_view)), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
}

extern const unsigned q_TAGS;
extern const unsigned q_USAGE;
                                #ifndef DEF_x21x3D_4aLNyMeIDy5
                                #define DEF_x21x3D_4aLNyMeIDy5
inline bool operator!=(const Lifetime_llCF& a, const Lifetime_llCF& b)
{
    return !!x3Cx3E_EUme(a, b);
}
                                #endif

static Target_VZrr nested_gDsn(const int index, const Target_VZrr& from, const Context_noPA& ctx, const TokenIdx_5581& _here)
{
    if (index != 0)
        return Target_xQNS(int(unsigned(((from._packed >> 40ull) & 0xfffffull))), int(unsigned(((from._packed >> 20ull) & 0xfffffull))), index);
    else
        BUG_u9Gb("nested(): bad locid"_view, ctx, _here);

}

static Target_VZrr nested_FDl5(const int index, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here)
{
    return nested_gDsn(index, ss._nestingFnort, ctx, _here);
}

static UnpackedOffset_f7kz field_unpackOffset_gDsn(const Overload_aO3i& o, const Context_noPA& ctx, const TokenIdx_5581& _here)
{
    if (o.kind == Kind_Idfg_field)
    {
        const int packed = o.solved.helpers.index;
        return UnpackedOffset_f7kz { (packed & 0xffff), (packed >> 16) };
    }
    else
        BUG_u9Gb("field_unpackOffset: Not a field."_view, ctx, _here);

}

                                #ifndef DEF_onSubRegion_cZZPnNPDTH0
                                #define DEF_onSubRegion_cZZPnNPDTH0
inline static void onSubRegion_cZZP(const int flatCount, int flatOffset, const bool isFirstSubRegion, const bool isLastSubRegion, const bool isLastPath, const int locid, Type_OiTm& type, fu::str& str, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    if (isFirstSubRegion)
        type = GET_gDsn(nested_FDl5(locid, ss, ctx, _here), ss, ctx, _here, module).type;

    for (; ; )
    { {
        const Struct_LDkB& s = tryLookupUserType_1qjp(type.vtype, ctx, _here, module);
        if ((flatCount >= s.shape.flatCount))
            break;
        else
        {
            for (int i = 0; i < s.items.size(); i++)
            {
                const Overload_aO3i& o = GET_gDsn(target_z0Qq(s.items[i]), ss, ctx, _here, module);
                const UnpackedOffset_f7kz _ = field_unpackOffset_gDsn(o, ctx, _here);
                if ((_.memberFlatOffset + _.memberFlatCount) > flatOffset)
                {
                    type = o.type;
                    flatOffset -= _.memberFlatOffset;
                    str += ("."_view + qID_e44U(human_gDsn(o.name, ss, ctx, _here, module, options)));
                    goto BL_3;
                };
            };
            break;
        };
      } BL_3:;
    };
    if (!isLastSubRegion)
    {
        if (is_sliceable_hxWW(type.vtype))
            type = clear_sliceable_1qjp(type.vtype, ctx, _here, module);

        str += "*"_view;
    };
    if (isLastSubRegion && !isLastPath)
        str += ", "_view;

}
                                #endif

                                #ifndef DEF___zlkPxhhAQk7
                                #define DEF___zlkPxhhAQk7
inline static void _zlkP(const int locid, const bool isStatic, const bool isTemp, const bool isArgIdx, const bool isAlwaysMoveable, const int argidx, fu::view<char> paths, const bool brief, fu::str& str, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    if (str)
        str += qLT_e44U("|"_view);

    str += (locid ? str_FDl5(nested_FDl5(locid, ss, ctx, _here), true, ss, ctx, _here, module, options) : (isStatic ? (isAlwaysMoveable ? qLT_e44U("zeroes"_view) : qLT_e44U("static"_view)) : (isTemp ? qLT_e44U("temp"_view) : (isArgIdx ? x7E_rA00("arg#"_view, fu::i64dec(argidx)) : BUG_u9Gb("invalid region"_view, ctx, _here)))));
    if (locid && !brief)
    {
        Type_OiTm type {};
        int offset = 0;
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit_7Yz9(paths, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(paths, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                const int flatCount = int((raw_flatCount >> 1u));
                const int flatOffset = int((raw_flatOffset >> 1u));
                onSubRegion_cZZP(flatCount, flatOffset, isFirstSubRegion, isLastSubRegion, isLastPath, locid, type, str, ss, ctx, _here, module, options);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        if (!(offset == paths.size()))
            BUG_u9Gb("walkPaths(!tailOK): excess bytes"_view, ctx, _here);

    };
}
                                #endif

                                #ifndef DEF_Lifetime_each_jDjvnb3Gdea
                                #define DEF_Lifetime_each_jDjvnb3Gdea
inline void Lifetime_each_jDjv(const Lifetime_llCF& lifetime, const bool brief, fu::str& str, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit_7Yz9(chars, offset);
        int offset0;
        int BL_3_v;
        const int sr = (__extension__ (
        {
            offset0 = (offset + 0);
            for (; ; )
            {
                bool isLastPath = false;
                bool isFirstSubRegion = true;
                for (; ; )
                {
                    const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                    isLastPath = !(raw_flatCount & 1u);
                    if (isLastSubRegion)
                        break;
                    else
                        isFirstSubRegion = false;

                };
                if (isLastPath)
                    break;

            };
            BL_3_v = (offset0);
            (void)0;
        }), BL_3_v);
        unsigned v;
        _zlkP(((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))))), ((r & 11u) == 1u), (r == 0b1001u), ((r & 3u) == 3u), ((r == 0b0101u) || (r == 0b1001u)), int(((r & 1u) ? (r >> 2u) : 0u)), fu::get_view(chars, sr, offset), brief, str, ss, ctx, _here, module, options);
    };
}
                                #endif

static fu::str str_gDsn(const Lifetime_llCF& lifetime, const bool brief, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    /*MOV*/ fu::str str {};
    Lifetime_each_jDjv(lifetime, brief, str, ss, ctx, _here, module, options);
    return /*NRVO*/ str;
}

                                #ifndef DEF___2DqUW96m2lk
                                #define DEF___2DqUW96m2lk
inline static void _2DqU(fu::view<char> argSpecType, const bool isFirst, fu::str& result, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    if (!isFirst)
        result += ", "_view;

    result += explainType_gDsn(Type_OiTm { parseType_1qjp(argSpecType, ctx, _here, module), Lifetime_llCF{} }, true, false, true, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options);
}
                                #endif

                                #ifndef DEF_eachArgSpecType_yscb44Cj4Qj
                                #define DEF_eachArgSpecType_yscb44Cj4Qj
inline void eachArgSpecType_yscb(fu::view<char> subPattern, fu::str& result, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    int offset = 0;
    for (; ; )
    {
        const int start = offset;
        bool isLastArgSpecType {};
        scan_Ot6w(subPattern, ':', offset, isLastArgSpecType);
        _2DqU(fu::get_view(subPattern, start, offset), !start, result, ss, ctx, _here, module, options);
        if (isLastArgSpecType)
            break;
        else
            offset++;

    };
}
                                #endif

                                #ifndef DEF___X675nyOUjb7
                                #define DEF___X675nyOUjb7
inline static void _X675(fu::view<char> pattern, fu::str& result, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    result += "("_view;
    eachArgSpecType_yscb(pattern, result, ss, ctx, _here, module, options);
    result += ")"_view;
}
                                #endif

                                #ifndef DEF_eachSubPattern_75aO7Uq8cp3
                                #define DEF_eachSubPattern_75aO7Uq8cp3
inline void eachSubPattern_75aO(fu::view<char> pattern, fu::str& result, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    int offset = 0;
    for (; ; )
    {
        parseGlobal_xQNS(pattern, offset);
        const int start = offset;
        bool isLastSubPattern {};
        scan_Ot6w(pattern, '|', offset, isLastSubPattern);
        _X675(fu::get_view(pattern, start, offset), result, ss, ctx, _here, module, options);
        if (isLastSubPattern)
            break;
        else
            offset++;

    };
}
                                #endif

                                #ifndef DEF_ends_OW45P9GlDid
                                #define DEF_ends_OW45P9GlDid
inline bool ends_OW45(fu::view<char> a, fu::view<char> with)
{
    return (a.size() >= with.size()) && (fu::get_view(a, (a.size() - with.size()), a.size()) == with);
}
                                #endif

                                #ifndef DEF_remove_XzGUSjv5k55
                                #define DEF_remove_XzGUSjv5k55
inline void remove_XzGU(fu::vec_range_mut<char> a, const int at, const int count)
{
    a.splice(at, count);
}
                                #endif

static void appendUsage_gDsn(const Type_OiTm& type, const unsigned usage, fu::str& result, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    result += " { "_view;
    if (!usage)
        result += "- "_view;
    else
    {
        const Struct_LDkB& s = tryLookupUserType_1qjp(type.vtype, ctx, _here, module);
        if (!s)
            result += "* "_view;
        else
        {
            for (int i = 0; i < s.items.size(); i++)
            {
                const Target_VZrr f = target_z0Qq(s.items[i]);
                const Overload_aO3i& o = GET_gDsn(f, ss, ctx, _here, module);
                const UnpackedOffset_f7kz _ = field_unpackOffset_gDsn(o, ctx, _here);
                const ValueType_JtNg* type_1;
                const unsigned match = USAGE_fieldUsageFromStructUsage_CaGD((type_1 = &(o.type.vtype), ((*type_1).quals & q_USAGE)), usage, _.memberFlatOffset, _.memberFlatCount);
                if (match)
                {
                    result += qID_e44U(human_gDsn(o.name, ss, ctx, _here, module, options));
                    if (match != getMaxUsage_CaGD(_.memberFlatCount))
                        appendUsage_gDsn(o.type, match, result, ss, ctx, _here, module, options);
                    else
                        result += ", "_view;

                };
            };
        };
    };
    if (ends_OW45(result, ", "_view))
        remove_XzGU(result, (result.size() - 2), 1);

    result += "}"_view;
}

static fu::str explainType_gDsn(const Type_OiTm& type, const bool brief, bool lt, bool no_quals, bool usage, bool no_vfacts, const Type_OiTm& diff, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    if (!type)
        return fu::str("< Empty Type >"_fu);
    else
    {
        if (diff)
        {
            no_quals = true;
            no_vfacts = true;
            if (isCanonAssignable_Ot6w(type.vtype.canon, diff.vtype.canon, ctx, _here) || isCanonAssignable_Ot6w(diff.vtype.canon, type.vtype.canon, ctx, _here))
            {
                no_quals = ((type.vtype.quals & q_TAGS) == (diff.vtype.quals & q_TAGS));
                no_vfacts = (type.vtype.vfacts == diff.vtype.vfacts);
                usage = ((type.vtype.quals & q_USAGE) != (diff.vtype.quals & q_USAGE));
                lt = (type.lifetime != diff.lifetime);
            };
        };
        /*MOV*/ fu::str result {};
        if (!no_vfacts && type.vtype.vfacts)
            result += explainVFacts_9CJm(type.vtype.vfacts);

        if (!no_quals)
        {
            result += explainQuals_9CJm(type.vtype.quals, (lt ? type.lifetime : (*(Lifetime_llCF*)fu::NIL)));
        };
        if (lt && type.lifetime)
        {
            result += (str_gDsn(type.lifetime, brief, ss, ctx, _here, module, options) + " "_view);
        };
        result += explainTypeName_gDsn(type, brief, ctx, _here, module, options);
        fu::view<char> pattern = tryGetPattern_Ot6w(type.vtype.canon);
        if (pattern)
            eachSubPattern_75aO(pattern, result, ss, ctx, _here, module, options);

        if (usage)
            appendUsage_gDsn(type, (type.vtype.quals & q_USAGE), result, ss, ctx, _here, module, options);

        return /*NRVO*/ result;
    };
}

static fu::str addr_and_snippet_gDsn(const TokenIdx_5581& token, const CodeFmt_snPx fmt, fu::view<char> backtrack, const Context_noPA& ctx, const Module_wo7O& module)
{
    /*MOV*/ fu::vec<TokenIdx_5581> tokens = fu::vec<TokenIdx_5581> {{ TokenIdx_5581(token) }};
    if (backtrack)
    {
        const TokenIdx_5581 other = tryBacktrack_gDsn(token, backtrack, Kind_Idfg_id, ctx);
        if (other)
        {
            tokens.unshift(TokenIdx_5581(other));
        };
    };
    return formatCodeSnippet_k53p(static_cast<fu::vec<TokenIdx_5581>&&>(tokens), module.modid, fmt, ctx);
}

                                #ifndef DEF_x3Cx3E_nZia4yUzL0e
                                #define DEF_x3Cx3E_nZia4yUzL0e
inline int x3Cx3E_nZia(const TokenIdx_5581& a, const TokenIdx_5581& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_odNT(a.modid, b.modid)))
        return cmp;
    else if ((cmp = x3Cx3E_odNT(a.tokidx, b.tokidx)))
        return cmp;

    return 0;
}
                                #endif

                                #ifndef DEF_x21x3D_96a3VvPDzT4
                                #define DEF_x21x3D_96a3VvPDzT4
inline bool operator!=(const TokenIdx_5581& a, const TokenIdx_5581& b)
{
    return !!x3Cx3E_nZia(a, b);
}
                                #endif

                                #ifndef DEF_x3Cx3E_XvO8JNMMsGh
                                #define DEF_x3Cx3E_XvO8JNMMsGh
inline int x3Cx3E_XvO8(const uint64_t a, const uint64_t b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YjZYNFAHEO6
                                #define DEF_x3Cx3E_YjZYNFAHEO6
inline int x3Cx3E_YjZY(const Target_VZrr& a, const Target_VZrr& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_XvO8(a._packed, b._packed)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x21x3D_l4Radib4xId
                                #define DEF_x21x3D_l4Radib4xId
inline bool operator!=(const Target_VZrr& a, const Target_VZrr& b)
{
    return !!x3Cx3E_YjZY(a, b);
}
                                #endif

static fu::str str_wyx7(const Argument_bbKc& arg, const bool brief, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    fu::str prefix = ((((arg.flags & Flags_Lzg8_F_INJECTED) ? "injected "_view : fu::view<char>{}) + ((arg.flags & Flags_Lzg8_F_IMPLICIT) ? "implicit "_view : fu::view<char>{})) + ((arg.flags & Flags_Lzg8_F_REF) ? "ref "_view : fu::view<char>{}));
    prefix += "arg"_view;
    fu::str ns {};
    if (arg.target && !brief)
    {
        const Target_VZrr parent = parent_gDsn(arg.target, ctx, _here);
        if (parent != _current_fn.out.target)
            ns = str_IDns_gDsn(parent, ss, ctx, _here, module, options);

    };
    return ((qKW_e44U(prefix) + " "_view) + ns) + qID_e44U(human_gDsn(arg.name, ss, ctx, _here, module, options));
}

static fu::str explainConversion_gDsn(fu::view<Target_VZrr> path, fu::view<char> prefix, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    /*MOV*/ fu::str res {};
    for (int i = 0; i < path.size(); i++)
    {
        if (!i)
            res += "\n"_view;

        res += "\t    "_view;
        if (!i && prefix)
            res += prefix;

        res += (qKW_e44U("using"_view) + " "_view);
        res += explainWhichFn_gDsn(Target_VZrr(path[i]), fu::view<fu::vec<Target_VZrr>>{}, "using"_view, CodeFmt_snPx_NoContext, _current_fn, ss, ctx, _here, module, options);
    };
    return /*NRVO*/ res;
}

static fu::str explainWhichFn_gDsn(Target_VZrr&& t, fu::view<fu::vec<Target_VZrr>> conversions, fu::view<char> backtrack, const CodeFmt_snPx fmt, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    /*MOV*/ fu::str result = str_FDl5(t, false, ss, ctx, _here, module, options);
    while (GET_gDsn(t, ss, ctx, _here, module).flags & Flags_Lzg8_F_INJECTED)
    {
        const ClosureID_qHEW cid = tryParseClosureID_UvH3(GET_gDsn(t, ss, ctx, _here, module).name, ctx, _here);
        if (!cid)
            break;
        else
            t = cid.target;

    };
    if (GET_gDsn(t, ss, ctx, _here, module).flags & Flags_Lzg8_F_INJECTED)
        result += "\n"_view;
    else
    {
        const TokenIdx_5581& t0 = EXT_gDsn(t, ss, ctx, module).tEmplate.node.token;
        const TokenIdx_5581& t1 = GET_gDsn(t, ss, ctx, _here, module).solved.token;
        if (t0 || t1)
            result += (" at "_view + addr_and_snippet_gDsn((t0 ? t0 : t1), fmt, backtrack, ctx, module));

        if (t0 && t1 && (t0 != t1))
            result += ("\n\t    ... via "_view + addr_and_snippet_gDsn(t1, fmt, backtrack, ctx, module));

        for (int i = 0; i < conversions.size(); i++)
        {
            fu::view<Target_VZrr> c = conversions[i];
            if (c)
            {
                result += explainConversion_gDsn(c, ((EXT_gDsn(t, ss, ctx, module).args.size() > 1) ? x7E_rA00(str_wyx7(EXT_gDsn(t, ss, ctx, module).args[i], false, _current_fn, ss, ctx, _here, module, options), ": "_view) : fu::str{}), _current_fn, ss, ctx, _here, module, options);
            };
        };
    };
    return /*NRVO*/ result;
}

static StaticEval_IZio tryAbstractEvalAsBool_gDsn(const SolvedNode_efhg& cond, const bool voidOk, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (cond.type.vtype.vfacts & VFacts_xhRf((VFacts_xhRf_AlwaysTrue | VFacts_xhRf_AlwaysFalse)))
    {
        if (!VFacts_xhRf((cond.type.vtype.vfacts & VFacts_xhRf_AlwaysTrue)))
            return StaticEval_IZio_SE_False;
        else if (!VFacts_xhRf((cond.type.vtype.vfacts & VFacts_xhRf_AlwaysFalse)))
            return StaticEval_IZio_SE_True;
        else
            BUG_gDsn("Expression both AlwaysTrue and AlwaysFalse."_view, ss, ctx, _here, module, options, _helpers);

    }
    else if (isIrrelevant_9CJm(cond.type))
    {
        if (voidOk)
            return StaticEval_IZio_SE_False;
        else
        {
            fail_gDsn(((((((("Condition is an always-empty "_view + explainType_gDsn(cond.type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)) + ((cond.kind == Kind_Idfg_call) ? (", returned from "_view + explainWhichFn_gDsn(Target_VZrr(cond.target), fu::view<fu::vec<Target_VZrr>>{}, fu::view<char>{}, CodeFmt_snPx_FullContext, _current_fn, ss, ctx, _here, module, options)) : fu::str(str_0ea6zET6IM5))) + "\n\n\tIf this is expected, use "_view) + qID_e44U("!="_view)) + " "_view) + qKW_e44U("[]"_view)) + " to suppress this warning."_view), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
        };
    }
    else
        return StaticEval_IZio_SE_Unknown;

}

                                #ifndef DEF_ensure_K25Gan5T2Ub
                                #define DEF_ensure_K25Gan5T2Ub
inline Ephemeral_xhb4& ensure_K25G(fu::vec_range_mut<Ephemeral_xhb4> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

static Ephemeral_xhb4& EPH_mut_gDsn(const int index, SolverState_aGlN& ss)
{
    return ensure_K25G(ss._ephemeral, index);
}

static Ephemeral_xhb4& EPH_mut_FDl5(const Target_VZrr& target, SolverState_aGlN& ss, const Module_wo7O& module)
{
    if (int(unsigned(((target._packed >> 40ull) & 0xfffffull))) == module.modid)
        return EPH_mut_gDsn(int(unsigned(((target._packed >> 20ull) & 0xfffffull))), ss);
    else
        fu::fail(fu::str(str_yabg9ydVki8));

}

static bool is_SPECFAIL_gDsn(const Target_VZrr& target)
{
    return !!(target._packed & 0x8000000000000000ull);
}

static Overload_aO3i& GET_mut_gDsn(const Target_VZrr& target, SolverState_aGlN& ss, const Module_wo7O& module)
{
    const int globid = int(unsigned(((target._packed >> 20ull) & 0xfffffull)));
    unsigned v;
    const int locid = (v = unsigned((target._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
    if ((globid > 0) && (int(unsigned(((target._packed >> 40ull) & 0xfffffull))) == module.modid))
    {
        if (locid)
        {
            Extended_z0HS& ext = ss._scope.extended.mutref(globid);
            const Extended_z0HS* ext_1;
            return ext.args_n_locals.mutref((ext_1 = &(ext), (((*ext_1).args_neg - ((locid > 0) ? 1 : 0)) + locid)));
        }
        else
            return ss._scope.overloads.mutref((globid - 1));

    }
    else
        fu::fail(fu::str(str_gRoMTrquoqa));

}

                                #ifndef DEF_steal_LVBpZyqzP1g
                                #define DEF_steal_LVBpZyqzP1g
inline CountedSet_C7kV steal_LVBp(CountedSet_C7kV& v)
{
    /*MOV*/ CountedSet_C7kV ret {};
    std::swap(v, ret);
    return /*NRVO*/ ret;
}
                                #endif

static Target_VZrr localfn_gDsn(const int index, const Module_wo7O& module)
{
    return Target_xQNS(module.modid, index, 0);
}

                                #ifndef DEF_remove_y2Z0M2I9Eq4
                                #define DEF_remove_y2Z0M2I9Eq4
inline static void remove_y2Z0(const int i, Set_qOJY& _, fu::vec_range_mut<int> values)
{
    _.keys_asc.splice(i, 1);
    values.splice(i, 1);
}
                                #endif

                                #ifndef DEF_remove_GZxJ4wwom6f
                                #define DEF_remove_GZxJ4wwom6f
inline bool remove_GZxJ(Map_99Lz& _, const int key)
{

    {
        Set_qOJY& __1 = _.keys;
        fu::vec<int>& values = _.vals;
        fu::view<int> keys_asc = __1.keys_asc;
        int lo = 0;
        int hi = keys_asc.size();
        while (lo < hi)
        {
            const int i = ((hi + lo) >> 1);
            const int cmp = x3Cx3E_odNT(keys_asc[i], key);
            if (cmp == 0)
            {
                remove_y2Z0(i, __1, values);
                return true;
            }
            else if (cmp < 0)
                lo = (i + 1);
            else
                hi = i;

        };
    };
    return false;
}
                                #endif

                                #ifndef DEF_remove_qxmVHJsZ4G4
                                #define DEF_remove_qxmVHJsZ4G4
inline bool remove_qxmV(CountedSet_C7kV& _, const int key)
{
    return remove_GZxJ(_.counts, key);
}
                                #endif

                                #ifndef DEF___eZbe1UETKp9
                                #define DEF___eZbe1UETKp9
inline static void _eZbe(const int callee, const Target_VZrr& target, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const Target_VZrr callee_1 = localfn_gDsn(callee, module);
    int _0;
    if (!((_0 = int(unsigned(((target._packed >> 20ull) & 0xfffffull))), remove_qxmV(EPH_mut_FDl5(callee_1, ss, module).callers, _0))))
        BUG_gDsn(x7E_rA00("resetChild: Missing in callers on "_view, str_FDl5(callee_1, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

}
                                #endif

                                #ifndef DEF___V8mQtu0Wtc2
                                #define DEF___V8mQtu0Wtc2
inline static void _V8mQ(const int key, const Target_VZrr& target, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    _eZbe(key, target, ss, ctx, _here, module, options, _helpers);
}
                                #endif

                                #ifndef DEF_each_Kze0hF59KVg
                                #define DEF_each_Kze0hF59KVg
inline void each_Kze0(const Map_99Lz& _, const Target_VZrr& target, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    for (int i = 0; i < _.vals.size(); i++)
    {
        const int key = _.keys.keys_asc[i];
        _V8mQ(key, target, ss, ctx, _here, module, options, _helpers);
    };
}
                                #endif

                                #ifndef DEF_each_TWCQ6fWGr84
                                #define DEF_each_TWCQ6fWGr84
inline void each_TWCQ(const CountedSet_C7kV& _, const Target_VZrr& target, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    each_Kze0(_.counts, target, ss, ctx, _here, module, options, _helpers);
}
                                #endif

                                #ifndef DEF___PKZQ8hAcLK1
                                #define DEF___PKZQ8hAcLK1
inline static void _PKZQ(const int caller, const Target_VZrr& target, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const Target_VZrr caller_1 = localfn_gDsn(caller, module);
    int _0;
    if (!((_0 = int(unsigned(((target._packed >> 20ull) & 0xfffffull))), remove_qxmV(EPH_mut_FDl5(caller_1, ss, module).calls, _0))))
        BUG_gDsn(x7E_rA00("resetChild: Missing in calls on "_view, str_FDl5(caller_1, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

}
                                #endif

                                #ifndef DEF___wteQiiAKYxj
                                #define DEF___wteQiiAKYxj
inline static void _wteQ(const int key, const Target_VZrr& target, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    _PKZQ(key, target, ss, ctx, _here, module, options, _helpers);
}
                                #endif

                                #ifndef DEF_each_ghm5RsdZxd0
                                #define DEF_each_ghm5RsdZxd0
inline void each_ghm5(const Map_99Lz& _, const Target_VZrr& target, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    for (int i = 0; i < _.vals.size(); i++)
    {
        const int key = _.keys.keys_asc[i];
        _wteQ(key, target, ss, ctx, _here, module, options, _helpers);
    };
}
                                #endif

                                #ifndef DEF_each_Jw3KDrTvBhi
                                #define DEF_each_Jw3KDrTvBhi
inline void each_Jw3K(const CountedSet_C7kV& _, const Target_VZrr& target, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    each_ghm5(_.counts, target, ss, ctx, _here, module, options, _helpers);
}
                                #endif

static Extended_z0HS& EXT_mut_gDsn(const Target_VZrr& target, SolverState_aGlN& ss, const Module_wo7O& module)
{
    const int globid = int(unsigned(((target._packed >> 20ull) & 0xfffffull)));
    unsigned v;
    if ((globid > 0) && (globid < ss._scope.extended.size()) && (int(unsigned(((target._packed >> 40ull) & 0xfffffull))) == module.modid) && !(v = unsigned((target._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))))
        return ss._scope.extended.mutref(globid);
    else
        fu::fail(fu::str(str_tL0MTx4Z4n2));

}

static void resetChild_gDsn(const Target_VZrr& target, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (!(is_SPECFAIL_gDsn(target)))
    {
        SolverStatus_h9em& status = GET_mut_gDsn(target, ss, module).status;
        if (status & SolverStatus_h9em_SS_LAZY)
        {
            status &= SolverStatus_h9em(~SolverStatus_h9em((SolverStatus_h9em((SolverStatus_h9em_SS_DID_START | SolverStatus_h9em_SS_FINALIZED)) | SolverStatus_h9em_SS_DIRTY)));
            CountedSet_C7kV calls = steal_LVBp(EPH_mut_FDl5(target, ss, module).calls);
            each_TWCQ(calls, target, ss, ctx, _here, module, options, _helpers);
            CountedSet_C7kV callers = steal_LVBp(EPH_mut_FDl5(target, ss, module).callers);
            each_Jw3K(callers, target, ss, ctx, _here, module, options, _helpers);
            fu::vec<Argument_bbKc>& args = EXT_mut_gDsn(target, ss, module).args;
            for (int i = args.size(); i-- > 0; )
            {
                if (args[i].flags & Flags_Lzg8_F_INJECTED)
                    args.splice(i, 1);

            };
            if (EPH_gDsn(target, ss, module).calls)
            {
                BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers);
            };
        }
        else
            BUG_gDsn(x7E_rA00("resetChild: not SS_LAZY: "_view, str_FDl5(target, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

    };
}

                                #ifndef DEF_onReuse_ggBhgeikACi
                                #define DEF_onReuse_ggBhgeikACi
inline static void onReuse_ggBh(const Target_VZrr& target, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    resetChild_gDsn(target, ss, ctx, _here, module, options, _helpers);
}
                                #endif

static Template_SsLx createTemplate_gDsn(const Node_JjyR& node, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss)
{
    return Template_SsLx { Node_JjyR(node), fu::vec<int>((!_current_fn ? ss._scope.imports : (*(fu::vec<int>*)fu::NIL))) };
}

                                #ifndef DEF_onCreate_rzMP62sUlji
                                #define DEF_onCreate_rzMP62sUlji
inline static void onCreate_rzMP(const Target_VZrr& target, const Node_JjyR& node, const SolverStatus_h9em status, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Module_wo7O& module)
{
    Overload_aO3i& o = GET_mut_gDsn(target, ss, module);
    o.kind = Kind_Idfg_fn;
    o.name = ("prep "_view + node.value);
    o.flags = node.flags;
    o.status = status;
    Extended_z0HS& ext = EXT_mut_gDsn(target, ss, module);
    ext.tEmplate = createTemplate_gDsn(node, _current_fn, ss);
    ext.min = int(0x7fffffffu);
    ext.max = 0;
}
                                #endif

                                #ifndef DEF_getOrCreateChild_VRsIuZ4bVJ5
                                #define DEF_getOrCreateChild_VRsIuZ4bVJ5
inline static Target_VZrr getOrCreateChild_VRsI(const Node_JjyR& node, const Node_JjyR& node_1, const SolverStatus_h9em status, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const Target_VZrr& parent = _current_fn.out.target;
    if (parent)
    {
        const unsigned parent_rev = EPH_gDsn(parent, ss, module).revision;
        fu::view_mut<ChildTarget_FjNI> children = EPH_mut_FDl5(parent, ss, module).children;
        for (int i = 0; i < children.size(); i++)
        {
            ChildTarget_FjNI& child = children.mutref(i);
            if (!((child.token != node.token) || (child.parent_rev == parent_rev)))
            {
                child.parent_rev = parent_rev;
                const Target_VZrr target = child.target;
                onReuse_ggBh(target, ss, ctx, _here, module, options, _helpers);
                return target;
            };
        };
    };
    const Target_VZrr target = Scope_create_z0Qq(ss._scope, Kind_Idfg___no_kind_yet, (*(fu::str*)fu::NIL), (*(Type_OiTm*)fu::NIL), Flags_Lzg8{}, DeclAsserts_taUG{}, SolverStatus_h9em{}, 0, false, module);
    onCreate_rzMP(target, node_1, status, _current_fn, ss, module);
    if (parent)
    {
        const unsigned parent_rev = EPH_gDsn(parent, ss, module).revision;
        fu::vec<ChildTarget_FjNI>& children = EPH_mut_FDl5(parent, ss, module).children;
        children += ChildTarget_FjNI { TokenIdx_5581(node.token), parent_rev, Target_VZrr(target) };
    };
    return target;
}
                                #endif

static bool shouldAutoshadow_gDsn(fu::view<char> id, const SolverState_aGlN& ss)
{

    {
        fu::view<ScopeItem_xiLD> items = ss._scope.items;
        fu::view<ScopeSkip_iozY> scope_skip = ss._ss.items;
        const int start = 0;
        const ScopeSkip_iozY END_DUMMY = ScopeSkip_iozY { items.size(), items.size() };
        int i0 = start;
        for (int i = 0; i < (scope_skip.size() + 1); i++)
        {
            const ScopeSkip_iozY& ss_1 = ((i < scope_skip.size()) ? scope_skip[i] : END_DUMMY);
            if (!((ss_1.end <= i0)))
            {
                const int i1 = ss_1.start;
                for (int i_1 = i0; i_1 < i1; i_1++)
                {
                    const ScopeItem_xiLD& item = items[i_1];
                    const int i_2 = i_1;
                    if ((i_2 >= ss._root_scope.items_len) && (item.id == id))
                        return false;

                };
                i0 = ss_1.end;
            };
        };
    };
    return true;
}

static void autoshadow_gDsn(bool& shadows, const int local_of, fu::view<char> id, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss)
{
    if (!(!_current_fn.autoshadow_ok))
    {
        if (!shadows && local_of && shouldAutoshadow_gDsn(id, ss))
            shadows = true;

    };
}

static ScopeMemo_9hVQ Scope_snap_gDsn(const SolverState_aGlN& ss, fu::view<Helpers_DyqV> _helpers)
{
    return ScopeMemo_9hVQ { ss._scope.items.size(), ss._scope.implicits.size(), ss._scope.imports.size(), ss._scope.privates.size(), ss._scope.usings.size(), ss._scope.converts.size(), _helpers.size() };
}

static Type_OiTm X_addrofTarget_gDsn(fu::view<Target_VZrr> targets)
{
    return Type_OiTm { ValueType_JtNg { 0u, VFacts_xhRf{}, packAddrOfFn_9CJm(targets) }, Lifetime_llCF{} };
}

static Type_OiTm X_addrofTarget_FDl5(const Target_VZrr& target)
{
    return X_addrofTarget_gDsn(fu::view<Target_VZrr> {{ Target_VZrr(target) }});
}

static SolvedNode_efhg SolvedNode_gDsn(const Kind_Idfg kind, const Type_OiTm& type, const Flags_Lzg8 flags, fu::vec_range<char> value, fu::vec_range<SolvedNode_efhg> items, const Target_VZrr& target, const Helpers_DyqV& helpers, const TokenIdx_5581& _here)
{
    return SolvedNode_efhg { kind, Helpers_DyqV(helpers), (flags | Flags_Lzg8_F_TEST_painted), 0, fu::str(value), fu::vec<SolvedNode_efhg>(items), TokenIdx_5581(_here), Type_OiTm(type), Target_VZrr(target) };
}

extern const Lifetime_llCF Lifetime_static_moveable;
static void intoEmpty_gDsn(SolvedNode_efhg& node, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    node.kind = Kind_Idfg_empty;
    node.helpers = Helpers_DyqV{};
    if (node.items)
        BUG_gDsn("intoEmpty: !!node.items"_view, ss, ctx, _here, module, options, _helpers);
    else
    {
        Type_OiTm& type = node.type;
        const bool canDiscard = isIrrelevant_9CJm(type);
        if (type.lifetime)
        {
            if (canDiscard || hasStatic_7Yz9(type.lifetime))
            {
                type.lifetime = Lifetime_static_moveable;
            }
            else
            {
                BUG_gDsn(x7E_rA00("intoEmpty: non-static non-irrelevant lifetime: "_view, str_gDsn(type.lifetime, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);
            };
        };
        if (!canDiscard)
        {
            if (type.vtype.vfacts & VFacts_xhRf_AlwaysTrue)
                BUG_gDsn(("intoEmpty: vfacts & AlwaysTrue: "_view + explainType_gDsn(type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);
            else
                type.vtype.vfacts |= VFacts_xhRf_AlwaysFalse;

        };
    };
}

static SolvedNode_efhg createEmpty_gDsn(const Type_OiTm& type, const Target_VZrr& target, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    /*MOV*/ SolvedNode_efhg ret = SolvedNode_gDsn(Kind_Idfg_empty, type, Flags_Lzg8{}, (*(fu::str*)fu::NIL), (*(fu::vec<SolvedNode_efhg>*)fu::NIL), target, Helpers_DyqV{}, _here);
    intoEmpty_gDsn(ret, ss, ctx, _here, module, options, _helpers);
    return /*NRVO*/ ret;
}

static SolvedNode_efhg uPrepFn_A_gDsn(const Node_JjyR& node, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const fu::str& id = node.value;
    const Target_VZrr* t;
    const int local_of = (t = &(_current_fn.out.target), int(unsigned((((*t)._packed >> 20ull) & 0xfffffull))));
    const SolverStatus_h9em status = SolverStatus_h9em_SS_LAZY;
    const Target_VZrr target = getOrCreateChild_VRsI(node, node, status, _current_fn, ss, ctx, _here, module, options, _helpers);
    bool shadows = !!(node.flags & Flags_Lzg8_F_SHADOW);
    autoshadow_gDsn(shadows, local_of, id, _current_fn, ss);
    if (~node.flags & Flags_Lzg8_F_LAMBDA)
        Scope_set_z0Qq(ss._scope, id, target, shadows);

    Ephemeral_xhb4& eph = EPH_mut_FDl5(target, ss, module);
    eph.local_of = local_of;
    eph.scope_memo = (_current_fn ? Scope_snap_gDsn(ss, _helpers) : ScopeMemo_9hVQ{});
    eph.scope_skip = (_current_fn ? ss._ss : (*(ScopeSkipMemos_0CE6*)fu::NIL));
    if (node.flags & Flags_Lzg8_F_CONVERSION)
    {
        ss._scope.converts.push(Target_VZrr(target));
        clear_jCLV(ss._conv_cache);
    };
    if (node.flags & Flags_Lzg8_F_USING)
    {
        ss._scope.usings.push(Target_VZrr(target));
        remove_mVke(ss._conv_cache, ValueType_JtNg{});
    };
    return createEmpty_gDsn(X_addrofTarget_FDl5(target), target, ss, ctx, _here, module, options, _helpers);
}

                                #ifndef DEF_only_hN9EXt7sNe2
                                #define DEF_only_hN9EXt7sNe2
inline const Node_JjyR& only_hN9E(fu::view<Node_JjyR> a)
{
    fu_ASSERT((a.size() == 1));
    return a[0];
}
                                #endif

static Type_OiTm T_gDsn(const Node_JjyR& node, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    return evalTypeAnnot_gDsn(only_hN9E(node.items), false, _current_fn, ss, ctx, _here, module, options, _helpers);
}

extern const Lifetime_llCF Lifetime_temporary;
extern const Type_OiTm t_zeroes;
                                #ifndef DEF_get_pMz5N8yxq40
                                #define DEF_get_pMz5N8yxq40
inline const TypeParam_Lrcu& get_pMz5(const Set_XshD& _, fu::view<char> key, fu::view<TypeParam_Lrcu> values)
{
    fu::view<fu::str> keys_asc = _.keys_asc;
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_j5CR(keys_asc[i], key);
        if (cmp == 0)
            return values[i];
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    return (*(TypeParam_Lrcu*)fu::NIL);
}
                                #endif

                                #ifndef DEF_get_mPhmibVTyui
                                #define DEF_get_mPhmibVTyui
inline const TypeParam_Lrcu& get_mPhm(const Map_v4nV& _, fu::view<char> key)
{
    return get_pMz5(_.keys, key, _.vals);
}
                                #endif

                                #ifndef DEF_iF_dk8yjLMumD4
                                #define DEF_iF_dk8yjLMumD4
inline const Import_7CIJ& iF_dk8y(fu::view<Import_7CIJ> a, const int i)
{
    if (uNsigned_40Hl(i) < uNsigned_40Hl(a.size()))
        return a[i];
    else
        return (*(Import_7CIJ*)fu::NIL);

}
                                #endif

static const Module_wo7O& findModule_gDsn(fu::view<char> marker, int& offset, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const int modid = int(parseVarint_V5Iu(offset, marker));
    const int index = int(parseVarint_V5Iu(offset, marker));
    const Module_wo7O& m = ((modid == module.modid) ? module : ctx.modules[modid]);
    fu::view<Import_7CIJ> imports = m.in.parse.imports;
    const Import_7CIJ& import = iF_dk8y(imports, index);
    return ctx.modules[(import.modid ? import.modid : BUG_gDsn((x7E_rA00((x7E_rA00("findModule: !import.modid, marker("_view, fu::i64dec(modid)) + ", "_view), fu::i64dec(index)) + ")"_view), ss, ctx, _here, module, options, _helpers))];
}

static const Scope_blWT& dequalify_andGetScope_gDsn(fu::vec_range_mut<char> id, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, const fu::vec<Helpers_DyqV>& _helpers)
{
    int offset = 0;
    const Module_wo7O& other = findModule_gDsn(id, offset, ss, ctx, _here, module, options, _helpers);
    if (other.modid == module.modid)
    {
        fail_gDsn(str_Jn0k1IbEIo4, fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
    }
    else
    {
        id.splice(0, offset);
        if (id)
            return other.out.solve.scope;
        else
        {
            BUG_gDsn("dequalify_andGetScope: ended up with an empty identifier."_view, ss, ctx, _here, module, options, _helpers);
        };
    };
}

                                #ifndef DEF___rSnGuU0WGgf
                                #define DEF___rSnGuU0WGgf
inline static int _rSnG(int& count)
{
    return count++;
}
                                #endif

                                #ifndef DEF_each_l8KjTeCHL4l
                                #define DEF_each_l8KjTeCHL4l
inline void each_l8Kj(fu::view<Target_VZrr> items, fu::view<ScopeSkip_iozY> scope_skip, const int start, int& count)
{
    const ScopeSkip_iozY END_DUMMY = ScopeSkip_iozY { items.size(), items.size() };
    int i0 = start;
    for (int i = 0; i < (scope_skip.size() + 1); i++)
    {
        const ScopeSkip_iozY& ss = ((i < scope_skip.size()) ? scope_skip[i] : END_DUMMY);
        if (!((ss.end <= i0)))
        {
            const int i1 = ss.start;
            for (int i_1 = i0; i_1 < i1; i_1++)
                _rSnG(count);

            i0 = ss.end;
        };
    };
}
                                #endif

                                #ifndef DEF_count_VLWPD9TKRP0
                                #define DEF_count_VLWPD9TKRP0
inline int count_VLWP(fu::view<Target_VZrr> items, fu::view<ScopeSkip_iozY> scope_skip)
{
    int count = 0;
    each_l8Kj(items, scope_skip, 0, count);
    return count;
}
                                #endif

                                #ifndef DEF_collectNamedArgs_5Te1deryoja
                                #define DEF_collectNamedArgs_5Te1deryoja
inline static NamedArgs_UjiQ collectNamedArgs_5Te1(fu::view<SolvedNode_efhg> args, int& minArity, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    /*MOV*/ NamedArgs_UjiQ ret {};
    bool some = false;
    for (int i = 0; i < args.size(); i++)
    {
        const SolvedNode_efhg& arg = args[i];
        fu::vec_range<char> _0 {};
        ret.names.push(fu::str(((arg.kind == Kind_Idfg_argid) ? ((_0.ptr_reassign(((some = true), arg.value))) ? _0 : BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers)) : (*(fu::str*)fu::NIL))));
        if (arg.flags & Flags_Lzg8_F_ARGID_IS_OPTIONAL)
        {
            minArity--;
            add_ZwXY(ret.optional, i);
        };
    };
    if (some)
        return /*NRVO*/ ret;
    else
        BUG_gDsn("collectNamedArgs: no named arguments here"_view, ss, ctx, _here, module, options, _helpers);

}
                                #endif

                                #ifndef DEF_first_GSzOnMGdAR9
                                #define DEF_first_GSzOnMGdAR9
inline const SolvedNode_efhg& first_GSzO(fu::view<SolvedNode_efhg> a)
{
    return a[0];
}
                                #endif

                                #ifndef DEF_init_Q9aq9YGZaCe
                                #define DEF_init_Q9aq9YGZaCe
inline static void init_Q9aq(bool& inserted)
{
    inserted = true;
    return;
}
                                #endif

                                #ifndef DEF_bfind_AUWH4qdXcAi
                                #define DEF_bfind_AUWH4qdXcAi
inline static int bfind_AUWH(fu::view<ValueType_JtNg> keys_asc, const ValueType_JtNg& key, Set_X4pj& _, const ValueType_JtNg& key_1, fu::vec_range_mut<ConvCache_ColsAndBakes_2n47> values, bool& inserted)
{
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_9721(keys_asc[i], key);
        if (cmp == 0)
            return i;
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    const int i = lo;
    ConvCache_ColsAndBakes_2n47 _0 {};
    (_0 = (init_Q9aq(inserted), ConvCache_ColsAndBakes_2n47{}), values.insert(i, static_cast<ConvCache_ColsAndBakes_2n47&&>(_0)));
    _.keys_asc.insert(i, ValueType_JtNg(key_1));
    return i;
}
                                #endif

                                #ifndef DEF_ref_7wuBrJeXqOb
                                #define DEF_ref_7wuBrJeXqOb
inline ConvCache_ColsAndBakes_2n47& ref_7wuB(Set_X4pj& _, const ValueType_JtNg& key, fu::vec_range_mut<ConvCache_ColsAndBakes_2n47> values, bool& inserted)
{
    const int idx = bfind_AUWH(_.keys_asc, key, _, key, values, inserted);
    return values.mutref(idx);
}
                                #endif

                                #ifndef DEF_ref_Tn1AUTTc5dj
                                #define DEF_ref_Tn1AUTTc5dj
inline ConvCache_ColsAndBakes_2n47& ref_Tn1A(Map_OMJS& _, const ValueType_JtNg& key, bool& inserted)
{
    return ref_7wuB(_.keys, key, _.vals, inserted);
}
                                #endif

extern const fu::static_ref<Lifetime_llCF> Lifetime_worst;
                                #ifndef DEF_x3Dx3D_XITs8EMohCa
                                #define DEF_x3Dx3D_XITs8EMohCa
inline bool operator==(const Target_VZrr& a, const Target_VZrr& b)
{
    return !x3Cx3E_YjZY(a, b);
}
                                #endif

                                #ifndef DEF_find_rD4Ct01ZZv1
                                #define DEF_find_rD4Ct01ZZv1
inline int find_rD4C(fu::view<Target_VZrr> haystack, const Target_VZrr& needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_has_bkvRJKomSq3
                                #define DEF_has_bkvRJKomSq3
inline bool has_bkvR(fu::view<Target_VZrr> a, const Target_VZrr& b)
{
    return (find_rD4C(a, b) >= 0);
}
                                #endif

static Type_OiTm make_field_reference_gDsn(const Type_OiTm& from, const Overload_aO3i& field, const bool TODO_FIX_useTemporaryLifetime, const Context_noPA& ctx, const TokenIdx_5581& _here)
{
    const UnpackedOffset_f7kz _ = field_unpackOffset_gDsn(field, ctx, _here);
    const unsigned quals = (!is_zeroes_9CJm(from.vtype) ? from.vtype.quals : 0u);
    return make_field_reference_9CJm(quals, (TODO_FIX_useTemporaryLifetime ? Lifetime_temporary : (!_.memberFlatCount ? Lifetime_static_moveable : from.lifetime)), Type_OiTm(field.type), _.memberFlatOffset, _.memberFlatCount, ctx, _here);
}

                                #ifndef DEF_only_WwIrlVtCYpd
                                #define DEF_only_WwIrlVtCYpd
inline fu::vec_range<Target_VZrr> only_WwIr(fu::view<fu::vec<Target_VZrr>> a)
{
    fu_ASSERT((a.size() == 1));
    return a[0];
}
                                #endif

static void foreach_gDsn(const Target_VZrr& target, const int at_index, const Type_OiTm& from, const bool nullary, ConvCache_ColsAndBakes_2n47& result, Reorder_0MNg& TODO_FIX_reorder, fu::vec<fu::vec<Target_VZrr>>& TODO_FIX_conversions, fu::vec<Target_VZrr>& path, fu::vec<int>& must_see, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    if (!(has_bkvR(path, target)))
    {
        if (SolverStatus_h9em((GET_gDsn(target, ss, ctx, _here, module).status & SolverStatus_h9em((SolverStatus_h9em_SS_LAZY | SolverStatus_h9em_SS_FINALIZED)))) == SolverStatus_h9em_SS_LAZY)
            GET_mut_gDsn(target, ss, module).status |= SolverStatus_h9em_SS_OBSERVED_BY_CONV_CACHE;
        else
        {
            /*MOV*/ Type_OiTm arg0type0 = ss.TODO_FIX_convert_args[0].type;
            if (!nullary)
                ss.TODO_FIX_convert_args.mutref(0).type = Type_OiTm(from);

            fu_DEFER(if (!nullary)
                ss.TODO_FIX_convert_args.mutref(0).type = static_cast<Type_OiTm&&>(arg0type0););
            fu::str error {};
            Target_VZrr candidate {};
            if (nullary || (candidate = tryMatchCall_gDsn(fu::str{}, TODO_FIX_reorder, TODO_FIX_conversions, error, false, (*(Scope_blWT*)fu::NIL), fu::vec<SolvedNode_efhg>(ss.TODO_FIX_convert_args), Flags_Lzg8_F_CONVERSION, fu::view<Target_VZrr> {{ Target_VZrr(target) }}, _current_fn, ss, ctx, _here, module, options, _helpers)))
            {
                const Target_VZrr& target_1 = (nullary ? target : candidate);
                Overload_aO3i convert = GET_gDsn(target_1, ss, ctx, _here, module);
                if (convert.type)
                {
                    Type_OiTm convertType = ((convert.kind != Kind_Idfg_field) ? Type_OiTm(convert.type) : make_field_reference_gDsn(from, convert, true, ctx, _here));
                    const bool isStruct = isStruct_p1TN(convertType.vtype);
                    if (int(unsigned(((target_1._packed >> 40ull) & 0xfffffull))) == module.modid)
                        GET_mut_gDsn(target_1, ss, module).status |= SolverStatus_h9em_SS_OBSERVED_BY_CONV_CACHE;

                    if (!(SolverStatus_h9em((convert.status & SolverStatus_h9em((SolverStatus_h9em_SS_DID_START | SolverStatus_h9em_SS_FINALIZED)))) == SolverStatus_h9em_SS_DID_START))
                    {
                        const int path0 = path.size();
                        const int must_see0 = must_see.size();
                        if (TODO_FIX_conversions)
                            path += only_WwIr(TODO_FIX_conversions);

                        path += Target_VZrr(target_1);
                        if ((at_index >= 0))
                            must_see += (nullary ? -(at_index + 1) : +(at_index + 1));

                        result.columns.types += ValueType_JtNg(convertType.vtype);
                        result.columns.paths += fu::vec<Target_VZrr>(path);
                        result.columns.must_see += fu::vec<int>(must_see);
                        if (isStruct || ss._scope.converts.size())
                            descend_gDsn(convertType, false, isStruct, result, TODO_FIX_reorder, TODO_FIX_conversions, path, must_see, _current_fn, ss, ctx, _here, module, options, _helpers);

                        path.shrink(path0);
                        must_see.shrink(must_see0);
                    };
                }
                else
                    BUG_gDsn((x7E_rA00("No convert.type, perhaps a `using inline fn` without a return type annotation: "_view, str_FDl5(target_1, false, ss, ctx, _here, module, options)) + "."_view), ss, ctx, _here, module, options, _helpers);

            };
        };
    };
}

static const Struct_LDkB& lookupUserType_gDsn(const Type_OiTm& type, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const Struct_LDkB* _0;
    return *(_0 = &(tryLookupUserType_1qjp(type.vtype, ctx, _here, module))) ? *_0 : fail_gDsn(("Not a struct nor custom primitive: "_view + explainType_gDsn(type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
}

static void descend_gDsn(const Type_OiTm& from, const bool nullary, const bool isStruct, ConvCache_ColsAndBakes_2n47& result, Reorder_0MNg& TODO_FIX_reorder, fu::vec<fu::vec<Target_VZrr>>& TODO_FIX_conversions, fu::vec<Target_VZrr>& path, fu::vec<int>& must_see, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    if (nullary)
        for (int i = 0; i < ss._scope.usings.size(); i++)
            foreach_gDsn(Target_VZrr(ss._scope.usings[i]), i, from, nullary, result, TODO_FIX_reorder, TODO_FIX_conversions, path, must_see, _current_fn, ss, ctx, _here, module, options, _helpers);

    else
    {
        if (isStruct)
        {
            fu::vec<Target_VZrr> inner = fu::vec<Target_VZrr>(lookupUserType_gDsn(from, ss, ctx, _here, module, options, _helpers).converts);
            for (int i = 0; i < inner.size(); i++)
                foreach_gDsn(Target_VZrr(inner[i]), -1, from, nullary, result, TODO_FIX_reorder, TODO_FIX_conversions, path, must_see, _current_fn, ss, ctx, _here, module, options, _helpers);

        };
        for (int i = 0; i < ss._scope.converts.size(); i++)
            foreach_gDsn(Target_VZrr(ss._scope.converts[i]), i, from, nullary, result, TODO_FIX_reorder, TODO_FIX_conversions, path, must_see, _current_fn, ss, ctx, _here, module, options, _helpers);

    };
}

                                #ifndef DEF_x3Cx3E_dHz1M9swxdh
                                #define DEF_x3Cx3E_dHz1M9swxdh
inline int x3Cx3E_dHz1(const StructCanon_TixV& a, const StructCanon_TixV& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_odNT(a.modid, b.modid)))
        return cmp;
    else if ((cmp = x3Cx3E_odNT(a.index, b.index)))
        return cmp;

    return 0;
}
                                #endif

                                #ifndef DEF_add_1NAPvVccWTb
                                #define DEF_add_1NAPvVccWTb
inline bool add_1NAP(Set_pEwD& _, const StructCanon_TixV& key)
{
    fu::view<StructCanon_TixV> keys_asc = _.keys_asc;
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_dHz1(keys_asc[i], key);
        if (cmp == 0)
            return false;
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    const int i = lo;
    _.keys_asc.insert(i, StructCanon_TixV(key));
    return true;
}
                                #endif

static ConvCache_ColsAndBakes_2n47 doExploreConversions_gDsn(const ValueType_JtNg& startType, ConvCache_ColsAndBakes_2n47& init, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    Type_OiTm startType_1 = (startType ? Type_OiTm { ValueType_JtNg(startType), Lifetime_llCF(Lifetime_worst.ref) } : Type_OiTm{});
    if (startType_1)
    {
        const Struct_LDkB& s = tryLookupUserType_1qjp(startType_1.vtype, ctx, _here, module);
        init.field_items = s.items;
        init.field_implicits = s.implicits;
    };
    /*MOV*/ ConvCache_ColsAndBakes_2n47 result {};
    const int conv_safety0 = _current_fn.conv_safety++;
    if ((conv_safety0 >= 128))
    {
        fail_gDsn(("Conversion stack got too deep, exploring: "_view + explainType_gDsn(startType_1, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
    }
    else
    {
        fu_DEFER(_current_fn.conv_safety = conv_safety0);
        Reorder_0MNg TODO_FIX_reorder {};
        fu::vec<fu::vec<Target_VZrr>> TODO_FIX_conversions {};
        fu::vec<Target_VZrr> path {};
        fu::vec<int> must_see {};
        descend_gDsn(startType_1, !startType_1, (startType_1 ? isStruct_p1TN(startType_1.vtype) : false), result, TODO_FIX_reorder, TODO_FIX_conversions, path, must_see, _current_fn, ss, ctx, _here, module, options, _helpers);
        Set_pEwD seen {};
        for (int i = (startType_1 ? -1 : 0); i < result.columns.types.size(); i++)
        {
            const ValueType_JtNg& t = ((i < 0) ? startType_1.vtype : result.columns.types[i]);
            const StructCanon_TixV t_1 = tryParseStructCanon_1qjp(t);
            if (t_1 && add_1NAP(seen, t_1))
            {
                const Struct_LDkB& s = lookupUserType_1qjp(t_1, module, ctx, _here);
                result.field_items += s.items;
                result.field_implicits += s.implicits;
            };
        };
        return /*NRVO*/ result;
    };
}

                                #ifndef DEF_bfind_OKTyxnHVfhd
                                #define DEF_bfind_OKTyxnHVfhd
inline static int bfind_OKTy(fu::view<ValueType_JtNg> keys_asc, const ValueType_JtNg& key, Set_X4pj& _, const ValueType_JtNg& key_1, fu::vec_range_mut<ConvCache_ColsAndBakes_2n47> values)
{
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_9721(keys_asc[i], key);
        if (cmp == 0)
            return i;
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    const int i = lo;
    values.insert(i, ConvCache_ColsAndBakes_2n47{});
    _.keys_asc.insert(i, ValueType_JtNg(key_1));
    return i;
}
                                #endif

                                #ifndef DEF_ref_wOWkoq5Zxgl
                                #define DEF_ref_wOWkoq5Zxgl
inline ConvCache_ColsAndBakes_2n47& ref_wOWk(Set_X4pj& _, const ValueType_JtNg& key, fu::vec_range_mut<ConvCache_ColsAndBakes_2n47> values)
{
    const int idx = bfind_OKTy(_.keys_asc, key, _, key, values);
    return values.mutref(idx);
}
                                #endif

                                #ifndef DEF_ref_F0gegIn3Yzj
                                #define DEF_ref_F0gegIn3Yzj
inline ConvCache_ColsAndBakes_2n47& ref_F0ge(Map_OMJS& _, const ValueType_JtNg& key)
{
    return ref_wOWk(_.keys, key, _.vals);
}
                                #endif

static const ConvCache_ColsAndBakes_2n47& exploreConversions_FDl5(const ValueType_JtNg& type, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    bool inserted = false;
    ConvCache_ColsAndBakes_2n47& cc = ref_Tn1A(ss._conv_cache, type, inserted);
    if (!inserted)
        return cc;
    else
        return (ref_F0ge(ss._conv_cache, type) = doExploreConversions_gDsn(type, cc, _current_fn, ss, ctx, _here, module, options, _helpers));

}

static const fu::vec<ScopeItem_xiLD>& convCache_considerFieldItems_gDsn(const Type_OiTm& type, const Flags_Lzg8 flags, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    for (int i = 0; i < 1; i++)
    {
        const ConvCache_ColsAndBakes_2n47& cc = exploreConversions_FDl5(type.vtype, _current_fn, ss, ctx, _here, module, options, _helpers);
        const fu::vec<ScopeItem_xiLD>& items = ((flags & Flags_Lzg8_F_IMPLICIT) ? cc.field_implicits : cc.field_items);
        if (2 > 1)
            return items;

    };
    return (*(fu::vec<ScopeItem_xiLD>*)fu::NIL);
}

                                #ifndef DEF___E8HveXvngOi
                                #define DEF___E8HveXvngOi
inline static bool _E8Hv(const int modid, BitSet_mmp7& seen)
{
    return add_ZwXY(seen, modid);
}
                                #endif

                                #ifndef DEF_each_3MSSX0YCzJ6
                                #define DEF_each_3MSSX0YCzJ6
inline void each_3MSS(fu::view<int> items, fu::view<ScopeSkip_iozY> scope_skip, const int start, BitSet_mmp7& seen)
{
    const ScopeSkip_iozY END_DUMMY = ScopeSkip_iozY { items.size(), items.size() };
    int i0 = start;
    for (int i = 0; i < (scope_skip.size() + 1); i++)
    {
        const ScopeSkip_iozY& ss = ((i < scope_skip.size()) ? scope_skip[i] : END_DUMMY);
        if (!((ss.end <= i0)))
        {
            const int i1 = ss.start;
            for (int i_1 = i0; i_1 < i1; i_1++)
                _E8Hv(items[i_1], seen);

            i0 = ss.end;
        };
    };
}
                                #endif

static void visitTypeImports_gDsn(const Type_OiTm& type, fu::vec_range<char> id, const bool local_scope, fu::vec<Target_VZrr>& extra_items, BitSet_mmp7& seen, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    const Set_qOJY& visit = lookupTypeImports_1qjp(type.vtype, ctx, _here, module);
    for (int i = -1; i < visit.keys_asc.size(); i++)
    {
        int i_1;
        const int modid = ((i >= 0) ? (i_1 = i, visit.keys_asc[i_1]) : modidOfOrigin_p1TN(type));
        if (!(has_ZwXY(seen, modid)))
        {
            if (!seen)
            {
                add_ZwXY(seen, 0);
                add_ZwXY(seen, module.modid);
                each_3MSS(ss._scope.imports, (local_scope ? ss._ss.imports : fu::view<ScopeSkip_iozY>{}), 0, seen);
            };
            if (!(!add_ZwXY(seen, modid)))
            {
                const Scope_blWT& s = ctx.modules[modid].out.solve.scope;
                for (int i_2 = 0; i_2 < s.pub_items; i_2++)
                {
                    if (s.items[i_2].id == id)
                        extra_items.push(target_z0Qq(s.items[i_2]));

                };
            };
        };
    };
}

                                #ifndef DEF___pbKLrEJ47D6
                                #define DEF___pbKLrEJ47D6
inline static void _pbKL(const Target_VZrr& u, fu::vec_range<char> id, const bool local_scope, fu::vec<Target_VZrr>& extra_items, BitSet_mmp7& seen, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    const Type_OiTm* _0;
    visitTypeImports_gDsn((*(_0 = &(GET_gDsn(u, ss, ctx, _here, module).type)) ? *_0 : (__extension__ (
    {
        return;
        (void)0;
    }), fu::unreachable)), id, local_scope, extra_items, seen, ss, ctx, _here, module);
}
                                #endif

                                #ifndef DEF_each_VZN2M5aXvDc
                                #define DEF_each_VZN2M5aXvDc
inline void each_VZN2(fu::view<Target_VZrr> items, fu::view<ScopeSkip_iozY> scope_skip, const int start, fu::vec_range<char> id, const bool local_scope, fu::vec<Target_VZrr>& extra_items, BitSet_mmp7& seen, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    const ScopeSkip_iozY END_DUMMY = ScopeSkip_iozY { items.size(), items.size() };
    int i0 = start;
    for (int i = 0; i < (scope_skip.size() + 1); i++)
    {
        const ScopeSkip_iozY& ss_1 = ((i < scope_skip.size()) ? scope_skip[i] : END_DUMMY);
        if (!((ss_1.end <= i0)))
        {
            const int i1 = ss_1.start;
            for (int i_1 = i0; i_1 < i1; i_1++)
                _pbKL(items[i_1], id, local_scope, extra_items, seen, ss, ctx, _here, module);

            i0 = ss_1.end;
        };
    };
}
                                #endif

static void clear_iUdw(Reorder_0MNg& reorder)
{
    reorder.applicable = false;
    reorder.map.clear();
}

                                #ifndef DEF_str_VyKZwu6LUvj
                                #define DEF_str_VyKZwu6LUvj
inline fu::str str_VyKZ(const SolverStatus_h9em n)
{
    /*MOV*/ fu::str res {};

    {
        if (n & SolverStatus_h9em_SS_LAZY)
            res += ("SS_LAZY"_view + ", "_view);

        if (n & SolverStatus_h9em_SS_DID_START)
            res += ("SS_DID_START"_view + ", "_view);

        if (n & SolverStatus_h9em_SS_DIRTY)
            res += ("SS_DIRTY"_view + ", "_view);

        if (n & SolverStatus_h9em_SS_FINALIZED)
            res += ("SS_FINALIZED"_view + ", "_view);

        if (n & SolverStatus_h9em_SS_UPDATED)
            res += ("SS_UPDATED"_view + ", "_view);

        if (n & SolverStatus_h9em_SS_TYPE_RECUR)
            res += ("SS_TYPE_RECUR"_view + ", "_view);

        if (n & SolverStatus_h9em_SS_FN_RECUR)
            res += ("SS_FN_RECUR"_view + ", "_view);

        if (n & SolverStatus_h9em_SS_FN_OOE_RTL)
            res += ("SS_FN_OOE_RTL"_view + ", "_view);

        if (n & SolverStatus_h9em_SS_NAME_UNUSED)
            res += ("SS_NAME_UNUSED"_view + ", "_view);

        if (n & SolverStatus_h9em_SS_UNUSED)
            res += ("SS_UNUSED"_view + ", "_view);

        if (n & SolverStatus_h9em_SS_MATCHED)
            res += ("SS_MATCHED"_view + ", "_view);

        if (n & SolverStatus_h9em_SS_MOVED_FROM)
            res += ("SS_MOVED_FROM"_view + ", "_view);

        if (n & SolverStatus_h9em_SS_EXTERNAL_LINKAGE)
            res += ("SS_EXTERNAL_LINKAGE"_view + ", "_view);

        if (n & SolverStatus_h9em_SS_OBSERVED_BY_CONV_CACHE)
            res += ("SS_OBSERVED_BY_CONV_CACHE"_view + ", "_view);

        if (n & SolverStatus_h9em_SS_TODO_FIX_was_rx_resize)
            res += ("SS_TODO_FIX_was_rx_resize"_view + ", "_view);

        if (n & SolverStatus_h9em_SS_Debug_AllPassesComplete)
            res += ("SS_Debug_AllPassesComplete"_view + ", "_view);

    };
    if (res)
        res.shrink((res.size() - 2));

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_steal_MnHlI5b9oM4
                                #define DEF_steal_MnHlI5b9oM4
inline CurrentFn_QbLp steal_MnHl(CurrentFn_QbLp& v)
{
    /*MOV*/ CurrentFn_QbLp ret {};
    std::swap(v, ret);
    return /*NRVO*/ ret;
}
                                #endif

                                #ifndef DEF_exchange_GcK8HT116vk
                                #define DEF_exchange_GcK8HT116vk
inline Target_VZrr exchange_GcK8(Target_VZrr& a, Target_VZrr&& b)
{
    std::swap(a, b);
    return b;
}
                                #endif

static void replaceGlobid_gDsn(Target_VZrr& t, const Target_VZrr& target, const Target_VZrr& original, const Context_noPA& ctx, const TokenIdx_5581& _here)
{
    if (parent_gDsn(t, ctx, _here) == original)
    {
        const Target_VZrr* t_1;
        unsigned v;
        t = Target_xQNS(int(unsigned(((target._packed >> 40ull) & 0xfffffull))), int(unsigned(((target._packed >> 20ull) & 0xfffffull))), (t_1 = &(t), v = unsigned(((*t_1)._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))));
    }
    else
    {
        BUG_u9Gb(fu::view<char>{}, ctx, _here);
    };
}

static Overload_aO3i& local_gDsn(const int locid, fu::view_mut<Overload_aO3i> args_n_locals, const int args_neg)
{
    return args_n_locals.mutref(((args_neg - ((locid > 0) ? 1 : 0)) + locid));
}

static HelpersData_uG6I HelpersReplica_gDsn(const int local_of, const int locals_start, const Type_OiTm& ret_actual)
{
    return HelpersData_uG6I { Target_VZrr{}, SolverPass_zVQ2{}, HelpersMask_w1sv{}, fu::str{}, local_of, locals_start, Type_OiTm{}, Type_OiTm(ret_actual), Postdom_Vy5u{}, Postdom_Vy5u{}, EventsSnap_elmt{}, Helpers_DyqV{} };
}

                                #ifndef DEF_ensure_fmAXP5nG1Tc
                                #define DEF_ensure_fmAXP5nG1Tc
inline Helpers_DyqV& ensure_fmAX(fu::vec_range_mut<Helpers_DyqV> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

                                #ifndef DEF_iF_uWItHwU5sUh
                                #define DEF_iF_uWItHwU5sUh
inline const Helpers_DyqV& iF_uWIt(fu::view<Helpers_DyqV> a, const int i)
{
    if (uNsigned_40Hl(i) < uNsigned_40Hl(a.size()))
        return a[i];
    else
        return (*(Helpers_DyqV*)fu::NIL);

}
                                #endif

static void relinkNode_gDsn(SolvedNode_efhg& node, const Target_VZrr& target, const Target_VZrr& original, fu::view_mut<Overload_aO3i> args_n_locals, const int args_neg, fu::vec<Helpers_DyqV>& helpersReplicas, int& lastKnownLocal, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, fu::vec<Helpers_DyqV>& _helpers)
{
    const Kind_Idfg k = node.kind;
    if (k == Kind_Idfg_letdef)
    {
        replaceGlobid_gDsn(node.target, target, original, ctx, _here);
        const Target_VZrr* t;
        unsigned v;
        const int locid = (t = &(node.target), v = unsigned(((*t)._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        SolvedNode_efhg letNode {};
        std::swap(letNode, local_gDsn(locid, args_n_locals, args_neg).solved);
        relinkNode_gDsn(letNode, target, original, args_n_locals, args_neg, helpersReplicas, lastKnownLocal, _current_fn, ss, ctx, _here, _helpers);
        std::swap(letNode, local_gDsn(locid, args_n_locals, args_neg).solved);
        if (locid > 0)
            lastKnownLocal = locid;

    }
    else if ((k == Kind_Idfg_let) || (k == Kind_Idfg_call))
    {
        if (isLocal_gDsn(node.target))
            replaceGlobid_gDsn(node.target, target, original, ctx, _here);

    }
    else if ((k == Kind_Idfg_block) || (k == Kind_Idfg_loop))
    {
        const Helpers_DyqV foreign = node.helpers;
        if (foreign)
        {
            const int locals_start = (lastKnownLocal + 1);
            const Target_VZrr* t;
            const Helpers_DyqV local = push_gDsn(HelpersReplica_gDsn((t = &(_current_fn.out.target), int(unsigned((((*t)._packed >> 20ull) & 0xfffffull)))), locals_start, node.type), ss, _helpers);
            ensure_fmAX(helpersReplicas, foreign.index) = Helpers_DyqV((node.helpers = (local ? local : BUG_u9Gb(fu::view<char>{}, ctx, _here))));
        };
    }
    else if (k == Kind_Idfg_jump)
    {
        const Helpers_DyqV& foreign = node.helpers;
        const Helpers_DyqV& local = iF_uWIt(helpersReplicas, foreign.index);
        node.helpers = (local ? local : BUG_u9Gb(fu::view<char>{}, ctx, _here));
    };
    for (int i = 0; i < node.items.size(); i++)
    {
        SolvedNode_efhg* _0;
        (_0 = &(node.items.mutref(i)), relinkNode_gDsn(*_0, target, original, args_n_locals, args_neg, helpersReplicas, lastKnownLocal, _current_fn, ss, ctx, _here, _helpers));
    };
}

                                #ifndef DEF_last_xZUSIChN45f
                                #define DEF_last_xZUSIChN45f
inline SolvedNode_efhg& last_xZUS(fu::view_mut<SolvedNode_efhg> a)
{
    return a.mutref((a.size() - 1));
}
                                #endif

                                #ifndef DEF_steal_bX67wrtA382
                                #define DEF_steal_bX67wrtA382
inline SolvedNode_efhg steal_bX67(SolvedNode_efhg& v)
{
    /*MOV*/ SolvedNode_efhg ret {};
    std::swap(v, ret);
    return /*NRVO*/ ret;
}
                                #endif

static const fu::str& currentFn_mustBecomeInline_gDsn(const CurrentFn_QbLp& _current_fn)
{
    if (_current_fn.TODO_FIX_isInline)
        return str_2n6EmQmnc7k;
    else if (_current_fn.far_jumps)
        return str_mF5LBrIw797;
    else
        return (*(fu::str*)fu::NIL);

}

static fu::str str_iUdw(const SolvedNode_efhg& n, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    /*MOV*/ fu::str src = qKW_e44U(str_eN8k(n.kind));
    if ((n.kind == Kind_Idfg_call) || (n.kind == Kind_Idfg_let) || (n.kind == Kind_Idfg_letdef))
        src += (x7E_rA00("("_view, str_FDl5(n.target, false, ss, ctx, _here, module, options)) + ")"_view);
    else if (n.value)
        src += (("("_view + qID_e44U(n.value)) + ")"_view);

    if (n.type)
        src += (" -> "_view + explainType_gDsn(n.type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options));

    return /*NRVO*/ src;
}

static void TEST_unpaintNode_gDsn(SolvedNode_efhg& node, const bool expect_paint, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (expect_paint)
    {
        if (!((node.flags & Flags_Lzg8_F_TEST_painted) || !node))
            BUG_gDsn(x7E_rA00("Not F_TEST_painted: "_view, str_iUdw(node, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

    };
    node.flags &= ~Flags_Lzg8_F_TEST_painted;
}

                                #ifndef DEF_iF_LIXbj7lk825
                                #define DEF_iF_LIXbj7lk825
inline const SolvedNode_efhg& iF_LIXb(fu::view<SolvedNode_efhg> a, const int i)
{
    if (uNsigned_40Hl(i) < uNsigned_40Hl(a.size()))
        return a[i];
    else
        return (*(SolvedNode_efhg*)fu::NIL);

}
                                #endif

static fu::str tryExplainWell_gDsn(const Type_OiTm& what, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{

    {
        const Lifetime_llCF& lifetime = what.lifetime;
        fu::view<char> chars = lifetime.uni0n;
        int offset = 0;
        while (offset < chars.size())
        {
            const unsigned r = parse7bit_7Yz9(chars, offset);
            for (; ; )
            {
                bool isLastPath = false;
                bool isFirstSubRegion = true;
                for (; ; )
                {
                    const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                    isLastPath = !(raw_flatCount & 1u);
                    if (isLastSubRegion)
                        break;
                    else
                        isFirstSubRegion = false;

                };
                if (isLastPath)
                    break;

            };
            unsigned v;
            const int locid = ((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))));
            if (!(!locid))
            {
                const Target_VZrr t = nested_FDl5(locid, ss, ctx, _here);
                const Overload_aO3i& o = GET_gDsn(t, ss, ctx, _here, module);
                const SolvedNode_efhg& init = iF_LIXb(o.solved.items, LET_INIT);
                if (!(is_mutref_9CJm(o.type, ctx, _here)))
                {
                    fu::str _0 {};
                    fu::str reason = ((_0 = ((((o.flags & (Flags_Lzg8_F_CONST | Flags_Lzg8_F_REF)) == Flags_Lzg8_F_REF) && init) ? tryExplainWell_gDsn(init.type, _current_fn, ss, ctx, _here, module, options) : fu::str{})) ? static_cast<fu::str&&>(_0) : fu::str("not mutable."_fu));
                    return (("a ref to "_view + explainWhichFn_gDsn(Target_VZrr(t), fu::view<fu::vec<Target_VZrr>>{}, fu::view<char>{}, CodeFmt_snPx_FullContext, _current_fn, ss, ctx, _here, module, options)) + "\n\t    ... which is "_view) + reason;
                };
            };
        };
    };
    return fu::str{};
}

static fu::str explainNotMutref_gDsn(const Type_OiTm& what, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    fu::str _0 {};
    return "expects a mutref, got "_view + ((_0 = tryExplainWell_gDsn(what, _current_fn, ss, ctx, _here, module, options)) ? static_cast<fu::str&&>(_0) : explainType_gDsn(what, false, true, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options));
}

static fu::str explainTypeDiff_gDsn(const Type_OiTm& a, const Type_OiTm& b, fu::view<char> sep, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    return (explainType_gDsn(a, false, false, false, false, false, b, ss, ctx, _here, module, options) + sep) + explainType_gDsn(b, false, false, false, false, false, a, ss, ctx, _here, module, options);
}

static fu::str explainNotAssignable_gDsn(const Type_OiTm& host, const Type_OiTm& guest, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    if (is_mutref_9CJm(host, ctx, _here))
    {
        if (!is_mutref_9CJm(guest, ctx, _here))
            return explainNotMutref_gDsn(guest, _current_fn, ss, ctx, _here, module, options);

    };
    return "expects "_view + explainTypeDiff_gDsn(host, guest, ", got "_view, ss, ctx, _here, module, options);
}

[[noreturn]] static fu::never err_gDsn(fu::view<char> reason, const SolvedNode_efhg& node, const Target_VZrr& t, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    BUG_gDsn(((x7E_rA00(x7E_rA00(str_iUdw(node, ss, ctx, _here, module, options), " "_view), str_FDl5(t, false, ss, ctx, _here, module, options)) + ": "_view) + reason), ss, ctx, _here, module, options, _helpers);
}

                                #ifndef DEF_mangleArgTypes_PNcMOzzQ2ic
                                #define DEF_mangleArgTypes_PNcMOzzQ2ic
inline static fu::str mangleArgTypes_PNcM(fu::view<SolvedNode_efhg> args)
{
    /*MOV*/ fu::str mangle {};
    int numNonInjected = 0;
    for (int i = 0; i < args.size(); i++)
    {
        const SolvedNode_efhg& arg = args[i];
        if (numNonInjected++)
            mangle += ',';

        const Type_OiTm& argType = arg.type;
        if (argType)
            mangle += serializeType_1qjp(argType.vtype, "mangle[$T]"_view);

    };
    return /*NRVO*/ mangle;
}
                                #endif

                                #ifndef DEF_if_last_Xdw0uWgbVgj
                                #define DEF_if_last_Xdw0uWgbVgj
inline const SolvedNode_efhg& if_last_Xdw0(fu::view<SolvedNode_efhg> a)
{
    if (a.size())
        return a[(a.size() - 1)];
    else
        return (*(SolvedNode_efhg*)fu::NIL);

}
                                #endif

static void checkLt_gDsn(const Type_OiTm& actual, fu::view<char> actualCopy, const SolvedNode_efhg& expect, fu::view<char> expectCopy, const SolvedNode_efhg& node, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (!(!is_ref_9CJm(expect.type) || isIrrelevant_9CJm(expect.type)))
    {
        Lifetime_llCF uNion = Lifetime_union_7Yz9(expect.type.lifetime, actual.lifetime, false, ctx, _here);
        if (uNion != expect.type.lifetime)
        {
            Lifetime_llCF debug = Lifetime_union_7Yz9(expect.type.lifetime, actual.lifetime, false, ctx, _here);
            BUG_gDsn(x7E_rA00((((((((((((((x7E_rA00(str_iUdw(node, ss, ctx, _here, module, options), ": "_view) + actualCopy) + " mentions a lifetime not listed in "_view) + expectCopy) + ":"_view) + "\n\n\t\t"_view) + actualCopy) + ":\t"_view) + explainType_gDsn(actual, false, true, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)) + "\n\n\t\t"_view) + expectCopy) + ":\t"_view) + explainType_gDsn(expect.type, false, true, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)) + "\n\n\t\tUNION:\t\t"_view), str_gDsn(debug, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);
        };
    };
}

static bool andNodeType_canCleanlyDefinit_gDsn(const Type_OiTm& type, const Context_noPA& ctx, const TokenIdx_5581& _here)
{
    if (!is_mutref_9CJm(type, ctx, _here))
    {
        return !is_ref_9CJm(type) || hasStatic_7Yz9(type.lifetime);
    }
    else
        return false;

}

                                #ifndef DEF_only_S4ERbJHBqhk
                                #define DEF_only_S4ERbJHBqhk
inline const SolvedNode_efhg& only_S4ER(fu::view<SolvedNode_efhg> a)
{
    fu_ASSERT((a.size() == 1));
    return a[0];
}
                                #endif

                                #ifndef DEF_x3Dx3D_XzRnJVHmbDb
                                #define DEF_x3Dx3D_XzRnJVHmbDb
inline bool operator==(const Lifetime_llCF& a, const Lifetime_llCF& b)
{
    return !x3Cx3E_EUme(a, b);
}
                                #endif

                                #ifndef DEF_Lifetime_each_tYWtSPHmli1
                                #define DEF_Lifetime_each_tYWtSPHmli1
inline void Lifetime_each_tYWt(const Lifetime_llCF& lifetime, bool& notPointless, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit_7Yz9(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        unsigned v;
        const int locid = ((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))));
        if (!(!locid))
        {
            const Target_VZrr t = nested_FDl5(locid, ss, ctx, _here);
            const Overload_aO3i& o = GET_gDsn(t, ss, ctx, _here, module);
            if (o.kind == Kind_Idfg_var)
            {
                if (is_mutref_9CJm(o.type, ctx, _here))
                    notPointless = true;
                else if (!(locid < 0))
                {
                    check_gDsn(o.solved.type.lifetime, notPointless, ss, ctx, _here, module, options, _helpers);
                };
                if (notPointless)
                    return;

            }
            else
            {
                BUG_gDsn(x7E_rA00("let.init::copy.expr.lifetime, locid not a var: "_view, str_FDl5(t, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);
            };
        };
    };
}
                                #endif

static void check_gDsn(const Lifetime_llCF& lifetime, bool& notPointless, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    Lifetime_each_tYWt(lifetime, notPointless, ss, ctx, _here, module, options, _helpers);
}

static void TEST_node_gDsn(SolvedNode_efhg& node, const SolverPass_zVQ2 pass, const bool expect_paint, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    for (int i = 0; i < node.items.size(); i++)
    {
        SolvedNode_efhg* _0;
        (_0 = &(node.items.mutref(i)), TEST_node_gDsn(*_0, pass, expect_paint, _current_fn, ss, ctx, _here, module, options, _helpers));
    };
    _here = node.token;
    const ValueType_JtNg* type;
    if (is_never_9CJm(node.type.vtype) && (type = &(node.type.vtype), ((*type).quals & q_USAGE)))
        BUG_gDsn("node.is_never but some usage bits set"_view, ss, ctx, _here, module, options, _helpers);
    else
    {
        TEST_unpaintNode_gDsn(node, expect_paint, ss, ctx, _here, module, options, _helpers);
        const Kind_Idfg k = node.kind;
        if (!is_ref_9CJm(node.type) == !node.type.lifetime)
        {
            if (k == Kind_Idfg_call)
            {
                const Target_VZrr& t = node.target;
                const Overload_aO3i& o = GET_gDsn(t, ss, ctx, _here, module);
                const Kind_Idfg k_1 = o.kind;
                fu::view<Argument_bbKc> host_args = EXT_gDsn(t, ss, ctx, module).args;
                fu::view<SolvedNode_efhg> args = node.items;
                if ((host_args.size() == args.size()) || ((k_1 == Kind_Idfg_type) && !args.size()))
                {
                    if (!((o.kind == Kind_Idfg_type) && (tryLookupUserType_1qjp(o.type.vtype, ctx, _here, module).kind == Kind_Idfg_struct)))
                    {
                        for (int i_1 = 0; i_1 < args.size(); i_1++)
                        {
                            const Argument_bbKc& host_arg = host_args[i_1];
                            const SolvedNode_efhg& arg = args[i_1];
                            if (isIrrelevant_9CJm(host_arg.type))
                            {
                                if (o.kind == Kind_Idfg_field)
                                {
                                    if (!(isIrrelevant_9CJm(node.type) || !isIrrelevant_9CJm(arg.type)))
                                        BUG_gDsn(((("Relevant data out of an irrelevant struct: getting a "_view + explainType_gDsn(node.type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)) + " from a "_view) + explainType_gDsn(arg.type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

                                };
                            }
                            else if (isAssignableAsArgument_9CJm(host_arg.type.vtype, arg.type.vtype, false, ctx, _here))
                            {
                                if ((pass >= SolverPass_zVQ2_RelaxCopyResize))
                                {
                                    if (!(is_ref_9CJm(host_arg.type) || !is_ref_9CJm(arg.type)))
                                        err_gDsn(((((x7E_rA00("Missing copy or move for arg #"_view, fu::i64dec(i_1)) + ", "_view) + qID_e44U(human_gDsn(host_arg.name, ss, ctx, _here, module, options))) + ": "_view) + explainNotAssignable_gDsn(host_arg.type, arg.type, _current_fn, ss, ctx, _here, module, options)), node, t, ss, ctx, _here, module, options, _helpers);

                                };
                            }
                            else
                                err_gDsn(((((x7E_rA00("Arg #"_view, fu::i64dec(i_1)) + ", "_view) + qID_e44U(human_gDsn(host_arg.name, ss, ctx, _here, module, options))) + " not assignable to host_arg: "_view) + explainNotAssignable_gDsn(host_arg.type, arg.type, _current_fn, ss, ctx, _here, module, options)), node, t, ss, ctx, _here, module, options, _helpers);

                        };
                    };
                    if (o.kind != Kind_Idfg_field)
                    {
                        if ((o.kind == Kind_Idfg_var) && isIrrelevant_9CJm(o.type))
                            BUG_gDsn(x7E_rA00("Call to irrelevant local: "_view, str_FDl5(t, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);
                        else
                        {
                            const Type_OiTm& expect = node.type;
                            /*MOV*/ Type_OiTm expect_1 = ((o.kind == Kind_Idfg_field) ? clear_refs_9CJm(Type_OiTm(expect)) : Type_OiTm(expect));
                            Type_OiTm expect_2 = (((o.kind == Kind_Idfg_type) && (node.value == "__partcopy_s"_view)) ? clear_vfacts_9CJm(static_cast<Type_OiTm&&>(expect_1)) : static_cast<Type_OiTm&&>(expect_1));
                            if (!(isAssignable_9CJm(expect_2, o.type, false, false, ctx, _here)))
                                err_gDsn(("Return value not assignable to node.type: "_view + explainNotAssignable_gDsn(expect_2, o.type, _current_fn, ss, ctx, _here, module, options)), node, t, ss, ctx, _here, module, options, _helpers);

                        };
                    };
                }
                else
                {
                    err_gDsn((((((x7E_rA00((x7E_rA00("host_args.len ("_view, fu::i64dec(host_args.size())) + ") != args.len ("_view), fu::i64dec(args.size())) + "):"_view) + "\n\t\t"_view) + mangleArgTypes_PNcM(args)) + "\n\t\t"_view) + explainWhichFn_gDsn(Target_VZrr(t), fu::view<fu::vec<Target_VZrr>>{}, fu::view<char>{}, CodeFmt_snPx_NoContext, _current_fn, ss, ctx, _here, module, options)), node, t, ss, ctx, _here, module, options, _helpers);
                };
            }
            else if ((k == Kind_Idfg_block) || (k == Kind_Idfg_and) || (k == Kind_Idfg_or) || (k == Kind_Idfg_if))
            {
                if (k == Kind_Idfg_block)
                {
                    checkLt_gDsn(if_last_Xdw0(node.items).type, "block.tail"_view, node, x7E_rA00(str_eN8k(node.kind), ".type"_view), node, ss, ctx, _here, module, options, _helpers);
                    const Helpers_DyqV* h;
                    const Helpers_DyqV* h_1;
                    if ((h = &(node.helpers), ((((*h).index >= 0) && ((*h).index < ss._helpers_data.size())) ? ss._helpers_data[(*h).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).ret_actual && !HelpersMask_w1sv(((h_1 = &(node.helpers), ((((*h_1).index >= 0) && ((*h_1).index < ss._helpers_data.size())) ? ss._helpers_data[(*h_1).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).mask & HelpersMask_w1sv_HM_Function)))
                    {
                        const Helpers_DyqV* h_2;
                        checkLt_gDsn((h_2 = &(node.helpers), ((((*h_2).index >= 0) && ((*h_2).index < ss._helpers_data.size())) ? ss._helpers_data[(*h_2).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).ret_actual, "helpers.ret_actual"_view, node, x7E_rA00(str_eN8k(node.kind), ".type"_view), node, ss, ctx, _here, module, options, _helpers);
                    };
                }
                else if ((k == Kind_Idfg_and) || (k == Kind_Idfg_or))
                {
                    if ((node.items.size() >= 2))
                    {
                        const int start = (andNodeType_canCleanlyDefinit_gDsn(node.type, ctx, _here) ? (node.items.size() - 1) : 0);
                        for (int i_1 = start; i_1 < node.items.size(); i_1++)
                        {
                            const SolvedNode_efhg& item = node.items[i_1];
                            checkLt_gDsn(node.type, (x7E_rA00(x7E_rA00(str_eN8k(k), ".items["_view), fu::i64dec(i_1)) + "]"_view), node, x7E_rA00(str_eN8k(node.kind), ".type"_view), node, ss, ctx, _here, module, options, _helpers);
                            if (is_never_9CJm(item.type.vtype))
                            {
                                if (i_1 < (node.items.size() - 1))
                                    BUG_gDsn(x7E_rA00("and/or has a never halfway: "_view, str_iUdw(item, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

                            }
                            else
                            {
                                if (!((pass < SolverPass_zVQ2_RelaxCopyResize) && is_zeroes_9CJm(item.type.vtype)))
                                {
                                    if (!is_void_or_propositionOK_9CJm(node.type, true, ctx, _here))
                                    {
                                        if (hasTemporary_7Yz9(node.type.lifetime))
                                            continue;
                                        else
                                        {
                                            Type_OiTm host = node.type;
                                            const Type_OiTm& guest = item.type;
                                            const VFacts_xhRf vfacts_ignore = ((i_1 < (node.items.size() - 1)) ? ((k == Kind_Idfg_and) ? VFacts_xhRf_AlwaysFalse : VFacts_xhRf_AlwaysTrue) : VFacts_xhRf{});
                                            const bool asArgument = false;
                                            if (vfacts_ignore)
                                                host.vtype.vfacts &= VFacts_xhRf(~vfacts_ignore);

                                            if (!(isAssignable_9CJm(host, guest, false, asArgument, ctx, _here)))
                                                BUG_gDsn((((x7E_rA00("and/or type !<- item["_view, fu::i64dec(i_1)) + "]"_view) + ": "_view) + explainNotAssignable_gDsn(host, guest, _current_fn, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

                                        };
                                    };
                                };
                            };
                        };
                    }
                    else
                        BUG_gDsn(x7E_rA00(x7E_rA00(str_iUdw(node, ss, ctx, _here, module, options), ".len: "_view), fu::i64dec(node.items.size())), ss, ctx, _here, module, options, _helpers);

                }
                else if (k == Kind_Idfg_if)
                {
                    if (node.items.size() == 3)
                    {
                        if (is_never_9CJm(node.type.vtype))
                        {
                            if (is_never_9CJm(node.items[1].type.vtype))
                            {
                                if (!(is_never_9CJm(node.items[2].type.vtype)))
                                    BUG_gDsn(x7E_rA00(x7E_rA00(str_iUdw(node, ss, ctx, _here, module, options), " never.alt not never: "_view), str_iUdw(node.items[2], ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

                            }
                            else
                                BUG_gDsn(x7E_rA00(x7E_rA00(str_iUdw(node, ss, ctx, _here, module, options), " never.cons not never: "_view), str_iUdw(node.items[1], ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

                        };
                        checkLt_gDsn(node.items[1].type, "if.then"_view, node, x7E_rA00(str_eN8k(node.kind), ".type"_view), node, ss, ctx, _here, module, options, _helpers);
                        checkLt_gDsn(node.items[2].type, "if.else"_view, node, x7E_rA00(str_eN8k(node.kind), ".type"_view), node, ss, ctx, _here, module, options, _helpers);
                    }
                    else
                        BUG_gDsn(x7E_rA00(x7E_rA00(str_iUdw(node, ss, ctx, _here, module, options), ".len: "_view), fu::i64dec(node.items.size())), ss, ctx, _here, module, options, _helpers);

                };
                fu::view<SolvedNode_efhg> items = node.items;
                for (int i_1 = 0; i_1 < items.size(); i_1++)
                {
                    if (!(items[i_1].kind))
                        BUG_gDsn((x7E_rA00(x7E_rA00(str_iUdw(node, ss, ctx, _here, module, options), ": No .kind on item["_view), fu::i64dec(i_1)) + "]."_view), ss, ctx, _here, module, options, _helpers);

                };
            }
            else if (k == Kind_Idfg_jump)
            {
                if ((pass >= SolverPass_zVQ2_RelaxCopyResize))
                {
                    const Helpers_DyqV& h = node.helpers;
                    const SolvedNode_efhg& expr = only_S4ER(node.items);
                    if (!(isAssignable_9CJm((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).ret_actual, expr.type, false, false, ctx, _here)))
                        BUG_gDsn(((x7E_rA00(((((("BROKEN JUMP TYPE"_view + "\n\t\tret_actual: "_view) + ((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).ret_actual ? explainType_gDsn((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).ret_actual, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options) : qBAD_e44U("N/A"_view))) + "\n\t\tret_expect: "_view) + ((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).ret_expect ? explainType_gDsn((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).ret_expect, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options) : qBAD_e44U("N/A"_view))) + "\n\t\texpr: "_view), str_iUdw(expr, ss, ctx, _here, module, options)) + "\n\n\t"_view) + explainNotAssignable_gDsn((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).ret_actual, expr.type, _current_fn, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

                };
            }
            else if (k == Kind_Idfg_try)
            {
                if (node.items.size() == 3)
                {
                    const SolvedNode_efhg& err = node.items[TRY_ERR];
                    if (!((err.kind == Kind_Idfg_letdef) || (err.kind == Kind_Idfg_empty)))
                        BUG_gDsn(x7E_rA00("TRY_ERR not a letdef/empty: "_view, str_iUdw(node.items[TRY_ERR], ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

                }
                else
                    BUG_gDsn("try.items.len != 3"_view, ss, ctx, _here, module, options, _helpers);

            }
            else if ((k == Kind_Idfg_empty) || (k == Kind_Idfg_definit))
            {
                if (node.type.lifetime)
                {
                    if (!(node.type.lifetime == Lifetime_static_moveable))
                    {
                        BUG_gDsn(x7E_rA00(x7E_rA00(str_eN8k(k), ": non-static lifetime: "_view), str_gDsn(node.type.lifetime, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);
                    };
                };
                if (!(VFacts_xhRf((node.type.vtype.vfacts & VFacts_xhRf_AlwaysFalse)) || isIrrelevant_9CJm(node.type) || VFacts_xhRf((node.type.vtype.vfacts & VFacts_xhRf_Typename))))
                    BUG_gDsn((x7E_rA00(str_eN8k(k), ": value is neither AlwaysFalse nor irrelevant: "_view) + explainType_gDsn(node.type, false, true, false, true, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

            }
            else if (k == Kind_Idfg_letdef)
            {
                SolvedNode_efhg* _1;
                (_1 = &(GET_mut_gDsn(node.target, ss, module).solved), TEST_node_gDsn(*_1, pass, expect_paint, _current_fn, ss, ctx, _here, module, options, _helpers));
            }
            else if (k == Kind_Idfg_let)
            {
                if (isIrrelevant_9CJm(node.type) && (pass >= SolverPass_zVQ2_RelaxMut))
                {
                    const Target_VZrr* target;
                    unsigned v;
                    if (!((target = &(node.target), ((v = unsigned(((*target)._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))) < 0)) || !isLocal_gDsn(node.target)))
                        BUG_gDsn((x7E_rA00(str_FDl5(node.target, false, ss, ctx, _here, module, options), " place.type is irrelevant: "_view) + explainType_gDsn(node.type, false, false, false, true, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

                };
                if (node.items.size() != 2)
                {
                    const Target_VZrr* target;
                    unsigned v;
                    if (!(node.target && (target = &(node.target), ((v = unsigned(((*target)._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))) < 0)) && (GET_gDsn(node.target, ss, ctx, _here, module).flags & Flags_Lzg8_F_INJECTED)))
                        BUG_gDsn(x7E_rA00("let.items.len: "_view, fu::i64dec(node.items.size())), ss, ctx, _here, module, options, _helpers);

                }
                else if (node.items[0])
                    BUG_gDsn(x7E_rA00("let.items[0] not empty: "_view, str_eN8k(node.items[0].kind)), ss, ctx, _here, module, options, _helpers);
                else if (hasTemporary_7Yz9(node.type.lifetime))
                    BUG_gDsn(("test_node(let) place.type has temp lt: "_view + explainType_gDsn(node.type, false, true, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);
                else
                {
                    const Overload_aO3i& o = GET_gDsn(node.target, ss, ctx, _here, module);

                    {
                        Type_OiTm host = clear_refs_9CJm(Type_OiTm(o.type));
                        const Type_OiTm& guest = node.type;
                        const bool asArgument = false;
                        if (!(isAssignable_9CJm(host, guest, false, asArgument, ctx, _here)))
                            BUG_gDsn((("test_node(let): let.target.type !<- let.place.type"_view + ": "_view) + explainNotAssignable_gDsn(host, guest, _current_fn, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

                    };
                    const SolvedNode_efhg& init = node.items[1];
                    if (init)
                    {
                        const Type_OiTm& host = node.type;
                        const Type_OiTm& guest = init.type;
                        const bool asArgument = false;
                        if (!(isAssignable_9CJm(host, guest, false, asArgument, ctx, _here)))
                            BUG_gDsn((("test_node(let): place.type !<- let.init.type"_view + ": "_view) + explainNotAssignable_gDsn(host, guest, _current_fn, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

                    };
                    if ((init.kind == Kind_Idfg_copy) && !is_trivial_1qjp(init.type.vtype, ctx, _here, module) && !SolverStatus_h9em((o.status & SolverStatus_h9em_SS_MOVED_FROM)) && !is_mutref_9CJm(o.type, ctx, _here))
                    {
                        const SolvedNode_efhg& expr = only_S4ER(init.items);
                        if (is_ref_9CJm(expr.type))
                        {
                            bool notPointless = false;
                            check_gDsn(expr.type.lifetime, notPointless, ss, ctx, _here, module, options, _helpers);
                            if (!(notPointless))
                            {
                                BUG_gDsn(x7E_rA00("test_node(let) Pointless copy "_view, str_gDsn(expr.type.lifetime, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);
                            };
                        }
                        else
                            BUG_gDsn("test_node(let) init::copy, !expr.is_ref"_view, ss, ctx, _here, module, options, _helpers);

                    };
                };
            };
        }
        else
            BUG_gDsn((x7E_rA00(str_iUdw(node, ss, ctx, _here, module, options), ": !!ref != !!lt: "_view) + explainType_gDsn(node.type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

    };
}

static void TEST_pass_gDsn(SolvedNode_efhg& node, const SolverPass_zVQ2 pass, const bool expect_paint, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const Helpers_DyqV* h;
    if ((h = &(node.helpers), ((((*h).index >= 0) && ((*h).index < ss._helpers_data.size())) ? ss._helpers_data[(*h).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).target == _current_fn.out.target)
    {
        for (int i = 0; i < (_current_fn.out.items.size() + FN_ARGS_BACK); i++)
        {
            SolvedNode_efhg* _0;
            (_0 = &(_current_fn.out.items.mutref(i)), TEST_unpaintNode_gDsn(*_0, false, ss, ctx, _here, module, options, _helpers));
        };
        TEST_node_gDsn(node, pass, expect_paint, _current_fn, ss, ctx, _here, module, options, _helpers);
    }
    else
    {
        BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers);
    };
}

static void Postdom_resetAtFnEnd_gDsn(Postdom_Vy5u& postdom)
{
    postdom = Postdom_Vy5u{};
    postdom.write_loop_start = NO_LOOP;
    postdom.read_loop_start = NO_LOOP;
    postdom.snap.exitPaths = ExitPaths_UXHs_XP_EmptyReturn;
}

extern const unsigned RELAX_before_bck;
static void TEST_paintNode_gDsn(SolvedNode_efhg& node, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (node.flags & Flags_Lzg8_F_TEST_painted)
    {
        if ((node.kind == Kind_Idfg_call) && (GET_gDsn(node.target, ss, ctx, _here, module).kind == Kind_Idfg_fn))
            BUG_gDsn(x7E_rA00("Already F_TEST_painted: "_view, str_iUdw(node, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

    };
    node.flags |= Flags_Lzg8_F_TEST_painted;
}

extern const unsigned RELAX_all;
static SolvedNode_efhg createBlock_gDsn(const Type_OiTm& type, fu::vec_range<SolvedNode_efhg> items, const Helpers_DyqV& h, const TokenIdx_5581& _here)
{
    return SolvedNode_gDsn(Kind_Idfg_block, type, Flags_Lzg8{}, (*(fu::str*)fu::NIL), items, Target_VZrr{}, h, _here);
}

static SolvedNode_efhg createBlock_FDl5(/*MOV*/ SolvedNode_efhg&& a, /*MOV*/ SolvedNode_efhg&& b, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    if (isImmediatelyDiscardable_UVY6(a.kind) || ((a.kind == Kind_Idfg_call) && (GET_gDsn(a.target, ss, ctx, _here, module).kind == Kind_Idfg_var)))
        return static_cast<SolvedNode_efhg&&>(b);
    else if (b.kind == Kind_Idfg_block)
    {
        b.items.unshift(static_cast<SolvedNode_efhg&&>(a));
        return static_cast<SolvedNode_efhg&&>(b);
    }
    else
    {
        return createBlock_gDsn(b.type, fu::vec<SolvedNode_efhg> {{ static_cast<SolvedNode_efhg&&>(a), SolvedNode_efhg(b) }}, Helpers_DyqV{}, _here);
    };
}

static void definitWrap_gDsn(SolvedNode_efhg& node, const Type_OiTm& slot, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (is_mutref_9CJm(slot, ctx, _here))
        BUG_gDsn(("Trying to definitWrap a mutref: "_view + explainType_gDsn(slot, false, true, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);
    else if (is_ref_9CJm(slot) && !hasStatic_7Yz9(slot.lifetime))
    {
        if (hasTemporary_7Yz9(slot.lifetime))
            definitWrap_gDsn(node, clear_refs_9CJm(Type_OiTm(slot)), ss, ctx, _here, module, options, _helpers);
        else
            BUG_gDsn(("Trying to definitWrap a non-static reference: "_view + explainType_gDsn(slot, false, true, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

    }
    else
    {
        /*MOV*/ SolvedNode_efhg empty = createEmpty_gDsn(slot, Target_VZrr{}, ss, ctx, _here, module, options, _helpers);
        node = (isImmediatelyDiscardable_UVY6(node.kind) ? static_cast<SolvedNode_efhg&&>(empty) : createBlock_FDl5(SolvedNode_efhg(node), static_cast<SolvedNode_efhg&&>(empty), ss, ctx, _here, module));
    };
}

static void maybeCopyOrMove_gDsn(SolvedNode_efhg& node, const Type_OiTm& slot, const bool isArgument, fu::vec_range<char> debug, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (!(isIrrelevant_9CJm(slot)))
    {
        const ValueType_JtNg* type;
        if (is_never_9CJm(slot.vtype) && (type = &(slot.vtype), ((*type).quals & q_USAGE)))
            BUG_gDsn("maybeCopyOrMove: slot.is_never but some usage bits set"_view, ss, ctx, _here, module, options, _helpers);
        else if (!isCanonAssignable_Ot6w(slot.vtype.canon, node.type.vtype.canon, ctx, _here) && !is_never_9CJm(node.type.vtype))
        {
            if (is_zeroes_9CJm(node.type.vtype) && !(is_mutref_9CJm(slot, ctx, _here) && CANNOT_definit_mutrefs))
                definitWrap_gDsn(node, slot, ss, ctx, _here, module, options, _helpers);
            else
                BUG_gDsn(("Considering copy or move for incompatible types: "_view + explainNotAssignable_gDsn(slot, node.type, _current_fn, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

        }
        else if (is_ref_9CJm(slot))
        {
            if (is_trivial_1qjp(node.type.vtype, ctx, _here, module))
            {
                if ((node.kind == Kind_Idfg_empty) && isArgument)
                    node.type = clear_refs_9CJm(Type_OiTm(node.type));

            };
        }
        else
        {
            if (!(!is_ref_9CJm(node.type)))
            {
                if ((node.kind == Kind_Idfg_empty) || (node.kind == Kind_Idfg_str))
                    node.type = clear_refs_9CJm(Type_OiTm(node.type));
                else
                {
                    const TokenIdx_5581 here0 = _here;
                    fu_DEFER(_here = here0);
                    _here = node.token;
                    node = SolvedNode_gDsn(Kind_Idfg_copy, clear_refs_9CJm(Type_OiTm(node.type)), Flags_Lzg8{}, debug, fu::vec<SolvedNode_efhg> {{ SolvedNode_efhg(node) }}, Target_VZrr{}, Helpers_DyqV{}, _here);
                };
            };
        };
    };
}

                                #ifndef DEF_ensure_hFionSHcevh
                                #define DEF_ensure_hFionSHcevh
inline Type_OiTm& ensure_hFio(fu::vec_range_mut<Type_OiTm> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

                                #ifndef DEF_ensure_DIIlq6zpA97
                                #define DEF_ensure_DIIlq6zpA97
inline static Type_OiTm& ensure_DIIl(LocidMap_X0gN& map, const int locid, const CurrentFn_QbLp& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    return ensure_hFio(map._values, (args_neg + locid));
}
                                #endif

static bool trackVarUsage_gDsn(const int locid, const Type_OiTm& slot, CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{

    {
        const Target_VZrr t = nested_FDl5(locid, ss, ctx, _here);
        if (is_rx_copy_9CJm(slot.vtype) && isIrrelevant_9CJm(slot) && !is_zst_1qjp(slot.vtype, ctx, _here, module))
            BUG_gDsn(((x7E_rA00("trackVarUsage "_view, str_FDl5(t, false, ss, ctx, _here, module, options)) + ": Usage is copy but no usage bits set: "_view) + explainType_gDsn(slot, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);
        else if (hasTemporary_7Yz9(slot.lifetime))
            BUG_gDsn((x7E_rA00(str_FDl5(t, false, ss, ctx, _here, module, options), ", trackVarUsage: slot is ref2temp: "_view) + explainType_gDsn(slot, false, true, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);
        else if (isIrrelevant_9CJm(slot))
            BUG_gDsn((x7E_rA00(str_FDl5(nested_FDl5(locid, ss, ctx, _here), false, ss, ctx, _here, module, options), ", trackVarUsage: slot is irrelevant: "_view) + explainType_gDsn(slot, false, false, false, true, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

    };
    Type_OiTm& usage = ensure_DIIl(_current_fn.relaxed.var_usage, locid, _current_fn);
    if (!usage)
    {
        usage = slot;
        return true;
    }
    else
    {
        Type_OiTm _0 {};
        usage = ((_0 = type_tryIntersect_9CJm(usage, slot, ctx, _here)) ? static_cast<Type_OiTm&&>(_0) : BUG_gDsn((x7E_rA00(str_FDl5(nested_FDl5(locid, ss, ctx, _here), false, ss, ctx, _here, module, options), ": Usage intersection failure: "_view) + explainTypeDiff_gDsn(usage, slot, " & "_view, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers));
        return false;
    };
}

                                #ifndef DEF_ensure_dtbq2DbyN39
                                #define DEF_ensure_dtbq2DbyN39
inline Warning_9p8u& ensure_dtbq(fu::vec_range_mut<Warning_9p8u> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

static void push_FDl5(const Warning_9p8u& warning, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss)
{
    const Target_VZrr* t;
    Warning_9p8u& a = ensure_dtbq(ss._warnings, (t = &(_current_fn.out.target), int(unsigned((((*t)._packed >> 20ull) & 0xfffffull)))));
    if (!(a))
        a = warning;

}

static void warnUnused_gDsn(const Target_VZrr& target, const Overload_aO3i& o, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    if (!((o.flags & Flags_Lzg8_F_LAX) || SolverStatus_h9em((o.status & SolverStatus_h9em_SS_MATCHED)) || is_zst_1qjp(o.type.vtype, ctx, _here, module)))
    {
        unsigned v;
        push_FDl5(Warning_9p8u { (v = unsigned((target._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))) }, _current_fn, ss);
    };
}

static void unwrapLetdef_gDsn(SolvedNode_efhg& node, const unsigned relax_mask, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (relax_mask != RELAX_before_bck)
    {
        const SolverNotes_LSla note = SolverNotes_LSla_N_McomUnwrapsLetdef;
        if (note & options.break_notes)
        {
            fu::view<char> reason = fu::view<char>{};
            fail_gDsn((("`break_notes`: Unwanted event: "_view + qBAD_e44U(str_kJvr(note))) + (reason ? ("\n\t\t"_view + reason) : fu::str("."_fu))), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
        }
        else
            ss._notes |= note;

    };
    Overload_aO3i& o = GET_mut_gDsn(node.target, ss, module);
    SolvedNode_efhg& init = o.solved.items.mutref(LET_INIT);
    if ((o.kind == Kind_Idfg_var) && SolverStatus_h9em((o.status & SolverStatus_h9em_SS_NAME_UNUSED)))
    {
        if (!is_mutref_9CJm(o.type, ctx, _here) || is_mutref_9CJm(o.solved.type, ctx, _here))
        {
            if (!(is_ref_9CJm(o.solved.type) || !is_ref_9CJm(init.type)))
                BUG_gDsn("unwrapLetdef: runs before mcom."_view, ss, ctx, _here, module, options, _helpers);

        }
        else
            BUG_gDsn("unwrapLetdef: converts a mutval into a mutref."_view, ss, ctx, _here, module, options, _helpers);

    }
    else
        BUG_gDsn("unwrapLetdef: !var || !SS_NAME_UNUSED"_view, ss, ctx, _here, module, options, _helpers);

    node = steal_bX67(init);
}

                                #ifndef DEF_iF_17vn4Z5YGoi
                                #define DEF_iF_17vn4Z5YGoi
inline const Type_OiTm& iF_17vn(fu::view<Type_OiTm> a, const int i)
{
    if (uNsigned_40Hl(i) < uNsigned_40Hl(a.size()))
        return a[i];
    else
        return (*(Type_OiTm*)fu::NIL);

}
                                #endif

                                #ifndef DEF_iF_Et8popFgGS2
                                #define DEF_iF_Et8popFgGS2
inline static const Type_OiTm& iF_Et8p(const LocidMap_X0gN& map, const int locid, const CurrentFn_QbLp& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    return iF_17vn(map._values, (args_neg + locid));
}
                                #endif

static bool isMutVal_gDsn(const Overload_aO3i& o)
{
    return !(~o.flags & (Flags_Lzg8_F_MUT | Flags_Lzg8_F_VAL));
}

static void keepOrClearMutVal_gDsn(Overload_aO3i& o, const bool keep, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if ((o.kind == Kind_Idfg_var) && isMutVal_gDsn(o))
    {
        SolvedNode_efhg& node = o.solved;
        if (keep)
            node.type = clear_refs_9CJm(Type_OiTm(node.type));
        else
            o.flags &= ~Flags_Lzg8_F_MUT;

    }
    else
        BUG_gDsn("keepOrClearMutVal: Not a mut var"_view, ss, ctx, _here, module, options, _helpers);

}

static bool add_gDsn(LocidSet_iAWt& set, const int locid, const CurrentFn_QbLp& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    return add_ZwXY(set._bitset, (args_neg + locid));
}

static void relaxBlockVar_gDsn(const Target_VZrr& t, const unsigned relax_mask, const bool canDiscard, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    const Overload_aO3i& o = GET_gDsn(t, ss, ctx, _here, module);
    if (_current_fn)
    {
        unsigned v;
        const Type_OiTm& usage = iF_Et8p(_current_fn.relaxed.var_usage, (v = unsigned((t._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))), _current_fn);
        const bool isUnused = !usage;
        if (isUnused)
            warnUnused_gDsn(t, o, _current_fn, ss, ctx, _here, module);

        if (is_rx_copy_9CJm(usage.vtype) && isIrrelevant_9CJm(usage) && !is_zst_1qjp(usage.vtype, ctx, _here, module))
            BUG_gDsn(((x7E_rA00("relaxBlockVar "_view, str_FDl5(t, false, ss, ctx, _here, module, options)) + ": Usage is copy but no usage bits set: "_view) + explainType_gDsn(usage, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);
        else
        {
            Overload_aO3i& o_1 = GET_mut_gDsn(t, ss, module);
            if (isUnused)
                o_1.status |= SolverStatus_h9em_SS_UNUSED;
            else if (o_1.status & SolverStatus_h9em_SS_UNUSED)
                BUG_gDsn(((x7E_rA00("relaxBlockVar: previously SS_UNUSED "_view, str_FDl5(t, false, ss, ctx, _here, module, options)) + " now used as "_view) + explainType_gDsn(usage, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

            if (isUnused && canDiscard)
                o_1.solved.type = t_void;

            try_relax_9CJm(o_1.type, usage, relax_mask);
            SolvedNode_efhg& node = o_1.solved;
            if (node.type)
            {
                try_relax_9CJm(node.type, usage, relax_mask);
                if (isMutVal_gDsn(o_1))
                {
                    unsigned v_1;
                    if (!((v_1 = unsigned((t._packed & 0xfffffull)), int(((v_1 >> 1u) ^ ((v_1 & 1u) ? 0xffffffffu : 0x0u)))) < 0))
                        keepOrClearMutVal_gDsn(o_1, is_mutref_9CJm(usage, ctx, _here), ss, ctx, _here, module, options, _helpers);

                };
            }
            else
                BUG_gDsn("relaxBlockVar: !var.solved.type, can`t propagateType"_view, ss, ctx, _here, module, options, _helpers);

        };
    };
    SolvedNode_efhg node = steal_bX67(GET_mut_gDsn(t, ss, module).solved);
    TEST_paintNode_gDsn(node, ss, ctx, _here, module, options, _helpers);
    unsigned v;
    if (node.items && node.items[LET_INIT] && !((v = unsigned((t._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))) < 0))
    {
        SolvedNode_efhg& init = node.items.mutref(LET_INIT);
        propagateType_gDsn(init, node.type, relax_mask, Helpers_DyqV{}, _current_fn, ss, ctx, _here, module, options, _helpers);
        if (is_ref_9CJm(node.type))
        {
            if ((init.kind == Kind_Idfg_letdef) && SolverStatus_h9em((GET_gDsn(init.target, ss, ctx, _here, module).status & SolverStatus_h9em_SS_NAME_UNUSED)))
                unwrapLetdef_gDsn(init, relax_mask, ss, ctx, _here, module, options, _helpers);

            node.type.lifetime = init.type.lifetime;
        };
    };
    std::swap(node, GET_mut_gDsn(t, ss, module).solved);
    unsigned v_1;
    add_gDsn(_current_fn.relaxed.done_relaxing, (v_1 = unsigned((t._packed & 0xfffffull)), int(((v_1 >> 1u) ^ ((v_1 & 1u) ? 0xffffffffu : 0x0u)))), _current_fn);
}

extern const Type_OiTm t_proposition;
static bool isDiscardable_FDl5(const SolvedNode_efhg& node, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (node.items)
        return false;
    else if ((node.kind == Kind_Idfg_call) || (node.kind == Kind_Idfg_letdef))
        return false;
    else if ((node.kind == Kind_Idfg_block) || isImmediatelyDiscardable_UVY6(node.kind))
        return true;
    else
        BUG_gDsn((x7E_rA00("TODO: isDiscardable("_view, str_eN8k(node.kind)) + ")"_view), ss, ctx, _here, module, options, _helpers);

}

                                #ifndef DEF_x3Cx3E_3xeOKo3Wr8i
                                #define DEF_x3Cx3E_3xeOKo3Wr8i
inline int x3Cx3E_3xeO(const MayEscapeVia_5nki a, const MayEscapeVia_5nki b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_LvxrscYgRI7
                                #define DEF_x3Cx3E_LvxrscYgRI7
inline int x3Cx3E_Lvxr(const ExitPaths_UXHs a, const ExitPaths_UXHs b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_cUxdHi8fTb1
                                #define DEF_x3Cx3E_cUxdHi8fTb1
inline int x3Cx3E_cUxd(const fu::u8 a, const fu::u8 b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_lO5uYkiFP0l
                                #define DEF_x3Cx3E_lO5uYkiFP0l
inline int x3Cx3E_lO5u(fu::view<fu::u8> a, fu::view<fu::u8> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_cUxd(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_cHEkaQdUAdi
                                #define DEF_x3Cx3E_cHEkaQdUAdi
inline int x3Cx3E_cHEk(const BitSet_mmp7& a, const BitSet_mmp7& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_lO5u(a._data, b._data)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_8DVxEBKmfif
                                #define DEF_x3Cx3E_8DVxEBKmfif
inline int x3Cx3E_8DVx(const LocidSet_iAWt& a, const LocidSet_iAWt& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_cHEk(a._bitset, b._bitset)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_FqmEP9P1tjl
                                #define DEF_x3Cx3E_FqmEP9P1tjl
inline int x3Cx3E_FqmE(fu::view<unsigned> a, fu::view<unsigned> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_Rgh3(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_uL7pdGvCXza
                                #define DEF_x3Cx3E_uL7pdGvCXza
inline int x3Cx3E_uL7p(const LocidMap_IP5H& a, const LocidMap_IP5H& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_FqmE(a._values, b._values)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_1Ry84GvcrR6
                                #define DEF_x3Cx3E_1Ry84GvcrR6
inline int x3Cx3E_1Ry8(const PostdomSnap_cfaM& a, const PostdomSnap_cfaM& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_3xeO(a.mayEscapeVia, b.mayEscapeVia)))
        return cmp;
    else if ((cmp = x3Cx3E_Lvxr(a.exitPaths, b.exitPaths)))
        return cmp;

    if ((cmp = x3Cx3E_8DVx(a.used_again, b.used_again)))
        return cmp;
    else if ((cmp = x3Cx3E_uL7p(a.ever_written, b.ever_written)))
        return cmp;

    return 0;
}
                                #endif

                                #ifndef DEF_x3Cx3E_LunDl3zS8W6
                                #define DEF_x3Cx3E_LunDl3zS8W6
inline int x3Cx3E_LunD(const Postdom_Vy5u& a, const Postdom_Vy5u& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_odNT(a.write_loop_start, b.write_loop_start)))
        return cmp;
    else if ((cmp = x3Cx3E_odNT(a.read_loop_start, b.read_loop_start)))
        return cmp;

    if ((cmp = x3Cx3E_1Ry8(a.snap, b.snap)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Dx3D_MJ963qASqv3
                                #define DEF_x3Dx3D_MJ963qASqv3
inline bool operator==(const Postdom_Vy5u& a, const Postdom_Vy5u& b)
{
    return !x3Cx3E_LunD(a, b);
}
                                #endif

                                #ifndef DEF_ensure_6WFe2OPyFQb
                                #define DEF_ensure_6WFe2OPyFQb
inline unsigned& ensure_6WFe(fu::vec_range_mut<unsigned> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

static void operator|=(LocidMap_IP5H& dest, const LocidMap_IP5H& src)
{
    for (int i = src._values.size(); i-- > 0; )
    {
        const unsigned src_1 = src._values[i];
        if (src_1)
            ensure_6WFe(dest._values, i) |= src_1;

    };
}

static void branch_gDsn(Postdom_Vy5u& dest, const Postdom_Vy5u& src, const Context_noPA& ctx, const TokenIdx_5581& _here)
{

    {

        {
            const LocidSet_iAWt& other = src.snap.used_again;
            LocidSet_iAWt& set = dest.snap.used_again;
            set._bitset |= other._bitset;
        };
        dest.snap.ever_written |= src.snap.ever_written;
        dest.snap.mayEscapeVia |= src.snap.mayEscapeVia;
        dest.snap.exitPaths |= src.snap.exitPaths;
    };
    dest.write_loop_start = max_BjFA((dest.write_loop_start ? dest.write_loop_start : BUG_u9Gb(fu::view<char>{}, ctx, _here)), (src.write_loop_start ? src.write_loop_start : BUG_u9Gb(fu::view<char>{}, ctx, _here)));
    dest.read_loop_start = max_BjFA((dest.read_loop_start ? dest.read_loop_start : BUG_u9Gb(fu::view<char>{}, ctx, _here)), (src.read_loop_start ? src.read_loop_start : BUG_u9Gb(fu::view<char>{}, ctx, _here)));
}

                                #ifndef DEF_if_only_RJ7XLHDMgFi
                                #define DEF_if_only_RJ7XLHDMgFi
inline const SolvedNode_efhg& if_only_RJ7X(fu::view<SolvedNode_efhg> a)
{
    if (a.size() == 1)
        return a[0];
    else
        return (*(SolvedNode_efhg*)fu::NIL);

}
                                #endif

static int createAndOr_staticEvalFold_gDsn(fu::vec_range_mut<SolvedNode_efhg> items, const StaticEval_IZio static_eval_fold, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, const fu::vec<Helpers_DyqV>& _helpers)
{
    int trim = 0;
    for (int i = (items.size() - 1); i-- > 0; )
    {
        const StaticEval_IZio se = tryAbstractEvalAsBool_gDsn(items[i], false, _current_fn, ss, ctx, _here, module, options, _helpers);
        if (se == static_eval_fold)
        {
            /*MOV*/ SolvedNode_efhg cond = items[i];
            items.splice(i, 1);
            if (trim)
                trim--;

            SolvedNode_efhg& cons = items.mutref(i);
            cons = createBlock_FDl5(static_cast<SolvedNode_efhg&&>(cond), SolvedNode_efhg(cons), ss, ctx, _here, module);
        }
        else if (se)
            trim = (i + 1);

    };
    return trim;
}

                                #ifndef DEF_last_c4M9LOKBCY2
                                #define DEF_last_c4M9LOKBCY2
inline const SolvedNode_efhg& last_c4M9(fu::view<SolvedNode_efhg> a)
{
    return a[(a.size() - 1)];
}
                                #endif

static SolvedNode_efhg createOr_gDsn(fu::vec<SolvedNode_efhg>&& items, Type_OiTm&& type, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, const fu::vec<Helpers_DyqV>& _helpers)
{

    {
        const int trim = createAndOr_staticEvalFold_gDsn(items, StaticEval_IZio_SE_False, _current_fn, ss, ctx, _here, module, options, _helpers);
        const VFacts_xhRf vfacts = VFacts_xhRf_AlwaysTrue;
        if (trim)
        {
            items.shrink(trim);
            type.vtype.vfacts |= vfacts;
        };
        if (items.size() < 2)
        {
            const SolvedNode_efhg& only = only_S4ER(items);
            return SolvedNode_efhg(only);
        };
    };
    if (!is_void_or_propositionOK_9CJm(type, false, ctx, _here))
    { {
        /*MOV*/ Type_OiTm sumType {};
        for (int i = items.size(); i-- > 0; )
        {
            const SolvedNode_efhg& item = items[i];
            if (!(is_never_9CJm(item.type.vtype)))
            {
                if (sumType)
                {
                    Type_OiTm _0 {};
                    sumType = ((_0 = type_trySuper_9CJm(sumType, item.type, false, ctx, _here)) ? static_cast<Type_OiTm&&>(_0) : (__extension__ (
                    {
                        for (int i_1 = 0; i_1 < items.size(); i_1++)
                        {
                            const SolvedNode_efhg& item_1 = items[i_1];
                            if (item_1.type.vtype.canon == t_bool.vtype.canon)
                            {
                                type = t_bool;
                                goto BL_4;
                            };
                        };
                        fail_gDsn(("Ambiguous ||, incompatible operands in a non-bool context: "_view + explainTypeDiff_gDsn(item.type, sumType, " || "_view, ss, ctx, _here, module, options)), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                        (void)0;
                    }), fu::unreachable));
                }
                else
                    sumType = item.type;

            };
        };
        if (!sumType)
            type = t_bool;
        else
            type = static_cast<Type_OiTm&&>(sumType);

      } BL_4:;
    }
    else
        type = t_bool;

    const Type_OiTm& last_type = last_c4M9(items).type;
    if (is_never_9CJm(last_type.vtype) || VFacts_xhRf((last_type.vtype.vfacts & VFacts_xhRf_AlwaysTrue)))
        type.vtype.vfacts = VFacts_xhRf_AlwaysTrue;

    return SolvedNode_gDsn(Kind_Idfg_or, type, Flags_Lzg8{}, (*(fu::str*)fu::NIL), items, Target_VZrr{}, Helpers_DyqV{}, _here);
}

static SolvedNode_efhg solveDefinit_gDsn(const Type_OiTm& type, const Context_noPA& ctx, const TokenIdx_5581& _here)
{
    Type_OiTm type_1 = definitType_9CJm(Type_OiTm(type), false, ctx, _here);
    return SolvedNode_gDsn(Kind_Idfg_definit, type_1, Flags_Lzg8{}, (*(fu::str*)fu::NIL), (*(fu::vec<SolvedNode_efhg>*)fu::NIL), Target_VZrr{}, Helpers_DyqV{}, _here);
}

                                #ifndef DEF_min_DbqN29MT8e3
                                #define DEF_min_DbqN29MT8e3
inline int min_DbqN(const int a, const int b)
{
    if ((a <= b))
        return a;
    else
        return b;

}
                                #endif

static int couldRetype_gDsn(const SolvedNode_efhg& node)
{
    if (node.kind == Kind_Idfg_real)
        return 1;
    else if (node.kind == Kind_Idfg_int)
        return 2;
    else if (node.kind == Kind_Idfg_definit)
        return 3;
    else if (is_zeroes_9CJm(node.type.vtype))
        return 3;
    else if (node.kind == Kind_Idfg_str)
        return 3;
    else if (node.kind == Kind_Idfg_if)
        return min_DbqN(couldRetype_gDsn(node.items[1]), couldRetype_gDsn(node.items[2]));
    else if (node.kind == Kind_Idfg_block)
    {
        if (!node.helpers)
            return couldRetype_gDsn(last_c4M9(node.items));
        else
            return 0;

    }
    else if (node.kind == Kind_Idfg_argid)
        return couldRetype_gDsn(only_S4ER(node.items));
    else
        return 0;

}

static SolvedNode_efhg litfix_bound_gDsn(const SolvedNode_efhg& expr, const SolvedNode_efhg& bound, const TokenIdx_5581& _here)
{
    if (couldRetype_gDsn(expr))
    {
        return SolvedNode_gDsn(Kind_Idfg___litfix_bound, expr.type, Flags_Lzg8{}, (*(fu::str*)fu::NIL), fu::vec<SolvedNode_efhg> {{ SolvedNode_efhg(expr), SolvedNode_efhg((couldRetype_gDsn(bound) ? bound : (*(SolvedNode_efhg*)fu::NIL))) }}, Target_VZrr{}, Helpers_DyqV{}, _here);
    }
    else
        return SolvedNode_efhg(expr);

}

static fu::view<char> getBasePrim_FDl5(const Type_OiTm& type, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const int offset = basePrimPrefixLen_hxWW(type.vtype.canon);
    if (offset < type.vtype.canon.size())
        return lookupUserType_gDsn(type, ss, ctx, _here, module, options, _helpers).shape.basePrim;
    else
        return type.vtype.canon;

}

static bool want_gDsn(const Type_OiTm& t, fu::view<char> c)
{
    return c == t.vtype.canon;
}

static const Type_OiTm& check_FDl5(const Type_OiTm& type, const Intlit_tw2d& parse, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (type && is_primitive_hxWW(type.vtype))
    {
        fu::view<char> c = getBasePrim_FDl5(type, ss, ctx, _here, module, options, _helpers);
        if (!parse.uNsigned)
        {
            if (((parse.minsize_f <= fu::u8(32u)) && want_gDsn(t_f32, c)) || ((parse.minsize_f <= fu::u8(64u)) && want_gDsn(t_f64, c)) || ((parse.minsize_i <= fu::u8(32u)) && want_gDsn(t_i32, c)) || ((parse.minsize_i <= fu::u8(64u)) && want_gDsn(t_i64, c)) || ((parse.minsize_i <= fu::u8(16u)) && want_gDsn(t_i16, c)) || ((parse.minsize_i <= fu::u8(8u)) && want_gDsn(t_i8, c)))
                return type;

        };
        if (!parse.sIgned)
        {
            if (((parse.minsize_u <= fu::u8(32u)) && want_gDsn(t_u32, c)) || ((parse.minsize_u <= fu::u8(64u)) && want_gDsn(t_u64, c)) || ((parse.minsize_u <= fu::u8(16u)) && want_gDsn(t_u16, c)) || ((parse.minsize_u <= fu::u8(8u)) && want_gDsn(t_u8, c)))
                return type;

        };
    };
    if (parse.uNsigned || (!parse.sIgned && (parse.base != fu::u8(10u))))
    {
        if ((parse.minsize_u <= fu::u8(32u)))
            return t_u32;
        else if ((parse.minsize_u <= fu::u8(64u)))
            return t_u64;

    }
    else if ((parse.minsize_i <= fu::u8(32u)))
        return t_i32;
    else if ((parse.minsize_i <= fu::u8(64u)))
        return t_i64;

    fail_gDsn(str_W2TNfRWjQyj, fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
}

static Type_OiTm solveInt_gDsn(fu::view<char> v, const Type_OiTm& type, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    Intlit_tw2d parse = Intlit_u8re(v);
    if (parse.error)
    {
        fail_gDsn(parse.error, fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
    }
    else
    {
        /*MOV*/ Type_OiTm type_1 = clear_refs_9CJm(Type_OiTm(check_FDl5(type, parse, ss, ctx, _here, module, options, _helpers)));
        if (!DevOptions_QEya((options.dev & DevOptions_QEya_DEV_DontFoldLiterals)))
            type_1.vtype.vfacts = (parse.absval ? VFacts_xhRf_AlwaysTrue : VFacts_xhRf_AlwaysFalse);

        return /*NRVO*/ type_1;
    };
}

static const Type_OiTm& solveReal_gDsn(const Type_OiTm& type)
{
    if (type.vtype.canon == t_f32.vtype.canon)
        return t_f32;
    else
        return t_f64;

}

extern const Type_OiTm t_string_literal;
static Type_OiTm solveString_gDsn(fu::view<char> v, const Type_OiTm& type, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    if (type && is_primitive_hxWW(type.vtype))
    {
        fu::view<ScopeItem_xiLD> a = tryLookupUserType_1qjp(type.vtype, ctx, _here, module).items;
        for (int i = 0; i < a.size(); i++)
        {
            const ScopeItem_xiLD& member = a[i];
            if (member.id == v)
                return Type_OiTm(GET_gDsn(target_z0Qq(member), ss, ctx, _here, module).type);

        };
    };
    /*MOV*/ Type_OiTm ret = t_string_literal;
    if (!DevOptions_QEya((options.dev & DevOptions_QEya_DEV_DontFoldLiterals)))
    {
        ret.vtype.vfacts = (v.size() ? VFacts_xhRf_AlwaysTrue : VFacts_xhRf_AlwaysFalse);
        ret.vtype.vfacts |= VFacts_xhRf((VFacts_xhRf_LeftAligned | VFacts_xhRf_RightAligned));
    };
    return /*NRVO*/ ret;
}

static Type_OiTm tryRetyping_gDsn(const SolvedNode_efhg& node, const Type_OiTm& expect, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if ((node.kind == Kind_Idfg_definit) || is_zeroes_9CJm(node.type.vtype))
        return definitType_9CJm(Type_OiTm(expect), false, ctx, _here);
    else
    {
        if (is_arithmetic_hxWW(node.type.vtype) && is_arithmetic_hxWW(expect.vtype))
        {
            if (node.kind == Kind_Idfg_int)
                return solveInt_gDsn(node.value, expect, ss, ctx, _here, module, options, _helpers);
            else if (node.kind == Kind_Idfg_real)
                return Type_OiTm(solveReal_gDsn(expect));

        };
        if (node.kind == Kind_Idfg_str)
            return solveString_gDsn(node.value, expect, ss, ctx, _here, module, options);
        else if (node.kind == Kind_Idfg_if)
        {
            Type_OiTm left = tryRetyping_gDsn(node.items[1], expect, ss, ctx, _here, module, options, _helpers);
            Type_OiTm right = tryRetyping_gDsn(node.items[2], expect, ss, ctx, _here, module, options, _helpers);
            if (left && right)
                return type_trySuper_9CJm(left, right, false, ctx, _here);
            else
            {
                return Type_OiTm{};
            };
        }
        else if ((node.kind == Kind_Idfg_block) || (node.kind == Kind_Idfg_argid))
        {
            const Helpers_DyqV* h;
            if (!HelpersMask_w1sv(((h = &(node.helpers), ((((*h).index >= 0) && ((*h).index < ss._helpers_data.size())) ? ss._helpers_data[(*h).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).mask & HelpersMask_w1sv_HM_LabelUsed)) && node.items)
                return tryRetyping_gDsn(last_c4M9(node.items), expect, ss, ctx, _here, module, options, _helpers);
            else
            {
                return Type_OiTm{};
            };
        }
        else
        {
            return Type_OiTm{};
        };
    };
}

static void applyRetype_gDsn(SolvedNode_efhg& node, const Type_OiTm& retype, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if ((node.kind == Kind_Idfg_definit) || is_zeroes_9CJm(node.type.vtype))
        definitWrap_gDsn(node, retype, ss, ctx, _here, module, options, _helpers);
    else
    {
        if (node.kind == Kind_Idfg_if)
        {
            SolvedNode_efhg* _0;
            (_0 = &(node.items.mutref(1)), applyRetype_gDsn(*_0, retype, ss, ctx, _here, module, options, _helpers));
            SolvedNode_efhg* _1;
            (_1 = &(node.items.mutref(2)), applyRetype_gDsn(*_1, retype, ss, ctx, _here, module, options, _helpers));
        }
        else if ((node.kind == Kind_Idfg_block) || (node.kind == Kind_Idfg_argid))
        {
            const Helpers_DyqV* h;
            if ((h = &(node.helpers), ((((*h).index >= 0) && ((*h).index < ss._helpers_data.size())) ? ss._helpers_data[(*h).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).mask & HelpersMask_w1sv_HM_LabelUsed)
                BUG_gDsn("Trying to retype a labelled block, we cant do this still."_view, ss, ctx, _here, module, options, _helpers);
            else
            {
                SolvedNode_efhg* _2;
                (_2 = &(last_xZUS(node.items)), applyRetype_gDsn(*_2, retype, ss, ctx, _here, module, options, _helpers));
            };
        };
        node.type = retype;
    };
}

                                #ifndef DEF_tryConvert_GKse2SoxXo1
                                #define DEF_tryConvert_GKse2SoxXo1
inline static fu::vec<Target_VZrr> tryConvert_GKse(const Type_OiTm& expect, const Type_OiTm& actual, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    /*MOV*/ fu::vec<Target_VZrr> match {};
    const ConvCache_ColsAndBakes_2n47& cc = exploreConversions_FDl5(actual.vtype, _current_fn, ss, ctx, _here, module, options, _helpers);
    for (int i = 0; i < cc.columns.types.size(); i++)
    { {
        const ValueType_JtNg& convertType = cc.columns.types[i];
        if (isAssignableAsArgument_9CJm(expect.vtype, convertType, false, ctx, _here))
        {
            fu::vec_range<Target_VZrr> path = cc.columns.paths[i];
            fu::view<int> ms = cc.columns.must_see[i];
            for (int i_1 = 0; i_1 < ms.size(); i_1++)
            {
                const int ms_1 = ms[i_1];
                const bool isUsing = (ms_1 < 0);
                const int index = ((isUsing ? -ms_1 : +ms_1) - 1);
                fu::view<ScopeSkip_iozY> skips = (isUsing ? ss._ss.usings : ss._ss.converts);
                fu::view<Target_VZrr> which = (isUsing ? ss._scope.usings : ss._scope.converts);
                if ((index >= 0) && (index < which.size()))
                {
                    for (int i_2 = 0; i_2 < skips.size(); i_2++)
                    {
                        const ScopeSkip_iozY& skip = skips[i_2];
                        if ((skip.start <= index) && (skip.end > index))
                            goto BL_2;

                    };
                }
                else
                    BUG_gDsn((x7E_rA00((x7E_rA00((x7E_rA00((x7E_rA00("ConvCache.must_see ms("_view, fu::i64dec(ms_1)) + ") isUsing("_view), fu::booldec(isUsing)) + ") index("_view), fu::i64dec(index)) + ") is out of bounds("_view), fu::i64dec(which.size())) + ")"_view), ss, ctx, _here, module, options, _helpers);

            };
            if (match)
            {
                fu::str suffix = ((("\n"_view + explainConversion_gDsn(match, fu::view<char>{}, _current_fn, ss, ctx, _here, module, options)) + "\n\tand:\n"_view) + explainConversion_gDsn(path, fu::view<char>{}, _current_fn, ss, ctx, _here, module, options));
                if (actual)
                {
                    fail_gDsn(((((("Conversion ambiguity, multiple ways to convert "_view + explainType_gDsn(actual, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)) + " into "_view) + explainType_gDsn(expect, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)) + ":"_view) + suffix), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                }
                else
                {
                    fail_gDsn(((((qBAD_e44U("using"_view) + " ambiguity, multiple ways to obtain a "_view) + explainType_gDsn(expect, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)) + " in this scope:"_view) + suffix), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                };
            }
            else
                match = (path ? path : BUG_gDsn("Empty conversion path in cache."_view, ss, ctx, _here, module, options, _helpers));

        };
      } BL_2:;
    };
    return /*NRVO*/ match;
}
                                #endif

static fu::view<char> explain_wyx7(const Type_OiTm& a, const Type_OiTm& b, fu::view<Target_VZrr> chain, fu::vec_range_mut<char> error, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    return (error += ((("\n\t"_view + explainTypeDiff_gDsn(a, b, " -> "_view, ss, ctx, _here, module, options)) + ":"_view) + explainConversion_gDsn(chain, fu::view<char>{}, _current_fn, ss, ctx, _here, module, options)));
}

static int findRestStart_gDsn(const Extended_z0HS& ext)
{
    for (int i = ext.args.size(); i-- > 0; )
    {
        const Argument_bbKc& arg = ext.args[i];
        if (arg.flags & Flags_Lzg8_F_REST_ARG)
            return i;
        else if (!(arg.flags & Flags_Lzg8_F_IMPLICIT))
            break;

    };
    return ext.args.size();
}

static Type_OiTm solveArrlit_itemType_init_gDsn(const Type_OiTm& head, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    Type_OiTm _0 {};
    return (_0 = clear_refs_9CJm(Type_OiTm(head))) ? static_cast<Type_OiTm&&>(_0) : BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers);
}

static Type_OiTm superType_gDsn(fu::view<char> reason, const Type_OiTm& a, const Type_OiTm& b, const Target_VZrr& target, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    Type_OiTm _0 {};
    return (_0 = type_trySuper_9CJm(a, b, false, ctx, _here)) ? static_cast<Type_OiTm&&>(_0) : fail_gDsn(((((target ? str_FDl5(target, false, ss, ctx, _here, module, options) : fu::str{}) + reason) + "No common supertype: "_view) + explainTypeDiff_gDsn(a, b, " | "_view, ss, ctx, _here, module, options)), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
}

static Type_OiTm solveArrlit_itemType_gDsn(fu::view<SolvedNode_efhg> items, /*MOV*/ Type_OiTm&& itemType, int start, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (!itemType)
    {
        if (start == items.size())
        {
            fail_gDsn(str_FaWEciPaRMe, fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
        }
        else
            itemType = solveArrlit_itemType_init_gDsn(items[start++].type, ss, ctx, _here, module, options, _helpers);

    }
    else if (is_ref_9CJm(itemType))
    {
        fail_gDsn(str_rSRZRLyoFVb, fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
    };
    for (int i = start; i < items.size(); i++)
    {
        itemType = superType_gDsn("Array literal: "_view, itemType, items[i].type, Target_VZrr{}, ss, ctx, _here, module, options, _helpers);
    };
    return static_cast<Type_OiTm&&>(itemType);
}

static Type_OiTm solveArrlit_done_gDsn(const Type_OiTm& itemType, const int itemCount, const Options_TBgD& options)
{
    /*MOV*/ Type_OiTm arrayType = createArray_9CJm(itemType);
    if (!DevOptions_QEya((options.dev & DevOptions_QEya_DEV_DontFoldLiterals)))
    {
        if ((itemCount >= 0) && !DevOptions_QEya((options.dev & DevOptions_QEya_DEV_DontFoldLiterals)))
            arrayType.vtype.vfacts = (itemCount ? VFacts_xhRf_AlwaysTrue : VFacts_xhRf_AlwaysFalse);

        arrayType.vtype.vfacts |= VFacts_xhRf((VFacts_xhRf_LeftAligned | VFacts_xhRf_RightAligned));
    };
    return /*NRVO*/ arrayType;
}

static SolvedNode_efhg createArrlit_gDsn(fu::vec_range<SolvedNode_efhg> items, const Type_OiTm& itemType, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    Type_OiTm itemType_1 = solveArrlit_itemType_gDsn(items, Type_OiTm(itemType), 0, ss, ctx, _here, module, options, _helpers);
    return SolvedNode_gDsn(Kind_Idfg_arrlit, solveArrlit_done_gDsn(itemType_1, items.size(), options), Flags_Lzg8{}, (*(fu::str*)fu::NIL), items, Target_VZrr{}, Helpers_DyqV{}, _here);
}

static int GET_next_local_index_gDsn(const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here)
{
    const Target_VZrr* t;
    const int globid = (t = &(_current_fn.out.target), int(unsigned((((*t)._packed >> 20ull) & 0xfffffull))));
    if (!globid)
        return 0;
    else if ((globid > 0) && (globid < ss._scope.extended.size()))
    {
        const Extended_z0HS& ext = ss._scope.extended[globid];
        return ext.args_n_locals.size() + (1 - ext.args_neg);
    }
    else
        BUG_u9Gb("GET_next_local_index: bad globid"_view, ctx, _here);

}

                                #ifndef DEF_remove_yIeDxHMMpb7
                                #define DEF_remove_yIeDxHMMpb7
inline void remove_yIeD(fu::vec_range_mut<SolvedNode_efhg> a, const int at, const int count)
{
    a.splice(at, count);
}
                                #endif

                                #ifndef DEF_update_E1weWcuD3tf
                                #define DEF_update_E1weWcuD3tf
inline bool update_E1we(Set_R8IU& _, const Target_VZrr& key, fu::vec_range_mut<Target_VZrr> values, const Target_VZrr& value)
{
    fu::view<Target_VZrr> keys_asc = _.keys_asc;
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_YjZY(keys_asc[i], key);
        if (cmp == 0)
        {
            values.mutref(i) = Target_VZrr(value);
            return false;
        }
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    const int i = lo;
    _.keys_asc.insert(i, Target_VZrr(key));
    values.insert(i, Target_VZrr(value));
    return true;
}
                                #endif

                                #ifndef DEF_set_5Vx3FbOapFk
                                #define DEF_set_5Vx3FbOapFk
inline bool set_5Vx3(Map_iaWx& _, const Target_VZrr& key, const Target_VZrr& value)
{
    return update_E1we(_.keys, key, _.vals, value);
}
                                #endif

extern const Lifetime_llCF Lifetime_static_immoveable;
static Lifetime_llCF Lifetime_fromBinding_gDsn(const Target_VZrr& target, const int flatCount, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    unsigned v;
    if ((v = unsigned((target._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))) || (int(unsigned(((target._packed >> 40ull) & 0xfffffull))) == module.modid))
    {
        if (!flatCount)
        {
            return Lifetime_llCF(Lifetime_static_moveable);
        }
        else
        {
            unsigned v_1;
            const int locid = (v_1 = unsigned((target._packed & 0xfffffull)), int(((v_1 >> 1u) ^ ((v_1 & 1u) ? 0xffffffffu : 0x0u))));
            if (locid)
            {
                return Lifetime_from_7Yz9(locid, flatCount, ctx, _here);
            }
            else
            {
                return Lifetime_llCF(Lifetime_static_immoveable);
            };
        };
    }
    else
        BUG_gDsn("not from this module"_view, ss, ctx, _here, module, options, _helpers);

}

static void TEST_LifetimeEqual_gDsn(const Lifetime_llCF& a, fu::view<char> aa, const Lifetime_llCF& b, fu::view<char> bb, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (!(a == b))
    {
        BUG_gDsn((x7E_rA00((((((x7E_rA00((((("visitNode TEST_LifetimeEqual:"_view + "\n\n\t    "_view) + aa) + ":\t"_view) + "("_view), str_gDsn(a, false, ss, ctx, _here, module, options)) + ")"_view) + "\n\n\t    "_view) + bb) + ":\t"_view) + "("_view), str_gDsn(b, false, ss, ctx, _here, module, options)) + ")"_view), ss, ctx, _here, module, options, _helpers);
    };
}

                                #ifndef DEF_get_6SDB51QWwhi
                                #define DEF_get_6SDB51QWwhi
inline const Target_VZrr& get_6SDB(const Set_R8IU& _, const Target_VZrr& key, fu::view<Target_VZrr> values)
{
    fu::view<Target_VZrr> keys_asc = _.keys_asc;
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_YjZY(keys_asc[i], key);
        if (cmp == 0)
            return values[i];
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    return (*(Target_VZrr*)fu::NIL);
}
                                #endif

                                #ifndef DEF_get_17MGQEHKSDg
                                #define DEF_get_17MGQEHKSDg
inline const Target_VZrr& get_17MG(const Map_iaWx& _, const Target_VZrr& key)
{
    return get_6SDB(_.keys, key, _.vals);
}
                                #endif

                                #ifndef DEF_TODO_FIX_pop_f7NvpXnq9a4
                                #define DEF_TODO_FIX_pop_f7NvpXnq9a4
inline static SolvedNode_efhg TODO_FIX_pop_f7Nv(fu::vec_range_mut<SolvedNode_efhg> arr)
{
    /*MOV*/ SolvedNode_efhg item {};
    std::swap(item, arr.mutref((arr.size() - 1)));
    arr.pop();
    return /*NRVO*/ item;
}
                                #endif

static fu::str qSTACK_implicit_FDl5(const Target_VZrr& target, const SolvedNode_efhg& node, fu::vec_range<char> id, const Type_OiTm& type, fu::view<Target_VZrr> seen, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    const Target_VZrr nestingFnort0 = exchange_GcK8(ss._nestingFnort, Target_VZrr(target));
    fu_DEFER(ss._nestingFnort = nestingFnort0);
    fu::str candidates {};
    fu::vec<Target_VZrr> seen_1 = (seen + target);

    {
        fu::vec<SolvedNode_efhg> stack = fu::vec<SolvedNode_efhg> {{ SolvedNode_efhg(node) }};
        while (stack)
        {
            SolvedNode_efhg node_1 = TODO_FIX_pop_f7Nv(stack);
            const SolvedNode_efhg& node_2 = ((node_1.kind == Kind_Idfg_letdef) ? GET_gDsn(node_1.target, ss, ctx, _here, module).solved : node_1);
            const SolvedNode_efhg* __partcopy_ref;
            SolvedNode_efhg node_3 = (__partcopy_ref = &(((node_2.kind == Kind_Idfg___preceding_ref_arg) ? _current_fn.events.preceding_ref_args[node_2.helpers.index].arg : node_2)), SolvedNode_efhg { (*__partcopy_ref).kind, {/*unused non-zst*/}, {/*unused non-zst*/}, {/*unused non-zst*/}, {/*unused non-zst*/}, fu::vec<SolvedNode_efhg>((*__partcopy_ref).items), TokenIdx_5581((*__partcopy_ref).token), {/*unused non-zst*/}, Target_VZrr((*__partcopy_ref).target) });

            { {
                if (node_3.kind == Kind_Idfg_let)
                {
                    const Target_VZrr& candidate = node_3.target;
                    if (candidate && !(GET_gDsn(candidate, ss, ctx, _here, module).flags & Flags_Lzg8_F_INJECTED) && (GET_gDsn(candidate, ss, ctx, _here, module).name == id) && isAssignableAsArgument_9CJm(type.vtype, GET_gDsn(candidate, ss, ctx, _here, module).type.vtype, false, ctx, _here))
                    {
                        candidates += (x7E_rA00("\n        Possible candidate in "_view, str_FDl5(target, false, ss, ctx, _here, module, options)) + ": "_view);
                        if (!(GET_gDsn(candidate, ss, ctx, _here, module).flags & Flags_Lzg8_F_IMPLICIT))
                            candidates += qBAD_e44U("NOT implicit "_view);

                        candidates += explainWhichFn_gDsn(Target_VZrr(candidate), fu::view<fu::vec<Target_VZrr>>{}, fu::view<char>{}, CodeFmt_snPx_FullContext, _current_fn, ss, ctx, _here, module, options);
                    };
                };
                if (!((node_3.kind != Kind_Idfg_call) || isLocal_gDsn(node_3.target)))
                {
                    if (!(has_bkvR(seen_1, node_3.target)))
                    {

                        { {
                            fu::view<Argument_bbKc> host_args = EXT_gDsn(node_3.target, ss, ctx, module).args;
                            for (int i = 0; i < host_args.size(); i++)
                            {
                                const Argument_bbKc& host_arg = host_args[i];
                                if ((host_arg.flags & Flags_Lzg8_F_IMPLICIT) && (host_arg.name == id) && isAssignableAsArgument_9CJm(host_arg.type.vtype, type.vtype, false, ctx, _here))
                                    goto BL_10;

                            };
                            goto BL_4;
                          } BL_10:;
                        };
                        fu::str peek = qSTACK_implicit_FDl5(node_3.target, GET_gDsn(node_3.target, ss, ctx, _here, module).solved, id, type, seen_1, _current_fn, ss, ctx, _here, module, options);
                        return (((x7E_rA00(("\n            "_view + "because of call to "_view), str_FDl5(node_3.target, false, ss, ctx, _here, module, options)) + " at "_view) + addr_and_snippet_gDsn(node_3.token, CodeFmt_snPx{}, fu::view<char>{}, ctx, module)) + peek) + candidates;
                    };
                };
              } BL_4:;
            };
            for (int i = node_3.items.size(); i-- > 0; )
                stack += SolvedNode_efhg(node_3.items[i]);

        };
    };
    fu::view<Argument_bbKc> host_args = EXT_gDsn(target, ss, ctx, module).args;
    for (int i = 0; i < host_args.size(); i++)
    {
        const Argument_bbKc& host_arg = host_args[i];
        if ((host_arg.flags & Flags_Lzg8_F_IMPLICIT) && (host_arg.name == id) && isAssignableAsArgument_9CJm(host_arg.type.vtype, type.vtype, false, ctx, _here))
        {
            return ("\n            "_view + "because of "_view) + explainWhichFn_gDsn(Target_VZrr(host_arg.target), fu::view<fu::vec<Target_VZrr>>{}, fu::view<char>{}, CodeFmt_snPx_FullContext, _current_fn, ss, ctx, _here, module, options);
        };
    };
    return fu::str{};
}

static fu::str qSTACK_implicit_gDsn(const Target_VZrr& becauseOf, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    const Target_VZrr target = parent_gDsn(becauseOf, ctx, _here);
    return qSTACK_implicit_FDl5(target, GET_gDsn(target, ss, ctx, _here, module).solved, GET_gDsn(becauseOf, ss, ctx, _here, module).name, GET_gDsn(becauseOf, ss, ctx, _here, module).type, fu::view<Target_VZrr>{}, _current_fn, ss, ctx, _here, module, options);
}

static Type_OiTm intersectionType_gDsn(fu::view<char> reason, const Type_OiTm& a, const Type_OiTm& b, fu::view<char> id, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    Type_OiTm _0 {};
    return (_0 = type_tryIntersect_9CJm(a, b, ctx, _here)) ? static_cast<Type_OiTm&&>(_0) : fail_gDsn(((((id ? (qID_e44U(id) + ": "_view) : fu::str{}) + reason) + "Cannot intersect types: "_view) + explainTypeDiff_gDsn(a, b, " & "_view, ss, ctx, _here, module, options)), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
}

extern const unsigned q_rx_resize;
                                #ifndef DEF_str_1FAcf9RERsa
                                #define DEF_str_1FAcf9RERsa
inline fu::str str_1FAc(const Flags_Lzg8 n)
{
    /*MOV*/ fu::str res {};

    {
        if (n & Flags_Lzg8_F_CALL_HAS_DOT)
            res += ("F_CALL_HAS_DOT"_view + ", "_view);

        if (n & Flags_Lzg8_F_CALL_HAS_ARGPARENS)
            res += ("F_CALL_HAS_ARGPARENS"_view + ", "_view);

        if (n & Flags_Lzg8_F_CALL_HAS_NAMED_ARGS)
            res += ("F_CALL_HAS_NAMED_ARGS"_view + ", "_view);

        if (n & Flags_Lzg8_F_OPERATOR)
            res += ("F_OPERATOR"_view + ", "_view);

        if (n & Flags_Lzg8_F_TYPENAME)
            res += ("F_TYPENAME"_view + ", "_view);

        if (n & Flags_Lzg8_F_COMPOUND_ID)
            res += ("F_COMPOUND_ID"_view + ", "_view);

        if (n & Flags_Lzg8_F_ARGID_IS_OPTIONAL)
            res += ("F_ARGID_IS_OPTIONAL"_view + ", "_view);

        if (n & Flags_Lzg8_F_LAX)
            res += ("F_LAX"_view + ", "_view);

        if (n & Flags_Lzg8_F_SHADOW)
            res += ("F_SHADOW"_view + ", "_view);

        if (n & Flags_Lzg8_F_MUSTNAME)
            res += ("F_MUSTNAME"_view + ", "_view);

        if (n & Flags_Lzg8_F_MUT)
            res += ("F_MUT"_view + ", "_view);

        if (n & Flags_Lzg8_F_CONST)
            res += ("F_CONST"_view + ", "_view);

        if (n & Flags_Lzg8_F_VAL)
            res += ("F_VAL"_view + ", "_view);

        if (n & Flags_Lzg8_F_REF)
            res += ("F_REF"_view + ", "_view);

        if (n & Flags_Lzg8_F_IMPLICIT)
            res += ("F_IMPLICIT"_view + ", "_view);

        if (n & Flags_Lzg8_F_USING)
            res += ("F_USING"_view + ", "_view);

        if (n & Flags_Lzg8_F_CONVERSION)
            res += ("F_CONVERSION"_view + ", "_view);

        if (n & Flags_Lzg8_F_TEST_painted)
            res += ("F_TEST_painted"_view + ", "_view);

        if (n & Flags_Lzg8_F_PUB)
            res += ("F_PUB"_view + ", "_view);

        if (n & Flags_Lzg8_F_EXTERN)
            res += ("F_EXTERN"_view + ", "_view);

        if (n & Flags_Lzg8_F_HOTSWAP)
            res += ("F_HOTSWAP"_view + ", "_view);

        if (n & Flags_Lzg8_F_PREDICATE)
            res += ("F_PREDICATE"_view + ", "_view);

        if (n & Flags_Lzg8_F_LT_RETURNED)
            res += ("F_LT_RETURNED"_view + ", "_view);

        if (n & Flags_Lzg8_F_REST_ARG)
            res += ("F_REST_ARG"_view + ", "_view);

        if (n & Flags_Lzg8_F_INJECTED)
            res += ("F_INJECTED"_view + ", "_view);

        if (n & Flags_Lzg8_F_TEMPLATE)
            res += ("F_TEMPLATE"_view + ", "_view);

        if (n & Flags_Lzg8_F_INLINE)
            res += ("F_INLINE"_view + ", "_view);

        if (n & Flags_Lzg8_F_LAMBDA)
            res += ("F_LAMBDA"_view + ", "_view);

        if (n & Flags_Lzg8_F_COW_INSIDE)
            res += ("F_COW_INSIDE"_view + ", "_view);

    };
    if (res)
        res.shrink((res.size() - 2));

    return /*NRVO*/ res;
}
                                #endif

static fu::str makeItLaxIfIntentional_gDsn()
{
    return (" Make it "_view + qKW_e44U("lax"_view)) + " if this is intentional."_view;
}

static Target_VZrr Binding_gDsn(fu::vec_range<char> id, /*MOV*/ Type_OiTm&& type, const Flags_Lzg8 flags, const DeclAsserts_taUG asserts, bool& shadows, const bool asArgument, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    fu::vec_range<char> name = id;
    const Target_VZrr* t;
    const int local_of = (t = &(_current_fn.out.target), int(unsigned((((*t)._packed >> 20ull) & 0xfffffull))));
    if (ss._root_scope)
        autoshadow_gDsn(shadows, local_of, id, _current_fn, ss);

    const SolverStatus_h9em status = ((type.vtype.quals & q_rx_resize) ? SolverStatus_h9em_SS_TODO_FIX_was_rx_resize : SolverStatus_h9em{});
    const Target_VZrr target = Scope_create_z0Qq(ss._scope, Kind_Idfg_var, name, (*(Type_OiTm*)fu::NIL), flags, asserts, status, local_of, asArgument, module);
    if (flags & Flags_Lzg8_F_REF)
    {
        if (is_ref_9CJm(type))
        {
            if (!(!(flags & Flags_Lzg8_F_MUT) || is_mutref_9CJm(type, ctx, _here)))
                BUG_gDsn(((((x7E_rA00("Binding("_view, str_1FAc(flags)) + " "_view) + name) + ") !type.is_mutref:\n\n\t\t"_view) + explainType_gDsn(type, false, true, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

        }
        else
            BUG_gDsn(((((x7E_rA00("Binding("_view, str_1FAc(flags)) + " "_view) + name) + ") !type.is_ref:\n\n\t\t"_view) + explainType_gDsn(type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

    };
    Overload_aO3i& overload = GET_mut_gDsn(target, ss, module);

    {
        Lifetime_llCF lifetime = Lifetime_fromBinding_gDsn(target, getFlatCount_1qjp(type.vtype, ctx, _here, module), ss, ctx, _here, module, options, _helpers);
        type.lifetime = Lifetime_llCF{};
        overload.type = ((flags & Flags_Lzg8_F_MUT) ? add_mutref_9CJm(static_cast<Type_OiTm&&>(type), lifetime, ctx, _here) : add_ref_9CJm(static_cast<Type_OiTm&&>(type), lifetime, ctx, _here));
        if (is_zeroes_9CJm(overload.type.vtype) && (~flags & Flags_Lzg8_F_LAX) && ((flags & ((Flags_Lzg8_F_TEMPLATE | Flags_Lzg8_F_REF) | Flags_Lzg8_F_MUT)) != Flags_Lzg8_F_TEMPLATE))
        {
            fail_gDsn((((x7E_rA00(str_FDl5(target, false, ss, ctx, _here, module, options), " needs a tighter type annotation, inferred type is "_view) + explainTypeName_gDsn(overload.type, false, ctx, _here, module, options)) + "."_view) + makeItLaxIfIntentional_gDsn()), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
        };
    };
    return target;
}

static const SolvedNode_efhg& solved_set_FDl5(const Target_VZrr& target, const SolvedNode_efhg& node, SolverState_aGlN& ss, const Module_wo7O& module)
{
    return (GET_mut_gDsn(target, ss, module).solved = SolvedNode_efhg(node));
}

static Target_VZrr createLet_implicitArg_gDsn(fu::vec_range<char> id, const Type_OiTm& type, const Flags_Lzg8 flags, bool& shadows, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const Target_VZrr target = Binding_gDsn(id, Type_OiTm(type), flags, _current_fn.asserts, shadows, true, _current_fn, ss, ctx, _here, module, options, _helpers);
    SolvedNode_efhg ret = SolvedNode_gDsn(Kind_Idfg_let, GET_gDsn(target, ss, ctx, _here, module).type, flags, GET_gDsn(target, ss, ctx, _here, module).name, (*(fu::vec<SolvedNode_efhg>*)fu::NIL), target, Helpers_DyqV{}, _here);
    solved_set_FDl5(target, ret, ss, module);
    return target;
}

static SolvedNode_efhg createLetDef_gDsn(const Target_VZrr& target, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    return SolvedNode_gDsn(Kind_Idfg_letdef, GET_gDsn(target, ss, ctx, _here, module).type, Flags_Lzg8{}, (*(fu::str*)fu::NIL), (*(fu::vec<SolvedNode_efhg>*)fu::NIL), target, Helpers_DyqV{}, _here);
}

static Target_VZrr injectImplicitArg_gDsn(fu::vec_range<char> id, const Type_OiTm& type, const Target_VZrr& becauseOf, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (!_current_fn.out.items || (_current_fn.out.flags & Flags_Lzg8_F_EXTERN))
    {
        fu::str _0 {};
        fu::str _1 {};
        (_1 = (_0 = (x7E_rA00((((("No implicit "_view + qBAD_e44U(human_gDsn(id, ss, ctx, _here, module, options))) + ": "_view) + explainType_gDsn(type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)) + " in scope, needed to call "_view), str_FDl5(parent_gDsn(becauseOf, ctx, _here), false, ss, ctx, _here, module, options)) + ":\n"_view), (static_cast<fu::str&&>(_0) + qSTACK_implicit_gDsn(becauseOf, _current_fn, ss, ctx, _here, module, options))), fail_gDsn(static_cast<fu::str&&>(_1), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers));
    }
    else
    {
        for (int i = 0; i < (_current_fn.out.items.size() + FN_ARGS_BACK); i++)
        {
            SolvedNode_efhg& arg = _current_fn.out.items.mutref(i);
            const Target_VZrr& target = arg.target;
            SolvedNode_efhg& arg_1 = ((arg.kind == Kind_Idfg_letdef) ? GET_mut_gDsn(target, ss, module).solved : arg);
            if ((arg_1.flags & Flags_Lzg8_F_IMPLICIT) && (arg_1.value == id))
            {
                if (arg_1.type == GET_gDsn(target, ss, ctx, _here, module).type)
                {
                    /*MOV*/ Type_OiTm super = intersectionType_gDsn("Implicit argument collision: "_view, add_ref_9CJm(Type_OiTm(type), arg_1.type.lifetime, ctx, _here), arg_1.type, id, ss, ctx, _here, module, options, _helpers);
                    arg_1.type = super;
                    GET_mut_gDsn(target, ss, module).type = static_cast<Type_OiTm&&>(super);
                    return (target ? target : BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers));
                }
                else
                {
                    BUG_gDsn(("injectImplicitArg: arg.type != target.type:\n\n\t    "_view + explainTypeDiff_gDsn(arg_1.type, GET_gDsn(target, ss, ctx, _here, module).type, " != "_view, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);
                };
            };
        };
        bool shadows {};
        const Flags_Lzg8 flags = (((Flags_Lzg8_F_INJECTED | Flags_Lzg8_F_IMPLICIT) | Flags_Lzg8_F_LAX) | Flags_Lzg8_F_REF);
        const Target_VZrr newArgTarget = createLet_implicitArg_gDsn(id, type, flags, shadows, _current_fn, ss, ctx, _here, module, options, _helpers);
        const int newArgIdx = (_current_fn.out.items.size() + FN_ARGS_BACK);
        /*MOV*/ SolvedNode_efhg newLetDef = createLetDef_gDsn(newArgTarget, ss, ctx, _here, module);
        _current_fn.out.items.insert(newArgIdx, static_cast<SolvedNode_efhg&&>(newLetDef));
        return newArgTarget;
    };
}

                                #ifndef DEF_fail_B3cu9IZkC1g
                                #define DEF_fail_B3cu9IZkC1g
[[noreturn]] inline static fu::never fail_B3cu(fu::view<char> reason, const Target_VZrr& becauseOf, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    fu::str _0 {};
    fu::str _1 {};
    (_1 = (_0 = (x7E_rA00((reason + "\n\n\tNeeded to call "_view), str_FDl5(parent_gDsn(becauseOf, ctx, _here), false, ss, ctx, _here, module, options)) + ":\n"_view), (static_cast<fu::str&&>(_0) + qSTACK_implicit_gDsn(becauseOf, _current_fn, ss, ctx, _here, module, options))), fail_gDsn(static_cast<fu::str&&>(_1), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers));
}
                                #endif

static SolvedNode_efhg bindImplicitArg_gDsn(fu::vec_range<char> name, const Type_OiTm& type, const Target_VZrr& becauseOf, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    const ClosureID_qHEW cid = tryParseClosureID_UvH3(name, ctx, _here);
    if (cid && (parent_gDsn(cid.target, ctx, _here) == _current_fn.out.target))
    {
        if (cid.revision == EPH_gDsn(_current_fn.out.target, ss, module).revision)
        {
            if (GET_gDsn(cid.target, ss, ctx, _here, module).kind == Kind_Idfg_var)
            {
                return CallerNode_gDsn(str_LRHKEAVNik7, Target_VZrr(cid.target), fu::vec<SolvedNode_efhg>{}, (*(Reorder_0MNg*)fu::NIL), fu::view<fu::vec<Target_VZrr>>{}, _current_fn, ss, ctx, _here, module, options, _helpers);
            }
            else
                BUG_gDsn(x7E_rA00("ClosureID.target is not a var: "_view, str_FDl5(cid.target, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

        }
        else
            BUG_gDsn(x7E_rA00((x7E_rA00((x7E_rA00("ClosureID.revision mismatch: "_view, str_FDl5(cid.target, false, ss, ctx, _here, module, options)) + "\n\tCaptured at: "_view), fu::u64dec(cid.revision)) + "\n\tCurrent rev: "_view), fu::u64dec(EPH_gDsn(_current_fn.out.target, ss, module).revision)), ss, ctx, _here, module, options, _helpers);

    }
    else
    {
        fu::str error {};
        Reorder_0MNg reorder {};
        fu::vec<fu::vec<Target_VZrr>> conversions {};
        Target_VZrr _0;
        const Target_VZrr target = ((_0 = (!cid ? tryMatchCall_gDsn(fu::str(name), reorder, conversions, error, true, (*(Scope_blWT*)fu::NIL), fu::view<SolvedNode_efhg>{}, Flags_Lzg8_F_IMPLICIT, fu::view<Target_VZrr>{}, _current_fn, ss, ctx, _here, module, options, _helpers) : Target_VZrr{})) ? static_cast<Target_VZrr&&>(_0) : (_0 = injectImplicitArg_gDsn(name, type, becauseOf, _current_fn, ss, ctx, _here, module, options, _helpers)) ? static_cast<Target_VZrr&&>(_0) : BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers));
        /*MOV*/ SolvedNode_efhg call = CallerNode_gDsn(str_cE12d2VNpS7, Target_VZrr(target), fu::vec<SolvedNode_efhg>{}, reorder, conversions, _current_fn, ss, ctx, _here, module, options, _helpers);

        {
            const Type_OiTm& guest = call.type;
            const bool asArgument = true;
            if (!(isAssignable_9CJm(type, guest, false, asArgument, ctx, _here)))
            {
                fail_B3cu((((fu::str{} + x7E_rA00(str_FDl5(becauseOf, false, ss, ctx, _here, module, options), " type mismatch"_view)) + ": "_view) + explainNotAssignable_gDsn(type, guest, _current_fn, ss, ctx, _here, module, options)), becauseOf, _current_fn, ss, ctx, _here, module, options, _helpers);
            };
        };
        return /*NRVO*/ call;
    };
}

static bool tryConvertIfNeeded_gDsn(SolvedNode_efhg& actual, const Type_OiTm& expect, const bool asArgument, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    if (!isAssignable_9CJm(expect, actual.type, false, asArgument, ctx, _here))
    {
        fu::vec<Target_VZrr> conv = tryConvert_GKse(expect, actual.type, _current_fn, ss, ctx, _here, module, options, _helpers);
        if (!conv)
            return false;
        else
            applyConversion_gDsn(actual, conv, _current_fn, ss, ctx, _here, module, options, _helpers);

    };
    if (is_zeroes_9CJm(actual.type.vtype) && !is_zeroes_9CJm(expect.vtype))
        definitWrap_gDsn(actual, expect, ss, ctx, _here, module, options, _helpers);

    return true;
}

static void convertIfNeeded_gDsn(SolvedNode_efhg& actual, const Type_OiTm& expect, fu::view<char> err, const bool asArgument, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    if (!tryConvertIfNeeded_gDsn(actual, expect, asArgument, _current_fn, ss, ctx, _here, module, options, _helpers))
    {
        fail_gDsn((err + explainNotAssignable_gDsn(expect, actual.type, _current_fn, ss, ctx, _here, module, options)), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
    };
}

static SolvedNode_efhg createLetLike_dontTouchScope_gDsn(fu::vec_range<char> id, Flags_Lzg8 flags, /*MOV*/ SolvedNode_efhg&& init, const bool asArgument, const Type_OiTm& annot, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    if (annot || init.type)
    {
        Type_OiTm BL_2_v {};
        /*MOV*/ Type_OiTm t_init = (init ? (__extension__ (
        {
            const bool init_isNever = is_never_9CJm(init.type.vtype);
            Type_OiTm t_init_1 {};
            BL_2_v = (((init_isNever && !(asArgument || (flags & Flags_Lzg8_F_INLINE))) ? (__extension__ (
            {

                {
                    const SolverNotes_LSla note = SolverNotes_LSla_N_DeadLet;
                    if (note & options.break_notes)
                    {
                        fu::view<char> reason = fu::view<char>{};
                        fail_gDsn((("`break_notes`: Unwanted event: "_view + qBAD_e44U(str_kJvr(note))) + (reason ? ("\n\t\t"_view + reason) : fu::str("."_fu))), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                    }
                    else
                        ss._notes |= note;

                };
                return static_cast<SolvedNode_efhg&&>(init);
                (void)0;
            }), fu::unreachable) : ((annot && init.type && !init_isNever && (convertIfNeeded_gDsn(init, annot, "Type annotation does not match initializer: "_view, asArgument, _current_fn, ss, ctx, _here, module, options, _helpers), 0)), ((flags & Flags_Lzg8_F_REF) && ((is_ref_9CJm(init.type) ? ((flags & Flags_Lzg8_F_MUT) && (is_mutref_9CJm(init.type, ctx, _here) || fail_gDsn(((("Init expression is not a "_view + qBAD_e44U("mut"_view)) + " ref: "_view) + explainType_gDsn(init.type, false, true, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers))) : fail_gDsn(((("Init expression is not a "_view + qBAD_e44U("ref"_view)) + ": "_view) + explainType_gDsn(init.type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers)), 0)), t_init_1 = clear_Typename_9CJm(Type_OiTm(init.type), false), (asArgument ? (t_init_1.vtype.vfacts = VFacts_xhRf{}) : ((flags & Flags_Lzg8_F_MUT) && ((t_init_1.vtype.vfacts &= VFacts_xhRf((VFacts_xhRf_LeftAligned | VFacts_xhRf_RightAligned))), 0))), (hasTemporary_7Yz9(t_init_1.lifetime) ? clear_refs_9CJm(static_cast<Type_OiTm&&>(t_init_1)) : static_cast<Type_OiTm&&>(t_init_1)))));
            (void)0;
        }), static_cast<Type_OiTm&&>(BL_2_v)) : Type_OiTm{});
        if (is_mutref_9CJm(annot, ctx, _here))
            flags |= Flags_Lzg8_F_REF;

        Type_OiTm t_let = ((annot && (asArgument || !t_init)) ? Type_OiTm(annot) : ((is_mutref_9CJm(t_init, ctx, _here) && ((flags & (Flags_Lzg8_F_REF | Flags_Lzg8_F_CONST)) != Flags_Lzg8_F_REF)) ? clear_mutref_9CJm(static_cast<Type_OiTm&&>(t_init)) : static_cast<Type_OiTm&&>(t_init)));
        if (asArgument)
        {
            t_let.lifetime = Lifetime_temporary;
        }
        else if (!init && is_sliceable_hxWW(t_let.vtype))
            t_let.vtype.vfacts |= VFacts_xhRf((VFacts_xhRf_LeftAligned | VFacts_xhRf_RightAligned));

        const ValueType_JtNg* type;
        if (is_Typename_9CJm(t_let))
            BUG_gDsn("solveLetLike_dontTouchScope: Ended up with a Typename"_view, ss, ctx, _here, module, options, _helpers);
        else if ((asArgument || (flags & Flags_Lzg8_F_MUT)) && VFacts_xhRf((t_let.vtype.vfacts & VFacts_xhRf((VFacts_xhRf_AlwaysTrue | VFacts_xhRf_AlwaysFalse)))) && (type = &(t_let.vtype), ((*type).quals & q_USAGE)))
            BUG_gDsn("solveLetLike_dontTouchScope: Ended up with an AlwaysTrue/False"_view, ss, ctx, _here, module, options, _helpers);

        return SolvedNode_gDsn(Kind_Idfg_let, t_let, flags, id, fu::vec<SolvedNode_efhg> {{ SolvedNode_efhg{}, static_cast<SolvedNode_efhg&&>(init) }}, Target_VZrr{}, Helpers_DyqV{}, _here);
    }
    else
    {
        fail_gDsn((("Variable declarations without type annotations must be initialized: "_view + qBAD_e44U(id)) + "."_view), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
    };
}

                                #ifndef DEF___I24AQmUq8a5
                                #define DEF___I24AQmUq8a5
inline static void _I24A(const Target_VZrr& target, fu::vec_range<char> id, const bool shadows, SolverState_aGlN& ss)
{
    Scope_set_FjkY(ss._scope.items, id, target, shadows);
}
                                #endif

                                #ifndef DEF_unpackAddrOfFn_l6mQapblSha
                                #define DEF_unpackAddrOfFn_l6mQapblSha
inline void unpackAddrOfFn_l6mQ(fu::view<char> canon, fu::vec_range<char> id, const bool shadows, SolverState_aGlN& ss)
{
    if (canon[0] == '@')
    {
        int offset = 1;
        while (offset < canon.size())
        {
            const Target_VZrr mi = parseLocalOrGlobal_xQNS(canon, offset);
            unsigned v;
            _I24A(Target_xQNS(int(unsigned(((mi._packed >> 40ull) & 0xfffffull))), int(unsigned(((mi._packed >> 20ull) & 0xfffffull))), (v = unsigned((mi._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))))), id, shadows, ss);
        };
    }
    else
        fu::fail((("unpackAddrOfFn: No leading @ in `"_view + canon) + "`."_view));

}
                                #endif

static void Scope_set_gDsn(const Target_VZrr& target, const SolvedNode_efhg& out, const bool setScope, const bool shadows, fu::vec_range<char> id, SolverState_aGlN& ss)
{
    if (!(!setScope))
    {
        Scope_set_z0Qq(ss._scope, id, target, shadows);
        if (out.flags & Flags_Lzg8_F_IMPLICIT)
            Scope_set_FjkY(ss._scope.implicits, id, target, shadows);

        if (out.flags & Flags_Lzg8_F_USING)
        {
            ss._scope.usings.push(Target_VZrr(target));
            remove_mVke(ss._conv_cache, ValueType_JtNg{});
        };
    };
}

static SolvedNode_efhg solveLet_createBindingAndGetLetdef_gDsn(/*MOV*/ SolvedNode_efhg&& out, fu::vec_range<char> id, const bool setScope, const bool isArg, const DeclAsserts_taUG asserts, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (out.kind != Kind_Idfg_let)
    {
        if (is_never_9CJm(out.type.vtype))
            return static_cast<SolvedNode_efhg&&>(out);
        else
            BUG_gDsn((((x7E_rA00("solveLet: results in a `"_view, str_eN8k(out.kind)) + ": "_view) + id) + "`."_view), ss, ctx, _here, module, options, _helpers);

    }
    else
    {
        bool shadows = !!(out.flags & Flags_Lzg8_F_SHADOW);
        fu::vec_range<char> id_1 = ((out.flags & Flags_Lzg8_F_COMPOUND_ID) ? cleanID_V5Iu(id) : id);
        if (isAddrOfFn_9CJm(out.type))
        {
            const bool shadows_1 = true;
            if (setScope)
                unpackAddrOfFn_l6mQ(out.type.vtype.canon, id_1, shadows_1, ss);

        }
        else
        {
            if (!isArg && !(out.flags & (Flags_Lzg8_F_PUB | Flags_Lzg8_F_VAL)))
            {
                const SolvedNode_efhg& init = out.items[LET_INIT];
                if ((init.kind == Kind_Idfg_call) && !init.items)
                {
                    const Target_VZrr& target = init.target;
                    const Overload_aO3i& other = GET_gDsn(target, ss, ctx, _here, module);
                    if ((other.kind == Kind_Idfg_var) && !(other.flags & Flags_Lzg8_F_INLINE) && (DeclAsserts_taUG((other.asserts & asserts)) == asserts))
                    {
                        if (isAssignable_9CJm(other.type, out.type, false, false, ctx, _here))
                        {
                            Scope_set_gDsn(target, out, setScope, shadows, id_1, ss);
                            out = createEmpty_gDsn(t_void, target, ss, ctx, _here, module, options, _helpers);
                            return static_cast<SolvedNode_efhg&&>(out);
                        };
                    };
                };
            };
            const DeclAsserts_taUG refArgAsserts = ((isArg && !(out.flags & Flags_Lzg8_F_VAL)) ? _current_fn.asserts : DeclAsserts_taUG{});
            const Target_VZrr& target = (out.target = Binding_gDsn(id_1, Type_OiTm(out.type), out.flags, DeclAsserts_taUG((asserts | refArgAsserts)), shadows, isArg, _current_fn, ss, ctx, _here, module, options, _helpers));
            if (!hasTemporary_7Yz9(out.type.lifetime) || isArg)
            {
                if (is_Typename_9CJm(out.type))
                    BUG_gDsn("solveLet_createBindingAndGetLetdef: Ended up with a Typename"_view, ss, ctx, _here, module, options, _helpers);

            }
            else
            {
                BUG_gDsn("solveLet_createBindingAndGetLetdef: Non-argument lifetime.hasTemporary"_view, ss, ctx, _here, module, options, _helpers);
            };
            solved_set_FDl5(target, out, ss, module);
            Scope_set_gDsn(target, out, setScope, shadows, id_1, ss);
            return createLetDef_gDsn(target, ss, ctx, _here, module);
        };
        if (isArg)
        {
            if (isAddrOfFn_9CJm(out.type))
                out.type = clear_refs_9CJm(Type_OiTm(out.type));

            return static_cast<SolvedNode_efhg&&>(out);
        }
        else
        {
            return createEmpty_gDsn(t_void, Target_VZrr{}, ss, ctx, _here, module, options, _helpers);
        };
    };
}

static SolvedNode_efhg createLet_gDsn(fu::vec_range<char> id, const Flags_Lzg8 flags, const DeclAsserts_taUG asserts, const SolvedNode_efhg& init, const bool setScope, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    /*MOV*/ SolvedNode_efhg out = createLetLike_dontTouchScope_gDsn(id, flags, SolvedNode_efhg(init), false, (*(Type_OiTm*)fu::NIL), _current_fn, ss, ctx, _here, module, options, _helpers);
    return solveLet_createBindingAndGetLetdef_gDsn(static_cast<SolvedNode_efhg&&>(out), id, setScope, false, asserts, _current_fn, ss, ctx, _here, module, options, _helpers);
}

static Target_VZrr injectForeignLocal_gDsn(const Target_VZrr& target, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (GET_gDsn(target, ss, ctx, _here, module).kind == Kind_Idfg_var)
    {
        const ClosureID_qHEW noClID = tryParseClosureID_UvH3(GET_gDsn(target, ss, ctx, _here, module).name, ctx, _here);
        if (noClID)
            BUG_gDsn(x7E_rA00("injectForeignLocal: Unexpected closure-id: "_view, str_FDl5(noClID.target, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

    }
    else
        BUG_gDsn(x7E_rA00("injectForeignLocal: trying to inject a non-var: "_view, str_FDl5(target, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

    if (GET_gDsn(target, ss, ctx, _here, module).flags & Flags_Lzg8_F_IMPLICIT)
        return injectImplicitArg_gDsn(fu::str(GET_gDsn(target, ss, ctx, _here, module).name), Type_OiTm(GET_gDsn(target, ss, ctx, _here, module).type), target, _current_fn, ss, ctx, _here, module, options, _helpers);
    else
    {
        unsigned _0;
        const ClosureID_qHEW clID = ClosureID_qHEW { Target_VZrr(target), ((_0 = EPH_gDsn(parent_gDsn(target, ctx, _here), ss, module).revision) ? _0 : BUG_gDsn(x7E_rA00("injectForeignLocal: About to serialize at rev 0: "_view, str_FDl5(target, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers)) };
        return injectImplicitArg_gDsn(serialize_UvH3(clID, ctx, _here), Type_OiTm(GET_gDsn(target, ss, ctx, _here, module).type), target, _current_fn, ss, ctx, _here, module, options, _helpers);
    };
}

static Target_VZrr matchReplicaOrInjectForeignLocal_gDsn(const Target_VZrr& target, const Type_OiTm& slot, const Target_VZrr& from, fu::view_mut<SolvedNode_efhg> callsite_args, const Map_iaWx& letdefReplicas, const int minLocalIdx, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    const Target_VZrr& replica = get_17MG(letdefReplicas, target);
    if (replica)
        return replica;
    else
    {
        const Target_VZrr parent = parent_gDsn(target, ctx, _here);
        if (parent == _current_fn.out.target)
        {
            unsigned v;
            if ((v = unsigned((target._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))) < minLocalIdx)
                return target;
            else
                BUG_gDsn(x7E_rA00("Missing a local replica for: "_view, str_FDl5(target, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

        }
        else
        {
            const Overload_aO3i& o = GET_gDsn(target, ss, ctx, _here, module);
            if (o.flags & Flags_Lzg8_F_IMPLICIT)
                return bindImplicitArg_gDsn(fu::str(o.name), Type_OiTm((slot ? slot : o.type)), target, _current_fn, ss, ctx, _here, module, options, _helpers).target;
            else if (int(unsigned(((from._packed >> 40ull) & 0xfffffull))) != module.modid)
                BUG_gDsn(x7E_rA00("inlineExpression: about to use injectForeignLocal with an off-module target: "_view, str_FDl5(target, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);
            else
            {
                if ((parent == from) && callsite_args)
                { {
                    unsigned v;
                    if ((v = unsigned((target._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))) < 0)
                    {
                        fu::view<Argument_bbKc> a = EXT_gDsn(parent, ss, ctx, module).args;
                        for (int i = 0; i < a.size(); i++)
                        {
                            const Argument_bbKc& host_arg = a[i];
                            const int i_1 = i;
                            if (host_arg.target == target)
                            {
                                if (callsite_args.size() < i_1)
                                    goto BL_10;
                                else
                                {
                                    SolvedNode_efhg& arg = callsite_args.mutref(i_1);
                                    const Target_VZrr& replacement = ((((arg.kind == Kind_Idfg_call) && (GET_gDsn(arg.target, ss, ctx, _here, module).kind == Kind_Idfg_var)) || (arg.kind == Kind_Idfg_letdef)) ? arg.target : (arg = createLet_gDsn(str_x5wTngZiZL0, Flags_Lzg8{}, DeclAsserts_taUG{}, arg, false, _current_fn, ss, ctx, _here, module, options, _helpers)).target);
                                    return replacement;
                                };
                            };
                        };
                    }
                    else
                        BUG_gDsn((x7E_rA00((x7E_rA00((x7E_rA00("inlineExpression callsite_args("_view, fu::i64dec(callsite_args.size())) + ") observing a non-F_ARG local("_view), str_FDl5(target, false, ss, ctx, _here, module, options)) + ") from("_view), str_FDl5(from, false, ss, ctx, _here, module, options)) + ")"_view), ss, ctx, _here, module, options, _helpers);

                  } BL_10:;
                };
                return injectForeignLocal_gDsn(target, _current_fn, ss, ctx, _here, module, options, _helpers);
            };
        };
    };
}

static Flags_Lzg8 isInlineLocal_gDsn(const Target_VZrr& t, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    unsigned v;
    if (!((v = unsigned((t._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))) < 0))
        return GET_gDsn(t, ss, ctx, _here, module).flags & Flags_Lzg8_F_INLINE;
    else
    {
        return Flags_Lzg8{};
    };
}

static const Type_OiTm& Lifetime_climbType_gDsn(const Target_VZrr& t, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    unsigned v;
    if ((v = unsigned((t._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))) < 0)
        return (*(Type_OiTm*)fu::NIL);
    else
    {
        const Overload_aO3i& o = GET_gDsn(t, ss, ctx, _here, module);
        if (o.kind == Kind_Idfg_var)
        {
            const SolvedNode_efhg& node = o.solved;
            if (is_ref_9CJm(node.type))
                return node.items[LET_INIT].type;
            else
                return (*(Type_OiTm*)fu::NIL);

        }
        else
        {
            BUG_gDsn("Lifetime_climbType: not a var"_view, ss, ctx, _here, module, options, _helpers);
        };
    };
}

static bool Lifetime_allowsMutrefReturn_gDsn(const Lifetime_llCF& lifetime, const int locals_start, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{

    { {
        fu::view<char> chars = lifetime.uni0n;
        int offset = 0;
        while (offset < chars.size())
        {
            const unsigned r = parse7bit_7Yz9(chars, offset);
            for (; ; )
            {
                bool isLastPath = false;
                bool isFirstSubRegion = true;
                for (; ; )
                {
                    const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                    isLastPath = !(raw_flatCount & 1u);
                    if (isLastSubRegion)
                        break;
                    else
                        isFirstSubRegion = false;

                };
                if (isLastPath)
                    break;

            };
            unsigned v;
            const int locid = ((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))));
            if (!(!locid))
            {
                if (locid < locals_start)
                    goto BL_1;
                else
                {
                    const Target_VZrr t = nested_FDl5(locid, ss, ctx, _here);
                    const Overload_aO3i& o = GET_gDsn(t, ss, ctx, _here, module);
                    if ((o.kind == Kind_Idfg_var) && is_mutref_9CJm(o.type, ctx, _here))
                    {
                        if (!(o.flags & Flags_Lzg8_F_REF))
                            return false;
                        else
                        {
                            const Type_OiTm& init = Lifetime_climbType_gDsn(t, ss, ctx, _here, module, options, _helpers);
                            if (!Lifetime_allowsMutrefReturn_gDsn(init.lifetime, locals_start, ss, ctx, _here, module, options, _helpers))
                                return false;

                        };
                    }
                    else
                    {
                        BUG_gDsn(x7E_rA00("Lifetime_allowsMutrefReturn: found non-mutref: "_view, str_FDl5(t, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);
                    };
                };
            };
        };
      } BL_1:;
    };
    return true;
}

static Type_OiTm superType_neverOK_gDsn(fu::view<char> reason, const Type_OiTm& a, const Type_OiTm& b, const Target_VZrr& target, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (is_never_9CJm(a.vtype))
        return Type_OiTm(b);
    else if (is_never_9CJm(b.vtype))
        return Type_OiTm(a);
    else
        return superType_gDsn(reason, a, b, target, ss, ctx, _here, module, options, _helpers);

}

static void reportReturnType_gDsn(const Helpers_DyqV& h, const Type_OiTm& type, const bool NICEERR_missingReturn, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    /*MOV*/ Type_OiTm type_1 = ((is_mutref_9CJm(type, ctx, _here) && !Lifetime_allowsMutrefReturn_gDsn(type.lifetime, (((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).locals_start, ss, ctx, _here, module, options, _helpers)) ? clear_mutref_9CJm(Type_OiTm(type)) : Type_OiTm(type));
    /*MOV*/ Type_OiTm type_2 = (hasTemporary_7Yz9(type_1.lifetime) ? clear_refs_9CJm(static_cast<Type_OiTm&&>(type_1)) : static_cast<Type_OiTm&&>(type_1));
    if ((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).ret_expect)
    {
        const Type_OiTm& host = (((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).ret_expect;
        const bool asArgument = false;
        if (!(isAssignable_9CJm(host, type_2, false, asArgument, ctx, _here)))
        {
            fail_gDsn((((fu::str{} + (NICEERR_missingReturn ? x7E_rA00(str_FDl5((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).target, false, ss, ctx, _here, module, options), " is missing a final return statement"_view) : (HelpersMask_w1sv(((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).mask & HelpersMask_w1sv_HM_Function)) ? x7E_rA00(str_FDl5((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).target, false, ss, ctx, _here, module, options), ": return type does not match annotation"_view) : fu::str(str_qJhjdVVOTZ0)))) + ": "_view) + explainNotAssignable_gDsn(host, type_2, _current_fn, ss, ctx, _here, module, options)), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
        };
    };
    (((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data.mutref(h.index) : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).ret_actual = ((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).ret_actual ? superType_neverOK_gDsn((NICEERR_missingReturn ? " is missing a final return statement: "_view : "Subsequent return: "_view), (((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).ret_actual, type_2, (NICEERR_missingReturn ? (((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).target : (*(Target_VZrr*)fu::NIL)), ss, ctx, _here, module, options, _helpers) : static_cast<Type_OiTm&&>(type_2));
    if (!((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).ret_actual))
        BUG_gDsn("reportReturnType: no ret_actual."_view, ss, ctx, _here, module, options, _helpers);

}

static SolvedNode_efhg createJump_gDsn(const Helpers_DyqV& h, const SolvedNode_efhg& expr, const TokenIdx_5581& _here)
{
    return SolvedNode_gDsn(Kind_Idfg_jump, t_never, Flags_Lzg8{}, (*(fu::str*)fu::NIL), fu::vec<SolvedNode_efhg> {{ SolvedNode_efhg(expr) }}, Target_VZrr{}, h, _here);
}

static SolvedNode_efhg solveJump_finish_gDsn(const Flags_Lzg8 flags, const SolvedNode_efhg& expr, const Helpers_DyqV& h, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    (((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data.mutref(h.index) : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).mask |= HelpersMask_w1sv_HM_LabelUsed;
    reportReturnType_gDsn(h, expr.type, !!(flags & Flags_Lzg8_F_IMPLICIT), _current_fn, ss, ctx, _here, module, options, _helpers);
    return createJump_gDsn(h, expr, _here);
}

                                #ifndef DEF_add_q7BeXLo3Yld
                                #define DEF_add_q7BeXLo3Yld
inline bool add_q7Be(Set_qOJY& _, const int key)
{
    fu::view<int> keys_asc = _.keys_asc;
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_odNT(keys_asc[i], key);
        if (cmp == 0)
            return false;
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    const int i = lo;
    _.keys_asc.insert(i, key);
    return true;
}
                                #endif

                                #ifndef DEF_visit_0hZ05km6FYk
                                #define DEF_visit_0hZ05km6FYk
inline static void visit_0hZ0(const Lifetime_llCF& lifetime, Lifetime_llCF& result, bool& maybeOutOfOrder, const Target_VZrr& from, fu::view_mut<SolvedNode_efhg> callsite_args, const Map_iaWx& letdefReplicas, const int minLocalIdx, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    const fu::str& chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const int offset0 = offset;

        {
            const unsigned r = parse7bit_7Yz9(chars, offset);
            int offset0_1;
            int BL_4_v;
            const int sr = (__extension__ (
            {
                offset0_1 = (offset + 0);
                for (; ; )
                {
                    bool isLastPath = false;
                    bool isFirstSubRegion = true;
                    for (; ; )
                    {
                        const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                        const bool isLastSubRegion = !(raw_flatOffset & 1u);
                        const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                        isLastPath = !(raw_flatCount & 1u);
                        if (isLastSubRegion)
                            break;
                        else
                            isFirstSubRegion = false;

                    };
                    if (isLastPath)
                        break;

                };
                BL_4_v = (offset0_1);
                (void)0;
            }), BL_4_v);
            unsigned v;
            const int index = ((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))));
            fu::view<char> paths = fu::get_view(chars, sr, offset);
            if (!(!index))
            {
                const Target_VZrr foreign = nested_gDsn(index, from, ctx, _here);
                const Target_VZrr local = matchReplicaOrInjectForeignLocal_gDsn(foreign, (*(Type_OiTm*)fu::NIL), from, callsite_args, letdefReplicas, minLocalIdx, _current_fn, ss, ctx, _here, module, options, _helpers);
                Lifetime_llCF replacement = (GET_gDsn(local, ss, ctx, _here, module).type.lifetime ? Lifetime_op_join_7Yz9(GET_gDsn(local, ss, ctx, _here, module).type.lifetime, paths, ctx, _here) : BUG_gDsn("visitType: !local.type.lifetime"_view, ss, ctx, _here, module, options, _helpers));
                maybeOutOfOrder = true;
                Lifetime_add_7Yz9(result, replacement, false, ctx, _here);
                continue;
            };
        };
        if (maybeOutOfOrder)
        {
            result = Lifetime_union_7Yz9(result, Lifetime_llCF { fu::str(fu::get_range(chars, offset0, offset)) }, false, ctx, _here);
        }
        else
            result.uni0n += fu::get_view(chars, offset0, offset);

    };
}
                                #endif

                                #ifndef DEF_Lifetime_process_swMsTtG3Zb4
                                #define DEF_Lifetime_process_swMsTtG3Zb4
inline Lifetime_llCF Lifetime_process_swMs(const Lifetime_llCF& lifetime, const Target_VZrr& from, fu::view_mut<SolvedNode_efhg> callsite_args, const Map_iaWx& letdefReplicas, const int minLocalIdx, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    /*MOV*/ Lifetime_llCF result {};
    bool maybeOutOfOrder = false;
    visit_0hZ0(lifetime, result, maybeOutOfOrder, from, callsite_args, letdefReplicas, minLocalIdx, _current_fn, ss, ctx, _here, module, options, _helpers);
    return /*NRVO*/ result;
}
                                #endif

static void visitType_gDsn(Type_OiTm& type, const Target_VZrr& from, fu::view_mut<SolvedNode_efhg> callsite_args, const Map_iaWx& letdefReplicas, const int minLocalIdx, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    type.lifetime = Lifetime_process_swMs(type.lifetime, from, callsite_args, letdefReplicas, minLocalIdx, _current_fn, ss, ctx, _here, module, options, _helpers);
}

static void visitNode_gDsn(SolvedNode_efhg& node, const int locals_start, const Target_VZrr& from, fu::view_mut<SolvedNode_efhg> callsite_args, Map_iaWx& letdefReplicas, const Target_VZrr& now_inlining, const int minLocalIdx, fu::vec<Helpers_DyqV>& helpersReplicas, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    if ((node.kind == Kind_Idfg_block) || (node.kind == Kind_Idfg_loop))
    {
        const Helpers_DyqV& foreign = node.helpers;
        if (foreign)
        {
            const int locals_start_1 = (locals_start ? locals_start : GET_next_local_index_gDsn(_current_fn, ss, ctx, _here));
            const Target_VZrr* t;
            const Helpers_DyqV local = push_gDsn(HelpersReplica_gDsn((t = &(_current_fn.out.target), int(unsigned((((*t)._packed >> 20ull) & 0xfffffull)))), locals_start_1, node.type), ss, _helpers);
            ensure_fmAX(helpersReplicas, foreign.index) = Helpers_DyqV((local ? local : BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers)));
            node.helpers = local;
        };
    };

    {
        int rest = 0;
        if ((node.kind == Kind_Idfg_if) || (node.kind == Kind_Idfg_and) || (node.kind == Kind_Idfg_or))
        {
            rest = ((node.kind == Kind_Idfg_if) ? 1 : (node.items.size() - 1));
            for (int i = 0; i < rest; i++)
            {
                SolvedNode_efhg& item = node.items.mutref(i);
                visitNode_gDsn(item, 0, from, callsite_args, letdefReplicas, now_inlining, minLocalIdx, helpersReplicas, _current_fn, ss, ctx, _here, module, options, _helpers);
                const StaticEval_IZio ae = tryAbstractEvalAsBool_gDsn(item, false, _current_fn, ss, ctx, _here, module, options, _helpers);
                if (ae)
                {
                    if (((ae == StaticEval_IZio_SE_True) && (node.kind != Kind_Idfg_and)) || ((ae == StaticEval_IZio_SE_False) && (node.kind != Kind_Idfg_or)))
                    {
                        if (node.kind == Kind_Idfg_if)
                        {
                            node.kind = Kind_Idfg_block;
                            remove_yIeD(node.items, ((ae == StaticEval_IZio_SE_True) ? 2 : 1), 1);
                        }
                        else if (!i)
                        {
                            node = steal_bX67(item);
                            return;
                        }
                        else
                            node.items.shrink((rest = (i + 1)));

                        break;
                    };
                };
            };
        };
        bool children_someNever = false;
        for (int i = rest; i < node.items.size(); i++)
        {
            SolvedNode_efhg& item = node.items.mutref(i);
            visitNode_gDsn(item, 0, from, callsite_args, letdefReplicas, now_inlining, minLocalIdx, helpersReplicas, _current_fn, ss, ctx, _here, module, options, _helpers);
            if (is_never_9CJm(item.type.vtype))
            {
                children_someNever = true;
                if ((node.kind == Kind_Idfg_and) || (node.kind == Kind_Idfg_or) || (node.kind == Kind_Idfg_block))
                {
                    node.items.shrink((i + 1));
                    break;
                }
                else if ((node.kind == Kind_Idfg_not) || ((node.kind == Kind_Idfg_if) && (i == 0)))
                {
                    node = item;
                    break;
                };
            };
        };
        if (children_someNever && (node.kind == Kind_Idfg_call))
        {
            const bool RTL = isRTL_xQNS(GET_gDsn(node.target, ss, ctx, _here, module));
            fu::view<Argument_bbKc> host_args = EXT_gDsn(node.target, ss, ctx, module).args;
            fu::vec<SolvedNode_efhg> block {};

            { {

                {
                    const int seqIdx_start = 0;
                    int seqIdx = 0;
                    int lastPass = 1;
                    for (int pass = 0; pass < lastPass; pass++)
                    {
                        for (int i_1 = 0; i_1 < host_args.size(); i_1++)
                        {
                            const Argument_bbKc& host_arg = host_args[i_1];
                            if (!!pass != (RTL ? !i_1 : !!((host_arg.flags & Flags_Lzg8_F_IMPLICIT) || is_mutref_9CJm(host_arg.type, ctx, _here))))
                                lastPass = 2;
                            else
                            {
                                if ((seqIdx_start <= seqIdx))
                                {
                                    const int i_2 = i_1;
                                    const SolvedNode_efhg& item = node.items[i_2];
                                    const bool discard_rest = is_never_9CJm(item.type.vtype);
                                    block += SolvedNode_efhg(item);
                                    if (discard_rest)
                                        goto BL_18;

                                };
                                seqIdx++;
                            };
                        };
                    };
                };
                BUG_gDsn("visitNode(call): !FOUND_NEVER"_view, ss, ctx, _here, module, options, _helpers);
              } BL_18:;
            };
            node = createBlock_gDsn(t_never, block, Helpers_DyqV{}, _here);
        };
    };
    if (node.kind == Kind_Idfg_letdef)
    {
        const Overload_aO3i* __partcopy_ref;
        /*MOV*/ Overload_aO3i foreign = (__partcopy_ref = &(GET_gDsn(node.target, ss, ctx, _here, module)), Overload_aO3i { (*__partcopy_ref).kind, (*__partcopy_ref).flags, (*__partcopy_ref).status, {/*unused non-zst*/}, fu::str((*__partcopy_ref).name), Type_OiTm((*__partcopy_ref).type), SolvedNode_efhg((*__partcopy_ref).solved) });
        const Target_VZrr* t;
        const Target_VZrr local = Scope_create_z0Qq(ss._scope, Kind_Idfg___no_kind_yet, (*(fu::str*)fu::NIL), (*(Type_OiTm*)fu::NIL), Flags_Lzg8{}, DeclAsserts_taUG{}, SolverStatus_h9em{}, (t = &(_current_fn.out.target), int(unsigned((((*t)._packed >> 20ull) & 0xfffffull)))), false, module);
        set_5Vx3(letdefReplicas, node.target, (local ? local : BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers)));
        /*MOV*/ Type_OiTm type = foreign.type;
        if (isStaticOrZeroes_7Yz9(type.lifetime))
        {
            if (!(is_zst_1qjp(type.vtype, ctx, _here, module)))
            {
                BUG_gDsn(x7E_rA00("Unexpected static lifetime on "_view, str_FDl5(node.target, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);
            };
        }
        else
        {
            const int flatCount = getFlatCount_1qjp(type.vtype, ctx, _here, module);
            TEST_LifetimeEqual_gDsn(type.lifetime, "foreign.type.lifetime"_view, Lifetime_fromBinding_gDsn(node.target, flatCount, ss, ctx, _here, module, options, _helpers), "Lifetime_fromBinding"_view, ss, ctx, _here, module, options, _helpers);
            type.lifetime = Lifetime_fromBinding_gDsn(local, flatCount, ss, ctx, _here, module, options, _helpers);
        };
        /*MOV*/ SolvedNode_efhg solved = foreign.solved;
        if ((solved.kind == Kind_Idfg_let) && (solved.target == node.target))
        {
            solved.target = local;
            visitNode_gDsn(solved, 0, from, callsite_args, letdefReplicas, now_inlining, minLocalIdx, helpersReplicas, _current_fn, ss, ctx, _here, module, options, _helpers);
            GET_mut_gDsn(local, ss, module) = Overload_aO3i { foreign.kind, foreign.flags, SolverStatus_h9em((foreign.status & SolverStatus_h9em_SS_MATCHED)), DeclAsserts_taUG{}, static_cast<fu::str&&>(foreign.name), static_cast<Type_OiTm&&>(type), static_cast<SolvedNode_efhg&&>(solved) };
            node.target = local;
        }
        else
        {
            BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers);
        };
    }
    else if (node.kind == Kind_Idfg_call)
    {
        if (isLocal_gDsn(node.target))
        {
            const Target_VZrr local = matchReplicaOrInjectForeignLocal_gDsn(node.target, node.type, from, callsite_args, letdefReplicas, minLocalIdx, _current_fn, ss, ctx, _here, module, options, _helpers);

            {
                const Target_VZrr& foreign = node.target;
                if (!(isAssignable_9CJm(GET_gDsn(foreign, ss, ctx, _here, module).type, GET_gDsn(local, ss, ctx, _here, module).type, false, false, ctx, _here) || (is_never_9CJm(GET_gDsn(local, ss, ctx, _here, module).type.vtype) && isInlineLocal_gDsn(local, ss, ctx, _here, module))))
                    BUG_gDsn((((((x7E_rA00("matchReplicaOrInjectForeignLocal botching the type of "_view, str_FDl5(foreign, false, ss, ctx, _here, module, options)) + ":\n"_view) + "\n\t\tExpect: "_view) + explainType_gDsn(GET_gDsn(foreign, ss, ctx, _here, module).type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)) + "\n\t\tActual: "_view) + explainType_gDsn(GET_gDsn(local, ss, ctx, _here, module).type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

            };
            node.target = local;
            if (isLocal_gDsn(local))
                GET_mut_gDsn(local, ss, module).status |= SolverStatus_h9em_SS_MATCHED;

            node.type.vtype.vfacts = GET_gDsn(local, ss, ctx, _here, module).type.vtype.vfacts;
            if (isInlineLocal_gDsn(local, ss, ctx, _here, module))
            {
                if (GET_gDsn(local, ss, ctx, _here, module).status & SolverStatus_h9em_SS_NAME_UNUSED)
                {
                    fail_gDsn(str_3guUkNyDiR9, fu::view<char>{}, TokenIdx_5581(node.token), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                }
                else
                {
                    Overload_aO3i& o = GET_mut_gDsn(local, ss, module);
                    o.status |= SolverStatus_h9em_SS_NAME_UNUSED;
                    const SolvedNode_efhg& init = o.solved.items[LET_INIT];
                    if (is_never_9CJm(init.type.vtype))
                    {
                        node = init;
                        return;
                    }
                    else
                    {
                        node = createLetDef_gDsn(local, ss, ctx, _here, module);
                        return;
                    };
                };
            };
        }
        else if ((node.target == now_inlining) || has_bkvR(_current_fn.already_inlined, node.target))
        {
            fail_gDsn(x7E_rA00("Cannot inline self-recursive fns: "_view, str_FDl5(node.target, false, ss, ctx, _here, module, options)), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
        };
    }
    else if ((node.kind == Kind_Idfg_jump) || (node.kind == Kind_Idfg___far_jump))
    { {
        if (node.kind == Kind_Idfg_jump)
        {
            const Helpers_DyqV& foreign = node.helpers;
            const Helpers_DyqV& local = iF_uWIt(helpersReplicas, foreign.index);
            if (local)
            {
                node.helpers = local;
                (((local.index >= 0) && (local.index < ss._helpers_data.size())) ? ss._helpers_data.mutref(local.index) : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).mask |= HelpersMask_w1sv_HM_LabelUsed;
                goto BL_45;
            }
            else
                node.kind = Kind_Idfg___far_jump;

        };
        const Helpers_DyqV* h;
        const Target_VZrr* t;
        if ((h = &(node.helpers), ((((*h).index >= 0) && ((*h).index < ss._helpers_data.size())) ? ss._helpers_data[(*h).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).local_of == (t = &(_current_fn.out.target), int(unsigned((((*t)._packed >> 20ull) & 0xfffffull)))))
        {
            const TokenIdx_5581 here0 = _here;
            _here = node.token;
            node = solveJump_finish_gDsn(node.flags, only_S4ER(node.items), node.helpers, _current_fn, ss, ctx, _here, module, options, _helpers);
            _here = here0;
        }
        else
        {
            const Helpers_DyqV* h_1;
            add_q7Be(_current_fn.far_jumps, (h_1 = &(node.helpers), ((((*h_1).index >= 0) && ((*h_1).index < ss._helpers_data.size())) ? ss._helpers_data[(*h_1).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).local_of);
        };
      } BL_45:;
    }
    else if (node.kind == Kind_Idfg_unwrap)
    {
        if (!node.target)
        {
            node.target = from;
            node.token = _here;
        };
    };
    visitType_gDsn(node.type, from, callsite_args, letdefReplicas, minLocalIdx, _current_fn, ss, ctx, _here, module, options, _helpers);
    if (node.helpers)
    {
        if ((node.kind == Kind_Idfg_block) || (node.kind == Kind_Idfg_loop))
        {
            const Helpers_DyqV* h;
            if ((h = &(node.helpers), ((((*h).index >= 0) && ((*h).index < ss._helpers_data.size())) ? ss._helpers_data[(*h).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).ret_actual)
            {
                Type_OiTm ret_actual {};
                const Helpers_DyqV* h_1;
                std::swap(ret_actual, (h_1 = &(node.helpers), ((((*h_1).index >= 0) && ((*h_1).index < ss._helpers_data.size())) ? ss._helpers_data.mutref((*h_1).index) : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).ret_actual);
                visitType_gDsn(ret_actual, from, callsite_args, letdefReplicas, minLocalIdx, _current_fn, ss, ctx, _here, module, options, _helpers);
                const Helpers_DyqV* h_2;
                std::swap(ret_actual, (h_2 = &(node.helpers), ((((*h_2).index >= 0) && ((*h_2).index < ss._helpers_data.size())) ? ss._helpers_data.mutref((*h_2).index) : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).ret_actual);
            };
        }
        else if ((node.kind != Kind_Idfg_jump) && (node.kind != Kind_Idfg___far_jump))
            BUG_gDsn(x7E_rA00("inlineExpression: TODO handle .helpers on a "_view, str_eN8k(node.kind)), ss, ctx, _here, module, options, _helpers);

    };
}

static SolvedNode_efhg inlineExpression_gDsn(const Target_VZrr& from, /*MOV*/ SolvedNode_efhg&& node, fu::view_mut<SolvedNode_efhg> callsite_args, Map_iaWx&& letdefReplicas, const int locals_start, const Target_VZrr& now_inlining, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    if (from)
    {
        const int helpers0 = _helpers.size();
        fu_DEFER(_helpers.shrink(helpers0));
        const int minLocalIdx = GET_next_local_index_gDsn(_current_fn, ss, ctx, _here);
        fu::vec<Helpers_DyqV> helpersReplicas {};
        visitNode_gDsn(node, locals_start, from, callsite_args, letdefReplicas, now_inlining, minLocalIdx, helpersReplicas, _current_fn, ss, ctx, _here, module, options, _helpers);
        return static_cast<SolvedNode_efhg&&>(node);
    }
    else
        BUG_gDsn("TODO inlining from global scope, never happened before, might work, remove assert as needed."_view, ss, ctx, _here, module, options, _helpers);

}

                                #ifndef DEF_argsForward_gOVxWP0nEmk
                                #define DEF_argsForward_gOVxWP0nEmk
inline void argsForward_gOVx(const bool RTL, fu::view<Argument_bbKc> host_args, const int seqIdx_start, const int i, fu::vec<SolvedNode_efhg>& ooe, fu::view<SolvedNode_efhg> args, const Context_noPA& ctx, const TokenIdx_5581& _here)
{
    int seqIdx = 0;
    int lastPass = 1;
    for (int pass = 0; pass < lastPass; pass++)
    {
        for (int i_1 = 0; i_1 < host_args.size(); i_1++)
        {
            const Argument_bbKc& host_arg = host_args[i_1];
            if (!!pass != (RTL ? !i_1 : !!((host_arg.flags & Flags_Lzg8_F_IMPLICIT) || is_mutref_9CJm(host_arg.type, ctx, _here))))
                lastPass = 2;
            else
            {
                if ((seqIdx_start <= seqIdx))
                {
                    const int j = i_1;
                    ooe += SolvedNode_efhg(args[j]);
                    if (i == j)
                        return;

                };
                seqIdx++;
            };
        };
    };
}
                                #endif

                                #ifndef DEF_only_krrBq6WXGO0
                                #define DEF_only_krrBq6WXGO0
inline SolvedNode_efhg& only_krrB(fu::view_mut<SolvedNode_efhg> a)
{
    fu_ASSERT((a.size() == 1));
    return a.mutref(0);
}
                                #endif

                                #ifndef DEF___ao0mmLYsgPb
                                #define DEF___ao0mmLYsgPb
inline static bool _ao0m(const int locid, const bool isStatic, const bool staticOK, const int expect)
{
    return (locid ? (!expect || (locid == expect)) : false) || (!isStatic ? isStatic : staticOK);
}
                                #endif

                                #ifndef DEF_Lifetime_if_only_QhtZXHC7GA7
                                #define DEF_Lifetime_if_only_QhtZXHC7GA7
inline bool Lifetime_if_only_QhtZ(const Lifetime_llCF& lifetime, const bool staticOK, const int expect)
{

    {
        fu::view<char> chars = lifetime.uni0n;
        int offset = 0;
        while (offset < chars.size())
        {
            const int offset0 = offset;
            const unsigned r = parse7bit_7Yz9(chars, offset);
            for (; ; )
            {
                bool isLastPath = false;
                bool isFirstSubRegion = true;
                for (; ; )
                {
                    const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                    isLastPath = !(raw_flatCount & 1u);
                    if (isLastSubRegion)
                        break;
                    else
                        isFirstSubRegion = false;

                };
                if (isLastPath)
                    break;

            };
            const bool isOnly = (!offset0 ? (offset == chars.size()) : false);
            unsigned v;
            const int locid = ((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))));
            const bool isStatic = ((r & 11u) == 1u);
            if (isOnly)
                return _ao0m(locid, isStatic, staticOK, expect);
            else
                return false;

        };
    };
    return false;
}
                                #endif

static void TEST_varLifetime_gDsn(const Lifetime_llCF& lifetime, const bool staticOK, const int expect, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (!Lifetime_if_only_QhtZ(lifetime, staticOK, expect))
    {
        BUG_gDsn(x7E_rA00("Bad local lifetime: "_view, str_gDsn(lifetime, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);
    };
}

static int localOf_gDsn(const Target_VZrr& target, const SolverState_aGlN& ss, const Module_wo7O& module)
{
    if (isLocal_gDsn(target))
        return int(unsigned(((target._packed >> 20ull) & 0xfffffull)));
    else
        return EPH_gDsn(target, ss, module).local_of;

}

                                #ifndef DEF_bfind_wHLVJYLEh47
                                #define DEF_bfind_wHLVJYLEh47
inline static int bfind_wHLV(fu::view<int> keys_asc, const int key, Set_qOJY& _, const int key_1, fu::vec_range_mut<int> values)
{
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_odNT(keys_asc[i], key);
        if (cmp == 0)
            return i;
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    const int i = lo;
    values.insert(i, 0);
    _.keys_asc.insert(i, key_1);
    return i;
}
                                #endif

                                #ifndef DEF_ref_8rDETTl4uFd
                                #define DEF_ref_8rDETTl4uFd
inline int& ref_8rDE(Set_qOJY& _, const int key, fu::vec_range_mut<int> values)
{
    const int idx = bfind_wHLV(_.keys_asc, key, _, key, values);
    return values.mutref(idx);
}
                                #endif

                                #ifndef DEF_ref_VgTwjm7ZQD1
                                #define DEF_ref_VgTwjm7ZQD1
inline int& ref_VgTw(Map_99Lz& _, const int key)
{
    return ref_8rDE(_.keys, key, _.vals);
}
                                #endif

                                #ifndef DEF_incr_Sn2eXuJ0jLg
                                #define DEF_incr_Sn2eXuJ0jLg
inline bool incr_Sn2e(CountedSet_C7kV& _, const int key)
{
    if (ref_VgTw(_.counts, key)++)
        return false;
    else
        return true;

}
                                #endif

static void detectRecursion_gDsn(const Target_VZrr& target, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const Overload_aO3i& overload = GET_gDsn(target, ss, ctx, _here, module);
    if (!(SolverStatus_h9em((overload.status & SolverStatus_h9em((SolverStatus_h9em_SS_FINALIZED | SolverStatus_h9em_SS_LAZY)))) != SolverStatus_h9em_SS_LAZY))
    {
        const SolverNotes_LSla note = ((overload.kind == Kind_Idfg_type) ? SolverNotes_LSla_N_TypeRecursion : SolverNotes_LSla_N_FnRecursion);
        const SolverStatus_h9em status = ((overload.kind == Kind_Idfg_type) ? SolverStatus_h9em_SS_TYPE_RECUR : SolverStatus_h9em_SS_FN_RECUR);
        for (int i = _helpers.size(); i-- > 0; )
        {
            const Helpers_DyqV& h = _helpers[i];
            if (!(!isFnOrType_gDsn(h, ss, ctx, _here)))
            {
                GET_mut_gDsn((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).target, ss, module).status |= status;
                if (note & options.break_notes)
                {
                    fu::view<char> reason = fu::view<char>{};
                    fail_gDsn((("`break_notes`: Unwanted event: "_view + qBAD_e44U(str_kJvr(note))) + (reason ? ("\n\t\t"_view + reason) : fu::str("."_fu))), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                }
                else
                    ss._notes |= note;

                if ((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).target == target)
                    return;

            };
        };
        BUG_gDsn((x7E_rA00((("detectRecursion: no _helpers entry for `"_view + overload.name) + " ("_view), str_VyKZ(overload.status)) + ")`."_view), ss, ctx, _here, module, options, _helpers);
    };
}

                                #ifndef DEF___3ezrT9L6Jxl
                                #define DEF___3ezrT9L6Jxl
inline static void _3ezr(const int i, fu::view<SolvedNode_efhg> args, fu::vec<SolvedNode_efhg>& argdefs, Map_iaWx& letdefReplicas, const unsigned revision, fu::view<Argument_bbKc> host_args, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    const Argument_bbKc& host_arg = host_args[i];
    if (!(!host_arg.target))
    {
        SolvedNode_efhg argdef = createLet_gDsn(serialize_UvH3(ClosureID_qHEW { Target_VZrr(host_arg.target), revision }, ctx, _here), ((host_arg.flags & ~Flags_Lzg8_F_COMPOUND_ID) | Flags_Lzg8_F_LAX), GET_gDsn(host_arg.target, ss, ctx, _here, module).asserts, args[i], false, _current_fn, ss, ctx, _here, module, options, _helpers);
        if ((argdef.kind == Kind_Idfg_empty) || (argdef.kind == Kind_Idfg_letdef))
        {
            if (!(argdef.target))
                BUG_gDsn(x7E_rA00("Inliner: no argdef.target: "_view, str_iUdw(argdef, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

        }
        else
            BUG_gDsn(x7E_rA00("Inliner: argdef neither letdef nor empty: "_view, str_iUdw(argdef, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

        if ((argdef.kind != Kind_Idfg_empty) && !(GET_gDsn(argdef.target, ss, ctx, _here, module).flags & Flags_Lzg8_F_INLINE))
            argdefs += SolvedNode_efhg(argdef);

        const Target_VZrr& foreign = host_arg.target;
        set_5Vx3(letdefReplicas, foreign, (argdef.target ? argdef.target : BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers)));
        if (!(isAssignable_9CJm(GET_gDsn(foreign, ss, ctx, _here, module).type, GET_gDsn(argdef.target, ss, ctx, _here, module).type, false, false, ctx, _here) || (is_never_9CJm(GET_gDsn(argdef.target, ss, ctx, _here, module).type.vtype) && (GET_gDsn(argdef.target, ss, ctx, _here, module).flags & Flags_Lzg8_F_INLINE))))
            BUG_gDsn((((((x7E_rA00("Inliner botching the argdef type of "_view, str_FDl5(foreign, false, ss, ctx, _here, module, options)) + ":\n"_view) + "\n\t\tExpect: "_view) + explainType_gDsn(GET_gDsn(foreign, ss, ctx, _here, module).type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)) + "\n\t\tActual: "_view) + explainType_gDsn(GET_gDsn(argdef.target, ss, ctx, _here, module).type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

    };
}
                                #endif

                                #ifndef DEF_argsForward_0ozppCirg3j
                                #define DEF_argsForward_0ozppCirg3j
inline void argsForward_0ozp(const bool RTL, fu::view<Argument_bbKc> host_args, const int seqIdx_start, fu::view<SolvedNode_efhg> args, fu::vec<SolvedNode_efhg>& argdefs, Map_iaWx& letdefReplicas, const unsigned revision, fu::view<Argument_bbKc> host_args_1, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    int seqIdx = 0;
    int lastPass = 1;
    for (int pass = 0; pass < lastPass; pass++)
    {
        for (int i = 0; i < host_args.size(); i++)
        {
            const Argument_bbKc& host_arg = host_args[i];
            if (!!pass != (RTL ? !i : !!((host_arg.flags & Flags_Lzg8_F_IMPLICIT) || is_mutref_9CJm(host_arg.type, ctx, _here))))
                lastPass = 2;
            else
            {
                if ((seqIdx_start <= seqIdx))
                    _3ezr(i, args, argdefs, letdefReplicas, revision, host_args_1, _current_fn, ss, ctx, _here, module, options, _helpers);

                seqIdx++;
            };
        };
    };
}
                                #endif

static SolvedNode_efhg CallerNode_inline_gDsn(const Target_VZrr& target, fu::view<SolvedNode_efhg> args, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    if ((int(unsigned(((target._packed >> 40ull) & 0xfffffull))) != module.modid) || (EPH_gDsn(target, ss, module).revision > 0u))
    {
        if (!(ss.TODO_FIX_inline_safety++ < 24))
            BUG_gDsn(x7E_rA00("Inliner recursion, something is off: "_view, str_FDl5(target, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

    }
    else
        BUG_gDsn((x7E_rA00("Inlining "_view, str_FDl5(target, false, ss, ctx, _here, module, options)) + " at revision 0."_view), ss, ctx, _here, module, options, _helpers);

    fu_DEFER(ss.TODO_FIX_inline_safety--);
    fu::vec<SolvedNode_efhg> argdefs {};
    /*MOV*/ Map_iaWx letdefReplicas {};
    const int locals_start = GET_next_local_index_gDsn(_current_fn, ss, ctx, _here);
    const unsigned revision = EPH_gDsn(target, ss, module).revision;
    fu::vec<Argument_bbKc> host_args = fu::vec<Argument_bbKc>(EXT_gDsn(target, ss, ctx, module).args);
    if (host_args.size() == args.size())
    {
        const bool RTL = isRTL_xQNS(GET_gDsn(target, ss, ctx, _here, module));
        argsForward_0ozp(RTL, host_args, 0, args, argdefs, letdefReplicas, revision, host_args, _current_fn, ss, ctx, _here, module, options, _helpers);
        const SolvedNode_efhg& n_body = last_c4M9(GET_gDsn(target, ss, ctx, _here, module).solved.items);
        fu::vec<SolvedNode_efhg> callsite_args {};
        /*MOV*/ SolvedNode_efhg s_body = inlineExpression_gDsn(target, SolvedNode_efhg(n_body), callsite_args, static_cast<Map_iaWx&&>(letdefReplicas), locals_start, target, _current_fn, ss, ctx, _here, module, options, _helpers);
        if (argdefs)
        {
            if (s_body.kind)
            {
                if (s_body.kind != Kind_Idfg_block)
                {
                    s_body = createBlock_gDsn(s_body.type, (argdefs + s_body), Helpers_DyqV{}, _here);
                }
                else
                    s_body.items.splice(0, 0, argdefs);

            }
            else
                BUG_gDsn("inline: no s_body.kind"_view, ss, ctx, _here, module, options, _helpers);

        };
        return /*NRVO*/ s_body;
    }
    else
        BUG_gDsn("inline: arglen mismatch"_view, ss, ctx, _here, module, options, _helpers);

}

                                #ifndef DEF_visit_yWu4058Wxyk
                                #define DEF_visit_yWu4058Wxyk
inline static void visit_yWu4(const Lifetime_llCF& lifetime, Lifetime_llCF& result, bool& maybeOutOfOrder, fu::view<SolvedNode_efhg> argNodes, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const fu::str& chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const int offset0 = offset;

        {
            const unsigned r = parse7bit_7Yz9(chars, offset);
            int offset0_1;
            int BL_4_v;
            const int sr = (__extension__ (
            {
                offset0_1 = (offset + 0);
                for (; ; )
                {
                    bool isLastPath = false;
                    bool isFirstSubRegion = true;
                    for (; ; )
                    {
                        const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                        const bool isLastSubRegion = !(raw_flatOffset & 1u);
                        const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                        isLastPath = !(raw_flatCount & 1u);
                        if (isLastSubRegion)
                            break;
                        else
                            isFirstSubRegion = false;

                    };
                    if (isLastPath)
                        break;

                };
                BL_4_v = (offset0_1);
                (void)0;
            }), BL_4_v);
            const bool isStatic = ((r & 11u) == 1u);
            const bool isTemp = (r == 0b1001u);
            unsigned v;
            const int locid = ((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))));
            const int argidx = int(((r & 1u) ? (r >> 2u) : 0u));
            fu::view<char> paths = fu::get_view(chars, sr, offset);
            if (!(isStatic))
            {
                if (isTemp || locid)
                {
                    BUG_gDsn("Lifetime_replaceArgsAtCallsite: Found a temp or locid."_view, ss, ctx, _here, module, options, _helpers);
                }
                else
                {
                    const SolvedNode_efhg& argNode = argNodes[argidx];
                    const Lifetime_llCF& argLt = (is_ref_9CJm(argNode.type) ? argNode.type.lifetime : Lifetime_temporary);
                    Lifetime_llCF replacement = Lifetime_op_join_7Yz9(argLt, paths, ctx, _here);
                    maybeOutOfOrder = true;
                    Lifetime_add_7Yz9(result, replacement, false, ctx, _here);
                    continue;
                };
            };
        };
        if (maybeOutOfOrder)
        {
            result = Lifetime_union_7Yz9(result, Lifetime_llCF { fu::str(fu::get_range(chars, offset0, offset)) }, false, ctx, _here);
        }
        else
            result.uni0n += fu::get_view(chars, offset0, offset);

    };
}
                                #endif

                                #ifndef DEF_Lifetime_process_QCsq04buEd8
                                #define DEF_Lifetime_process_QCsq04buEd8
inline Lifetime_llCF Lifetime_process_QCsq(const Lifetime_llCF& lifetime, fu::view<SolvedNode_efhg> argNodes, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    /*MOV*/ Lifetime_llCF result {};
    bool maybeOutOfOrder = false;
    visit_yWu4(lifetime, result, maybeOutOfOrder, argNodes, ss, ctx, _here, module, options, _helpers);
    return /*NRVO*/ result;
}
                                #endif

static Lifetime_llCF Lifetime_replaceArgsAtCallsite_gDsn(const Target_VZrr& target, fu::view<SolvedNode_efhg> argNodes, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    return Lifetime_process_QCsq(GET_gDsn(target, ss, ctx, _here, module).type.lifetime, argNodes, ss, ctx, _here, module, options, _helpers);
}

                                #ifndef DEF___S96QIfD4UA9
                                #define DEF___S96QIfD4UA9
inline static void _S96Q(const int locid, const bool isStatic, const bool isAlwaysMoveable, const bool isTemp, const bool isArgIdx, const int argidx, fu::view<char> paths, const Type_OiTm& type, const bool tempsOK, const bool argPositionsOK, bool& first, int& lastStatic, int& lastLocid, int& lastArgIdx, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (isTemp)
    {
        if (tempsOK)
        {
            if (!(first))
            {
                BUG_gDsn("TEST_Lifetime: temporary is not first"_view, ss, ctx, _here, module, options, _helpers);
            };
        }
        else
        {
            BUG_gDsn("TEST_Lifetime: unexpected temporary"_view, ss, ctx, _here, module, options, _helpers);
        };
    };
    first = false;
    if (isStatic)
    {
        const int r = (isAlwaysMoveable ? 1 : 0);
        if (lastStatic > r)
            lastStatic = r;
        else
        {
            BUG_gDsn("TEST_Lifetime: static out of order"_view, ss, ctx, _here, module, options, _helpers);
        };
    };
    if (locid)
    {
        if (!argPositionsOK)
        {
            if (lastArgIdx == 1000000)
            {
                if (lastStatic == 1000000)
                {
                    if (lastLocid > locid)
                        lastLocid = locid;
                    else
                    {
                        BUG_gDsn("TEST_Lifetime: locid out of order"_view, ss, ctx, _here, module, options, _helpers);
                    };
                }
                else
                {
                    BUG_gDsn("TEST_Lifetime: local after static"_view, ss, ctx, _here, module, options, _helpers);
                };
            }
            else
            {
                BUG_gDsn("TEST_Lifetime: local after argpos"_view, ss, ctx, _here, module, options, _helpers);
            };
        }
        else
        {
            BUG_gDsn("TEST_Lifetime: unexpected locid"_view, ss, ctx, _here, module, options, _helpers);
        };
    };
    if (isArgIdx)
    {
        if (argPositionsOK)
        {
            if (lastLocid == 1000000)
            {
                if (lastStatic == 1000000)
                {
                    if (lastArgIdx > argidx)
                        lastArgIdx = argidx;
                    else
                    {
                        BUG_gDsn("TEST_Lifetime: argidx out of order"_view, ss, ctx, _here, module, options, _helpers);
                    };
                }
                else
                {
                    BUG_gDsn("TEST_Lifetime: argidx after static"_view, ss, ctx, _here, module, options, _helpers);
                };
            }
            else
            {
                BUG_gDsn("TEST_Lifetime: argidx after local"_view, ss, ctx, _here, module, options, _helpers);
            };
        }
        else
        {
            BUG_gDsn("TEST_Lifetime: unexpected argidx"_view, ss, ctx, _here, module, options, _helpers);
        };
    };
    if (isStatic || isTemp)
    {
        if (!(paths == "\x00\x00"_view))
        {
            BUG_gDsn("TEST_Lifetime: static/temp paths != x00x00"_view, ss, ctx, _here, module, options, _helpers);
        };
    }
    else
        assertPathsValid_7Yz9(paths, getFlatCount_1qjp(type.vtype, ctx, _here, module), (locid ? getFlatCount_1qjp(GET_gDsn(nested_FDl5(locid, ss, ctx, _here), ss, ctx, _here, module).type.vtype, ctx, _here, module) : -1), false, 1, ctx, _here);

}
                                #endif

                                #ifndef DEF_Lifetime_each_DOOYtiZAN2j
                                #define DEF_Lifetime_each_DOOYtiZAN2j
inline void Lifetime_each_DOOY(const Lifetime_llCF& lifetime, const Type_OiTm& type, const bool tempsOK, const bool argPositionsOK, bool& first, int& lastStatic, int& lastLocid, int& lastArgIdx, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit_7Yz9(chars, offset);
        int offset0;
        int BL_3_v;
        const int sr = (__extension__ (
        {
            offset0 = (offset + 0);
            for (; ; )
            {
                bool isLastPath = false;
                bool isFirstSubRegion = true;
                for (; ; )
                {
                    const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                    isLastPath = !(raw_flatCount & 1u);
                    if (isLastSubRegion)
                        break;
                    else
                        isFirstSubRegion = false;

                };
                if (isLastPath)
                    break;

            };
            BL_3_v = (offset0);
            (void)0;
        }), BL_3_v);
        unsigned v;
        _S96Q(((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))))), ((r & 11u) == 1u), ((r == 0b0101u) || (r == 0b1001u)), (r == 0b1001u), ((r & 3u) == 3u), int(((r & 1u) ? (r >> 2u) : 0u)), fu::get_view(chars, sr, offset), type, tempsOK, argPositionsOK, first, lastStatic, lastLocid, lastArgIdx, ss, ctx, _here, module, options, _helpers);
    };
}
                                #endif

static const Lifetime_llCF& TEST_Lifetime_gDsn(const Lifetime_llCF& lifetime, const Type_OiTm& type, const bool tempsOK, const bool argPositionsOK, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (!lifetime)
    {
        BUG_gDsn("TEST_Lifetime: empty lifetime"_view, ss, ctx, _here, module, options, _helpers);
    }
    else
    {
        bool first = true;
        int lastStatic = 1000000;
        int lastLocid = 1000000;
        int lastArgIdx = 1000000;
        Lifetime_each_DOOY(lifetime, type, tempsOK, argPositionsOK, first, lastStatic, lastLocid, lastArgIdx, ss, ctx, _here, module, options, _helpers);
    };
    return lifetime;
}

static SolvedNode_efhg CallerNode_gDsn(fu::vec_range<char> debug, Target_VZrr&& target, fu::vec<SolvedNode_efhg>&& args, const Reorder_0MNg& reorder, fu::view<fu::vec<Target_VZrr>> conversions, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    if (reorder)
    {
        /*MOV*/ fu::vec<SolvedNode_efhg> args_out {};
        args_out.resize(reorder.map.size());
        for (int i = 0; i < reorder.map.size(); i++)
        {
            const int idx = reorder.map[i];
            if ((idx >= 0))
                args_out.mutref(i) = steal_bX67(args.mutref(idx));

        };
        args = static_cast<fu::vec<SolvedNode_efhg>&&>(args_out);
    };
    for (int argIdx = 0; argIdx < conversions.size(); argIdx++)
    {
        fu::view<Target_VZrr> conversion = conversions[argIdx];
        if (applyConversion_gDsn(args.mutref(argIdx), conversion, _current_fn, ss, ctx, _here, module, options, _helpers))
        {
            args.shrink((argIdx + 1));

            {
                const SolverNotes_LSla note = SolverNotes_LSla_N_DeadConv;
                if (note & options.break_notes)
                {
                    fu::view<char> reason = fu::view<char>{};
                    fail_gDsn((("`break_notes`: Unwanted event: "_view + qBAD_e44U(str_kJvr(note))) + (reason ? ("\n\t\t"_view + reason) : fu::str("."_fu))), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                }
                else
                    ss._notes |= note;

            };
            return createBlock_gDsn(t_never, args, Helpers_DyqV{}, _here);
        };
    };
    const int REST_START = findRestStart_gDsn(EXT_gDsn(target, ss, ctx, module));
    if (REST_START < args.size())
    {
        fu::vec<SolvedNode_efhg> rest {};
        rest.resize((args.size() - REST_START));
        for (int i = args.size(); i-- > REST_START; )
        {
            std::swap(rest.mutref((i - REST_START)), args.mutref(i));
            if (i > REST_START)
                args.splice(i, 1);
            else
                args.mutref(i) = createArrlit_gDsn(rest, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options, _helpers);

        };
    };
    const Kind_Idfg kind = GET_gDsn(target, ss, ctx, _here, module).kind;
    const bool isZeroInit = ((kind == Kind_Idfg_type) ? !args.size() : false);
    if (!isZeroInit)
    {
        fu::vec<Argument_bbKc> host_args = fu::vec<Argument_bbKc>(EXT_gDsn(target, ss, ctx, module).args);
        const Target_VZrr spec_of = EXT_gDsn(target, ss, ctx, module).spec_of;
        fu::vec<Argument_bbKc> spec_of_args = fu::vec<Argument_bbKc>((spec_of ? EXT_gDsn(spec_of, ss, ctx, module).args : (*(fu::vec<Argument_bbKc>*)fu::NIL)));
        args.resize(host_args.size());
        const bool RTL = isRTL_xQNS(GET_gDsn(target, ss, ctx, _here, module));
        const int seqIdx_start = 0;
        int seqIdx = 0;
        int lastPass = 1;
        for (int pass = 0; pass < lastPass; pass++)
        {
            for (int i = 0; i < host_args.size(); i++)
            {
                const Argument_bbKc& host_arg = host_args[i];
                if (!!pass != (RTL ? !i : !!((host_arg.flags & Flags_Lzg8_F_IMPLICIT) || is_mutref_9CJm(host_arg.type, ctx, _here))))
                    lastPass = 2;
                else
                {
                    if ((seqIdx_start <= seqIdx))
                    {
                        const int i_1 = i;
                        SolvedNode_efhg& arg = args.mutref(i_1);
                        if (!arg)
                        {
                            Target_VZrr defaultFrom = target;
                            const SolvedNode_efhg& dEfault = (host_arg.dEfault ? host_arg.dEfault : ((defaultFrom = spec_of), ((spec_of_args.size() > i_1) ? spec_of_args[i_1].dEfault : (*(SolvedNode_efhg*)fu::NIL))));
                            if (dEfault)
                            {
                                args.mutref(i_1) = inlineExpression_gDsn(defaultFrom, SolvedNode_efhg(dEfault), args, Map_iaWx{}, 0, Target_VZrr{}, _current_fn, ss, ctx, _here, module, options, _helpers);
                            }
                            else if (host_arg.flags & Flags_Lzg8_F_IMPLICIT)
                                arg = bindImplicitArg_gDsn(fu::str(host_arg.name), Type_OiTm(host_arg.type), Target_VZrr(host_arg.target), _current_fn, ss, ctx, _here, module, options, _helpers);
                            else
                                BUG_gDsn(x7E_rA00("tryMatch: about to implicit-bind a non-implicit argument: "_view, str_wyx7(host_arg, false, _current_fn, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

                        };
                        SolvedNode_efhg& arg_1 = args.mutref(i_1);
                        if ((kind != Kind_Idfg_field) && (kind != Kind_Idfg_template))
                        {
                            if (arg_1.kind == Kind_Idfg_argid)
                                arg_1 = only_S4ER(arg_1.items);

                            const Type_OiTm& expect = host_arg.type;
                            Type_OiTm retype = tryRetyping_gDsn(arg_1, expect, ss, ctx, _here, module, options, _helpers);
                            if (retype && isAssignableAsArgument_9CJm(expect.vtype, retype.vtype, false, ctx, _here))
                                applyRetype_gDsn(arg_1, retype, ss, ctx, _here, module, options, _helpers);

                        };
                        if (is_never_9CJm(arg_1.type.vtype) && !(host_arg.flags & Flags_Lzg8_F_INLINE))
                        {
                            fu::vec<SolvedNode_efhg> ooe {};
                            argsForward_gOVx(RTL, host_args, 0, i_1, ooe, args, ctx, _here);

                            {
                                const SolverNotes_LSla note = SolverNotes_LSla_N_DeadCall;
                                if (note & options.break_notes)
                                {
                                    fu::view<char> reason = fu::view<char>{};
                                    fail_gDsn((("`break_notes`: Unwanted event: "_view + qBAD_e44U(str_kJvr(note))) + (reason ? ("\n\t\t"_view + reason) : fu::str("."_fu))), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                                }
                                else
                                    ss._notes |= note;

                            };
                            return createBlock_gDsn(t_never, ooe, Helpers_DyqV{}, _here);
                        };
                    };
                    seqIdx++;
                };
            };
        };
    };
    Type_OiTm type = GET_gDsn(target, ss, ctx, _here, module).type;
    if (kind == Kind_Idfg_field)
    {
        SolvedNode_efhg* _0;
        SolvedNode_efhg& arg = (*(_0 = &(only_krrB(args))) ? *_0 : BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers));
        type = make_field_reference_gDsn(arg.type, GET_gDsn(target, ss, ctx, _here, module), false, ctx, _here);
        if (is_zeroes_9CJm(arg.type.vtype))
        {
            definitWrap_gDsn(arg, type, ss, ctx, _here, module, options, _helpers);
            return SolvedNode_efhg(arg);
        };
    }
    else if (kind == Kind_Idfg_var)
    {
        TEST_varLifetime_gDsn(type.lifetime, true, 0, ss, ctx, _here, module, options, _helpers);
        const Target_VZrr* t;
        unsigned v;
        const Target_VZrr* t_1;
        if ((t = &(target), v = unsigned(((*t)._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))) || (((t_1 = &(target), int(unsigned((((*t_1)._packed >> 40ull) & 0xfffffull)))) == module.modid) && !(GET_gDsn(target, ss, ctx, _here, module).flags & Flags_Lzg8_F_PUB)))
            GET_mut_gDsn(target, ss, module).status |= SolverStatus_h9em_SS_MATCHED;

        const Target_VZrr* t_2;
        if (isLocal_gDsn(target) && (localOf_gDsn(target, ss, module) != (t_2 = &(_current_fn.out.target), int(unsigned((((*t_2)._packed >> 20ull) & 0xfffffull))))))
        {
            target = injectForeignLocal_gDsn(target, _current_fn, ss, ctx, _here, module, options, _helpers);
            const Type_OiTm* _1;
            type = (*(_1 = &(GET_gDsn(target, ss, ctx, _here, module).type)) ? *_1 : BUG_gDsn(("CallerNode: !type on var "_view + GET_gDsn(target, ss, ctx, _here, module).name), ss, ctx, _here, module, options, _helpers));
        };
        const Target_VZrr* target_1;
        unsigned v_1;
        if (isIrrelevant_9CJm(type) && !((target_1 = &(target), ((v_1 = unsigned(((*target_1)._packed & 0xfffffull)), int(((v_1 >> 1u) ^ ((v_1 & 1u) ? 0xffffffffu : 0x0u)))) < 0)) && (GET_gDsn(target, ss, ctx, _here, module).flags & Flags_Lzg8_F_INLINE)))
        {
            return createEmpty_gDsn(type, Target_VZrr{}, ss, ctx, _here, module, options, _helpers);
        };
    }
    else
    {
        const Target_VZrr* t;
        if ((t = &(target), int(unsigned((((*t)._packed >> 40ull) & 0xfffffull)))) == module.modid)
        {
            if ((kind == Kind_Idfg_fn) || (kind == Kind_Idfg_type) || (kind == Kind_Idfg_inline))
            {
                if (ss._solvingFnort)
                {
                    const Target_VZrr* t_1;
                    int _2;
                    (_2 = (t_1 = &(ss._solvingFnort), int(unsigned((((*t_1)._packed >> 20ull) & 0xfffffull)))), incr_Sn2e(EPH_mut_FDl5(target, ss, module).callers, _2));
                    const Target_VZrr* t_2;
                    incr_Sn2e(EPH_mut_FDl5(ss._solvingFnort, ss, module).calls, (t_2 = &(target), int(unsigned((((*t_2)._packed >> 20ull) & 0xfffffull)))));
                    detectRecursion_gDsn(target, ss, ctx, _here, module, options, _helpers);
                };
            };
        };
        if (args)
        {
            if (kind == Kind_Idfg_type)
                type = clear_Typename_9CJm(Type_OiTm(type), false);

        };
        if ((kind == Kind_Idfg_inline) && SolverStatus_h9em((GET_gDsn(target, ss, ctx, _here, module).status & SolverStatus_h9em_SS_FINALIZED)))
            return CallerNode_inline_gDsn(target, args, _current_fn, ss, ctx, _here, module, options, _helpers);
        else if (args && is_ref_9CJm(type))
        {
            type.lifetime = static_cast<Lifetime_llCF&&>(const_cast<Lifetime_llCF&>(TEST_Lifetime_gDsn(Lifetime_replaceArgsAtCallsite_gDsn(target, args, ss, ctx, _here, module, options, _helpers), type, true, false, ss, ctx, _here, module, options, _helpers)));
        };
    };
    if (isZeroInit)
    {
        return createEmpty_gDsn(type, Target_VZrr{}, ss, ctx, _here, module, options, _helpers);
    }
    else
    {
        return SolvedNode_gDsn(Kind_Idfg_call, type, Flags_Lzg8{}, debug, args, target, Helpers_DyqV{}, _here);
    };
}

static bool applyConversion_gDsn(SolvedNode_efhg& arg, fu::view<Target_VZrr> conversion, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    for (int i = 0; i < conversion.size(); i++)
    {
        const Target_VZrr& t = conversion[i];
        if (EXT_gDsn(t, ss, ctx, module).min || (EXT_gDsn(t, ss, ctx, module).max && arg))
        {
            arg = CallerNode_gDsn(str_5UZMuQGyOB0, Target_VZrr(t), fu::vec<SolvedNode_efhg> {{ SolvedNode_efhg(arg) }}, (*(Reorder_0MNg*)fu::NIL), fu::view<fu::vec<Target_VZrr>>{}, _current_fn, ss, ctx, _here, module, options, _helpers);
        }
        else if (i)
            BUG_gDsn(x7E_rA00("Bad conversion chain, non-leading nullary: "_view, str_FDl5(t, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);
        else if (arg)
            BUG_gDsn("Bad conversion chain, about to throw away an argnode."_view, ss, ctx, _here, module, options, _helpers);
        else
        {
            arg = CallerNode_gDsn(str_id6aIsm0eRi, Target_VZrr(t), fu::vec<SolvedNode_efhg>{}, (*(Reorder_0MNg*)fu::NIL), fu::view<fu::vec<Target_VZrr>>{}, _current_fn, ss, ctx, _here, module, options, _helpers);
        };
        if (is_never_9CJm(arg.type.vtype))
            return true;

    };
    return false;
}

static Type_OiTm convertToSuperType_gDsn(fu::view<char> topic, SolvedNode_efhg& a, SolvedNode_efhg& b, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{

    {
        /*MOV*/ Type_OiTm super = type_trySuper_9CJm(a.type, b.type, false, ctx, _here);
        if (super)
            return /*NRVO*/ super;

    };
    /*MOV*/ Type_OiTm b_T = clear_vfacts_9CJm(Type_OiTm(b.type));
    /*MOV*/ Type_OiTm a_T = clear_vfacts_9CJm(Type_OiTm(a.type));

    {
        Type_OiTm aRetype = tryRetyping_gDsn(a, b_T, ss, ctx, _here, module, options, _helpers);
        Type_OiTm bRetype = tryRetyping_gDsn(b, a_T, ss, ctx, _here, module, options, _helpers);
        if (aRetype)
        {
            if (bRetype)
            {
                fail_gDsn(((((topic + ": Type ambiguity, literals can be retyped both ways: "_view) + explainType_gDsn(a.type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)) + " <-> "_view) + explainType_gDsn(b.type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
            }
            else
            {
                /*MOV*/ Type_OiTm super = type_trySuper_9CJm(aRetype, b.type, false, ctx, _here);
                if (super)
                {
                    applyRetype_gDsn(a, aRetype, ss, ctx, _here, module, options, _helpers);
                    return /*NRVO*/ super;
                };
            };
        };
        if (bRetype)
        {
            /*MOV*/ Type_OiTm super = type_trySuper_9CJm(bRetype, a.type, false, ctx, _here);
            if (super)
            {
                applyRetype_gDsn(b, bRetype, ss, ctx, _here, module, options, _helpers);
                return /*NRVO*/ super;
            };
        };
    };

    {
        fu::vec<Target_VZrr> aConv = tryConvert_GKse(clear_all_9CJm(static_cast<Type_OiTm&&>(b_T)), a.type, _current_fn, ss, ctx, _here, module, options, _helpers);
        fu::vec<Target_VZrr> bConv = tryConvert_GKse(clear_all_9CJm(static_cast<Type_OiTm&&>(a_T)), b.type, _current_fn, ss, ctx, _here, module, options, _helpers);
        if (aConv)
        {
            if (bConv)
            {
                fu::str error = (topic + ": Type ambiguity, conversions exist both ways:\n"_view);
                explain_wyx7(a.type, b.type, aConv, error, _current_fn, ss, ctx, _here, module, options);
                explain_wyx7(b.type, a.type, bConv, error, _current_fn, ss, ctx, _here, module, options);
                fail_gDsn(error, fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
            }
            else
            {
                applyConversion_gDsn(a, aConv, _current_fn, ss, ctx, _here, module, options, _helpers);
                Type_OiTm _0 {};
                return (_0 = type_trySuper_9CJm(a.type, b.type, false, ctx, _here)) ? static_cast<Type_OiTm&&>(_0) : BUG_gDsn("convertToSuper: aConv super"_view, ss, ctx, _here, module, options, _helpers);
            };
        }
        else if (bConv)
        {
            applyConversion_gDsn(b, bConv, _current_fn, ss, ctx, _here, module, options, _helpers);
            Type_OiTm _1 {};
            return (_1 = type_trySuper_9CJm(a.type, b.type, false, ctx, _here)) ? static_cast<Type_OiTm&&>(_1) : BUG_gDsn("convertToSuper: bConv super"_view, ss, ctx, _here, module, options, _helpers);
        };
    };
    fail_gDsn(((((topic + ": No common supertype: "_view) + explainType_gDsn(a.type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)) + " <-> "_view) + explainType_gDsn(b.type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
}

static SolvedNode_efhg createIf_gDsn(const SolvedNode_efhg& cond, /*MOV*/ SolvedNode_efhg&& cons, /*MOV*/ SolvedNode_efhg&& alt, Type_OiTm&& type, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    StaticEval_IZio ae_cond;
    if (is_never_9CJm(cond.type.vtype))
        BUG_gDsn("createIf: cond.is_never"_view, ss, ctx, _here, module, options, _helpers);
    else if ((ae_cond = tryAbstractEvalAsBool_gDsn(cond, false, _current_fn, ss, ctx, _here, module, options, _helpers)))
        return createBlock_FDl5(SolvedNode_efhg(cond), ((ae_cond == StaticEval_IZio_SE_True) ? litfix_bound_gDsn(cons, alt, _here) : ((ae_cond == StaticEval_IZio_SE_False) ? litfix_bound_gDsn(alt, cons, _here) : BUG_gDsn("createIf: ae_cond, neither True nor False."_view, ss, ctx, _here, module, options, _helpers))), ss, ctx, _here, module);
    else
    {
        const bool cons_isNever = is_never_9CJm(cons.type.vtype);
        const bool alt_isNever = is_never_9CJm(alt.type.vtype);
        if (cons_isNever && alt_isNever)
            type = t_never;
        else if (propositionOK_9CJm(type, false, ctx, _here))
            type = t_bool;
        else if (!is_void_9CJm(type.vtype))
        {
            type = (cons_isNever ? Type_OiTm(alt.type) : (alt_isNever ? Type_OiTm(cons.type) : convertToSuperType_gDsn("if/else"_view, cons, alt, _current_fn, ss, ctx, _here, module, options, _helpers)));
        };
        return SolvedNode_gDsn(Kind_Idfg_if, (type ? type : BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers)), Flags_Lzg8{}, (*(fu::str*)fu::NIL), fu::vec<SolvedNode_efhg> {{ SolvedNode_efhg(cond), static_cast<SolvedNode_efhg&&>(cons), static_cast<SolvedNode_efhg&&>(alt) }}, Target_VZrr{}, Helpers_DyqV{}, _here);
    };
}

static SolvedNode_efhg createAnd_gDsn(fu::vec<SolvedNode_efhg>&& items, Type_OiTm&& type, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    const int trim = createAndOr_staticEvalFold_gDsn(items, StaticEval_IZio_SE_True, _current_fn, ss, ctx, _here, module, options, _helpers);
    if ((items.size() > 1) && !is_void_or_propositionOK_9CJm(type, false, ctx, _here))
    {
        /*MOV*/ Type_OiTm sumType {};
        for (int i = items.size(); i-- > 0; )
        {
            const SolvedNode_efhg& item = items[i];
            if (!(is_never_9CJm(item.type.vtype)))
            {
                if (sumType)
                {
                    sumType = type_trySuper_9CJm(sumType, item.type, false, ctx, _here);
                    if (andNodeType_canCleanlyDefinit_gDsn(sumType, ctx, _here))
                        break;

                }
                else
                {
                    type = item.type;
                    sumType = item.type;
                    if (is_zeroes_9CJm(type.vtype))
                        break;

                };
            };
        };
        if (andNodeType_canCleanlyDefinit_gDsn(sumType, ctx, _here))
        {
            fu::vec_range<SolvedNode_efhg> cond = fu::get_range(items, 0, (items.size() - 1));
            const SolvedNode_efhg& cons = last_c4M9(items);
            SolvedNode_efhg _0 {};
            return (_0 = createAnd_gDsn(fu::vec<SolvedNode_efhg>(cond), Type_OiTm(t_bool), _current_fn, ss, ctx, _here, module, options, _helpers), createIf_gDsn(static_cast<SolvedNode_efhg&&>(_0), SolvedNode_efhg(cons), solveDefinit_gDsn(type, ctx, _here), Type_OiTm{}, _current_fn, ss, ctx, _here, module, options, _helpers));
        }
        else
            type = static_cast<Type_OiTm&&>(sumType);

    }
    else
        type = t_bool;


    {
        const VFacts_xhRf vfacts = VFacts_xhRf_AlwaysFalse;
        if (trim)
        {
            items.shrink(trim);
            type.vtype.vfacts |= vfacts;
        };
        if (items.size() < 2)
        {
            const SolvedNode_efhg& only = only_S4ER(items);
            return SolvedNode_efhg(only);
        };
    };
    const SolvedNode_efhg& last_type = last_c4M9(items);
    if (is_never_9CJm(last_type.type.vtype) || VFacts_xhRf((last_type.type.vtype.vfacts & VFacts_xhRf_AlwaysFalse)))
        type.vtype.vfacts = VFacts_xhRf_AlwaysFalse;

    return SolvedNode_gDsn(Kind_Idfg_and, type, Flags_Lzg8{}, (*(fu::str*)fu::NIL), items, Target_VZrr{}, Helpers_DyqV{}, _here);
}

static SolvedNode_efhg& recover_gDsn(SolvedNode_efhg& node)
{
    return node.items.mutref(TRY_CATCH);
}

static SolvedNode_efhg& error_gDsn(SolvedNode_efhg& node)
{
    return node.items.mutref(TRY_ERR);
}

static SolvedNode_efhg& attempt_gDsn(SolvedNode_efhg& node)
{
    return node.items.mutref(TRY_TRY);
}

static const SolvedNode_efhg& attempt_FDl5(const SolvedNode_efhg& node)
{
    return node.items[TRY_TRY];
}

static void Breakable_begin_gDsn(const bool loop_PREVITER, const SolvedNode_efhg& node, const unsigned relax_mask, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here)
{
    if (node.helpers)
    {
        const Helpers_DyqV* h;
        (h = &(node.helpers), ((((*h).index >= 0) && ((*h).index < ss._helpers_data.size())) ? ss._helpers_data.mutref((*h).index) : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).postdom = Postdom_Vy5u(_current_fn.postdom);
    };
    if (loop_PREVITER && (relax_mask == RELAX_all))
    {
        const Helpers_DyqV* h;
        branch_gDsn(_current_fn.postdom, (h = &(node.helpers), ((((*h).index >= 0) && ((*h).index < ss._helpers_data.size())) ? ss._helpers_data[(*h).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).loop_PREVITER, ctx, _here);
    };
}

static const SolvedNode_efhg& post_cond_FDl5(const SolvedNode_efhg& node)
{
    return node.items[LOOP_POST_COND];
}

static SolvedNode_efhg& post_cond_gDsn(SolvedNode_efhg& node)
{
    return node.items.mutref(LOOP_POST_COND);
}

static const SolvedNode_efhg& post_FDl5(const SolvedNode_efhg& node)
{
    return node.items[LOOP_POST];
}

static SolvedNode_efhg& post_gDsn(SolvedNode_efhg& node)
{
    return node.items.mutref(LOOP_POST);
}

static const SolvedNode_efhg& body_FDl5(const SolvedNode_efhg& node)
{
    return node.items[LOOP_BODY];
}

static SolvedNode_efhg& body_gDsn(SolvedNode_efhg& node)
{
    return node.items.mutref(LOOP_BODY);
}

static const SolvedNode_efhg& pre_FDl5(const SolvedNode_efhg& node)
{
    return node.items[LOOP_PRE];
}

static SolvedNode_efhg& pre_gDsn(SolvedNode_efhg& node)
{
    return node.items.mutref(LOOP_PRE);
}

static const SolvedNode_efhg& pre_cond_FDl5(const SolvedNode_efhg& node)
{
    return node.items[LOOP_PRE_COND];
}

static SolvedNode_efhg& pre_cond_gDsn(SolvedNode_efhg& node)
{
    return node.items.mutref(LOOP_PRE_COND);
}

static void clear_FDl5(LocidSet_iAWt& set, const int start, const CurrentFn_QbLp& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    clear_Na55(set._bitset, (args_neg + ((start == NO_LOOP) ? -args_neg : start)));
}

                                #ifndef DEF_clear_ZIEcR8MI8s3
                                #define DEF_clear_ZIEcR8MI8s3
inline static void clear_ZIEc(LocidMap_IP5H& map, const int start, const CurrentFn_QbLp& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    const int i = (start + args_neg);
    if (map._values.size() > i)
        map._values.shrink(i);

}
                                #endif

static void Breakable_end_gDsn(const bool loop_PREVITER, const SolvedNode_efhg& node, const unsigned relax_mask, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here)
{
    if (loop_PREVITER && !(relax_mask == RELAX_all))
    {
        const Helpers_DyqV* h;
        Postdom_Vy5u& previter = (h = &(node.helpers), ((((*h).index >= 0) && ((*h).index < ss._helpers_data.size())) ? ss._helpers_data.mutref((*h).index) : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).loop_PREVITER;
        previter = _current_fn.postdom;
        const Helpers_DyqV* h_1;
        const int loop_start = (h_1 = &(node.helpers), ((((*h_1).index >= 0) && ((*h_1).index < ss._helpers_data.size())) ? ss._helpers_data[(*h_1).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).locals_start;
        clear_FDl5(previter.snap.used_again, loop_start, _current_fn);
        clear_ZIEc(previter.snap.ever_written, loop_start, _current_fn);
    };
    if (node.helpers)
    {
        const Helpers_DyqV* h;
        branch_gDsn(_current_fn.postdom, (h = &(node.helpers), ((((*h).index >= 0) && ((*h).index < ss._helpers_data.size())) ? ss._helpers_data[(*h).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).postdom, ctx, _here);
    };
}

static const SolvedNode_efhg& init_FDl5(const SolvedNode_efhg& node)
{
    return node.items[LOOP_INIT];
}

static SolvedNode_efhg& init_gDsn(SolvedNode_efhg& node)
{
    return node.items.mutref(LOOP_INIT);
}

static bool has_gDsn(const LocidSet_iAWt& set, const int locid, const CurrentFn_QbLp& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    return has_ZwXY(set._bitset, (args_neg + locid));
}

static UsedAgain_5DsR descend_wyx7(const Target_VZrr& t, LocidSet_iAWt& bitset, LocidSet_iAWt& just_added, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    unsigned v;
    const int locid = (v = unsigned((t._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
    if (!add_gDsn(bitset, locid, _current_fn))
    {
        const UsedAgainReason_wQO7 reason = UsedAgainReason_wQO7_UsedAgain;
        return UsedAgain_5DsR(((((unsigned(locid) << 1u) ^ ((locid < 0) ? 0xffffffffu : 0x0u)) << 8u) | unsigned(reason)));
    }
    else
    {
        add_gDsn(just_added, locid, _current_fn);
        const Overload_aO3i& o = GET_gDsn(t, ss, ctx, _here, module);
        unsigned v_1;
        const bool isArg = ((v_1 = unsigned((t._packed & 0xfffffull)), int(((v_1 >> 1u) ^ ((v_1 & 1u) ? 0xffffffffu : 0x0u)))) < 0);
        const SolvedNode_efhg& letNode = o.solved;
        if (is_ref_9CJm(letNode.type))
        {
            if (isArg)
            {
                if (!isMutVal_gDsn(o))
                {
                    const UsedAgainReason_wQO7 reason = UsedAgainReason_wQO7_ArgReference;
                    return UsedAgain_5DsR(((((unsigned(locid) << 1u) ^ ((locid < 0) ? 0xffffffffu : 0x0u)) << 8u) | unsigned(reason)));
                }
                else
                    return 0u;

            }
            else
            {
                const UsedAgain_5DsR usedAgain = descend_FDl5(Lifetime_climbType_gDsn(t, ss, ctx, _here, module, options, _helpers).lifetime, bitset, just_added, _current_fn, ss, ctx, _here, module, options, _helpers);
                if (usedAgain)
                    return usedAgain;

            };
        }
        else if (isArg)
            BUG_gDsn("trackUsedAgain/descend: o.isArg but !o.solved.is_ref"_view, ss, ctx, _here, module, options, _helpers);

        if (locid < _current_fn.postdom.write_loop_start)
        {
            const UsedAgainReason_wQO7 reason = UsedAgainReason_wQO7_UsedInALoop;
            return UsedAgain_5DsR(((((unsigned(locid) << 1u) ^ ((locid < 0) ? 0xffffffffu : 0x0u)) << 8u) | unsigned(reason)));
        }
        else
            return 0u;

    };
}

                                #ifndef DEF___rQtFnyILdig
                                #define DEF___rQtFnyILdig
inline static void _rQtF(const int locid, const bool isAlwaysMoveable, const bool isStatic, LocidSet_iAWt& bitset, UsedAgain_5DsR& some, LocidSet_iAWt& just_added, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (!(isAlwaysMoveable))
    {
        if (!locid)
        {
            if (isStatic)
            {
                UsedAgainReason_wQO7 reason;
                some = (reason = UsedAgainReason_wQO7_StaticReference, UsedAgain_5DsR(((((unsigned(locid) << 1u) ^ ((locid < 0) ? 0xffffffffu : 0x0u)) << 8u) | unsigned(reason))));
            }
            else
                BUG_gDsn("trackUsedAgain/descend: non-static non-local"_view, ss, ctx, _here, module, options, _helpers);

        }
        else if (!has_gDsn(just_added, locid, _current_fn))
        {
            const UsedAgain_5DsR usedAgain = descend_wyx7(nested_FDl5(locid, ss, ctx, _here), bitset, just_added, _current_fn, ss, ctx, _here, module, options, _helpers);
            if (usedAgain && !some)
                some = usedAgain;

        };
    };
}
                                #endif

                                #ifndef DEF_Lifetime_each_gZXNKg58DRk
                                #define DEF_Lifetime_each_gZXNKg58DRk
inline void Lifetime_each_gZXN(const Lifetime_llCF& lifetime, LocidSet_iAWt& bitset, UsedAgain_5DsR& some, LocidSet_iAWt& just_added, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit_7Yz9(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        unsigned v;
        _rQtF(((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))))), ((r == 0b0101u) || (r == 0b1001u)), ((r & 11u) == 1u), bitset, some, just_added, _current_fn, ss, ctx, _here, module, options, _helpers);
    };
}
                                #endif

static UsedAgain_5DsR descend_FDl5(const Lifetime_llCF& lt, LocidSet_iAWt& bitset, LocidSet_iAWt& just_added, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    UsedAgain_5DsR some {};
    Lifetime_each_gZXN(lt, bitset, some, just_added, _current_fn, ss, ctx, _here, module, options, _helpers);
    return some;
}

static UsedAgain_5DsR trackUsedAgain_gDsn(const Lifetime_llCF& lt, const unsigned relax_mask, CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    LocidSet_iAWt just_added {};
    if (relax_mask == RELAX_all)
        return descend_FDl5(lt, _current_fn.postdom.snap.used_again, just_added, _current_fn, ss, ctx, _here, module, options, _helpers);
    else
    {
        const int locid = 0;
        const UsedAgainReason_wQO7 reason = UsedAgainReason_wQO7_WrongPass;
        return UsedAgain_5DsR(((((unsigned(locid) << 1u) ^ ((locid < 0) ? 0xffffffffu : 0x0u)) << 8u) | unsigned(reason)));
    };
}

static Target_VZrr tryReverseSpecialize_gDsn(Target_VZrr&& original, unsigned relaxed_quals, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const Target_VZrr* up;
    while ((*(up = &(EPH_gDsn(original, ss, module).rev_spec.instance.original))))
    {
        unsigned _0;
        relaxed_quals |= ((_0 = EPH_gDsn(original, ss, module).rev_spec.instance.relaxed_quals) ? _0 : BUG_gDsn((x7E_rA00("tryReverseSpecialize: .original set on "_view, str_FDl5(original, false, ss, ctx, _here, module, options)) + " but !relaxed_quals"_view), ss, ctx, _here, module, options, _helpers));
        original = (*up);
    };
    if (!SolverStatus_h9em((GET_gDsn(original, ss, ctx, _here, module).status & SolverStatus_h9em_SS_FINALIZED)))
    {
        return Target_VZrr{};
    }
    else
    {
        const unsigned expect_revision = EPH_gDsn(original, ss, module).revision;
        fu::view<RevSpecOutput_pbkT> outputs = EPH_gDsn(original, ss, module).rev_spec.outputs;
        for (int i = 0; i < outputs.size(); i++)
        {
            if (outputs[i].relaxed_quals == relaxed_quals)
                return outputs[i].instance_targ;

        };
        const Target_VZrr target = Scope_create_z0Qq(ss._scope, Kind_Idfg_fn, (*(fu::str*)fu::NIL), (*(Type_OiTm*)fu::NIL), Flags_Lzg8{}, DeclAsserts_taUG{}, SolverStatus_h9em{}, 0, false, module);
        GET_mut_gDsn(target, ss, module) = Overload_aO3i(GET_gDsn(original, ss, ctx, _here, module));
        EXT_mut_gDsn(target, ss, module) = Extended_z0HS(EXT_gDsn(original, ss, ctx, module));
        EPH_mut_FDl5(target, ss, module).rev_spec = ReverseSpecialization_xE3F { RevSpecPrototype_vWbr{}, RevSpecInstance_Td5T { Target_VZrr(original), relaxed_quals }, fu::vec<RevSpecOutput_pbkT>{} };
        Ephemeral_xhb4& eph_orig = EPH_mut_FDl5(original, ss, module);
        if (expect_revision && (eph_orig.revision == expect_revision))
        {
            eph_orig.rev_spec.outputs += RevSpecOutput_pbkT { relaxed_quals, Target_VZrr(target) };
            GET_mut_gDsn(target, ss, module).status &= SolverStatus_h9em((SolverStatus_h9em_SS_LAZY | SolverStatus_h9em_SS_FN_RECUR));
            EPH_mut_FDl5(target, ss, module).local_of = EPH_gDsn(original, ss, module).local_of;
            return target;
        }
        else
            BUG_gDsn("tryReverseSpecialize: original.revision bumped while reverse specializing."_view, ss, ctx, _here, module, options, _helpers);

    };
}

                                #ifndef DEF___9BgnEGq1mVg
                                #define DEF___9BgnEGq1mVg
inline static fu::str _9Bgn(const Argument_bbKc& _, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    return str_wyx7(_, false, _current_fn, ss, ctx, _here, module, options);
}
                                #endif

                                #ifndef DEF_map_zUrbul6KCk6
                                #define DEF_map_zUrbul6KCk6
inline fu::vec<fu::str> map_zUrb(fu::view<Argument_bbKc> a, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    /*MOV*/ fu::vec<fu::str> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _9Bgn(a[i], _current_fn, ss, ctx, _here, module, options);

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_join_yqDbqRmcQYi
                                #define DEF_join_yqDbqRmcQYi
inline fu::str join_yqDb(fu::view<fu::str> a, fu::view<char> sep)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = sep.size();
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> range = a[i_1];
            fu::view_assign(fu::get_view_mut(res, size, (size + N)), sep);
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

static void redirectCallTarget_gDsn(const Target_VZrr& spec, SolvedNode_efhg& node, const Target_VZrr& t, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    const Target_VZrr& orig = node.target;
    if (!(orig == spec))
    {
        ensureLazySolved_gDsn(spec, _current_fn, ss, ctx, _here, module, options, _helpers);
        if (EXT_gDsn(spec, ss, ctx, module).args.size() == EXT_gDsn(t, ss, ctx, module).args.size())
        {

            {
                const Type_OiTm& host = node.type;
                const Type_OiTm& guest = GET_gDsn(spec, ss, ctx, _here, module).type;
                const bool asArgument = false;
                if (!(isAssignable_9CJm(host, guest, false, asArgument, ctx, _here)))
                    BUG_gDsn((("Relaxed specialization does not return a subtype"_view + ": "_view) + explainNotAssignable_gDsn(host, guest, _current_fn, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

            };
            if (is_ref_9CJm(node.type))
            {
                node.type.lifetime = static_cast<Lifetime_llCF&&>(const_cast<Lifetime_llCF&>(TEST_Lifetime_gDsn(Lifetime_replaceArgsAtCallsite_gDsn(spec, node.items, ss, ctx, _here, module, options, _helpers), node.type, true, false, ss, ctx, _here, module, options, _helpers)));
            };
            node.target = spec;
            const SolverNotes_LSla note = SolverNotes_LSla_N_RelaxRespec;
            if (note & options.break_notes)
            {
                fu::view<char> reason = fu::view<char>{};
                fail_gDsn((("`break_notes`: Unwanted event: "_view + qBAD_e44U(str_kJvr(note))) + (reason ? ("\n\t\t"_view + reason) : fu::str("."_fu))), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
            }
            else
                ss._notes |= note;

        }
        else
            BUG_gDsn((((((x7E_rA00((x7E_rA00("Relaxed spec.args.len("_view, fu::i64dec(EXT_gDsn(spec, ss, ctx, module).args.size())) + ") != original.args.len("_view), fu::i64dec(EXT_gDsn(t, ss, ctx, module).args.size())) + "):"_view) + "\n\n\t\t"_view) + join_yqDb(map_zUrb(EXT_gDsn(spec, ss, ctx, module).args, _current_fn, ss, ctx, _here, module, options), ", "_view)) + "\n\n\t\t"_view) + join_yqDb(map_zUrb(EXT_gDsn(t, ss, ctx, module).args, _current_fn, ss, ctx, _here, module, options), ", "_view)), ss, ctx, _here, module, options, _helpers);

    };
}

static Type_OiTm conversionTailType_gDsn(const Type_OiTm& from, fu::view<Target_VZrr> conversions, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    for (int i = conversions.size(); i-- > 0; )
    {
        const Target_VZrr& lastConv = conversions[i];
        if (GET_gDsn(lastConv, ss, ctx, _here, module).kind == Kind_Idfg_field)
            return make_field_reference_gDsn(conversionTailType_gDsn(from, fu::get_view_start0(conversions, i), ss, ctx, _here, module), GET_gDsn(lastConv, ss, ctx, _here, module), true, ctx, _here);
        else
            return Type_OiTm(GET_gDsn(lastConv, ss, ctx, _here, module).type);

    };
    return Type_OiTm(from);
}

static fu::str mangleArgTypes_gDsn(fu::view<SolvedNode_efhg> args, const Reorder_0MNg& reorder, fu::view<fu::vec<Target_VZrr>> conversions, const int REST_START, const Type_OiTm& REST_TYPE, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    /*MOV*/ fu::str mangle {};
    const int REST_END = (reorder ? reorder.map.size() : args.size());
    const int N = min_DbqN(REST_END, REST_START);
    for (int i = 0; i < N; i++)
    {
        if (i)
            mangle += ',';

        const int callsiteIndex = (reorder ? reorder.map[i] : i);
        const SolvedNode_efhg& arg = ((callsiteIndex >= 0) ? args[callsiteIndex] : (*(SolvedNode_efhg*)fu::NIL));
        Type_OiTm type = ((conversions.size() > i) ? conversionTailType_gDsn(arg.type, conversions[i], ss, ctx, _here, module) : Type_OiTm(arg.type));
        if (type)
            mangle += serializeType_1qjp(type.vtype, "mangle.conv"_view);

    };
    if (REST_START < REST_END)
    {
        if (REST_START)
            mangle += ',';

        mangle += serializeType_1qjp(REST_TYPE.vtype, "mangle[Nodes].rest"_view);
    };
    return /*NRVO*/ mangle;
}

                                #ifndef DEF___vdAbWnVZmAd
                                #define DEF___vdAbWnVZmAd
inline static void _vdAb(const Target_VZrr& target, int& parent_idx, const SolverState_aGlN& ss, const Module_wo7O& module)
{
    unsigned v;
    if ((v = unsigned((target._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))) || (int(unsigned(((target._packed >> 40ull) & 0xfffffull))) == module.modid))
    {
        const int local_of = localOf_gDsn(target, ss, module);
        if (parent_idx < local_of)
            parent_idx = local_of;

    };
}
                                #endif

                                #ifndef DEF_unpackAddrOfFn_gaRfKxfsbc9
                                #define DEF_unpackAddrOfFn_gaRfKxfsbc9
inline void unpackAddrOfFn_gaRf(fu::view<char> canon, int& parent_idx, const SolverState_aGlN& ss, const Module_wo7O& module)
{
    if (canon[0] == '@')
    {
        int offset = 1;
        while (offset < canon.size())
        {
            const Target_VZrr mi = parseLocalOrGlobal_xQNS(canon, offset);
            unsigned v;
            _vdAb(Target_xQNS(int(unsigned(((mi._packed >> 40ull) & 0xfffffull))), int(unsigned(((mi._packed >> 20ull) & 0xfffffull))), (v = unsigned((mi._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))))), parent_idx, ss, module);
        };
    }
    else
        fu::fail((("unpackAddrOfFn: No leading @ in `"_view + canon) + "`."_view));

}
                                #endif

                                #ifndef DEF_ensure_i5omguWys1g
                                #define DEF_ensure_i5omguWys1g
inline const Ephemeral_xhb4& ensure_i5om(fu::vec_range_mut<Ephemeral_xhb4> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a[i];
}
                                #endif

static const Ephemeral_xhb4& EPH_mut_iUdw(const int index, SolverState_aGlN& ss)
{
    return ensure_i5om(ss._ephemeral, index);
}

static const Map_BZ38& getSpecs_FDl5(const int parent_idx, SolverState_aGlN& ss)
{
    return EPH_mut_iUdw(parent_idx, ss).specs;
}

                                #ifndef DEF_get_X1BI7jJxIPc
                                #define DEF_get_X1BI7jJxIPc
inline const Target_VZrr& get_X1BI(const Set_XshD& _, fu::view<char> key, fu::view<Target_VZrr> values)
{
    fu::view<fu::str> keys_asc = _.keys_asc;
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_j5CR(keys_asc[i], key);
        if (cmp == 0)
            return values[i];
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    return (*(Target_VZrr*)fu::NIL);
}
                                #endif

                                #ifndef DEF_get_1BI4q3Gzjcg
                                #define DEF_get_1BI4q3Gzjcg
inline const Target_VZrr& get_1BI4(const Map_BZ38& _, fu::view<char> key)
{
    return get_X1BI(_.keys, key, _.vals);
}
                                #endif

                                #ifndef DEF_steal_ew2wtAaMD1d
                                #define DEF_steal_ew2wtAaMD1d
inline Map_v4nV steal_ew2w(Map_v4nV& v)
{
    /*MOV*/ Map_v4nV ret {};
    std::swap(v, ret);
    return /*NRVO*/ ret;
}
                                #endif

                                #ifndef DEF_x3Cx3E_sZV4Bxiwlr6
                                #define DEF_x3Cx3E_sZV4Bxiwlr6
inline int x3Cx3E_sZV4(const RetypeOrder_6uAI& a, const RetypeOrder_6uAI& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_odNT(a.retype_score, b.retype_score)))
        return cmp;
    else if ((cmp = x3Cx3E_odNT(a.index, b.index)))
        return cmp;

    return 0;
}
                                #endif

                                #ifndef DEF___yQF51vxqCne
                                #define DEF___yQF51vxqCne
inline static bool _yQF5(const RetypeOrder_6uAI& a, const RetypeOrder_6uAI& b)
{
    return x3Cx3E_sZV4(a, b) < 0;
}
                                #endif

                                #ifndef DEF_sort_pyPdGugY7mk
                                #define DEF_sort_pyPdGugY7mk
inline static void sort_pyPd(fu::vec_range_mut<RetypeOrder_6uAI> a)
{
    RetypeOrder_6uAI l {};
    RetypeOrder_6uAI r {};
    (void) l;
    (void) r;
    auto* data = a.data_mut();
    std::sort(data, data + a.size(), [&](auto& l, auto& r)
    {;
    bool lt = _yQF5(l, r);
    return lt;
            });

}
                                #endif

                                #ifndef DEF_sort_MmeFjbbtHW4
                                #define DEF_sort_MmeFjbbtHW4
inline void sort_MmeF(fu::vec_range_mut<RetypeOrder_6uAI> a)
{
    sort_pyPd(a);
}
                                #endif

                                #ifndef DEF_bfind_Emryw57Lrml
                                #define DEF_bfind_Emryw57Lrml
inline static int bfind_Emry(fu::view<fu::str> keys_asc, fu::view<char> key, Set_XshD& _, fu::vec_range<char> key_1, fu::vec_range_mut<TypeParam_Lrcu> values)
{
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_j5CR(keys_asc[i], key);
        if (cmp == 0)
            return i;
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    const int i = lo;
    values.insert(i, TypeParam_Lrcu{});
    _.keys_asc.insert(i, fu::str(key_1));
    return i;
}
                                #endif

                                #ifndef DEF_ref_sqiFXm2tzWe
                                #define DEF_ref_sqiFXm2tzWe
inline const TypeParam_Lrcu& ref_sqiF(Set_XshD& _, fu::vec_range<char> key, fu::vec_range_mut<TypeParam_Lrcu> values)
{
    const int idx = bfind_Emry(_.keys_asc, key, _, key, values);
    return values[idx];
}
                                #endif

                                #ifndef DEF_ref_NU9O04d2bWc
                                #define DEF_ref_NU9O04d2bWc
inline const TypeParam_Lrcu& ref_NU9O(Map_v4nV& _, fu::vec_range<char> key)
{
    return ref_sqiF(_.keys, key, _.vals);
}
                                #endif

                                #ifndef DEF_x21x3D_ZDMfM5XjHla
                                #define DEF_x21x3D_ZDMfM5XjHla
inline bool operator!=(fu::view<char> a, fu::view<char> b)
{
    return !!x3Cx3E_j5CR(a, b);
}
                                #endif

static bool isMutRef_gDsn(const Flags_Lzg8 flags)
{
    return !(~flags & (Flags_Lzg8_F_MUT | Flags_Lzg8_F_REF));
}

                                #ifndef DEF_ref_YYaL2Dy6LX4
                                #define DEF_ref_YYaL2Dy6LX4
inline TypeParam_Lrcu& ref_YYaL(Set_XshD& _, fu::vec_range<char> key, fu::vec_range_mut<TypeParam_Lrcu> values)
{
    const int idx = bfind_Emry(_.keys_asc, key, _, key, values);
    return values.mutref(idx);
}
                                #endif

                                #ifndef DEF_ref_hn2E7zV0qda
                                #define DEF_ref_hn2E7zV0qda
inline TypeParam_Lrcu& ref_hn2E(Map_v4nV& _, fu::vec_range<char> key)
{
    return ref_YYaL(_.keys, key, _.vals);
}
                                #endif

                                #ifndef DEF___Mc7IBGShmgj
                                #define DEF___Mc7IBGShmgj
inline static fu::view<Target_VZrr> _Mc7I(const Target_VZrr& target, fu::vec<Target_VZrr>& targets)
{
    return (targets += Target_VZrr(target));
}
                                #endif

                                #ifndef DEF_unpackAddrOfFn_L5tmtimzwK7
                                #define DEF_unpackAddrOfFn_L5tmtimzwK7
inline void unpackAddrOfFn_L5tm(fu::view<char> canon, fu::vec<Target_VZrr>& targets)
{
    if (canon[0] == '@')
    {
        int offset = 1;
        while (offset < canon.size())
        {
            const Target_VZrr mi = parseLocalOrGlobal_xQNS(canon, offset);
            unsigned v;
            _Mc7I(Target_xQNS(int(unsigned(((mi._packed >> 40ull) & 0xfffffull))), int(unsigned(((mi._packed >> 20ull) & 0xfffffull))), (v = unsigned((mi._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))))), targets);
        };
    }
    else
        fu::fail((("unpackAddrOfFn: No leading @ in `"_view + canon) + "`."_view));

}
                                #endif

                                #ifndef DEF_add_sjqYZjk1ROa
                                #define DEF_add_sjqYZjk1ROa
inline bool add_sjqY(Set_R8IU& _, const Target_VZrr& key)
{
    fu::view<Target_VZrr> keys_asc = _.keys_asc;
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_YjZY(keys_asc[i], key);
        if (cmp == 0)
            return false;
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    const int i = lo;
    _.keys_asc.insert(i, Target_VZrr(key));
    return true;
}
                                #endif

static void visitScope_gDsn(const bool local_scope, fu::view<ScopeItem_xiLD> items, fu::view<ScopeItem_xiLD> globals, fu::vec_range<char> id, const bool shadow, fu::vec<Target_VZrr>& result, Set_R8IU& unique, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here)
{
    int scope_iterator {};
    Target_VZrr target {};
    bool shadows {};
    while (!shadow && (target = (local_scope ? search_z0Qq(ss._scope.items, id, scope_iterator, ss._ss.items, shadows, fu::view<Target_VZrr>{}, ss._scope.globals, ctx, _here) : search_KHWe(items, id, scope_iterator, globals))))
    {
        if (add_sjqY(unique, target))
            result += Target_VZrr(target);

    };
}

                                #ifndef DEF_reverse_4l3Y8LVrgG3
                                #define DEF_reverse_4l3Y8LVrgG3
inline void reverse_4l3Y(fu::view_mut<Target_VZrr> a)
{
    const int n1 = (a.size() - 1);
    const int n2 = (a.size() >> 1);
    for (int i = 0; i < n2; i++)
        fu::view_swap(a, i, (n1 - i));

}
                                #endif

static fu::str isNotDefinedHere_gDsn(fu::view<char> id)
{
    return qID_e44U(id) + " is not defined here."_view;
}

static fu::vec<Target_VZrr> solveAddrOfFn_FDl5(fu::str&& id, const TokenIdx_5581& token, const Flags_Lzg8 flags, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, const fu::vec<Helpers_DyqV>& _helpers)
{
    const bool shadow = false;
    /*MOV*/ fu::vec<Target_VZrr> result {};
    Set_R8IU unique {};
    const Flags_Lzg8 qualified = (flags & Flags_Lzg8_F_COMPOUND_ID);
    const Scope_blWT& s = (qualified ? dequalify_andGetScope_gDsn(id, ss, ctx, _here, module, options, _helpers) : (*(Scope_blWT*)fu::NIL));
    visitScope_gDsn(!qualified, fu::get_view_start0(s.items, s.pub_items), fu::get_view_start0(s.globals, s.pub_globals), id, shadow, result, unique, ss, ctx, _here);
    reverse_4l3Y(result);
    return (result ? result : fail_gDsn(isNotDefinedHere_gDsn(id), fu::view<char>{}, TokenIdx_5581(token), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers)).destructive_move();
}

                                #ifndef DEF_collectNamedArgs_U42QOEIkxW8
                                #define DEF_collectNamedArgs_U42QOEIkxW8
inline static NamedArgs_UjiQ collectNamedArgs_U42Q(fu::view<Node_JjyR> args, int& minArity, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    /*MOV*/ NamedArgs_UjiQ ret {};
    bool some = false;
    for (int i = 0; i < args.size(); i++)
    {
        const Node_JjyR& arg = args[i];
        fu::vec_range<char> _0 {};
        ret.names.push(fu::str(((arg.kind == Kind_Idfg_argid) ? ((_0.ptr_reassign(((some = true), arg.value))) ? _0 : BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers)) : (*(fu::str*)fu::NIL))));
        if (arg.flags & Flags_Lzg8_F_ARGID_IS_OPTIONAL)
        {
            minArity--;
            add_ZwXY(ret.optional, i);
        };
    };
    if (some)
        return /*NRVO*/ ret;
    else
        BUG_gDsn("collectNamedArgs: no named arguments here"_view, ss, ctx, _here, module, options, _helpers);

}
                                #endif

                                #ifndef DEF_find_cVszpoH03s0
                                #define DEF_find_cVszpoH03s0
inline int find_cVsz(fu::view<fu::str> haystack, fu::view<char> needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

static bool reorderByArgIDs_gDsn(Reorder_0MNg& reorder, fu::view<fu::str> names, BitSet_mmp7&& optional, fu::view<Argument_bbKc> host_args, const int num_usings, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    reorder.applicable = true;
    reorder.map.clear();
    int used = 0;
    int offset = 0;
    int usings_left = num_usings;
    int ha_required = 0;
    int ha_bound_optional = 0;
    for (int i = 0; i < host_args.size(); i++)
    {
        const Argument_bbKc& host_arg = host_args[i];
        if (!(host_arg.flags & Flags_Lzg8_F_INJECTED))
        {
            int idx = find_cVsz(names, host_arg.name);
            if (idx < 0)
            {
                if (usings_left > 0)
                    usings_left--;
                else
                {
                    for (int i_1 = offset; i_1 < names.size(); i_1++)
                    {
                        offset++;
                        if (!names[i_1])
                        {
                            idx = i_1;
                            break;
                        };
                    };
                };
            }
            else
            {
                used++;
                remove_Na55(optional, idx);
            };
            reorder.map.push(idx);
            if (!(host_arg.dEfault || (host_arg.flags & Flags_Lzg8_F_IMPLICIT)))
                ha_required++;
            else if ((idx >= 0))
                ha_bound_optional++;

        };
    };
    if ((ha_bound_optional + ha_required) > (names.size() + num_usings))
        return false;
    else if (usings_left)
        BUG_gDsn("reorderByArgIDs: usings_left != 0"_view, ss, ctx, _here, module, options, _helpers);
    else
    {
        if (used != names.size())
        {
            for (int i_1 = 0; i_1 < names.size(); i_1++)
            {
                if (!names[i_1])
                    used++;

            };
            if ((used + popcount_ZwXY(optional)) != names.size())
                return false;

        };

        {
            int trailing_misses = 0;
            int non_trailing_misses = 0;
            for (int i_1 = reorder.map.size(); i_1-- > 0; )
            {
                if ((reorder.map[i_1] >= 0))
                {
                    while (i_1-- > 0)
                    {
                        if (reorder.map[i_1] < 0)
                            non_trailing_misses++;

                    };
                    break;
                }
                else
                    trailing_misses++;

            };
            const int trailing_usings = max_BjFA((num_usings - non_trailing_misses), 0);
            if (trailing_misses > trailing_usings)
                reorder.map.shrink((reorder.map.size() - (trailing_misses - trailing_usings)));

        };
        if (reorder.map.size() != names.size())
            return true;
        else
        {
            for (int i_1 = 0; i_1 < reorder.map.size(); i_1++)
            {
                if (reorder.map[i_1] != i_1)
                    return true;

            };
            clear_iUdw(reorder);
            return true;
        };
    };
}

                                #ifndef DEF___mzU7CwRfOa7
                                #define DEF___mzU7CwRfOa7
inline static void _mzU7(fu::view<char> n, const int i, fu::view<char> name, int& count, int& first)
{
    if ((n == name) && !count++)
        first = i;

}
                                #endif

                                #ifndef DEF_each_Ho2VXxFVx97
                                #define DEF_each_Ho2VXxFVx97
inline void each_Ho2V(fu::view<fu::str> a, fu::view<char> name, int& count, int& first)
{
    for (int i = 0; i < a.size(); i++)
        _mzU7(a[i], i, name, count, first);

}
                                #endif

static fu::str ERRMSG_findUnmatchedArgName_gDsn(const Reorder_0MNg& reorder, fu::view<fu::str> names, fu::view<Argument_bbKc> host_args, const Target_VZrr& target, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    BitSet_mmp7 used {};
    BitSet_mmp7 matched {};
    for (int i = 0; i < reorder.map.size(); i++)
    {
        const int pos = reorder.map[i];
        if ((pos >= 0))
        {
            add_ZwXY(used, pos);
            add_ZwXY(matched, i);
        };
    };
    fu::str fOr = (target ? (" for "_view + str_FDl5(target, false, ss, ctx, _here, module, options)) : fu::str{});
    for (int i_1 = 0; i_1 < names.size(); i_1++)
    {
        fu::view<char> name = names[i_1];
        const int i_2 = i_1;
        if (!(has_ZwXY(used, i_2)))
        {
            int count = 0;
            int first = names.size();
            each_Ho2V(names, name, count, first);
            if (first < i_2)
                return x7E_rA00((((((("Duplicate :named arguments"_view + fOr) + ": "_view) + qBAD_KW_e44U("arg"_view)) + " "_view) + qBAD_e44U(names[i_2])) + " explicitly provided "_view), fu::i64dec(count)) + " times."_view;
            else
                return ((((("Named :argument mismatch"_view + fOr) + ": no "_view) + qBAD_KW_e44U("arg"_view)) + " "_view) + qBAD_e44U(names[i_2])) + "."_view;

        };
    };
    for (int i_2 = 0; i_2 < host_args.size(); i_2++)
    {
        const Argument_bbKc& host_arg = host_args[i_2];
        const int i_3 = i_2;
        if (!host_arg.dEfault && !has_ZwXY(matched, i_3))
            return x7E_rA00(((((host_arg.flags & Flags_Lzg8_F_TYPENAME) ? "Missing type argument"_view : "Missing required argument"_view) + fOr) + ": "_view), str_wyx7(host_arg, false, _current_fn, ss, ctx, _here, module, options));

    };
    return ("Named :argument mismatch"_view + fOr) + ": BUG failing to explain what's wrong."_view;
}

static bool trySolveTypeParams_gDsn(const Node_JjyR& node, /*MOV*/ Type_OiTm&& type, fu::vec_range_mut<char> error, bool invariant, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    if (node.kind == Kind_Idfg_call)
    { {
        fu::view<Node_JjyR> items = node.items;
        if (items.size() == 1)
        {
            Type_OiTm _0 {};
            Type_OiTm _1 {};
            Type_OiTm _2 {};
            Type_OiTm _3 {};
            /*MOV*/ Type_OiTm t = ((node.value == "&"_view) ? ((_0 = tryClear_ref_9CJm(type, ctx, _here)) ? static_cast<Type_OiTm&&>(_0) : (__extension__ (
            {
                if (error)
                    error += ("\n\t    "_view + ("Not a reference: "_view + explainType_gDsn(type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)));

                return false;
                (void)0;
            }), fu::unreachable)) : ((node.value == "&mut"_view) ? ((_1 = tryClear_mutref_9CJm(type, ctx, _here)) ? static_cast<Type_OiTm&&>(_1) : (__extension__ (
            {
                if (error)
                    error += ("\n\t    "_view + ("Not a mutref: "_view + explainType_gDsn(type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)));

                return false;
                (void)0;
            }), fu::unreachable)) : ((node.value == "[]"_view) ? ((_2 = (is_zeroes_9CJm(type.vtype) ? Type_OiTm(t_zeroes) : ((invariant = true), tryClear_array_9CJm(type, ctx, _here, module)))) ? static_cast<Type_OiTm&&>(_2) : (__extension__ (
            {
                if (error)
                    error += ("\n\t    "_view + ("Not an array: "_view + explainType_gDsn(type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)));

                return false;
                (void)0;
            }), fu::unreachable)) : ((node.value == "[..]"_view) ? ((_3 = (is_zeroes_9CJm(type.vtype) ? Type_OiTm(t_zeroes) : ((invariant = true), tryClear_sliceable_1qjp(type.vtype, ctx, _here, module)))) ? static_cast<Type_OiTm&&>(_3) : (__extension__ (
            {
                if (error)
                    error += ("\n\t    "_view + ("Not sliceable: "_view + explainType_gDsn(type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)));

                return false;
                (void)0;
            }), fu::unreachable)) : (__extension__ (
            {
                goto BL_1;
                (void)0;
            }), fu::unreachable)))));
            const Node_JjyR* _4;
            return trySolveTypeParams_gDsn((*(_4 = &(node.items[0])) ? *_4 : BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers)), static_cast<Type_OiTm&&>(t), error, invariant, _current_fn, ss, ctx, _here, module, options, _helpers);
        };
      } BL_1:;
    }
    else if (node.kind == Kind_Idfg_typeparam)
    { {
        fu::vec_range<char> id = (node.value ? node.value : BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers));
        type = relax_typeParam_9CJm(Type_OiTm(type));
        TypeParam_Lrcu& param = ref_hn2E(ss._typeParams, id);
        if (param)
        {
            if (param.flags & TypeParamFlags_vSpZ_TP_isArgSpec)
                goto BL_12;
            else
            {
                if (invariant)
                {
                    if (!isAssignable_9CJm(type, param.matched, DONT_match_zeroes, false, ctx, _here))
                    {
                        if (error)
                        {
                            error += ("\n\t    "_view + ((("Incompatible types for "_view + qBAD_e44U(id)) + ": "_view) + explainTypeDiff_gDsn(param.matched, type, " -> "_view, ss, ctx, _here, module, options)));
                        };
                        return false;
                    };
                }
                else
                {
                    /*MOV*/ Type_OiTm uNion = type_trySuper_9CJm(param.matched, type, false, ctx, _here);
                    if (!uNion)
                    {
                        if (error)
                        {
                            error += ("\n\t    "_view + ((("Incompatible types for "_view + qBAD_e44U(id)) + ": "_view) + explainTypeDiff_gDsn(param.matched, type, " <-> "_view, ss, ctx, _here, module, options)));
                        };
                        return false;
                    }
                    else
                        type = static_cast<Type_OiTm&&>(uNion);

                };
                if (param.invariant && !isAssignable_9CJm(param.invariant, type, DONT_match_zeroes, false, ctx, _here))
                {
                    if (error)
                        error += ("\n\t    "_view + ((("Incompatible types for "_view + qBAD_e44U(id)) + ": "_view) + explainNotAssignable_gDsn(param.invariant, type, _current_fn, ss, ctx, _here, module, options)));

                    return false;
                };
            };
        };
        param.matched = type;
        if (invariant)
            param.invariant = static_cast<Type_OiTm&&>(type);

        return true;
      } BL_12:;
    }
    else if (node.kind == Kind_Idfg_typeunion)
    {
        const int error0 = error.size();
        Map_v4nV typeParams0 = ss._typeParams;
        for (int i = 0; i < node.items.size(); i++)
        {
            if (trySolveTypeParams_gDsn(node.items[i], static_cast<Type_OiTm&&>(type), error, invariant, _current_fn, ss, ctx, _here, module, options, _helpers))
            {
                error.shrink(error0);
                return true;
            }
            else
                ss._typeParams = typeParams0;

        };
        return false;
    };
    if (((node.kind == Kind_Idfg_call) && (node.flags & Flags_Lzg8_F_TEMPLATE) && (node.value != "typeof"_view)) || (node.kind == Kind_Idfg___serialized_addrof_type_fn))
    {
        fu::vec<Target_VZrr> targets {};
        if (node.kind == Kind_Idfg___serialized_addrof_type_fn)
            unpackAddrOfFn_L5tm(node.value, targets);
        else
            targets = solveAddrOfFn_FDl5(fu::str(node.value), node.token, (node.flags & Flags_Lzg8_F_COMPOUND_ID), ss, ctx, _here, module, options, _helpers);

        fu::view<char> pattern = tryGetPattern_Ot6w(type.vtype.canon);
        if (pattern)
        {
            Reorder_0MNg reorder {};
            int TODO_FIX_what_about_opt_args = 0;
            NamedArgs_UjiQ namedArgs = ((node.flags & Flags_Lzg8_F_CALL_HAS_NAMED_ARGS) ? collectNamedArgs_U42Q(node.items, TODO_FIX_what_about_opt_args, ss, ctx, _here, module, options, _helpers) : NamedArgs_UjiQ{});
            int offset = 0;
            for (; ; )
            {
                const Target_VZrr spec_of = parseGlobal_xQNS(pattern, offset);
                const int start = offset;
                bool isLastSubPattern {};
                scan_Ot6w(pattern, '|', offset, isLastSubPattern);

                { {
                    fu::view<char> pattern_1 = fu::get_view(pattern, start, offset);
                    const int targetsIdx = find_rD4C(targets, spec_of);
                    if (!(targetsIdx < 0))
                    {
                        targets.splice(targetsIdx, 1);
                        clear_iUdw(reorder);
                        if (namedArgs.names)
                        {
                            fu::view<Argument_bbKc> host_args = EXT_gDsn(spec_of, ss, ctx, module).args;
                            if (!reorderByArgIDs_gDsn(reorder, namedArgs.names, BitSet_mmp7(namedArgs.optional), host_args, 0, ss, ctx, _here, module, options, _helpers))
                            {
                                if (error)
                                    error += ("\n\t    "_view + ERRMSG_findUnmatchedArgName_gDsn(reorder, namedArgs.names, host_args, spec_of, _current_fn, ss, ctx, _here, module, options));

                                goto BL_37;
                            };
                        };
                        int numArgs = 0;

                        {
                            int offset_1 = 0;
                            for (; ; )
                            {
                                const int start_1 = offset_1;
                                bool isLastArgSpecType {};
                                scan_Ot6w(pattern_1, ':', offset_1, isLastArgSpecType);

                                { {
                                    fu::view<char> argSpecType = fu::get_view(pattern_1, start_1, offset_1);
                                    const int i = numArgs++;
                                    if (!((i >= node.items.size())))
                                    {
                                        const int callsiteIndex = (reorder ? reorder.map[i] : i);
                                        if (!(callsiteIndex < 0))
                                        {
                                            const Node_JjyR& node_1 = node.items[callsiteIndex];
                                            /*MOV*/ Type_OiTm type_1 = Type_OiTm { parseType_1qjp(argSpecType, ctx, _here, module), Lifetime_llCF{} };
                                            const Node_JjyR& node_2 = ((node_1.kind == Kind_Idfg_argid) ? only_hN9E(node_1.items) : node_1);
                                            if (!trySolveTypeParams_gDsn(node_2, static_cast<Type_OiTm&&>(type_1), error, true, _current_fn, ss, ctx, _here, module, options, _helpers))
                                                goto BL_37;
                                            else
                                                goto BL_45;

                                        };
                                    };
                                    if (error)
                                        error += ("\n\t    "_view + x7E_rA00((x7E_rA00("Missing type argument for "_view, str_FDl5(spec_of, false, ss, ctx, _here, module, options)) + ": "_view), str_wyx7(EXT_gDsn(spec_of, ss, ctx, module).args[i], false, _current_fn, ss, ctx, _here, module, options)));

                                    goto BL_37;
                                  } BL_45:;
                                };
                                if (isLastArgSpecType)
                                    break;
                                else
                                    offset_1++;

                            };
                        };
                        if (numArgs != node.items.size())
                        {
                            if (error)
                                error += ("\n\t    "_view + (x7E_rA00("Too many type arguments for "_view, str_FDl5(spec_of, false, ss, ctx, _here, module, options)) + "."_view));

                        }
                        else
                            return true;

                    };
                  } BL_37:;
                };
                if (isLastSubPattern)
                    break;
                else
                    offset++;

            };
        };
        if (error && targets)
        {
            for (int i = 0; i < targets.size(); i++)
            {
                if (error)
                    error += ("\n\t    "_view + ((x7E_rA00("Not produced by "_view, str_FDl5(targets[i], false, ss, ctx, _here, module, options)) + ": "_view) + explainType_gDsn(type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)));

            };
        };
        return false;
    }
    else
    {
        Type_OiTm expect = evalTypeAnnot_gDsn(node, false, _current_fn, ss, ctx, _here, module, options, _helpers);
        if (!isAssignable_9CJm(expect, type, DONT_match_zeroes, false, ctx, _here))
        {
            if (error)
                error += ("\n\t    "_view + ("Incompatible types: "_view + explainNotAssignable_gDsn(expect, type, _current_fn, ss, ctx, _here, module, options)));

            return false;
        }
        else
            return true;

    };
}

                                #ifndef DEF_mangleArgTypes_BKEkFm6hivh
                                #define DEF_mangleArgTypes_BKEkFm6hivh
inline static fu::str mangleArgTypes_BKEk(fu::view<Type_OiTm> args)
{
    /*MOV*/ fu::str mangle {};
    int numNonInjected = 0;
    for (int i = 0; i < args.size(); i++)
    {
        const Type_OiTm& arg = args[i];
        if (numNonInjected++)
            mangle += ',';

        if (arg)
            mangle += serializeType_1qjp(arg.vtype, "mangle[$T]"_view);

    };
    return /*NRVO*/ mangle;
}
                                #endif

                                #ifndef DEF_add_JHtkOYaHZm9
                                #define DEF_add_JHtkOYaHZm9
inline bool add_JHtk(Set_XshD& _, fu::vec_range<char> key)
{
    fu::view<fu::str> keys_asc = _.keys_asc;
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_j5CR(keys_asc[i], key);
        if (cmp == 0)
            return false;
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    const int i = lo;
    _.keys_asc.insert(i, fu::str(key));
    return true;
}
                                #endif

                                #ifndef DEF_remove_HljLw1oPPni
                                #define DEF_remove_HljLw1oPPni
inline bool remove_HljL(Set_XshD& _, fu::view<char> key)
{
    fu::view<fu::str> keys_asc = _.keys_asc;
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_j5CR(keys_asc[i], key);
        if (cmp == 0)
        {
            _.keys_asc.splice(i, 1);
            return true;
        }
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    return false;
}
                                #endif

                                #ifndef DEF___ZVdjooeWC53
                                #define DEF___ZVdjooeWC53
inline static void _ZVdj(const Target_VZrr& spec, SolverState_aGlN& ss, const Module_wo7O& module)
{
    intoTombstone_gDsn(spec, ss, module);
}
                                #endif

                                #ifndef DEF_each_CmxT8n5FBMl
                                #define DEF_each_CmxT8n5FBMl
inline void each_CmxT(const Map_BZ38& _, SolverState_aGlN& ss, const Module_wo7O& module)
{
    for (int i = 0; i < _.vals.size(); i++)
        _ZVdj(_.vals[i], ss, module);

}
                                #endif

static void intoTombstone_gDsn(const Target_VZrr& t, SolverState_aGlN& ss, const Module_wo7O& module)
{
    Extended_z0HS& ext = EXT_mut_gDsn(t, ss, module);
    ext = Extended_z0HS{};
    Overload_aO3i& o = GET_mut_gDsn(t, ss, module);
    o = Overload_aO3i{};
    o.kind = Kind_Idfg___tombstone;
    fu::vec<ChildTarget_FjNI> children = fu::vec<ChildTarget_FjNI>(EPH_gDsn(t, ss, module).children);
    for (int i = 0; i < children.size(); i++)
        intoTombstone_gDsn(Target_VZrr(children[i].target), ss, module);

    Map_BZ38 specs = EPH_gDsn(t, ss, module).specs;
    each_CmxT(specs, ss, module);
}

static void destroyOverload_gDsn(const Target_VZrr& t, SolverState_aGlN& ss, const Module_wo7O& module)
{
    intoTombstone_gDsn(t, ss, module);
}

static Map_BZ38& getSpecs_gDsn(const int parent_idx, SolverState_aGlN& ss)
{
    return EPH_mut_gDsn(parent_idx, ss).specs;
}

                                #ifndef DEF_bfind_E1D5xWm2AUl
                                #define DEF_bfind_E1D5xWm2AUl
inline static int bfind_E1D5(fu::view<fu::str> keys_asc, fu::view<char> key, Set_XshD& _, fu::vec_range<char> key_1, fu::vec_range_mut<Target_VZrr> values)
{
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_j5CR(keys_asc[i], key);
        if (cmp == 0)
            return i;
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    const int i = lo;
    values.insert(i, Target_VZrr{});
    _.keys_asc.insert(i, fu::str(key_1));
    return i;
}
                                #endif

                                #ifndef DEF_ref_osrghS8uax8
                                #define DEF_ref_osrghS8uax8
inline Target_VZrr& ref_osrg(Set_XshD& _, fu::vec_range<char> key, fu::vec_range_mut<Target_VZrr> values)
{
    const int idx = bfind_E1D5(_.keys_asc, key, _, key, values);
    return values.mutref(idx);
}
                                #endif

                                #ifndef DEF_ref_5gqED1XaKil
                                #define DEF_ref_5gqED1XaKil
inline Target_VZrr& ref_5gqE(Map_BZ38& _, fu::vec_range<char> key)
{
    return ref_osrg(_.keys, key, _.vals);
}
                                #endif

                                #ifndef DEF_id_yJizChF0ON8
                                #define DEF_id_yJizChF0ON8
inline static fu::str id_yJiz(const Target_VZrr& target, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    if (is_SPECFAIL_gDsn(target))
        return qBAD_e44U("SPEC_FAIL"_view);
    else
        return str_FDl5(target, false, ss, ctx, _here, module, options);

}
                                #endif

static void setSpec_gDsn(fu::vec_range<char> mangle, const Target_VZrr& target, const bool nx, const bool allowReplaceNonSpecfails, const int parent_idx, fu::view<char> error, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (error)
        BUG_gDsn("doTrySpec: setSpec on error path"_view, ss, ctx, _here, module, options, _helpers);
    else
    {
        Target_VZrr& t = ref_5gqE(getSpecs_gDsn(parent_idx, ss), mangle);
        if ((!t == nx) && (!t || is_SPECFAIL_gDsn(t) || allowReplaceNonSpecfails))
            t = target;
        else
        {
            const Target_VZrr* t_1;
            BUG_gDsn(((((((x7E_rA00((x7E_rA00("About to screw up royally, replacing spec: "_view, fu::i64dec((t_1 = &(t), int(unsigned((((*t_1)._packed >> 20ull) & 0xfffffull)))))) + " with "_view), fu::i64dec(int(unsigned(((target._packed >> 20ull) & 0xfffffull))))) + ", mangle: "_view) + mangle) + ", that's: "_view) + id_yJiz(t, ss, ctx, _here, module, options)) + " becoming "_view) + id_yJiz(target, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);
        };
    };
}

static void resetSpec_gDsn(const Target_VZrr& spec, const bool allowReplaceNonSpecfails, const int parent_idx, fu::view<char> error, const Set_XshD& mangles, Target_VZrr& currentSpec, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (spec != currentSpec)
    {
        currentSpec = spec;
        const Set_XshD* _;
        for (int i = 0; i < (_ = &(mangles), (*_).keys_asc.size()); i++)
        {
            const Set_XshD* __1;
            int i_1;
            setSpec_gDsn((__1 = &(mangles), i_1 = i, (*__1).keys_asc[i_1]), spec, false, allowReplaceNonSpecfails, parent_idx, error, ss, ctx, _here, module, options, _helpers);
        };
    };
}

static const Target_VZrr& SPECFAIL_gDsn(fu::view<char> reason, const int parent_idx, fu::vec_range_mut<char> error, const Target_VZrr& SPECFAIL_RentrySafety, const int err0, const Set_XshD& mangles, Target_VZrr& currentSpec, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, const fu::vec<Helpers_DyqV>& _helpers)
{
    if (error)
    {
        error += reason;
        if (!(error.size() > err0))
            BUG_gDsn("SPECFAIL: no error output"_view, ss, ctx, _here, module, options, _helpers);

    }
    else
        resetSpec_gDsn(SPECFAIL_RentrySafety, false, parent_idx, error, mangles, currentSpec, ss, ctx, _here, module, options, _helpers);

    return SPECFAIL_RentrySafety;
}

static bool isNativeBody_gDsn(const Node_JjyR& n_body)
{
    if (n_body.kind == Kind_Idfg_call)
        return n_body.value == "__native"_view;
    else
        return false;

}

                                #ifndef DEF_useConsumedType_ifNative_Yahjdh1xdvh
                                #define DEF_useConsumedType_ifNative_Yahjdh1xdvh
inline static bool useConsumedType_ifNative_Yahj(const TypeParam_Lrcu& tp)
{
    return TypeParamFlags_vSpZ((tp.flags & TypeParamFlags_vSpZ((TypeParamFlags_vSpZ_TP_isArgSpec | TypeParamFlags_vSpZ_TP_isTypenameArgSpec)))) == TypeParamFlags_vSpZ_TP_isArgSpec;
}
                                #endif

                                #ifndef DEF___rLO829liqcc
                                #define DEF___rLO829liqcc
inline static void _rLO8(TypeParam_Lrcu& tp)
{
    if (useConsumedType_ifNative_Yahj(tp))
        tp.flags |= TypeParamFlags_vSpZ_TP_needsConsumedTypes;

}
                                #endif

                                #ifndef DEF_each_fleDAHSlXPl
                                #define DEF_each_fleDAHSlXPl
inline void each_fleD(Map_v4nV& _)
{
    for (int i = 0; i < _.vals.size(); i++)
        _rLO8(_.vals.mutref(i));

}
                                #endif

static bool type_has_gDsn(const Type_OiTm& type, fu::view<char> tag, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (tag == "trivial"_view)
        return is_trivial_1qjp(type.vtype, ctx, _here, module);
    else if (tag == "copy"_view)
        return is_rx_copy_9CJm(type.vtype);
    else if (tag == "arithmetic"_view)
        return is_arithmetic_hxWW(type.vtype);
    else if (tag == "primitive"_view)
        return is_primitive_hxWW(type.vtype);
    else if (tag == "bitfield"_view)
        return is_bitfield_hxWW(type.vtype);
    else if (tag == "integral"_view)
        return is_integral_hxWW(type.vtype);
    else if (tag == "unsigned"_view)
        return is_unsigned_hxWW(type.vtype);
    else if (tag == "floating_point"_view)
        return is_floating_pt_hxWW(type.vtype);
    else if (tag == "mutref"_view)
        return is_mutref_9CJm(type, ctx, _here);
    else if (tag == "enum"_view)
        return is_enum_hxWW(type.vtype);
    else if (tag == "flags"_view)
        return is_flags_hxWW(type.vtype);
    else if (tag == "reinterpretable"_view)
        return is_reinterpretable_1qjp(type.vtype, ctx, _here, module);
    else if (tag == "zero_size"_view)
        return is_zst_1qjp(type.vtype, ctx, _here, module);
    else
        BUG_gDsn((("Unknown type tag: `"_view + tag) + "`."_view), ss, ctx, _here, module, options, _helpers);

}

                                #ifndef DEF_if_only_Ywo8Jz4Vew0
                                #define DEF_if_only_Ywo8Jz4Vew0
inline const Node_JjyR& if_only_Ywo8(fu::view<Node_JjyR> a)
{
    if (a.size() == 1)
        return a[0];
    else
        return (*(Node_JjyR*)fu::NIL);

}
                                #endif

static SolvedNode_efhg solveCall_gDsn(const Node_JjyR& node, fu::view<Target_VZrr> targets, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    /*MOV*/ fu::vec<SolvedNode_efhg> args = solveNodes_gDsn(node.items, DeadBreak_Z4ob_DeadBreak_Only_WhileSolvingRecursion, (*(Type_OiTm*)fu::NIL), (*(Type_OiTm*)fu::NIL), false, StaticEval_IZio{}, false, _current_fn, ss, ctx, _here, module, options, _helpers);
    if (is_AssumeNever_WhileSolvingRecursion_9CJm(if_last_Xdw0(args).type.vtype))
        return SolvedNode_efhg(last_c4M9(args));
    else
        return solveCall_FDl5(fu::str(node.value), static_cast<fu::vec<SolvedNode_efhg>&&>(args), node.flags, targets, _current_fn, ss, ctx, _here, module, options, _helpers);

}

static bool evalTypePattern_gDsn(const Node_JjyR& node, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    if (node.kind == Kind_Idfg_and)
    {
        for (int i = 0; i < node.items.size(); i++)
        {
            if (!evalTypePattern_gDsn(node.items[i], _current_fn, ss, ctx, _here, module, options, _helpers))
                return false;

        };
        return true;
    }
    else if (node.kind == Kind_Idfg_or)
    {
        Map_v4nV undo = ss._typeParams;
        for (int i = 0; i < node.items.size(); i++)
        {
            if (evalTypePattern_gDsn(node.items[i], _current_fn, ss, ctx, _here, module, options, _helpers))
                return true;
            else
                ss._typeParams = undo;

        };
        return false;
    }
    else if (node.kind == Kind_Idfg_typeassert)
    {
        const Node_JjyR* _0;
        const Node_JjyR& left = (*(_0 = &(node.items[0])) ? *_0 : BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers));
        const Node_JjyR* _1;
        const Node_JjyR& right = (*(_1 = &(node.items[1])) ? *_1 : BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers));
        /*MOV*/ Type_OiTm actual = evalTypeAnnot_gDsn(left, true, _current_fn, ss, ctx, _here, module, options, _helpers);
        if (right.kind == Kind_Idfg_typetag)
        {
            return type_has_gDsn(actual, (right.value ? right.value : fail_gDsn(str_HtGuB8H8tX5, fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers)), ss, ctx, _here, module, options, _helpers);
        }
        else
        {
            fu::str error {};
            const bool ok = trySolveTypeParams_gDsn(right, static_cast<Type_OiTm&&>(actual), error, false, _current_fn, ss, ctx, _here, module, options, _helpers);
            if (error)
                BUG_gDsn("Inefficient: trySolveTypeParams pushing errors when told not to (falsy errout)."_view, ss, ctx, _here, module, options, _helpers);
            else
            {
                if (ok)
                {
                    const Node_JjyR* _2;
                    const Node_JjyR& left_1 = (*(_2 = &((((left.kind == Kind_Idfg_call) && (left.value == "typeof"_view)) ? if_only_Ywo8(left.items) : (*(Node_JjyR*)fu::NIL)))) ? *_2 : left);
                    if (left_1.kind == Kind_Idfg_typeparam)
                    {
                        const fu::str& id = left_1.value;
                        if (get_mPhm(ss._typeParams, id).flags & TypeParamFlags_vSpZ_TP_needsConsumedTypes)
                        {
                            /*MOV*/ Type_OiTm expect = evalTypeAnnot_gDsn(right, false, _current_fn, ss, ctx, _here, module, options, _helpers);
                            TypeParam_Lrcu& tp = ref_hn2E(ss._typeParams, id);
                            Type_OiTm _3 {};
                            tp.consumed = (tp.consumed ? ((_3 = type_tryIntersect_9CJm(tp.consumed, expect, ctx, _here)) ? static_cast<Type_OiTm&&>(_3) : fail_gDsn(str_yf9vetBDKP3, fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers)) : static_cast<Type_OiTm&&>(expect));
                        };
                    };
                };
                return ok;
            };
        };
    }
    else if (node.kind == Kind_Idfg_not)
        return !evalTypePattern_gDsn(only_hN9E(node.items), _current_fn, ss, ctx, _here, module, options, _helpers);
    else if (node.kind == Kind_Idfg_call)
    {
        SolvedNode_efhg _4 {};
        const StaticEval_IZio res = (_4 = solveCall_gDsn(node, fu::view<Target_VZrr>{}, _current_fn, ss, ctx, _here, module, options, _helpers), tryAbstractEvalAsBool_gDsn(static_cast<SolvedNode_efhg&&>(_4), false, _current_fn, ss, ctx, _here, module, options, _helpers));
        if (res == StaticEval_IZio_SE_True)
            return true;
        else if (res == StaticEval_IZio_SE_False)
            return false;

    };
    fail_gDsn(str_9wi5bbjWhR5, fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
}

static const Node_JjyR& n_fn_wyx7(const Template_SsLx& tEmplate)
{
    return tEmplate.node;
}

static fu::view<Node_JjyR> sig_iUdw(const Template_SsLx& tEmplate)
{
    return n_fn_wyx7(tEmplate).items;
}

static Node_JjyR& n_fn_iUdw(Template_SsLx& tEmplate)
{
    return tEmplate.node;
}

static fu::view_mut<Node_JjyR> sig_wyx7(Template_SsLx& tEmplate)
{
    return n_fn_iUdw(tEmplate).items;
}

                                #ifndef DEF___9TuKec1jBKi
                                #define DEF___9TuKec1jBKi
inline static void _9TuK(TypeParam_Lrcu& tp)
{
    if (useConsumedType_ifNative_Yahj(tp))
        tp.matched = tp.consumed;

}
                                #endif

                                #ifndef DEF_each_n1d8oZoQJti
                                #define DEF_each_n1d8oZoQJti
inline void each_n1d8(Map_v4nV& _)
{
    for (int i = 0; i < _.vals.size(); i++)
        _9TuK(_.vals.mutref(i));

}
                                #endif

                                #ifndef DEF_starts_KTruIk69Bbk
                                #define DEF_starts_KTruIk69Bbk
inline bool starts_KTru(fu::view<Target_VZrr> a, const Target_VZrr& with)
{
    return a.size() && (a[0] == with);
}
                                #endif

                                #ifndef DEF___VONFfaREkP5
                                #define DEF___VONFfaREkP5
inline static void _VONF(ConvCache_ColsAndBakes_2n47& cc, const Target_VZrr& t)
{
    for (int i = cc.columns.paths.size(); i-- > 0; )
    {
        if (starts_KTru(cc.columns.paths[i], t))
        {
            cc.columns.types.splice(i, 1);
            cc.columns.paths.splice(i, 1);
            cc.columns.must_see.splice(i, 1);
        };
    };
}
                                #endif

                                #ifndef DEF_iF_t0bqbemC8K3
                                #define DEF_iF_t0bqbemC8K3
inline bool iF_t0bq(const Set_X4pj& _, const ValueType_JtNg& key, fu::view_mut<ConvCache_ColsAndBakes_2n47> values, const Target_VZrr& t)
{
    fu::view<ValueType_JtNg> keys_asc = _.keys_asc;
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_9721(keys_asc[i], key);
        if (cmp == 0)
        {
            _VONF(values.mutref(i), t);
            return true;
        }
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    return false;
}
                                #endif

                                #ifndef DEF_iF_qWPoVjyzjVf
                                #define DEF_iF_qWPoVjyzjVf
inline bool iF_qWPo(Map_OMJS& _, const ValueType_JtNg& key, const Target_VZrr& t)
{
    return iF_t0bq(_.keys, key, _.vals, t);
}
                                #endif

                                #ifndef DEF___kQcwlfzE144
                                #define DEF___kQcwlfzE144
inline static void _kQcw(ConvCache_ColsAndBakes_2n47& cc, const Target_VZrr& t)
{
    for (int i = cc.columns.paths.size(); i-- > 0; )
    {
        if (has_bkvR(cc.columns.paths[i], t))
        {
            cc.columns.types.splice(i, 1);
            cc.columns.paths.splice(i, 1);
            cc.columns.must_see.splice(i, 1);
        };
    };
}
                                #endif

                                #ifndef DEF_each_674RNhxhqQf
                                #define DEF_each_674RNhxhqQf
inline void each_674R(Map_OMJS& _, const Target_VZrr& t)
{
    for (int i = 0; i < _.vals.size(); i++)
        _kQcw(_.vals.mutref(i), t);

}
                                #endif

static void Scope_pop_gDsn(const ScopeMemo_9hVQ& memo, SolverState_aGlN& ss, fu::vec<Helpers_DyqV>& _helpers)
{
    for (int i = memo.usings_len; i < ss._scope.usings.size(); i++)
    {
        const Target_VZrr& t = ss._scope.usings[i];
        iF_qWPo(ss._conv_cache, ValueType_JtNg{}, t);
    };
    for (int i_1 = memo.converts_len; i_1 < ss._scope.converts.size(); i_1++)
    {
        const Target_VZrr& t = ss._scope.converts[i_1];
        each_674R(ss._conv_cache, t);
    };
    ss._scope.items.shrink(memo.items_len);
    ss._scope.implicits.shrink(memo.implicits_len);
    ss._scope.imports.shrink(memo.imports_len);
    ss._scope.privates.shrink(memo.privates_len);
    ss._scope.usings.shrink(memo.usings_len);
    ss._scope.converts.shrink(memo.converts_len);
    _helpers.shrink(memo.helpers_len);
}

                                #ifndef DEF_if_last_EKfEFRHvrUk
                                #define DEF_if_last_EKfEFRHvrUk
inline const ScopeSkip_iozY& if_last_EKfE(fu::view<ScopeSkip_iozY> a)
{
    if (a.size())
        return a[(a.size() - 1)];
    else
        return (*(ScopeSkip_iozY*)fu::NIL);

}
                                #endif

                                #ifndef DEF_last_uVe3mRf8u9j
                                #define DEF_last_uVe3mRf8u9j
inline ScopeSkip_iozY& last_uVe3(fu::view_mut<ScopeSkip_iozY> a)
{
    return a.mutref((a.size() - 1));
}
                                #endif

static void ScopeSkip_push_gDsn(fu::vec_range_mut<ScopeSkip_iozY> scope_skip, const int start, const int end, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if ((start <= end))
    {
        if (!(end == start))
        {
            const ScopeSkip_iozY& last = if_last_EKfE(scope_skip);
            if ((last.end <= start))
            {
                if (scope_skip && (last.end == start))
                    last_uVe3(scope_skip).end = end;
                else
                {
                    scope_skip += ScopeSkip_iozY { start, end };
                };
            }
            else
                BUG_gDsn("ScopeSkip_push: last.end > start."_view, ss, ctx, _here, module, options, _helpers);

        };
    }
    else
        BUG_gDsn("ScopeSkip_push: bad args."_view, ss, ctx, _here, module, options, _helpers);

}

static bool Scope_import_gDsn(const int modid, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here)
{

    {
        fu::view<int> items = ss._scope.imports;
        fu::view<ScopeSkip_iozY> scope_skip = ss._ss.imports;
        const int start = 0;
        const ScopeSkip_iozY END_DUMMY = ScopeSkip_iozY { items.size(), items.size() };
        int i0 = start;
        for (int i = 0; i < (scope_skip.size() + 1); i++)
        {
            const ScopeSkip_iozY& ss_1 = ((i < scope_skip.size()) ? scope_skip[i] : END_DUMMY);
            if (!((ss_1.end <= i0)))
            {
                const int i1 = ss_1.start;
                for (int i_1 = i0; i_1 < i1; i_1++)
                {
                    const int m = items[i_1];
                    if (m == modid)
                        return false;

                };
                i0 = ss_1.end;
            };
        };
    };
    if (modid)
    {
        ss._scope.imports += modid;
        _Scope_import__forceCopy_gDsn(modid, false, ss, ctx);
        return true;
    }
    else
        BUG_u9Gb("Attempting to import modid-0."_view, ctx, _here);

}

static void Scope_import_privates_gDsn(const int modid, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here)
{

    {
        fu::view<int> items = ss._scope.privates;
        fu::view<ScopeSkip_iozY> scope_skip = ss._ss.privates;
        const int start = 0;
        const ScopeSkip_iozY END_DUMMY = ScopeSkip_iozY { items.size(), items.size() };
        int i0 = start;
        for (int i = 0; i < (scope_skip.size() + 1); i++)
        {
            const ScopeSkip_iozY& ss_1 = ((i < scope_skip.size()) ? scope_skip[i] : END_DUMMY);
            if (!((ss_1.end <= i0)))
            {
                const int i1 = ss_1.start;
                for (int i_1 = i0; i_1 < i1; i_1++)
                {
                    const int m = items[i_1];
                    if (m == modid)
                        return;

                };
                i0 = ss_1.end;
            };
        };
    };
    if (modid)
    {
        ss._scope.privates += modid;
        _Scope_import__forceCopy_gDsn(modid, true, ss, ctx);
    }
    else
        BUG_u9Gb("Attempting to import_privates modid-0."_view, ctx, _here);

}

                                #ifndef DEF_update_25tmopuQ4Fe
                                #define DEF_update_25tmopuQ4Fe
inline bool update_25tm(Set_XshD& _, fu::vec_range<char> key, fu::vec_range_mut<Type_OiTm> values, const Type_OiTm& value)
{
    fu::view<fu::str> keys_asc = _.keys_asc;
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_j5CR(keys_asc[i], key);
        if (cmp == 0)
        {
            values.mutref(i) = Type_OiTm(value);
            return false;
        }
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    const int i = lo;
    _.keys_asc.insert(i, fu::str(key));
    values.insert(i, Type_OiTm(value));
    return true;
}
                                #endif

                                #ifndef DEF_set_JBBNENzNiY9
                                #define DEF_set_JBBNENzNiY9
inline bool set_JBBN(Map_qY9d& _, fu::vec_range<char> key, const Type_OiTm& value)
{
    return update_25tm(_.keys, key, _.vals, value);
}
                                #endif

static void createTypedef_gDsn(fu::vec_range<char> id, const Type_OiTm& annot, const Flags_Lzg8 flags, const TokenIdx_5581& token, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    const Struct_LDkB& s = tryLookupUserType_1qjp(annot.vtype, ctx, _here, module);
    const Target_VZrr target = createRawTypedef_gDsn(id, Type_OiTm(annot), flags, (*(fu::str*)fu::NIL), SolverStatus_h9em{}, ss, module);
    if (s.target)
    {
        const Flags_Lzg8 TODO_FIX_flags0 = GET_gDsn(target, ss, ctx, _here, module).flags;
        EXT_mut_gDsn(target, ss, module) = Extended_z0HS(EXT_gDsn(s.target, ss, ctx, module));
        GET_mut_gDsn(target, ss, module) = Overload_aO3i(GET_gDsn(s.target, ss, ctx, _here, module));
        Overload_aO3i& o = GET_mut_gDsn(target, ss, module);
        o.flags |= (TODO_FIX_flags0 & Flags_Lzg8_F_PUB);
    };
    if (token)
        GET_mut_gDsn(target, ss, module).solved.token = TokenIdx_5581(token);

}

                                #ifndef DEF___R4ttHV4WSt2
                                #define DEF___R4ttHV4WSt2
inline static void _R4tt(fu::vec_range<char> id, const TypeParam_Lrcu& tp, SpecExtras_JI9K& res, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    const Type_OiTm& type = tp.matched;
    if (!(!type))
    {
        if (tp.flags & TypeParamFlags_vSpZ_TP_isArgSpec)
            set_JBBN(res.arg_spec_types, id, type);
        else
        {
            createTypedef_gDsn(id, type, Flags_Lzg8{}, TokenIdx_5581{}, ss, ctx, _here, module);
        };
    };
}
                                #endif

                                #ifndef DEF_each_51T6NcmDkzc
                                #define DEF_each_51T6NcmDkzc
inline void each_51T6(const Map_v4nV& _, SpecExtras_JI9K& res, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    for (int i = 0; i < _.vals.size(); i++)
    {
        fu::vec_range<char> key = _.keys.keys_asc[i];
        _R4tt(key, _.vals[i], res, ss, ctx, _here, module);
    };
}
                                #endif

                                #ifndef DEF_steal_NE6yry1IIrl
                                #define DEF_steal_NE6yry1IIrl
inline fu::vec<ScopeItem_xiLD> steal_NE6y(fu::vec_range_mut<ScopeItem_xiLD> a, const int start)
{
    /*MOV*/ fu::vec<ScopeItem_xiLD> ret {};
    ret.resize((a.size() - start));
    for (int i = 0; i < ret.size(); i++)
        std::swap(ret.mutref(i), a.mutref((i + start)));

    a.shrink(start);
    return /*NRVO*/ ret;
}
                                #endif

static SpecExtras_JI9K intoSpecExtras_gDsn(const Map_v4nV& typeParams, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    /*MOV*/ SpecExtras_JI9K res {};
    const int scopeItems0 = ss._scope.items.size();
    each_51T6(typeParams, res, ss, ctx, _here, module);
    res.scope_items = steal_NE6y(ss._scope.items, scopeItems0);
    return /*NRVO*/ res;
}

static const Node_JjyR& n_fn_FDl5(const Template_SsLx& tEmplate)
{
    return tEmplate.node;
}

static SolvedNode_efhg solved_gDsn(const Node_JjyR& node, const Type_OiTm& type, fu::vec_range<SolvedNode_efhg> items, const Target_VZrr& target, const TokenIdx_5581& _here)
{
    return SolvedNode_gDsn(node.kind, type, node.flags, node.value, items, target, Helpers_DyqV{}, _here);
}

static fu::vec<SolvedNode_efhg>& outItems_gDsn(CurrentFn_QbLp& _current_fn)
{
    return _current_fn.out.items;
}

static void TODO_FIX_partialEvalTypeAnnot_gDsn(Node_JjyR& node, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    if (node.kind == Kind_Idfg_call)
    {
        if (node.flags & Flags_Lzg8_F_TEMPLATE)
        {
            fu::vec<Target_VZrr> targets = solveAddrOfFn_FDl5(fu::str(node.value), node.token, (node.flags & Flags_Lzg8_F_COMPOUND_ID), ss, ctx, _here, module, options, _helpers);
            node.kind = Kind_Idfg___serialized_addrof_type_fn;
            node.value = packAddrOfFn_9CJm(targets);
        }
        else if ((node.items.size() != 1) || ((node.value != "[]"_view) && (node.value != "[..]"_view) && (node.value != "&"_view) && (node.value != "&mut"_view)))
        {
            Type_OiTm type = evalTypeAnnot_gDsn(node, false, _current_fn, ss, ctx, _here, module, options, _helpers);
            node.kind = Kind_Idfg___serialized_type;
            node.value = serializeType_1qjp(type.vtype, "__serialized_type"_view);
            node.items.clear();
        };
    };
    if ((node.kind == Kind_Idfg_call) || (node.kind == Kind_Idfg_typeunion) || (node.kind == Kind_Idfg___serialized_addrof_type_fn))
        for (int i = 0; i < node.items.size(); i++)
            TODO_FIX_partialEvalTypeAnnot_gDsn(node.items.mutref(i), _current_fn, ss, ctx, _here, module, options, _helpers);
;
}

static fu::view_mut<SolvedNode_efhg> outItems_wyx7(CurrentFn_QbLp& _current_fn)
{
    return _current_fn.out.items;
}

                                #ifndef DEF_get_uhf5u3IWFwg
                                #define DEF_get_uhf5u3IWFwg
inline const Type_OiTm& get_uhf5(const Set_XshD& _, fu::view<char> key, fu::view<Type_OiTm> values)
{
    fu::view<fu::str> keys_asc = _.keys_asc;
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_j5CR(keys_asc[i], key);
        if (cmp == 0)
            return values[i];
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    return (*(Type_OiTm*)fu::NIL);
}
                                #endif

                                #ifndef DEF_get_Inl8Mglo5Lh
                                #define DEF_get_Inl8Mglo5Lh
inline const Type_OiTm& get_Inl8(const Map_qY9d& _, fu::view<char> key)
{
    return get_uhf5(_.keys, key, _.vals);
}
                                #endif

static SolvedNode_efhg solveTypedef_gDsn(const Node_JjyR& node, const bool asArgument, const Type_OiTm& specType, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    if (node.items[LET_TYPE])
    {
        _here = node.items[LET_TYPE].token;
        fail_gDsn(str_Rsr05MN8ZAi, fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
    }
    else if (specType && !is_Typename_9CJm(specType))
        BUG_gDsn("solveTypedef: specType is not a Typename"_view, ss, ctx, _here, module, options, _helpers);
    else
    {
        const Node_JjyR* _0;
        /*MOV*/ Type_OiTm annot = (specType ? Type_OiTm(specType) : evalTypeAnnot_gDsn((*(_0 = &(node.items[LET_INIT])) ? *_0 : fail_gDsn(str_vevxISs7fYh, fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers)), false, _current_fn, ss, ctx, _here, module, options, _helpers));
        fu::vec_range<char> id = ((node.flags & Flags_Lzg8_F_COMPOUND_ID) ? cleanID_V5Iu(node.value) : node.value);
        createTypedef_gDsn(id, annot, node.flags, node.token, ss, ctx, _here, module);
        if (asArgument)
        {
            Type_OiTm relaxed = static_cast<Type_OiTm&&>(annot);
            relaxed.vtype.quals &= ~q_USAGE;
            return createEmpty_gDsn(relaxed, Target_VZrr{}, ss, ctx, _here, module, options, _helpers);
        }
        else
        {
            return createEmpty_gDsn(t_void, Target_VZrr{}, ss, ctx, _here, module, options, _helpers);
        };
    };
}

                                #ifndef DEF_at_most_one_set_IBpMXGk50q5
                                #define DEF_at_most_one_set_IBpMXGk50q5
inline static bool at_most_one_set_IBpM(const uint64_t v)
{
    return !(v & (v - 1ull));
}
                                #endif

static SolvedNode_efhg solveLetLike_dontTouchScope_gDsn(const Node_JjyR& node, const bool asArgument, const Type_OiTm& specType, const Type_OiTm& primType, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    Flags_Lzg8 flags = node.flags;
    if (at_most_one_set_IBpM(uint64_t((flags & (Flags_Lzg8_F_VAL | Flags_Lzg8_F_REF)))))
    {
        if (at_most_one_set_IBpM(uint64_t((flags & (Flags_Lzg8_F_CONST | Flags_Lzg8_F_MUT)))))
        {
            const Node_JjyR& n_annot = node.items[LET_TYPE];
            Type_OiTm specType_1 {};
            Type_OiTm annot_1 {};
            Type_OiTm annot = ((specType && (!n_annot || (n_annot.kind == Kind_Idfg_typeunion) || !is_zeroes_9CJm(specType.vtype))) ? static_cast<Type_OiTm&&>(const_cast<Type_OiTm&>((specType_1 = ((!(flags & Flags_Lzg8_F_REF) || (flags & Flags_Lzg8_F_CONST)) ? clear_mutref_9CJm(Type_OiTm(specType)) : Type_OiTm(specType)), specType_1))) : (primType ? Type_OiTm(primType) : (annot_1 = (n_annot ? evalTypeAnnot_gDsn(n_annot, false, _current_fn, ss, ctx, _here, module, options, _helpers) : Type_OiTm{}), ((annot_1 && ((node.flags & (Flags_Lzg8_F_REF | Flags_Lzg8_F_CONST)) == Flags_Lzg8_F_REF)) ? add_mutref_9CJm(static_cast<Type_OiTm&&>(annot_1), Lifetime_temporary, ctx, _here) : static_cast<Type_OiTm&&>(annot_1)))));
            const Node_JjyR& n_init = (!specType ? node.items[LET_INIT] : (*(Node_JjyR*)fu::NIL));
            /*MOV*/ SolvedNode_efhg init = (n_init ? solveNode_gDsn(n_init, annot, _current_fn, ss, ctx, _here, module, options, _helpers) : SolvedNode_efhg{});
            if (ParseSyntax_Lay2((node.syntax & ParseSyntax_Lay2_PS_USING_EXPRESSION)) && !annot && is_ref_9CJm(init.type))
                flags |= Flags_Lzg8_F_REF;

            _here = node.token;
            return createLetLike_dontTouchScope_gDsn(node.value, flags, static_cast<SolvedNode_efhg&&>(init), asArgument, annot, _current_fn, ss, ctx, _here, module, options, _helpers);
        }
        else
            BUG_gDsn("F_CONST & F_MUT both set"_view, ss, ctx, _here, module, options, _helpers);

    }
    else
        BUG_gDsn("F_VAL & F_REF both set"_view, ss, ctx, _here, module, options, _helpers);

}

static SolvedNode_efhg solveLet_gDsn(const Node_JjyR& node, const bool asArgument, const Type_OiTm& specType, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    if (node.flags & Flags_Lzg8_F_TYPENAME)
        return solveTypedef_gDsn(node, asArgument, specType, _current_fn, ss, ctx, _here, module, options, _helpers);
    else
    {
        SolvedNode_efhg out = solveLetLike_dontTouchScope_gDsn(node, asArgument, specType, (*(Type_OiTm*)fu::NIL), _current_fn, ss, ctx, _here, module, options, _helpers);
        const fu::str& id = out.value;
        return solveLet_createBindingAndGetLetdef_gDsn(SolvedNode_efhg(out), id, true, asArgument, node.asserts, _current_fn, ss, ctx, _here, module, options, _helpers);
    };
}

extern const Type_OiTm t_AssumeNever_WhileSolvingRecursion;
                                #ifndef DEF___nOR6lNMF55j
                                #define DEF___nOR6lNMF55j
inline static bool _nOR6(const int locid)
{
    return !!locid;
}
                                #endif

                                #ifndef DEF_Lifetime_if_only_mIQqKEH7JZd
                                #define DEF_Lifetime_if_only_mIQqKEH7JZd
inline bool Lifetime_if_only_mIQq(const Lifetime_llCF& lifetime)
{

    {
        fu::view<char> chars = lifetime.uni0n;
        int offset = 0;
        while (offset < chars.size())
        {
            const int offset0 = offset;
            const unsigned r = parse7bit_7Yz9(chars, offset);
            for (; ; )
            {
                bool isLastPath = false;
                bool isFirstSubRegion = true;
                for (; ; )
                {
                    const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                    isLastPath = !(raw_flatCount & 1u);
                    if (isLastSubRegion)
                        break;
                    else
                        isFirstSubRegion = false;

                };
                if (isLastPath)
                    break;

            };
            const bool isOnly = (!offset0 ? (offset == chars.size()) : false);
            unsigned v;
            const int locid = ((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))));
            if (isOnly)
                return _nOR6(locid);
            else
                return false;

        };
    };
    return false;
}
                                #endif

static Lifetime_llCF Lifetime_fromNative_gDsn(fu::view<Node_JjyR> sig, fu::view<SolvedNode_efhg> args, const Type_OiTm& actual, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    /*MOV*/ Type_OiTm res {};
    if ((sig.size() + FN_ARGS_BACK) == args.size())
    {
        for (int i = 0; i < args.size(); i++)
        {
            if (sig[i].flags & Flags_Lzg8_F_REF)
            {
                if (res)
                {
                    fail_gDsn(str_KgyUI9xCo7c, fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                }
                else
                {
                    res = GET_gDsn(args[i].target, ss, ctx, _here, module).type;
                    if (!(res.lifetime))
                    {
                        fail_gDsn(str_lPIs9JAS638, fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                    };
                };
            };
        };
        if (res.lifetime)
        {
            if (Lifetime_if_only_mIQq(res.lifetime) || is_zst_1qjp(res.vtype, ctx, _here, module))
            {
                if (!isAssignable_9CJm(actual, res, false, false, ctx, _here))
                {
                    const int flatCount = getFlatCount_1qjp(actual.vtype, ctx, _here, module);
                    if (!flatCount)
                    {
                        return Lifetime_llCF(Lifetime_static_moveable);
                    }
                    else
                    {
                        return Lifetime_makeShared_7Yz9(res.lifetime, flatCount, ctx, _here);
                    };
                }
                else
                {
                    return static_cast<Lifetime_llCF&&>(res.lifetime);
                };
            }
            else
            {
                fail_gDsn(x7E_rA00("Infered a non-single-local __native lifetime: "_view, str_gDsn(res.lifetime, false, ss, ctx, _here, module, options)), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
            };
        }
        else
        {
            fail_gDsn(str_cff6zKl3Fj7, fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
        };
    }
    else
        BUG_gDsn("sig.len != args.len"_view, ss, ctx, _here, module, options, _helpers);

}

                                #ifndef DEF_starts_SfbfOAVfSee
                                #define DEF_starts_SfbfOAVfSee
inline bool starts_Sfbf(fu::view<char> a, const char with)
{
    return a.size() && (a[0] == with);
}
                                #endif

extern const FxMask_2dRz EFFECTS_output;
                                #ifndef DEF_parse_fcZvSOyFZa2
                                #define DEF_parse_fcZvSOyFZa2
inline FxMask_2dRz parse_fcZv(fu::view<char> v)
{
    if (v == "Fx_NotDeadCode"_view)
        return FxMask_2dRz_Fx_NotDeadCode;
    else if (v == "Fx_NonDeterministic"_view)
        return FxMask_2dRz_Fx_NonDeterministic;
    else if (v == "Fx_DontMoveUp"_view)
        return FxMask_2dRz_Fx_DontMoveUp;
    else if (v == "Fx_DontMoveDown"_view)
        return FxMask_2dRz_Fx_DontMoveDown;
    else if (v == "Fx_Input"_view)
        return FxMask_2dRz_Fx_Input;
    else if (v == "Fx_Output"_view)
        return FxMask_2dRz_Fx_Output;
    else if (v == "Fx_Throws"_view)
        return FxMask_2dRz_Fx_Throws;
    else if (v == "Fx_Crashes"_view)
        return FxMask_2dRz_Fx_Crashes;
    else if (v == "Fx_Crashes_Div0"_view)
        return FxMask_2dRz_Fx_Crashes_Div0;
    else if (v == "Fx_Crashes_OOB"_view)
        return FxMask_2dRz_Fx_Crashes_OOB;
    else if (v == "Fx_Crashes_Assert"_view)
        return FxMask_2dRz_Fx_Crashes_Assert;
    else if (v == "Fx_Crashes_Exit"_view)
        return FxMask_2dRz_Fx_Crashes_Exit;
    else if (v == "Fx_Syscall"_view)
        return FxMask_2dRz_Fx_Syscall;
    else if (v == "Fx_Blocks"_view)
        return FxMask_2dRz_Fx_Blocks;
    else if (v == "Fx_Blocks_Alloc"_view)
        return FxMask_2dRz_Fx_Blocks_Alloc;
    else if (v == "Fx_Blocks_Await"_view)
        return FxMask_2dRz_Fx_Blocks_Await;

    return FxMask_2dRz{};
}
                                #endif

                                #ifndef DEF_ensure_2Giz4sIWyKi
                                #define DEF_ensure_2Giz4sIWyKi
inline int& ensure_2Giz(fu::vec_range_mut<int> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

                                #ifndef DEF___dP9rD8lRdZ7
                                #define DEF___dP9rD8lRdZ7
inline static const ValueType_JtNg& _dP9r(const ValueType_JtNg& itemType)
{
    if (is_rx_copy_9CJm(itemType))
        return itemType;
    else
        return (*(ValueType_JtNg*)fu::NIL);

}
                                #endif

                                #ifndef DEF_if_sliceable_3fNj7tI4LEj
                                #define DEF_if_sliceable_3fNj7tI4LEj
inline ValueType_JtNg if_sliceable_3fNj(const ValueType_JtNg& type, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    if (is_sliceable_hxWW(type))
        return fu::move_or_default(const_cast<ValueType_JtNg&>(_dP9r(parseType_1qjp(fu::get_view(type.canon, 1, (type.canon.size() - 1)), ctx, _here, module))));
    else
    {
        return ValueType_JtNg{};
    };
}
                                #endif

static fu::str CompoundArgID_outerSplice_gDsn(fu::vec_range_mut<char> name, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, const fu::vec<Helpers_DyqV>& _helpers)
{
    bool exclam = false;
    for (int i = 0; i < name.size(); i++)
    {
        const char c = name[i];
        if (c == '!')
        {
            if (exclam)
                BUG_gDsn((("CompoundArgID: double bang in `"_view + name) + "`."_view), ss, ctx, _here, module, options, _helpers);
            else
            {
                exclam = true;
                const int i0 = i++;
                for (; i < name.size(); i++)
                {
                    if (name[i] == '.')
                        break;

                };
                name.splice(i0, (i - i0));
                i = (i0 - 1);
            };
        }
        else if (c == '.')
        {
            /*MOV*/ fu::str ret = fu::str(fu::get_range(name, (i + 1)));
            name.shrink(i);
            return /*NRVO*/ ret;
        };
    };
    if (!exclam)
        BUG_gDsn((("CompoundArgID: no `.` nor `!` in id `"_view + name) + "`."_view), ss, ctx, _here, module, options, _helpers);
    else
    {
        return fu::str{};
    };
}

                                #ifndef DEF_iF_9bSloYAliZc
                                #define DEF_iF_9bSloYAliZc
inline unsigned iF_9bSl(fu::view<unsigned> a, const int i)
{
    if (uNsigned_40Hl(i) < uNsigned_40Hl(a.size()))
        return a[i];
    else
        return 0u;

}
                                #endif

                                #ifndef DEF_iF_BZQzBsYJSuf
                                #define DEF_iF_BZQzBsYJSuf
inline static unsigned iF_BZQz(const LocidMap_IP5H& map, const int locid, const CurrentFn_QbLp& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    return iF_9bSl(map._values, (args_neg + locid));
}
                                #endif

                                #ifndef DEF_iF_4ygva58qrBb
                                #define DEF_iF_4ygva58qrBb
inline const LocidSet_iAWt& iF_4ygv(fu::view<LocidSet_iAWt> a, const int i)
{
    if (uNsigned_40Hl(i) < uNsigned_40Hl(a.size()))
        return a[i];
    else
        return (*(LocidSet_iAWt*)fu::NIL);

}
                                #endif

                                #ifndef DEF_iF_dxP1u4ppk41
                                #define DEF_iF_dxP1u4ppk41
inline static const LocidSet_iAWt& iF_dxP1(const LocidMap_DNUT& map, const int locid, const CurrentFn_QbLp& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    return iF_4ygv(map._values, (args_neg + locid));
}
                                #endif

                                #ifndef DEF_iF_KelPbrBUghh
                                #define DEF_iF_KelPbrBUghh
inline int iF_KelP(fu::view<int> a, const int i)
{
    if (uNsigned_40Hl(i) < uNsigned_40Hl(a.size()))
        return a[i];
    else
        return 0;

}
                                #endif

                                #ifndef DEF___TY3zg7uK809
                                #define DEF___TY3zg7uK809
inline static void _TY3z(const int other, BitSet_mmp7& output, fu::view<int> argPos_1b)
{
    const int otherPos_1b = iF_KelP(argPos_1b, (-1 - other));
    if (otherPos_1b)
        add_ZwXY(output, (otherPos_1b - 1));

}
                                #endif

                                #ifndef DEF___Gnn7bMXC8Kj
                                #define DEF___Gnn7bMXC8Kj
inline static void _Gnn7(const int locid, const int args_neg, BitSet_mmp7& output, fu::view<int> argPos_1b)
{
    _TY3z((locid - args_neg), output, argPos_1b);
}
                                #endif

                                #ifndef DEF_each_IyIKMYlfbYg
                                #define DEF_each_IyIKMYlfbYg
inline void each_IyIK(const BitSet_mmp7& _, const int args_neg, BitSet_mmp7& output, fu::view<int> argPos_1b)
{
    for (int i = 0; i < _._data.size(); i++)
    {
        const fu::u8 item = _._data[i];
        if (item)
        {
            for (int b = 0; b < 8; b++)
            {
                const fu::u8 mask = fu::u8((fu::u8(1u) << fu::u8(unsigned(b))));
                if (item & mask)
                    _Gnn7(((i << 3) | int(b)), args_neg, output, argPos_1b);

            };
        };
    };
}
                                #endif

                                #ifndef DEF_each_ufvRdlU9Juj
                                #define DEF_each_ufvRdlU9Juj
inline static void each_ufvR(const LocidSet_iAWt& set, BitSet_mmp7& output, fu::view<int> argPos_1b, const CurrentFn_QbLp& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    each_IyIK(set._bitset, args_neg, output, argPos_1b);
}
                                #endif

static void ArgsAtRisk_list_gDsn(BitSet_mmp7& output, const LocidMap_DNUT& at_risk, fu::view<int> argPos_1b, const Target_VZrr& argTarget, const CurrentFn_QbLp& _current_fn)
{
    unsigned v;
    each_ufvR(iF_dxP1(at_risk, (v = unsigned((argTarget._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))), _current_fn), output, argPos_1b, _current_fn);
}

                                #ifndef DEF___Q6kIhnSBvPe
                                #define DEF___Q6kIhnSBvPe
inline static void _Q6kI(const int index, fu::view<SolvedNode_efhg> items, Set_qOJY& TODO_FIX_mayAlias_ensureStable, BitSet_mmp7& hard_risk, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    const Overload_aO3i& other = GET_gDsn(items[index].target, ss, ctx, _here, module);
    if (is_sliceable_hxWW(other.solved.type.vtype) && !TODO_FIX_isArray_9CJm(other.solved.type))
    {
        if (other.status & SolverStatus_h9em_SS_TODO_FIX_was_rx_resize)
            add_q7Be(TODO_FIX_mayAlias_ensureStable, index);
        else
            add_ZwXY(hard_risk, index);

    };
}
                                #endif

                                #ifndef DEF_each_c5gHqb2W8J4
                                #define DEF_each_c5gHqb2W8J4
inline void each_c5gH(const BitSet_mmp7& _, fu::view<SolvedNode_efhg> items, Set_qOJY& TODO_FIX_mayAlias_ensureStable, BitSet_mmp7& hard_risk, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    for (int i = 0; i < _._data.size(); i++)
    {
        const fu::u8 item = _._data[i];
        if (item)
        {
            for (int b = 0; b < 8; b++)
            {
                const fu::u8 mask = fu::u8((fu::u8(1u) << fu::u8(unsigned(b))));
                if (item & mask)
                    _Q6kI(((i << 3) | int(b)), items, TODO_FIX_mayAlias_ensureStable, hard_risk, ss, ctx, _here, module);

            };
        };
    };
}
                                #endif

static bool isNoVec_gDsn(const Type_OiTm& t, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    return is_trivial_1qjp(t.vtype, ctx, _here, module) || !(is_rx_copy_9CJm(t.vtype) || is_rx_resize_9CJm(t.vtype));
}

                                #ifndef DEF_visit_8CGM9TJCNTb
                                #define DEF_visit_8CGM9TJCNTb
inline static void visit_8CGM(const Lifetime_llCF& lifetime, bool& maybeOutOfOrder, const int needle, bool& found, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit_7Yz9(chars, offset);
        int offset0;
        int BL_3_v;
        const int sr = (__extension__ (
        {
            offset0 = (offset + 0);
            for (; ; )
            {
                bool isLastPath = false;
                bool isFirstSubRegion = true;
                for (; ; )
                {
                    const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                    isLastPath = !(raw_flatCount & 1u);
                    if (isLastSubRegion)
                        break;
                    else
                        isFirstSubRegion = false;

                };
                if (isLastPath)
                    break;

            };
            BL_3_v = (offset0);
            (void)0;
        }), BL_3_v);
        unsigned v;
        const int locid = ((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))));
        fu::view<char> paths = fu::get_view(chars, sr, offset);
        if (!(!locid || found))
        {
            if (locid == needle)
                found = true;
            else
            {
                const Type_OiTm& init = Lifetime_climbType_gDsn(nested_FDl5(locid, ss, ctx, _here), ss, ctx, _here, module, options, _helpers);
                if (is_ref_9CJm(init))
                {
                    Lifetime_llCF parent = Lifetime_op_join_7Yz9(init.lifetime, paths, ctx, _here);
                    maybeOutOfOrder = true;
                    visit_8CGM(parent, maybeOutOfOrder, needle, found, ss, ctx, _here, module, options, _helpers);
                };
            };
        };
    };
}
                                #endif

                                #ifndef DEF_Lifetime_process_HJGoh7hHKO7
                                #define DEF_Lifetime_process_HJGoh7hHKO7
inline Lifetime_llCF Lifetime_process_HJGo(const Lifetime_llCF& lifetime, const int needle, bool& found, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    /*MOV*/ Lifetime_llCF result {};
    bool maybeOutOfOrder = false;
    visit_8CGM(lifetime, maybeOutOfOrder, needle, found, ss, ctx, _here, module, options, _helpers);
    return /*NRVO*/ result;
}
                                #endif

static bool Lifetime_unwinds_through_gDsn(const Lifetime_llCF& lifetime, const int needle, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    bool found = false;
    Lifetime_process_HJGo(lifetime, needle, found, ss, ctx, _here, module, options, _helpers);
    return found;
}

static fu::str qSTACK_local_gDsn(const Target_VZrr& target, const int locid, fu::view<Target_VZrr> seen, const ArgQuery_O2xW query, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    return qSTACK_local_FDl5(target, GET_gDsn(target, ss, ctx, _here, module).solved, locid, seen, query, _current_fn, ss, ctx, _here, module, options, _helpers);
}

static fu::str qSTACK_arg_gDsn(const Target_VZrr& target, const int position, fu::view<Target_VZrr> seen, const ArgQuery_O2xW query, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const Target_VZrr* t;
    unsigned v;
    return qSTACK_local_gDsn(target, (t = &(EXT_gDsn(target, ss, ctx, module).args[position].target), v = unsigned(((*t)._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))), seen, query, _current_fn, ss, ctx, _here, module, options, _helpers);
}

static fu::str qSTACK_local_FDl5(const Target_VZrr& target, const SolvedNode_efhg& node, const int locid, fu::view<Target_VZrr> seen, const ArgQuery_O2xW query, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const Target_VZrr nestingFnort0 = exchange_GcK8(ss._nestingFnort, Target_VZrr(target));
    fu_DEFER(ss._nestingFnort = nestingFnort0);
    if (!seen)
        ss._qstack_safety = 0;
    else if (ss._qstack_safety++ > 1024)
        return fu::str("[QSTACK > 1024]"_fu);

    fu::vec<Target_VZrr> seen_1 = (seen + target);

    {
        fu::vec<SolvedNode_efhg> stack = fu::vec<SolvedNode_efhg> {{ SolvedNode_efhg(node) }};
        while (stack)
        {
            SolvedNode_efhg node_1 = TODO_FIX_pop_f7Nv(stack);
            const SolvedNode_efhg& node_2 = ((node_1.kind == Kind_Idfg_letdef) ? GET_gDsn(node_1.target, ss, ctx, _here, module).solved : node_1);
            const SolvedNode_efhg* __partcopy_ref;
            SolvedNode_efhg node_3 = (__partcopy_ref = &(((node_2.kind == Kind_Idfg___preceding_ref_arg) ? _current_fn.events.preceding_ref_args[node_2.helpers.index].arg : node_2)), SolvedNode_efhg { (*__partcopy_ref).kind, {/*unused non-zst*/}, {/*unused non-zst*/}, {/*unused non-zst*/}, {/*unused non-zst*/}, fu::vec<SolvedNode_efhg>((*__partcopy_ref).items), TokenIdx_5581((*__partcopy_ref).token), {/*unused non-zst*/}, Target_VZrr((*__partcopy_ref).target) });
            if (node_3.kind != Kind_Idfg_call)
            {
                if ((query == ArgQuery_O2xW_AQ_WhyNotNovec) && ((node_3.kind == Kind_Idfg_copy) || (node_3.kind == Kind_Idfg_move)))
                {
                    const SolvedNode_efhg& arg = only_S4ER(node_3.items);
                    if (Lifetime_unwinds_through_gDsn(arg.type.lifetime, locid, ss, ctx, _here, module, options, _helpers))
                    {
                        return (x7E_rA00(("\n            "_view + "via "_view), str_eN8k(node_3.kind)) + " at "_view) + addr_and_snippet_gDsn(node_3.token, CodeFmt_snPx{}, fu::view<char>{}, ctx, module);
                    };
                };
            }
            else
            {
                if (!(has_bkvR(seen_1, node_3.target)))
                {
                    fu::view<SolvedNode_efhg> args = node_3.items;
                    fu::vec<Argument_bbKc> host_args = fu::vec<Argument_bbKc>(EXT_gDsn(node_3.target, ss, ctx, module).args);
                    if (args.size() == host_args.size())
                    {
                        for (int i = 0; i < host_args.size(); i++)
                        {
                            const Argument_bbKc& host_arg = host_args[i];
                            if (query == ArgQuery_O2xW_AQ_WhyNotNovec)
                            {
                                if (isNoVec_gDsn(host_arg.type, ctx, _here, module))
                                    continue;

                            }
                            else if (!host_arg.written_to)
                                continue;

                            const SolvedNode_efhg& arg = args[i];
                            if (!(!Lifetime_unwinds_through_gDsn(arg.type.lifetime, locid, ss, ctx, _here, module, options, _helpers)))
                            {
                                fu::str peek = qSTACK_arg_gDsn(node_3.target, i, seen_1, query, _current_fn, ss, ctx, _here, module, options, _helpers);
                                if (!(!peek && (GET_gDsn(node_3.target, ss, ctx, _here, module).kind == Kind_Idfg_fn)))
                                {
                                    return ((x7E_rA00(("\n            "_view + "via "_view), str_FDl5(node_3.target, false, ss, ctx, _here, module, options)) + " at "_view) + addr_and_snippet_gDsn(node_3.token, CodeFmt_snPx{}, fu::view<char>{}, ctx, module)) + peek;
                                };
                            };
                        };
                    };
                };
            };
            for (int i = node_3.items.size(); i-- > 0; )
                stack += SolvedNode_efhg(node_3.items[i]);

        };
    };
    return fu::str{};
}

                                #ifndef DEF___HwDUUsjbUZj
                                #define DEF___HwDUUsjbUZj
inline static bool _HwDU(const COWInside_qvly& cow, const Target_VZrr& argTarget)
{
    unsigned v;
    return cow.argTarget == (v = unsigned((argTarget._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
}
                                #endif

                                #ifndef DEF_some_IddiSXH5did
                                #define DEF_some_IddiSXH5did
inline bool some_Iddi(fu::view<COWInside_qvly> a, const Target_VZrr& argTarget)
{
    for (int i = 0; i < a.size(); i++)
    {
        const COWInside_qvly& item = a[i];
        if (_HwDU(item, argTarget))
            return true;

    };
    return false;
}
                                #endif

static const Lifetime_llCF& TEST_Lifetime_FDl5(const Lifetime_llCF& lifetime, const Type_OiTm& type, const bool tempsOK, const bool argPositionsOK, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (!lifetime)
    {
        BUG_gDsn("TEST_Lifetime: empty lifetime"_view, ss, ctx, _here, module, options, _helpers);
    }
    else
    {
        bool first = true;
        int lastStatic = 1000000;
        int lastLocid = 1000000;
        int lastArgIdx = 1000000;
        Lifetime_each_DOOY(lifetime, type, tempsOK, argPositionsOK, first, lastStatic, lastLocid, lastArgIdx, ss, ctx, _here, module, options, _helpers);
    };
    return lifetime;
}

                                #ifndef DEF_visit_oW4OBwbl2z2
                                #define DEF_visit_oW4OBwbl2z2
inline static void visit_oW4O(const Lifetime_llCF& lifetime, Lifetime_llCF& result, bool& maybeOutOfOrder, fu::view<int> argPos_1b, fu::view_mut<Argument_bbKc> args, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const fu::str& chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const int offset0 = offset;

        {
            const unsigned r = parse7bit_7Yz9(chars, offset);
            int offset0_1;
            int BL_4_v;
            const int sr = (__extension__ (
            {
                offset0_1 = (offset + 0);
                for (; ; )
                {
                    bool isLastPath = false;
                    bool isFirstSubRegion = true;
                    for (; ; )
                    {
                        const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                        const bool isLastSubRegion = !(raw_flatOffset & 1u);
                        const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                        isLastPath = !(raw_flatCount & 1u);
                        if (isLastSubRegion)
                            break;
                        else
                            isFirstSubRegion = false;

                    };
                    if (isLastPath)
                        break;

                };
                BL_4_v = (offset0_1);
                (void)0;
            }), BL_4_v);
            unsigned v;
            const int locid = ((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))));
            const bool isStatic = ((r & 11u) == 1u);
            fu::view<char> paths = fu::get_view(chars, sr, offset);
            if (!locid)
            {
                if (!(isStatic))
                {
                    BUG_gDsn("Non-local/non-static in retval.lifetime."_view, ss, ctx, _here, module, options, _helpers);
                };
            }
            else
            {
                int _0;
                const int argPos_1b_1 = ((_0 = iF_KelP(argPos_1b, (-1 - locid))) ? _0 : BUG_gDsn(x7E_rA00("Non-argument local in retval.lifetime: "_view, str_FDl5(nested_FDl5(locid, ss, ctx, _here), false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers));
                const int i = (argPos_1b_1 - 1);
                Argument_bbKc& arg = args.mutref(i);
                if (is_ref_9CJm(arg.type))
                {
                    arg.flags |= Flags_Lzg8_F_LT_RETURNED;
                    Lifetime_llCF replacement = Lifetime_from_UkiI(i, paths, ctx, _here);
                    maybeOutOfOrder = true;
                    Lifetime_add_7Yz9(result, replacement, false, ctx, _here);
                    continue;
                }
                else
                {
                    BUG_gDsn(x7E_rA00("Non-ref argument in retval.lifetime: "_view, str_FDl5(nested_FDl5(locid, ss, ctx, _here), false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);
                };
            };
        };
        if (maybeOutOfOrder)
        {
            result = Lifetime_union_7Yz9(result, Lifetime_llCF { fu::str(fu::get_range(chars, offset0, offset)) }, false, ctx, _here);
        }
        else
            result.uni0n += fu::get_view(chars, offset0, offset);

    };
}
                                #endif

                                #ifndef DEF_Lifetime_process_iDY3UqDyGF4
                                #define DEF_Lifetime_process_iDY3UqDyGF4
inline Lifetime_llCF Lifetime_process_iDY3(const Lifetime_llCF& lifetime, fu::view<int> argPos_1b, fu::view_mut<Argument_bbKc> args, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    /*MOV*/ Lifetime_llCF result {};
    bool maybeOutOfOrder = false;
    visit_oW4O(lifetime, result, maybeOutOfOrder, argPos_1b, args, ss, ctx, _here, module, options, _helpers);
    return /*NRVO*/ result;
}
                                #endif

static ArgRationale_mffC rejectsTempCopies_gDsn(const Argument_bbKc& arg, const ArgRationale_mffC requireVal, const Context_noPA& ctx, const TokenIdx_5581& _here)
{
    if (arg.flags & Flags_Lzg8_F_IMPLICIT)
        return ArgRationale_mffC_CantTempCopy_HostArg_Implicit;
    else if (arg.flags & Flags_Lzg8_F_REF)
        return ArgRationale_mffC_CantTempCopy_HostArg_Ref;
    else if (is_mutref_9CJm(arg.type, ctx, _here))
        return ArgRationale_mffC_CantTempCopy_HostArg_MutRef;
    else if (!(arg.flags & Flags_Lzg8_F_VAL))
        return requireVal;
    else
    {
        return ArgRationale_mffC{};
    };
}

static bool acceptsTempCopies_gDsn(const Argument_bbKc& arg, const ArgRationale_mffC requireVal, const Context_noPA& ctx, const TokenIdx_5581& _here)
{
    return !rejectsTempCopies_gDsn(arg, requireVal, ctx, _here);
}

static bool willPassByValue_gDsn(const Argument_bbKc& arg, const Context_noPA& ctx, const TokenIdx_5581& _here)
{
    if (acceptsTempCopies_gDsn(arg, ArgRationale_mffC{}, ctx, _here))
        return isPassByValue_hxWW(arg.type.vtype);
    else
        return false;

}

                                #ifndef DEF___ZYwGWheJjV9
                                #define DEF___ZYwGWheJjV9
inline static bool _ZYwG(const bool isArgIdx, const bool isStatic, const Type_OiTm& retval, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    return isArgIdx ? isArgIdx : isStatic ? isStatic : BUG_gDsn(x7E_rA00("updateScope: Non-static/non-arg leaked:\n\t"_view, str_gDsn(retval.lifetime, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);
}
                                #endif

                                #ifndef DEF_Lifetime_each_3zYvKQOvSol
                                #define DEF_Lifetime_each_3zYvKQOvSol
inline void Lifetime_each_3zYv(const Lifetime_llCF& lifetime, const Type_OiTm& retval, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit_7Yz9(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        _ZYwG(((r & 3u) == 3u), ((r & 11u) == 1u), retval, ss, ctx, _here, module, options, _helpers);
    };
}
                                #endif

static const Type_OiTm& ignoreLocalLts_gDsn(const Type_OiTm& type, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (is_ref_9CJm(type))
    {
        if (!(type.lifetime == Lifetime_temporary))
        {
            BUG_gDsn("type.lifetime != Lifetime_temporary"_view, ss, ctx, _here, module, options, _helpers);
        };
    };
    return type;
}

static fu::str qSTACK_effect_gDsn(const Target_VZrr& target, const SolvedNode_efhg& node, const FxMask_2dRz fx_mask, fu::view<Target_VZrr> seen, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    const Target_VZrr nestingFnort0 = exchange_GcK8(ss._nestingFnort, Target_VZrr(target));
    fu_DEFER(ss._nestingFnort = nestingFnort0);
    fu::vec<Target_VZrr> seen_1 = (seen + target);

    {
        fu::vec<SolvedNode_efhg> stack = fu::vec<SolvedNode_efhg> {{ SolvedNode_efhg(node) }};
        while (stack)
        {
            SolvedNode_efhg node_1 = TODO_FIX_pop_f7Nv(stack);
            const SolvedNode_efhg& node_2 = ((node_1.kind == Kind_Idfg_letdef) ? GET_gDsn(node_1.target, ss, ctx, _here, module).solved : node_1);
            const SolvedNode_efhg* __partcopy_ref;
            SolvedNode_efhg node_3 = (__partcopy_ref = &(((node_2.kind == Kind_Idfg___preceding_ref_arg) ? _current_fn.events.preceding_ref_args[node_2.helpers.index].arg : node_2)), SolvedNode_efhg { (*__partcopy_ref).kind, {/*unused non-zst*/}, {/*unused non-zst*/}, {/*unused non-zst*/}, {/*unused non-zst*/}, fu::vec<SolvedNode_efhg>((*__partcopy_ref).items), TokenIdx_5581((*__partcopy_ref).token), {/*unused non-zst*/}, Target_VZrr((*__partcopy_ref).target) });
            if (!((node_3.kind != Kind_Idfg_call) || isLocal_gDsn(node_3.target)))
            {
                if (!(has_bkvR(seen_1, node_3.target)))
                {
                    if (!(!FxMask_2dRz((EXT_gDsn(node_3.target, ss, ctx, module).fx_mask & fx_mask))))
                    {
                        fu::str peek = qSTACK_effect_gDsn(node_3.target, GET_gDsn(node_3.target, ss, ctx, _here, module).solved, fx_mask, seen_1, _current_fn, ss, ctx, _here, module, options);
                        if (!(!peek && (GET_gDsn(node_3.target, ss, ctx, _here, module).kind == Kind_Idfg_fn)))
                        {
                            return ((x7E_rA00(("\n            "_view + "via "_view), str_FDl5(node_3.target, false, ss, ctx, _here, module, options)) + " at "_view) + addr_and_snippet_gDsn(node_3.token, CodeFmt_snPx{}, fu::view<char>{}, ctx, module)) + peek;
                        };
                    };
                };
            };
            for (int i = node_3.items.size(); i-- > 0; )
                stack += SolvedNode_efhg(node_3.items[i]);

        };
    };
    return fu::str{};
}

                                #ifndef DEF_first_EY14dq47OXf
                                #define DEF_first_EY14dq47OXf
inline int first_EY14(fu::view<int> a)
{
    return a[0];
}
                                #endif

                                #ifndef DEF___QQc84eolTFi
                                #define DEF___QQc84eolTFi
inline static bool _QQc8(const Argument_bbKc& _)
{
    return isAddrOfFn_9CJm(_.type);
}
                                #endif

                                #ifndef DEF_some_eVJLyUed4A2
                                #define DEF_some_eVJLyUed4A2
inline bool some_eVJL(fu::view<Argument_bbKc> a)
{
    for (int i = 0; i < a.size(); i++)
    {
        const Argument_bbKc& item = a[i];
        if (_QQc8(item))
            return true;

    };
    return false;
}
                                #endif

static bool astChange_gDsn(const SolvedNode_efhg& a, const SolvedNode_efhg& b)
{
    if ((a.kind != b.kind) || (a.items.size() != b.items.size()))
        return true;
    else
    {
        for (int i = a.items.size(); i-- > 0; )
        {
            if (astChange_gDsn(a.items[i], b.items[i]))
                return true;

        };
        return false;
    };
}

                                #ifndef DEF_steal_kdfTsL0PHk0
                                #define DEF_steal_kdfTsL0PHk0
inline RevSpecPrototype_vWbr steal_kdfT(RevSpecPrototype_vWbr& v)
{
    /*MOV*/ RevSpecPrototype_vWbr ret {};
    std::swap(v, ret);
    return /*NRVO*/ ret;
}
                                #endif

static void doUpdateScope_gDsn(Type_OiTm&& retval, const Target_VZrr& target, const bool maybeLast, const bool isNative, const bool isUnspec, const DeclAsserts_taUG asserts, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, const fu::vec<Helpers_DyqV>& _helpers)
{
    if (target == _current_fn.out.target)
    {
        const int args_neg0 = _current_fn.args_neg;
        _current_fn.args_neg = EXT_gDsn(target, ss, ctx, module).args_neg;
        fu_DEFER(if (_current_fn.args_neg == EXT_gDsn(target, ss, ctx, module).args_neg)
            _current_fn.args_neg = args_neg0;
        else
        {
            BUG_gDsn("doUpdateScope: args_neg drift"_view, ss, ctx, _here, module, options, _helpers);
        });
        fu::view<SolvedNode_efhg> items = _current_fn.out.items;
        fu::view<char> mustBecomeInline = currentFn_mustBecomeInline_gDsn(_current_fn);
        const int N = (items.size() + FN_ARGS_BACK);
        int min = 0;
        int max = 0;
        const NativeQualities_5Qbp NativeQualities = (isNative ? NativeQualities_UvH3(GET_gDsn(target, ss, ctx, _here, module).name) : NativeQualities_5Qbp{});
        int numArgsWritten = 0;
        const bool relaxMutValArgs = (maybeLast ? !mustBecomeInline : false);
        MayEscapeVia_5nki TODO_FIX_nativeCOWsInside_mayEscapeVia {};
        fu::vec<int> argPos_1b {};
        for (int i = 0; i < N; i++)
        {
            const SolvedNode_efhg& argNode = items[i];
            const Target_VZrr& argTarget = argNode.target;
            if (!(!argTarget))
            {
                unsigned v;
                ensure_2Giz(argPos_1b, (-1 - (v = unsigned((argTarget._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))))) = (i + 1);
                if (relaxMutValArgs)
                {
                    Overload_aO3i& o = GET_mut_gDsn(argTarget, ss, module);
                    if (isMutVal_gDsn(o))
                        keepOrClearMutVal_gDsn(o, (is_mutref_9CJm(o.type, ctx, _here) || SolverStatus_h9em((o.status & SolverStatus_h9em_SS_MOVED_FROM))), ss, ctx, _here, module, options, _helpers);

                };
                if (isNative && is_mutref_9CJm(argNode.type, ctx, _here) && !is_trivial_1qjp(argNode.type.vtype, ctx, _here, module))
                {
                    const Target_VZrr* t;
                    unsigned v_1;
                    int _0;
                    add_xQNS(TODO_FIX_nativeCOWsInside_mayEscapeVia, ((_0 = (t = &(argNode.target), v_1 = unsigned(((*t)._packed & 0xfffffull)), int(((v_1 >> 1u) ^ ((v_1 & 1u) ? 0xffffffffu : 0x0u))))) ? _0 : BUG_gDsn("TODO_FIX_nativeCOWsInside_mayEscapeVia: no locid"_view, ss, ctx, _here, module, options, _helpers)));
                };
            };
        };
        const bool TODO_FIX_nativeCOWsInside = (!!TODO_FIX_nativeCOWsInside_mayEscapeVia || ((isNative && !is_ref_9CJm(retval)) ? !is_trivial_1qjp(retval.vtype, ctx, _here, module) : false));
        if (TODO_FIX_nativeCOWsInside)
        {
            if (_current_fn.events.cows_inside)
                BUG_gDsn("TODO_FIX_nativeCOWsInside: _current_fn.cows_inside already set"_view, ss, ctx, _here, module, options, _helpers);
            else
            {
                for (int i_1 = 0; i_1 < N; i_1++)
                {
                    const SolvedNode_efhg& argNode = items[i_1];
                    SolvedNode_efhg& argNode_1 = ((argNode.kind == Kind_Idfg_letdef) ? GET_mut_gDsn(argNode.target, ss, module).solved : (__extension__ (
                    {
                        continue;
                        (void)0;
                    }), fu::unreachable));
                    if (is_ref_9CJm(argNode_1.type) && !is_mutref_9CJm(argNode_1.type, ctx, _here) && !is_trivial_1qjp(argNode_1.type.vtype, ctx, _here, module))
                    {
                        const Target_VZrr* t;
                        unsigned v;
                        int _1;
                        const int locid = ((_1 = (t = &(argNode_1.target), v = unsigned(((*t)._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))))) ? _1 : BUG_gDsn("TODO_FIX_nativeCOWsInside: ref arg target not set"_view, ss, ctx, _here, module, options, _helpers));
                        /*MOV*/ ValueType_JtNg vtype = (is_rx_copy_9CJm(argNode_1.type.vtype) ? ValueType_JtNg(argNode_1.type.vtype) : if_sliceable_3fNj(argNode_1.type.vtype, ctx, _here, module));
                        if (!is_rx_copy_9CJm(vtype))
                        {
                            if (!is_ref_9CJm(retval) || is_mutref_9CJm(retval, ctx, _here))
                                argNode_1.type = clear_refs_9CJm(Type_OiTm(argNode_1.type));
                            else
                            {
                                fail_gDsn(((x7E_rA00((x7E_rA00("Heuristically, "_view, str_FDl5(target, false, ss, ctx, _here, module, options)) + " likely performs COW inside, but "_view), str_FDl5(argNode_1.target, false, ss, ctx, _here, module, options)) + " is neither copiable nor value-convertible "_view) + " (appears to be ref-returned)."_view), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                            };
                        }
                        else
                        {
                            _current_fn.events.cows_inside += COWInside_qvly { static_cast<ValueType_JtNg&&>(vtype), TokenIdx_5581(argNode_1.token), locid, TODO_FIX_nativeCOWsInside_mayEscapeVia, ExitPaths_UXHs((ExitPaths_UXHs_XP_NonEmptyReturn | (TODO_FIX_nativeCOWsInside_mayEscapeVia ? ExitPaths_UXHs_XP_EmptyReturn : ExitPaths_UXHs{}))) };
                        };
                    };
                };
            };
        };
        Set_qOJY TODO_FIX_mayAlias_ensureStable {};
        fu::vec<Argument_bbKc> args {};
        for (int i_1 = 0; i_1 < N; i_1++)
        {
            const SolvedNode_efhg& argNode = items[i_1];
            if (!(argNode.kind == Kind_Idfg_letdef))
            {
                if (argNode.target)
                    BUG_gDsn(x7E_rA00("Argnode is not letdef, but has a target: "_view, str_FDl5(argNode.target, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

            };
            const SolvedNode_efhg& argNode_1 = ((argNode.kind == Kind_Idfg_letdef) ? GET_gDsn(argNode.target, ss, ctx, _here, module).solved : argNode);
            if ((argNode_1.kind == Kind_Idfg_let) || (argNode_1.kind == Kind_Idfg_empty))
            {
                /*MOV*/ fu::str name = fu::str(argNode_1.value);
                /*MOV*/ fu::str autocall = ((argNode_1.flags & Flags_Lzg8_F_COMPOUND_ID) ? CompoundArgID_outerSplice_gDsn(name, ss, ctx, _here, module, options, _helpers) : fu::str{});
                const bool isImplicit = !!(argNode_1.flags & Flags_Lzg8_F_IMPLICIT);
                const bool isInjected = !!(argNode_1.flags & Flags_Lzg8_F_INJECTED);
                const Target_VZrr& argTarget = argNode_1.target;
                const ValueType_JtNg* type;
                unsigned v;
                const unsigned written_to = ((!isUnspec && is_mutref_9CJm(argNode_1.type, ctx, _here)) ? (isNative ? (type = &(argNode_1.type.vtype), ((*type).quals & q_USAGE)) : iF_BZQz(_current_fn.postdom.snap.ever_written, (v = unsigned((argTarget._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))), _current_fn)) : 0u);
                BitSet_mmp7 soft_risk {};
                BitSet_mmp7 hard_risk {};
                if (written_to)
                {
                    const ValueType_JtNg* type_1;
                    if ((written_to & (type_1 = &(argNode_1.type.vtype), ((*type_1).quals & q_USAGE))) == written_to)
                    {
                        numArgsWritten++;
                        if (isNative)
                        {
                            add_range_ZwXY(soft_risk, N);
                            remove_Na55(soft_risk, i_1);
                            if (!NativeQualities.MayAlias)
                                hard_risk = soft_risk;

                        }
                        else
                        {
                            ArgsAtRisk_list_gDsn(soft_risk, _current_fn.flow.at_soft_risk, argPos_1b, argTarget, _current_fn);
                            ArgsAtRisk_list_gDsn(hard_risk, _current_fn.flow.at_hard_risk, argPos_1b, argTarget, _current_fn);
                            if (TODO_FIX_isArray_9CJm(argNode_1.type))
                            {
                                BitSet_mmp7 soft = soft_risk;
                                remove_ZwXY(soft, hard_risk);
                                each_c5gH(soft, items, TODO_FIX_mayAlias_ensureStable, hard_risk, ss, ctx, _here, module);
                            };
                        };
                    }
                    else
                    {
                        const ValueType_JtNg* type_2;
                        BUG_gDsn(x7E_rA00((x7E_rA00((x7E_rA00("doUpdateScope written_to("_view, fu::u64dec(written_to)) + ") argNode.usage("_view), fu::u64dec((type_2 = &(argNode_1.type.vtype), ((*type_2).quals & q_USAGE)))) + "): "_view), str_FDl5(argNode_1.target, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);
                    };
                };
                if (maybeLast && DeclAsserts_taUG((asserts & DeclAsserts_taUG_A_NOVEC)) && !isNoVec_gDsn(argNode_1.type, ctx, _here, module) && !mustBecomeInline)
                {
                    fu::str _2 {};
                    unsigned v_1;
                    fu::str _3 {};
                    (_3 = (_2 = (((x7E_rA00(x7E_rA00(str_FDl5(target, false, ss, ctx, _here, module, options), " is not novec, "_view), str_FDl5(argTarget, false, ss, ctx, _here, module, options)) + " is "_view) + explainType_gDsn(argNode_1.type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)) + ":\n"_view), (static_cast<fu::str&&>(_2) + qSTACK_local_FDl5(target, _current_fn.out, (v_1 = unsigned((argTarget._packed & 0xfffffull)), int(((v_1 >> 1u) ^ ((v_1 & 1u) ? 0xffffffffu : 0x0u)))), fu::view<Target_VZrr>{}, ArgQuery_O2xW_AQ_WhyNotNovec, _current_fn, ss, ctx, _here, module, options, _helpers))), fail_gDsn(static_cast<fu::str&&>(_3), "novec"_view, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers));
                }
                else
                {
                    const bool cow_inside = some_Iddi(_current_fn.events.cows_inside, argTarget);
                    if (has_ZwXY(soft_risk, i_1))
                        BUG_gDsn((x7E_rA00("updateScope: "_view, str_FDl5(argTarget, false, ss, ctx, _here, module, options)) + " soft_risk lists self"_view), ss, ctx, _here, module, options, _helpers);
                    else if (has_ZwXY(hard_risk, i_1))
                        BUG_gDsn((x7E_rA00("updateScope: "_view, str_FDl5(argTarget, false, ss, ctx, _here, module, options)) + " hard_risk lists self"_view), ss, ctx, _here, module, options, _helpers);

                    /*MOV*/ BitSet_mmp7 may_alias = negated_ZwXY(hard_risk, N);
                    /*MOV*/ BitSet_mmp7 may_invalidate = negated_ZwXY(soft_risk, N);
                    if (popcount_ZwXY(may_alias) > N)
                        BUG_gDsn((x7E_rA00("updateScope: "_view, str_FDl5(argTarget, false, ss, ctx, _here, module, options)) + " may_alias.popcount > N"_view), ss, ctx, _here, module, options, _helpers);
                    else if (popcount_ZwXY(may_invalidate) > N)
                        BUG_gDsn((x7E_rA00("updateScope: "_view, str_FDl5(argTarget, false, ss, ctx, _here, module, options)) + " may_invalidate.popcount > N"_view), ss, ctx, _here, module, options, _helpers);

                    /*MOV*/ Argument_bbKc arg = Argument_bbKc { static_cast<fu::str&&>(name), autocall.destructive_move(), Type_OiTm(argNode_1.type), SolvedNode_efhg(((!isImplicit && argNode_1.items) ? argNode_1.items[LET_INIT] : (*(SolvedNode_efhg*)fu::NIL))), Target_VZrr(argTarget), (argNode_1.flags | (cow_inside ? Flags_Lzg8_F_COW_INSIDE : Flags_Lzg8{})), written_to, static_cast<BitSet_mmp7&&>(may_invalidate), static_cast<BitSet_mmp7&&>(may_alias) };
                    if (arg.type.lifetime && !(arg.flags & Flags_Lzg8_F_INJECTED))
                    {
                        if (!(arg.type.lifetime == Lifetime_temporary))
                            BUG_gDsn(x7E_rA00("Non-temporary lt on ref arg: "_view, str_FDl5(argTarget, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

                    }
                    else
                        ref_anonymize_9CJm(arg.type);

                    if (arg.type || isUnspec)
                    {
                        const ValueType_JtNg* type_1;
                        if (VFacts_xhRf((arg.type.vtype.vfacts & VFacts_xhRf((VFacts_xhRf_AlwaysTrue | VFacts_xhRf_AlwaysFalse)))) && (type_1 = &(arg.type.vtype), ((*type_1).quals & q_USAGE)) && !tryParseClosureID_UvH3(arg.name, ctx, _here))
                            BUG_gDsn("updateScope: arg.type is AlwaysTrue/False."_view, ss, ctx, _here, module, options, _helpers);

                    }
                    else
                        BUG_gDsn("updateScope: Unexpected untyped argument."_view, ss, ctx, _here, module, options, _helpers);

                    if (!isInjected)
                    {
                        if (max != int(0x7fffffffu))
                            max++;

                        if (!arg.dEfault && !isImplicit)
                            min++;

                    };
                    if (arg.flags & Flags_Lzg8_F_REST_ARG)
                        max = int(0x7fffffffu);

                    if ((arg.flags & Flags_Lzg8_F_VAL) && is_mutref_9CJm(arg.type, ctx, _here))
                        BUG_gDsn("F_VAL but arg.type.is_mutref"_view, ss, ctx, _here, module, options, _helpers);
                    else if (isMutRef_gDsn(arg.flags) && arg.type && !is_mutref_9CJm(arg.type, ctx, _here))
                        BUG_gDsn("F_MUT|F_REF but !arg.type.is_mutref"_view, ss, ctx, _here, module, options, _helpers);
                    else
                    {
                        if (!(args.size() == i_1))
                            BUG_gDsn("TODO_FIX_mayAlias_ensureStable: the stuff below relies on argument indices being 1:1"_view, ss, ctx, _here, module, options, _helpers);

                    };
                    args.push(static_cast<Argument_bbKc&&>(arg));
                };
            }
            else
            {
                BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers);
            };
        };
        const Set_qOJY* _;
        for (int i_2 = 0; i_2 < (_ = &(TODO_FIX_mayAlias_ensureStable), (*_).keys_asc.size()); i_2++)
        {
            const Set_qOJY* __1;
            int i_4;
            const int i_3 = (__1 = &(TODO_FIX_mayAlias_ensureStable), i_4 = i_2, (*__1).keys_asc[i_4]);
            Argument_bbKc& arg = args.mutref(i_3);
            if (is_sliceable_hxWW(arg.type.vtype) && !TODO_FIX_isArray_9CJm(arg.type))
            {
                arg.type.vtype.quals |= q_rx_resize;
                SolvedNode_efhg& argNode = GET_mut_gDsn(items[i_3].target, ss, module).solved;
                if (is_sliceable_hxWW(argNode.type.vtype) && !TODO_FIX_isArray_9CJm(argNode.type))
                    argNode.type.vtype.quals |= q_rx_resize;
                else
                    BUG_gDsn(((((("TODO_FIX_mayAlias_ensureStable[2] ("_view + arg.name) + "): "_view) + argNode.value) + " : "_view) + explainType_gDsn(argNode.type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

            }
            else
                BUG_gDsn("TODO_FIX_mayAlias_ensureStable[1]"_view, ss, ctx, _here, module, options, _helpers);

        };

        {
            if (is_ref_9CJm(retval))
            {
                TEST_Lifetime_FDl5(retval.lifetime, retval, false, false, ss, ctx, _here, module, options, _helpers);
            };
            retval.lifetime = Lifetime_process_iDY3(retval.lifetime, argPos_1b, args, ss, ctx, _here, module, options, _helpers);
            for (int i_3 = 0; i_3 < args.size(); i_3++)
            {
                Argument_bbKc& arg = args.mutref(i_3);
                if (!(arg.flags & Flags_Lzg8_F_LT_RETURNED))
                {
                    if (is_ref_9CJm(arg.type) && willPassByValue_gDsn(arg, ctx, _here))
                        arg.type = clear_refs_9CJm(Type_OiTm(arg.type));

                };
            };
        };
        if (retval)
        {
            if (is_ref_9CJm(retval))
            {
                if (isIrrelevant_9CJm(retval))
                {
                    retval.lifetime = Lifetime_static_moveable;
                };
                TEST_Lifetime_FDl5(retval.lifetime, retval, false, true, ss, ctx, _here, module, options, _helpers);
            };
            const Type_OiTm& retval_1 = retval;

            {
                Lifetime_each_3zYv(retval_1.lifetime, retval_1, ss, ctx, _here, module, options, _helpers);
                if (isNative && is_Typename_9CJm(retval_1))
                    BUG_gDsn(("updateScope: native retval.is_Typename: "_view + explainType_gDsn(retval_1, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

            };
            const Overload_aO3i* __partcopy_ref;
            Overload_aO3i overload = (__partcopy_ref = &(GET_gDsn(target, ss, ctx, _here, module)), Overload_aO3i { {/*unused non-zst*/}, (*__partcopy_ref).flags, {/*unused non-zst*/}, {/*unused non-zst*/}, {/*unused non-zst*/}, Type_OiTm((*__partcopy_ref).type), {/*unused non-zst*/} });
            Extended_z0HS& ext = EXT_mut_gDsn(target, ss, module);
            bool change = false;
            const bool hasCallers = !!EPH_gDsn(target, ss, module).callers;
            if (hasCallers)
            {
                if (!(change))
                    change = ((args.size() != ext.args.size()) || !(overload.type == retval_1));

                if (!change)
                {
                    for (int i_3 = 0; i_3 < args.size(); i_3++)
                    {
                        const Argument_bbKc& a = args[i_3];
                        const Argument_bbKc& b = ext.args[i_3];
                        if (!((a.name == b.name) && (ignoreLocalLts_gDsn(a.type, ss, ctx, _here, module, options, _helpers) == ignoreLocalLts_gDsn(b.type, ss, ctx, _here, module, options, _helpers))))
                        {
                            change = true;
                            break;
                        };
                    };
                };
            };
            ext.min = min;
            ext.max = max;
            ext.args = args;
            if (!isNative)
                ext.fx_mask = _current_fn.effects.fx_mask;

            ext.cows_inside = _current_fn.events.cows_inside;
            const Target_VZrr* retval_targ;
            if ((*(retval_targ = &(tryLookupUserType_1qjp(retval_1.vtype, ctx, _here, module).target))))
                ext.tEmplate.node.asserts |= EXT_gDsn((*retval_targ), ss, ctx, module).tEmplate.node.asserts;

            if (DeclAsserts_taUG((asserts & DeclAsserts_taUG_A_NOTHROW)) && FxMask_2dRz((ext.fx_mask & FxMask_2dRz_Fx_Throws)))
            {
                fu::str _4 {};
                fu::str assertion {};
                fu::view<char> _5 {};
                fu::str _6 {};
                (_6 = (_4 = x7E_rA00(str_FDl5(target, false, ss, ctx, _here, module, options), " is not nothrow, throws here:\n"_view), (static_cast<fu::str&&>(_4) + ((_5.ptr_reassign((assertion = qSTACK_effect_gDsn(target, _current_fn.out, FxMask_2dRz_Fx_Throws, fu::view<Target_VZrr>{}, _current_fn, ss, ctx, _here, module, options)))) ? _5 : BUG_u9Gb("Empty nothrow qSTACK"_view, ctx, _here)))), fail_gDsn(static_cast<fu::str&&>(_6), "nothrow"_view, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers));
            }
            else if (DeclAsserts_taUG((asserts & DeclAsserts_taUG_A_NOCRASH)) && FxMask_2dRz((ext.fx_mask & FxMask_2dRz_Fx_Crashes)))
            {
                fu::str _7 {};
                fu::str assertion {};
                fu::view<char> _8 {};
                fu::str _9 {};
                (_9 = (_7 = x7E_rA00(str_FDl5(target, false, ss, ctx, _here, module, options), " is not nocrash, can crash here:\n"_view), (static_cast<fu::str&&>(_7) + ((_8.ptr_reassign((assertion = qSTACK_effect_gDsn(target, _current_fn.out, FxMask_2dRz_Fx_Crashes, fu::view<Target_VZrr>{}, _current_fn, ss, ctx, _here, module, options)))) ? _8 : BUG_u9Gb("Empty nocrash qSTACK"_view, ctx, _here)))), fail_gDsn(static_cast<fu::str&&>(_9), "nocrash"_view, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers));
            }
            else if (DeclAsserts_taUG((asserts & DeclAsserts_taUG_A_NOIO)) && FxMask_2dRz((ext.fx_mask & FxMask_2dRz((FxMask_2dRz_Fx_Input | FxMask_2dRz_Fx_Output)))))
            {
                fu::str _10 {};
                fu::str assertion {};
                fu::view<char> _11 {};
                fu::str _12 {};
                (_12 = (_10 = x7E_rA00(str_FDl5(target, false, ss, ctx, _here, module, options), " is not noio, performs I/O here:\n"_view), (static_cast<fu::str&&>(_10) + ((_11.ptr_reassign((assertion = qSTACK_effect_gDsn(target, _current_fn.out, FxMask_2dRz((FxMask_2dRz_Fx_Input | FxMask_2dRz_Fx_Output)), fu::view<Target_VZrr>{}, _current_fn, ss, ctx, _here, module, options)))) ? _11 : BUG_u9Gb("Empty noio qSTACK"_view, ctx, _here)))), fail_gDsn(static_cast<fu::str&&>(_12), "noio"_view, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers));
            }
            else if (DeclAsserts_taUG((asserts & DeclAsserts_taUG_A_PURE_FX)) && FxMask_2dRz((ext.fx_mask & FxMask_2dRz_Fx_Output)))
            {
                fu::str _13 {};
                fu::str assertion {};
                fu::view<char> _14 {};
                fu::str _15 {};
                (_15 = (_13 = x7E_rA00(str_FDl5(target, false, ss, ctx, _here, module, options), " is not purefx, outputs here:\n"_view), (static_cast<fu::str&&>(_13) + ((_14.ptr_reassign((assertion = qSTACK_effect_gDsn(target, _current_fn.out, FxMask_2dRz_Fx_Output, fu::view<Target_VZrr>{}, _current_fn, ss, ctx, _here, module, options)))) ? _14 : BUG_u9Gb("Empty purefx qSTACK"_view, ctx, _here)))), fail_gDsn(static_cast<fu::str&&>(_15), "purefx"_view, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers));
            }
            else if (DeclAsserts_taUG((asserts & DeclAsserts_taUG_A_NOFLOW)) && _current_fn.far_jumps)
            {
                fail_gDsn((x7E_rA00(x7E_rA00(str_FDl5(target, false, ss, ctx, _here, module, options), " is not noflow: contains non-local control flow, jumping out to "_view), str_FDl5(localfn_gDsn(first_EY14(_current_fn.far_jumps.keys_asc), module), false, ss, ctx, _here, module, options)) + "."_view), "noflow"_view, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
            }
            else
            {
                if (maybeLast && !mustBecomeInline)
                {
                    if (!(numArgsWritten || ext.fx_mask || !is_void_9CJm(retval_1.vtype) || (overload.flags & Flags_Lzg8_F_LAX) || some_eVJL(args)))
                    {
                        push_FDl5(Warning_9p8u { 0x11110000 }, _current_fn, ss);
                    };
                };
                Overload_aO3i& overload_1 = GET_mut_gDsn(target, ss, module);
                overload_1.type = retval_1;
                overload_1.flags = _current_fn.out.flags;
                const Kind_Idfg kind = (isUnspec ? Kind_Idfg_template : (isNative ? Kind_Idfg___native : (mustBecomeInline ? Kind_Idfg_inline : Kind_Idfg_fn)));
                if (kind != overload_1.kind)
                {
                    overload_1.kind = kind;
                    change = true;
                };

                {
                    const bool rtl = (((args.size() == 2) && (overload_1.flags & Flags_Lzg8_F_OPERATOR)) ? hasAssignment_vRqJ(overload_1.name) : false);
                    isRTL_set_xQNS(overload_1, rtl);
                };
                const SolvedNode_efhg& solved = (!isUnspec ? _current_fn.out : (*(SolvedNode_efhg*)fu::NIL));
                if (hasCallers)
                {
                    if (!change && (kind == Kind_Idfg_inline))
                        change = astChange_gDsn(overload_1.solved, solved);

                    if (change)
                        overload_1.status |= SolverStatus_h9em_SS_UPDATED;

                };
                overload_1.solved = solved;
                if (overload_1.flags & Flags_Lzg8_F_CONVERSION)
                {
                    if (is_zeroes_9CJm(retval_1.vtype))
                    {
                        fail_gDsn((((x7E_rA00(str_FDl5(target, false, ss, ctx, _here, module, options), " returns type "_view) + explainTypeName_gDsn(retval_1, false, ctx, _here, module, options)) + "."_view) + "\n\n\tThis would make the conversion function ambiguous because it assigns to anything."_view), "using"_view, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                    };
                };
                if (overload_1.status & SolverStatus_h9em_SS_OBSERVED_BY_CONV_CACHE)
                {
                    overload_1.status &= SolverStatus_h9em(~SolverStatus_h9em_SS_OBSERVED_BY_CONV_CACHE);
                    if (overload_1.flags & Flags_Lzg8_F_CONVERSION)
                        clear_jCLV(ss._conv_cache);
                    else if (overload_1.flags & Flags_Lzg8_F_USING)
                    {
                        remove_mVke(ss._conv_cache, ValueType_JtNg{});
                    }
                    else
                        BUG_gDsn("SS_OBSERVED_BY_CONV_CACHE but !F_CONVERSION && !F_USING"_view, ss, ctx, _here, module, options, _helpers);

                };
                Ephemeral_xhb4& eph = EPH_mut_FDl5(target, ss, module);
                eph.far_jumps = _current_fn.far_jumps;
                eph.rev_spec.prototype = steal_kdfT(_current_fn.rev_spec_proto);
            };
        }
        else
            BUG_gDsn("updateScope: no return type."_view, ss, ctx, _here, module, options, _helpers);

    }
    else
        BUG_gDsn("doUpdateScope: target mismatch"_view, ss, ctx, _here, module, options, _helpers);

}

                                #ifndef DEF_mangleArgTypes_VSPOfHfh5S1
                                #define DEF_mangleArgTypes_VSPOfHfh5S1
inline static fu::str mangleArgTypes_VSPO(fu::view<Argument_bbKc> args)
{
    /*MOV*/ fu::str mangle {};
    int numNonInjected = 0;
    for (int i = 0; i < args.size(); i++)
    {
        const Argument_bbKc& arg = args[i];
        if (!(arg.flags & Flags_Lzg8_F_INJECTED))
        {
            if (numNonInjected++)
                mangle += ',';

            const Type_OiTm& argType = arg.type;
            if (argType)
                mangle += serializeType_1qjp(argType.vtype, "mangle[$T]"_view);

        };
    };
    return /*NRVO*/ mangle;
}
                                #endif

                                #ifndef DEF___ucS8T7hpoai
                                #define DEF___ucS8T7hpoai
inline static bool _ucS8(const int callee, const Target_VZrr& target, const int self, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    int _0;
    return (_0 = self, remove_qxmV(EPH_mut_FDl5(localfn_gDsn(callee, module), ss, module).callers, _0)) || BUG_gDsn(x7E_rA00((x7E_rA00("doTrySpec: "_view, str_FDl5(target, false, ss, ctx, _here, module, options)) + " not listed as a caller of "_view), str_FDl5(localfn_gDsn(callee, module), false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);
}
                                #endif

                                #ifndef DEF___jBIcnmkNUoc
                                #define DEF___jBIcnmkNUoc
inline static bool _jBIc(const int key, const Target_VZrr& target, const int self, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    return _ucS8(key, target, self, ss, ctx, _here, module, options, _helpers);
}
                                #endif

                                #ifndef DEF_each_mFmI0AbNyc9
                                #define DEF_each_mFmI0AbNyc9
inline void each_mFmI(const Map_99Lz& _, const Target_VZrr& target, const int self, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    for (int i = 0; i < _.vals.size(); i++)
    {
        const int key = _.keys.keys_asc[i];
        _jBIc(key, target, self, ss, ctx, _here, module, options, _helpers);
    };
}
                                #endif

                                #ifndef DEF_each_846677Ac760
                                #define DEF_each_846677Ac760
inline void each_8466(const CountedSet_C7kV& _, const Target_VZrr& target, const int self, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    each_mFmI(_.counts, target, self, ss, ctx, _here, module, options, _helpers);
}
                                #endif

                                #ifndef DEF_last_krcn9h36FKk
                                #define DEF_last_krcn9h36FKk
inline Node_JjyR& last_krcn(fu::view_mut<Node_JjyR> a)
{
    return a.mutref((a.size() - 1));
}
                                #endif

extern const Flags_Lzg8 F_TODO_FIX_TRAILING_RETURN;
static bool TODO_FIX_optionalSemis_blockWantsVoid_gDsn(const HelpersData_uG6I& h)
{
    return is_void_9CJm((h.ret_expect ? h.ret_expect : h.ret_actual).vtype);
}

                                #ifndef DEF_x3C_AKgS2zBMRzl
                                #define DEF_x3C_AKgS2zBMRzl
inline bool operator<(fu::view<char> a, fu::view<char> b)
{
    return x3Cx3E_j5CR(a, b) < 0;
}
                                #endif

static bool compare_gDsn(const SolvedNode_efhg& a, const SolvedNode_efhg& b, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    const Overload_aO3i& a_1 = GET_gDsn(a.target, ss, ctx, _here, module);
    const Overload_aO3i& b_1 = GET_gDsn(b.target, ss, ctx, _here, module);
    fu::view<char> an = a_1.name;
    fu::view<char> bn = b_1.name;
    const ClosureID_qHEW acid = tryParseClosureID_UvH3(an, ctx, _here);
    const ClosureID_qHEW bcid = tryParseClosureID_UvH3(bn, ctx, _here);
    if (acid)
    {
        if (bcid)
        {
            const Target_VZrr* t;
            const Target_VZrr* t_1;
            int _0;
            int a_2;
            const Target_VZrr* t_2;
            unsigned v;
            int b_2;
            const Target_VZrr* t_3;
            unsigned v_1;
            const int cmp = ((_0 = ((t = &(bcid.target), int(unsigned((((*t)._packed >> 20ull) & 0xfffffull)))) - (t_1 = &(acid.target), int(unsigned((((*t_1)._packed >> 20ull) & 0xfffffull)))))) ? _0 : (a_2 = (t_2 = &(acid.target), v = unsigned(((*t_2)._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))), b_2 = (t_3 = &(bcid.target), v_1 = unsigned(((*t_3)._packed & 0xfffffull)), int(((v_1 >> 1u) ^ ((v_1 & 1u) ? 0xffffffffu : 0x0u)))), ((a_2 < 0) ? ((b_2 < 0) ? (b_2 - a_2) : -1) : ((b_2 < 0) ? +1 : (a_2 - b_2)))));
            return cmp < 0;
        }
        else
            return true;

    }
    else if (bcid)
        return false;

    return an < bn;
}

                                #ifndef DEF_sort_YWjfFiGp67k
                                #define DEF_sort_YWjfFiGp67k
inline static void sort_YWjf(fu::vec_range_mut<SolvedNode_efhg> a, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    SolvedNode_efhg l {};
    SolvedNode_efhg r {};
    (void) l;
    (void) r;
    auto* data = a.data_mut();
    std::sort(data, data + a.size(), [&](auto& l, auto& r)
    {;
    bool lt = compare_gDsn(l, r, ss, ctx, _here, module);
    return lt;
            });

}
                                #endif

                                #ifndef DEF_sort_HiiR6YCAaye
                                #define DEF_sort_HiiR6YCAaye
inline void sort_HiiR(fu::vec_range_mut<SolvedNode_efhg> a, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    sort_YWjf(a, ss, ctx, _here, module);
}
                                #endif

static void sortInjectedArguments_gDsn(CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    fu::vec_range_mut<SolvedNode_efhg> args = fu::get_range_start0_mut(_current_fn.out.items, (_current_fn.out.items.size() + FN_ARGS_BACK));
    for (int i = 0; i < args.size(); i++)
    {
        const SolvedNode_efhg& arg = args[i];
        if (arg.target && (GET_gDsn(arg.target, ss, ctx, _here, module).flags & Flags_Lzg8_F_INJECTED))
        {
            sort_HiiR(fu::get_range_mut(args, i), ss, ctx, _here, module);
            return;
        };
    };
}

                                #ifndef DEF_visit_lQfIZbUjS76
                                #define DEF_visit_lQfIZbUjS76
inline static void visit_lQfI(const Lifetime_llCF& lifetime, Lifetime_llCF& result, bool& maybeOutOfOrder, const bool locals_only, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const fu::str& chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const int offset0 = offset;

        { {
            const unsigned r = parse7bit_7Yz9(chars, offset);
            int offset0_1;
            int BL_4_v;
            const int sr = (__extension__ (
            {
                offset0_1 = (offset + 0);
                for (; ; )
                {
                    bool isLastPath = false;
                    bool isFirstSubRegion = true;
                    for (; ; )
                    {
                        const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                        const bool isLastSubRegion = !(raw_flatOffset & 1u);
                        const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                        isLastPath = !(raw_flatCount & 1u);
                        if (isLastSubRegion)
                            break;
                        else
                            isFirstSubRegion = false;

                    };
                    if (isLastPath)
                        break;

                };
                BL_4_v = (offset0_1);
                (void)0;
            }), BL_4_v);

            { {
                unsigned v;
                const int locid = ((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))));
                fu::view<char> paths = fu::get_view(chars, sr, offset);
                if (!locid)
                {
                    if (locals_only)
                        goto BL_12;

                }
                else
                {
                    const Type_OiTm& init = Lifetime_climbType_gDsn(nested_FDl5(locid, ss, ctx, _here), ss, ctx, _here, module, options, _helpers);
                    if (is_ref_9CJm(init))
                    {
                        Lifetime_llCF parent = Lifetime_op_join_7Yz9(init.lifetime, paths, ctx, _here);
                        maybeOutOfOrder = true;
                        visit_lQfI(parent, result, maybeOutOfOrder, locals_only, ss, ctx, _here, module, options, _helpers);
                        continue;
                    };
                };
                goto BL_3;
              } BL_12:;
            };
            continue;
          } BL_3:;
        };
        if (maybeOutOfOrder)
        {
            result = Lifetime_union_7Yz9(result, Lifetime_llCF { fu::str(fu::get_range(chars, offset0, offset)) }, false, ctx, _here);
        }
        else
            result.uni0n += fu::get_view(chars, offset0, offset);

    };
}
                                #endif

                                #ifndef DEF_Lifetime_process_jybbPNVA71l
                                #define DEF_Lifetime_process_jybbPNVA71l
inline Lifetime_llCF Lifetime_process_jybb(const Lifetime_llCF& lifetime, const bool locals_only, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    /*MOV*/ Lifetime_llCF result {};
    bool maybeOutOfOrder = false;
    visit_lQfI(lifetime, result, maybeOutOfOrder, locals_only, ss, ctx, _here, module, options, _helpers);
    return /*NRVO*/ result;
}
                                #endif

static Lifetime_llCF Lifetime_unwind_gDsn(const Lifetime_llCF& lifetime, const bool locals_only, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    return Lifetime_process_jybb(lifetime, locals_only, ss, ctx, _here, module, options, _helpers);
}

static void mcom_FnReturn_CopyOrMoveDecision_gDsn(const Helpers_DyqV& h, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const Type_OiTm& retval = (((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).ret_actual;
    if (!(!is_ref_9CJm(retval)))
    {
        /*MOV*/ Lifetime_llCF unwound = Lifetime_unwind_gDsn(retval.lifetime, false, ss, ctx, _here, module, options, _helpers);

        {
            fu::view<char> chars = unwound.uni0n;
            int offset = 0;
            while (offset < chars.size())
            {
                const unsigned r = parse7bit_7Yz9(chars, offset);
                for (; ; )
                {
                    bool isLastPath = false;
                    bool isFirstSubRegion = true;
                    for (; ; )
                    {
                        const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                        const bool isLastSubRegion = !(raw_flatOffset & 1u);
                        const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                        isLastPath = !(raw_flatCount & 1u);
                        if (isLastSubRegion)
                            break;
                        else
                            isFirstSubRegion = false;

                    };
                    if (isLastPath)
                        break;

                };
                unsigned v;
                const int locid = ((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))));
                const bool isStatic = ((r & 11u) == 1u);
                const bool isTemp = (r == 0b1001u);
                const Target_VZrr t = (locid ? nested_FDl5(locid, ss, ctx, _here) : Target_VZrr{});
                unsigned v_1;
                const bool isRefArg = (((v_1 = unsigned((t._packed & 0xfffffull)), int(((v_1 >> 1u) ^ ((v_1 & 1u) ? 0xffffffffu : 0x0u)))) < 0) ? !isMutVal_gDsn(GET_gDsn(t, ss, ctx, _here, module)) : false);
                if (!isRefArg && !isStatic)
                {
                    if (locid || isTemp)
                    {
                        reportReturnType_gDsn(h, clear_refs_9CJm(Type_OiTm((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).ret_actual)), false, _current_fn, ss, ctx, _here, module, options, _helpers);
                        return;
                    }
                    else
                        BUG_gDsn("mcom_FnReturn_CopyOrMoveDecision: !locid && !isStatic && !isTemp."_view, ss, ctx, _here, module, options, _helpers);

                };
            };
        };
        (((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data.mutref(h.index) : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).ret_actual.lifetime = static_cast<Lifetime_llCF&&>(unwound);
    };
}

static SolvedNode_efhg solveBlock_gDsn(const Node_JjyR& node, const Type_OiTm& type, const int fnbody_of, const HelpersMask_w1sv mask, fu::vec_range<char> id, const int locals_start, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    fu::vec<Node_JjyR> nodes = ((node.kind == Kind_Idfg_block) ? fu::vec<Node_JjyR>(node.items) : fu::vec<Node_JjyR> {{ Node_JjyR(node) }});
    fu::vec_range<char> id_1 = (id ? id : ((node.kind == Kind_Idfg_block) ? node.value : (*(fu::str*)fu::NIL)));
    const ScopeMemo_9hVQ scope0 = Scope_snap_gDsn(ss, _helpers);
    fu_DEFER(if (!HelpersMask_w1sv((mask & HelpersMask_w1sv_HM_LoopPreheader)))
        Scope_pop_gDsn(scope0, ss, _helpers););
    const int helpers_idx = _helpers.size();
    const Target_VZrr* t;
    push_gDsn(HelpersData_uG6I { (fnbody_of ? localfn_gDsn(fnbody_of, module) : Target_VZrr{}), SolverPass_zVQ2{}, mask, fu::str(id_1), (fnbody_of ? fnbody_of : (t = &(_current_fn.out.target), int(unsigned((((*t)._packed >> 20ull) & 0xfffffull))))), (fnbody_of ? +1 : (locals_start ? locals_start : GET_next_local_index_gDsn(_current_fn, ss, ctx, _here))), Type_OiTm(type), Type_OiTm{}, Postdom_Vy5u{}, Postdom_Vy5u{}, EventsSnap_elmt{}, Helpers_DyqV{} }, ss, _helpers);
    const Helpers_DyqV h = _helpers[helpers_idx];
    if (fnbody_of && nodes)
    {
        Node_JjyR& last = last_krcn(nodes);
        if (last.kind == Kind_Idfg_unwrap)
            _current_fn.TODO_FIX_isInline = true;
        else
        {
            const bool NICEERR_missingReturn = ((node.kind == Kind_Idfg_block) ? ((last.kind == Kind_Idfg_empty) || ParseSyntax_Lay2((last.syntax & ParseSyntax_Lay2_PS_ALWAYS_DISCARD))) : false);
            last = Node_JjyR { Kind_Idfg_return, DeclAsserts_taUG{}, ParseSyntax_Lay2{}, (((NICEERR_missingReturn ? Flags_Lzg8_F_IMPLICIT : Flags_Lzg8{}) | Flags_Lzg8_F_LAMBDA) | F_TODO_FIX_TRAILING_RETURN), fu::str{}, ((last.kind != Kind_Idfg_empty) ? fu::vec<Node_JjyR> {{ Node_JjyR(last) }} : fu::vec<Node_JjyR>{}), TokenIdx_5581(last.token) };
        };
    };
    fu::vec<SolvedNode_efhg> items = solveNodes_gDsn(nodes, DeadBreak_Z4ob_DeadBreak_Always, t_void, type, !is_void_9CJm(type.vtype), StaticEval_IZio{}, false, _current_fn, ss, ctx, _here, module, options, _helpers);
    if (TODO_FIX_optionalSemis_blockWantsVoid_gDsn((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))))
    {
        if (items && !isIrrelevantOrNever_9CJm(last_c4M9(items).type))
        {
            items += createEmpty_gDsn(t_void, Target_VZrr{}, ss, ctx, _here, module, options, _helpers);
        };
    };
    if (!fnbody_of)
    {
        (((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data.mutref(h.index) : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).ret_expect = Type_OiTm{};
    };

    {
        const Type_OiTm& tail = (items ? last_c4M9(items).type : t_void);
        if (!is_never_9CJm(tail.vtype))
            reportReturnType_gDsn(h, tail, false, _current_fn, ss, ctx, _here, module, options, _helpers);
        else if (!(((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).ret_actual)
            (((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data.mutref(h.index) : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).ret_actual = Type_OiTm(t_never);

    };
    if ((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).ret_actual)
    {
        const Type_OiTm* _0;
        /*MOV*/ SolvedNode_efhg block = createBlock_gDsn((*(_0 = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).ret_actual)) ? *_0 : BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers)), items, h, _here);
        if (fnbody_of)
        { {
            const SolverStatus_h9em status = GET_gDsn(localfn_gDsn(fnbody_of, module), ss, ctx, _here, module).status;
            if (!SolverStatus_h9em((status & SolverStatus_h9em_SS_DIRTY)))
            {
                sortInjectedArguments_gDsn(_current_fn, ss, ctx, _here, module);
                if (currentFn_mustBecomeInline_gDsn(_current_fn))
                {
                    mcom_FnReturn_CopyOrMoveDecision_gDsn(h, _current_fn, ss, ctx, _here, module, options, _helpers);
                    goto BL_12;
                }
                else
                {

                    {
                        /*MOV*/ SolvedNode_efhg solved = _current_fn.out;
                        last_xZUS(solved.items) = SolvedNode_efhg(block);
                        const Target_VZrr target = localfn_gDsn(fnbody_of, module);
                        _current_fn.rev_spec_proto = RevSpecPrototype_vWbr { static_cast<SolvedNode_efhg&&>(solved), fu::vec<Overload_aO3i>(EXT_gDsn(target, ss, ctx, module).args_n_locals), EXT_gDsn(target, ss, ctx, module).args_neg };
                    };
                    runAllPasses_gDsn(block, _current_fn, ss, ctx, _here, module, options, _helpers);
                };
            };
          } BL_12:;
        };
        return /*NRVO*/ block;
    }
    else
        BUG_gDsn("No ret_actual"_view, ss, ctx, _here, module, options, _helpers);

}

static fu::view<SolvedNode_efhg> outItems_iUdw(const CurrentFn_QbLp& _current_fn)
{
    return _current_fn.out.items;
}

static const Ephemeral_xhb4& EPH_mut_wyx7(const Target_VZrr& target, SolverState_aGlN& ss, const Module_wo7O& module)
{
    if (int(unsigned(((target._packed >> 40ull) & 0xfffffull))) == module.modid)
        return EPH_mut_iUdw(int(unsigned(((target._packed >> 20ull) & 0xfffffull))), ss);
    else
        fu::fail(fu::str(str_yabg9ydVki8));

}

                                #ifndef DEF___hDElrZATtLd
                                #define DEF___hDElrZATtLd
inline static void _hDEl(int index, fu::vec<int>& reopen, const int parent, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    for (; ; )
    {
        const Target_VZrr t = localfn_gDsn(index, module);
        Overload_aO3i& o = GET_mut_gDsn(t, ss, module);
        if (SolverStatus_h9em((o.status & SolverStatus_h9em((SolverStatus_h9em_SS_DID_START | SolverStatus_h9em_SS_DIRTY)))) != SolverStatus_h9em_SS_DID_START)
            return;
        else if (!SolverStatus_h9em((o.status & SolverStatus_h9em_SS_FINALIZED)))
        {
            o.status |= SolverStatus_h9em_SS_DIRTY;
            return;
        }
        else
        {
            const int up = EPH_gDsn(t, ss, module).local_of;
            if (up != parent)
            {
                if (up > parent)
                    index = up;
                else
                    BUG_gDsn("lazySolveEnd: about to climb up the wrong tree."_view, ss, ctx, _here, module, options, _helpers);

            }
            else
            {

                {
                    const SolverNotes_LSla note = ((o.kind == Kind_Idfg_type) ? SolverNotes_LSla_N_TypeReopen : SolverNotes_LSla_N_FnReopen);
                    if (note & options.break_notes)
                    {
                        fu::view<char> reason = fu::view<char>{};
                        fail_gDsn((("`break_notes`: Unwanted event: "_view + qBAD_e44U(str_kJvr(note))) + (reason ? ("\n\t\t"_view + reason) : fu::str("."_fu))), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                    }
                    else
                        ss._notes |= note;

                };
                o.status &= SolverStatus_h9em(~SolverStatus_h9em((SolverStatus_h9em((SolverStatus_h9em_SS_DID_START | SolverStatus_h9em_SS_DIRTY)) | SolverStatus_h9em_SS_FINALIZED)));
                reopen += index;
                return;
            };
        };
    };
}
                                #endif

                                #ifndef DEF___gllgNQeiw4i
                                #define DEF___gllgNQeiw4i
inline static void _gllg(const int key, fu::vec<int>& reopen, const int parent, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    _hDEl(key, reopen, parent, ss, ctx, _here, module, options, _helpers);
}
                                #endif

                                #ifndef DEF_each_ven39s2dRa8
                                #define DEF_each_ven39s2dRa8
inline void each_ven3(const Map_99Lz& _, fu::vec<int>& reopen, const int parent, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    for (int i = 0; i < _.vals.size(); i++)
    {
        const int key = _.keys.keys_asc[i];
        _gllg(key, reopen, parent, ss, ctx, _here, module, options, _helpers);
    };
}
                                #endif

                                #ifndef DEF_each_SGCl68sZFi6
                                #define DEF_each_SGCl68sZFi6
inline void each_SGCl(const CountedSet_C7kV& _, fu::vec<int>& reopen, const int parent, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    each_ven3(_.counts, reopen, parent, ss, ctx, _here, module, options, _helpers);
}
                                #endif

static void lazySolveEnd_gDsn(const Target_VZrr& t, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    Overload_aO3i& o = GET_mut_gDsn(t, ss, module);
    fu::vec<int> reopen {};
    const int parent = EPH_gDsn(t, ss, module).local_of;
    if (o.status & SolverStatus_h9em_SS_UPDATED)
    {
        o.status &= SolverStatus_h9em(~SolverStatus_h9em_SS_UPDATED);
        CountedSet_C7kV callers = EPH_mut_wyx7(t, ss, module).callers;
        each_SGCl(callers, reopen, parent, ss, ctx, _here, module, options, _helpers);
    };
    Overload_aO3i& o_1 = GET_mut_gDsn(t, ss, module);
    if (!SolverStatus_h9em((o_1.status & SolverStatus_h9em_SS_DIRTY)))
    {
        o_1.status |= SolverStatus_h9em_SS_FINALIZED;
        fu::vec<RevSpecOutput_pbkT> rev_specs = fu::vec<RevSpecOutput_pbkT>(((o_1.kind == Kind_Idfg_fn) ? EPH_gDsn(t, ss, module).rev_spec.outputs : (*(fu::vec<RevSpecOutput_pbkT>*)fu::NIL)));
        if (rev_specs)
        {
            const unsigned actual = o_1.type.vtype.quals;
            for (int i = 0; i < rev_specs.size(); i++)
            {
                const RevSpecOutput_pbkT& rev_spec = rev_specs[i];
                const Target_VZrr& t_1 = rev_spec.instance_targ;
                Overload_aO3i& o_2 = GET_mut_gDsn(t_1, ss, module);
                if ((actual & rev_spec.relaxed_quals) == rev_spec.relaxed_quals)
                {
                    o_2.status &= SolverStatus_h9em(~SolverStatus_h9em((SolverStatus_h9em((SolverStatus_h9em_SS_DID_START | SolverStatus_h9em_SS_DIRTY)) | SolverStatus_h9em_SS_FINALIZED)));
                    lazySolveStart_gDsn(t_1, _current_fn, ss, ctx, _here, module, options, _helpers);
                }
                else if (o_2.kind != Kind_Idfg___tombstone)
                    destroyOverload_gDsn(t_1, ss, module);

            };
        };
    }
    else if (o_1.status & SolverStatus_h9em_SS_FINALIZED)
        BUG_gDsn("Stray SS_FINALIZED."_view, ss, ctx, _here, module, options, _helpers);
    else
    {
        o_1.status &= SolverStatus_h9em(~SolverStatus_h9em((SolverStatus_h9em_SS_DID_START | SolverStatus_h9em_SS_DIRTY)));
        const SolverNotes_LSla note = ((o_1.kind == Kind_Idfg_type) ? SolverNotes_LSla_N_TypeResolve : SolverNotes_LSla_N_FnResolve);
        if (note & options.break_notes)
        {
            fu::view<char> reason = fu::view<char>{};
            fail_gDsn((("`break_notes`: Unwanted event: "_view + qBAD_e44U(str_kJvr(note))) + (reason ? ("\n\t\t"_view + reason) : fu::str("."_fu))), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
        }
        else
            ss._notes |= note;

    };
    for (int i = 0; i < reopen.size(); i++)
    {
        const Target_VZrr t_1 = localfn_gDsn(reopen[i], module);
        lazySolveStart_gDsn(t_1, _current_fn, ss, ctx, _here, module, options, _helpers);
    };
}

static Target_VZrr doTrySpecialize_gDsn(const int parent_idx, fu::vec_range_mut<char> error, const Target_VZrr& into, const Target_VZrr& overloadIdx, fu::view<SolvedNode_efhg> args_in, fu::view<char> mangle, const Reorder_0MNg& reorder, fu::view<fu::vec<Target_VZrr>> conversions, const int REST_START, const Type_OiTm& REST_TYPE, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    const Target_VZrr SPECFAIL_RentrySafety = Target_VZrr { 0x8000000000000000ull };
    const int err0 = error.size();
    const Target_VZrr& original = (overloadIdx ? overloadIdx : into ? into : BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers));
    Template_SsLx tEmplate = EXT_gDsn(original, ss, ctx, module).tEmplate;
    const TokenIdx_5581 here0 = _here;
    _here = EXT_gDsn(original, ss, ctx, module).tEmplate.node.token;
    const int solver_safety0 = ss._solver_safety++;
    if ((solver_safety0 >= 128))
    {
        fail_gDsn(("Solver stack got too deep, was about to start working on "_view + qID_e44U(tEmplate.node.value)), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
    }
    else
    {
        fu_DEFER(
        {
            _here = here0;
            ss._solver_safety = solver_safety0;
        });
        Set_XshD mangles {};
        Target_VZrr currentSpec = SPECFAIL_RentrySafety;
        fu::view<Node_JjyR> items = tEmplate.node.items;
        const int numArgs = ((tEmplate.node.kind == Kind_Idfg_fn) ? (items.size() + FN_ARGS_BACK) : BUG_gDsn("template.node.kind != `fn`"_view, ss, ctx, _here, module, options, _helpers));
        Map_v4nV typeParams0 = steal_ew2w(ss._typeParams);
        fu_DEFER(std::swap(ss._typeParams, typeParams0));
        if (!into)
        {
            bool fail = false;
            fu::vec<Type_OiTm> args {};
            if (reorder)
            {
                for (int i = 0; i < reorder.map.size(); i++)
                {
                    const int callsiteIndex = reorder.map[i];
                    args.push(Type_OiTm((((callsiteIndex >= 0) && (callsiteIndex < args_in.size())) ? args_in[callsiteIndex].type : (*(Type_OiTm*)fu::NIL))));
                };
            }
            else
                for (int i = 0; i < args_in.size(); i++)
                    args.push(Type_OiTm(args_in[i].type));
;
            for (int i = 0; i < conversions.size(); i++)
            {
                Type_OiTm& arg = args.mutref(i);
                arg = conversionTailType_gDsn(arg, conversions[i], ss, ctx, _here, module);
            };
            if (REST_TYPE)
                args.mutref(REST_START) = Type_OiTm(REST_TYPE);

            fu::vec<RetypeOrder_6uAI> retypeIndices {};
            for (int pass_retype = 0; (pass_retype == 0) || ((pass_retype == 1) && retypeIndices); pass_retype++)
            {
                const int N = (pass_retype ? (sort_MmeF(retypeIndices), retypeIndices.size()) : numArgs);
                for (int i_1 = 0; i_1 < N; i_1++)
                {
                    const int i_2 = (pass_retype ? retypeIndices[i_1].index : i_1);
                    /*MOV*/ Type_OiTm inType = ((args.size() > i_2) ? args[i_2] : (*(Type_OiTm*)fu::NIL));
                    const SolvedNode_efhg& inValue = (reorder ? (((reorder.map.size() > i_2) && (reorder.map[i_2] >= 0)) ? args_in[reorder.map[i_2]] : (*(SolvedNode_efhg*)fu::NIL)) : ((args_in.size() > i_2) ? args_in[i_2] : (*(SolvedNode_efhg*)fu::NIL)));
                    const Node_JjyR* _0;
                    const Node_JjyR& argNode = (*(_0 = &(items[i_2])) ? *_0 : BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers));
                    const Node_JjyR& annot = argNode.items[LET_TYPE];
                    /*MOV*/ Argument_bbKc host_arg = EXT_gDsn(original, ss, ctx, module).args[i_2];
                    const SolvedNode_efhg& inValue_1 = ((!host_arg.dEfault || !is_zeroes_9CJm(inValue.type.vtype)) ? inValue : (*(SolvedNode_efhg*)fu::NIL));
                    const SolvedNode_efhg& inValue_2 = (inValue_1 ? inValue_1 : ((inType = host_arg.dEfault.type), host_arg.dEfault));
                    const int retype_score = couldRetype_gDsn(inValue_2);
                    if (retype_score)
                    {
                        if (!pass_retype)
                        {
                            retypeIndices.push(RetypeOrder_6uAI { retype_score, i_2 });
                            continue;
                        }
                        else
                        {
                            Type_OiTm paramType = ((annot.kind == Kind_Idfg_typeparam) ? Type_OiTm(ref_NU9O(ss._typeParams, annot.value).matched) : (((annot.kind == Kind_Idfg_call) && !annot.items) ? Scope_lookupType_gDsn(annot.value, annot.flags, _current_fn, ss, ctx, _here, module, options, _helpers) : Type_OiTm{}));
                            if (paramType)
                            {
                                /*MOV*/ Type_OiTm retype = tryRetyping_gDsn(inValue_2, paramType, ss, ctx, _here, module, options, _helpers);
                                if (retype && (retype.vtype.canon != inType.vtype.canon))
                                {
                                    inType = static_cast<Type_OiTm&&>(retype);
                                    if (args.size() > i_2)
                                        args.mutref(i_2) = Type_OiTm(inType);

                                };
                            };
                        };
                    };
                    if (!pass_retype && (annot.kind == Kind_Idfg_typeunion))
                    {
                        retypeIndices.push(RetypeOrder_6uAI { MAX_GzC5(), i_2 });
                    }
                    else if (isMutRef_gDsn(host_arg.flags) && !is_mutref_9CJm(inType, ctx, _here))
                    {
                        if (error)
                        {
                            fu::str reason {};
                            fu::view<char> _1 {};
                            error += ((_1.ptr_reassign((reason = (x7E_rA00(str_wyx7(host_arg, false, _current_fn, ss, ctx, _here, module, options), " "_view) + explainNotMutref_gDsn(inType, _current_fn, ss, ctx, _here, module, options))))) ? _1 : BUG_gDsn("matchFail: No reason."_view, ss, ctx, _here, module, options, _helpers));
                        };
                        fail = true;
                        goto LL_14;
                    }
                    else if (argNode.kind == Kind_Idfg_let)
                    {
                        if (inType)
                        {
                            ref_anonymize_9CJm(inType);
                            /*MOV*/ Type_OiTm& exactType = host_arg.type;
                            if (exactType && !isAssignableAsArgument_9CJm(exactType.vtype, inType.vtype, DONT_match_zeroes, ctx, _here))
                            {
                                if (args.size() > i_2)
                                    args.mutref(i_2) = static_cast<Type_OiTm&&>(exactType);

                                continue;
                            }
                            else
                            {
                                fu::vec_range<char> argName = ((argNode.flags & Flags_Lzg8_F_COMPOUND_ID) ? cleanID_V5Iu(argNode.value) : argNode.value);
                                if (argName)
                                {
                                    TypeParam_Lrcu& argName_typeParam = ref_hn2E(ss._typeParams, argName);
                                    const bool isTypedef = !!(argNode.flags & Flags_Lzg8_F_TYPENAME);
                                    if (isTypedef)
                                    {
                                        if (!(is_Typename_9CJm(inType)))
                                            BUG_gDsn(((argName + " not a typename: "_view) + explainType_gDsn(inType, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

                                    }
                                    else
                                        inType = clear_Typename_9CJm(Type_OiTm(inType), false);

                                    inType.vtype.vfacts = (isTypedef ? VFacts_xhRf_Typename : VFacts_xhRf{});
                                    (!argName_typeParam ? argName_typeParam : fail_gDsn((x7E_rA00("Type param name collision with "_view, str_wyx7(host_arg, false, _current_fn, ss, ctx, _here, module, options)) + "."_view), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers)).matched = Type_OiTm(inType);
                                    argName_typeParam.flags |= TypeParamFlags_vSpZ_TP_isArgSpec;
                                    if (isTypedef)
                                        argName_typeParam.flags |= TypeParamFlags_vSpZ_TP_isTypenameArgSpec;

                                    if (annot && !exactType)
                                    {
                                        fu::str error_1 = (error ? ((((qKW_e44U("arg"_view) + " "_view) + str_IDns_gDsn(original, ss, ctx, _here, module, options)) + qID_e44U(argName)) + ":"_view) : fu::str{});
                                        if (!trySolveTypeParams_gDsn(annot, static_cast<Type_OiTm&&>(inType), error_1, false, _current_fn, ss, ctx, _here, module, options, _helpers))
                                        {
                                            if (error)
                                            {
                                                fu::view<char> reason {};
                                                fu::view<char> _2 {};
                                                error += ((_2.ptr_reassign(reason.ptr_reassign(error_1))) ? _2 : BUG_gDsn("matchFail: No reason."_view, ss, ctx, _here, module, options, _helpers));
                                            };
                                            fail = true;
                                            goto LL_14;
                                        };
                                    };
                                }
                                else
                                    BUG_gDsn("No argName"_view, ss, ctx, _here, module, options, _helpers);

                            };
                        };
                    }
                    else
                    {
                        BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers);
                    };
                };
            } LL_14:;

            if (!error)
            {
                fu::view<Type_OiTm> args_1 = args;
                const bool allowReplaceNonSpecfails = false;
                int _3;
                const int start = ((_3 = (find_ZKsG(mangle, ' ') + 1)) ? _3 : BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers));
                fu::str mangle_1 = (fu::get_view(mangle, 0, start) + mangleArgTypes_BKEk(args_1));
                if (add_JHtk(mangles, mangle_1))
                {
                    const Target_VZrr preexisting = get_1BI4(getSpecs_FDl5(parent_idx, ss), mangle_1);
                    if (preexisting)
                    {
                        if (error)
                            BUG_gDsn("doTrySpec: resetMangle/preexisting on error path"_view, ss, ctx, _here, module, options, _helpers);
                        else
                        {
                            remove_HljL(mangles, mangle_1);
                            if (!is_SPECFAIL_gDsn(currentSpec))
                                destroyOverload_gDsn(currentSpec, ss, module);

                            resetSpec_gDsn(preexisting, allowReplaceNonSpecfails, parent_idx, error, mangles, currentSpec, ss, ctx, _here, module, options, _helpers);
                            return preexisting;
                        };
                    }
                    else
                        setSpec_gDsn(mangle_1, currentSpec, true, false, parent_idx, error, ss, ctx, _here, module, options, _helpers);

                };
            };
            if (fail)
            {
                return SPECFAIL_gDsn(fu::view<char>{}, parent_idx, error, SPECFAIL_RentrySafety, err0, mangles, currentSpec, ss, ctx, _here, module, options, _helpers);
            };
        };
        if (!into)
        {
            const Node_JjyR* _4;
            const Node_JjyR& body = (*(_4 = &(items[(items.size() + FN_BODY_BACK)])) ? *_4 : BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers));
            if (body.kind == Kind_Idfg_pattern)
            {
                Map_v4nV undo = ss._typeParams;
                fu::view<Node_JjyR> branches = body.items;
                bool did_match = false;
                for (int i = 0; i < branches.size(); i++)
                {
                    fu::view<Node_JjyR> branch = branches[i].items;
                    /*MOV*/ Node_JjyR n_body = branch[(branch.size() + FN_BODY_BACK)];
                    if (isNativeBody_gDsn(n_body))
                        each_fleD(ss._typeParams);

                    const Node_JjyR& cond = branches[i].items[0];
                    if (cond && !evalTypePattern_gDsn(cond, _current_fn, ss, ctx, _here, module, options, _helpers))
                        ss._typeParams = undo;
                    else
                    {

                        {
                            const Node_JjyR& n_ret = branch[(branch.size() + FN_RET_BACK)];
                            if (n_ret)
                                sig_wyx7(tEmplate).mutref((sig_iUdw(tEmplate).size() + FN_RET_BACK)) = Node_JjyR(n_ret);

                            sig_wyx7(tEmplate).mutref((sig_iUdw(tEmplate).size() + FN_BODY_BACK)) = static_cast<Node_JjyR&&>((n_body ? n_body : BUG_gDsn("doTrySpec: no case/body."_view, ss, ctx, _here, module, options, _helpers)));
                        };
                        did_match = true;
                        break;
                    };
                };
                if (!did_match)
                    return SPECFAIL_gDsn("No body pattern matched."_view, parent_idx, error, SPECFAIL_RentrySafety, err0, mangles, currentSpec, ss, ctx, _here, module, options, _helpers);

            };
            const Node_JjyR& n_body = n_fn_wyx7(tEmplate).items[(n_fn_wyx7(tEmplate).items.size() + FN_BODY_BACK)];
            if (isNativeBody_gDsn(n_body))
            {
                fu::view_mut<Node_JjyR> argNodes = fu::get_view_start0_mut(n_fn_iUdw(tEmplate).items, (n_fn_wyx7(tEmplate).items.size() + FN_ARGS_BACK));
                for (int i = 0; i < argNodes.size(); i++)
                {
                    Node_JjyR& argNode = argNodes.mutref(i);
                    if (!((argNode.flags & ((Flags_Lzg8_F_REF | Flags_Lzg8_F_CONST) | Flags_Lzg8_F_MUT)) != Flags_Lzg8_F_REF))
                    {
                        fu::view<char> argName = ((argNode.flags & Flags_Lzg8_F_COMPOUND_ID) ? cleanID_V5Iu(argNode.value) : argNode.value);
                        const Type_OiTm* _5;
                        const Type_OiTm& matched = (*(_5 = &(get_mPhm(ss._typeParams, (argName ? argName : BUG_gDsn("No argName"_view, ss, ctx, _here, module, options, _helpers))).matched)) ? *_5 : BUG_gDsn("native F_REF arg without a matched type"_view, ss, ctx, _here, module, options, _helpers));
                        if (!is_mutref_9CJm(matched, ctx, _here))
                            argNode.flags |= Flags_Lzg8_F_CONST;

                    };
                };
                each_n1d8(ss._typeParams);
            };
        };
        Target_VZrr target {};
        if (error)
            BUG_gDsn("doTrySpecialize: error path about to start solving"_view, ss, ctx, _here, module, options, _helpers);
        else
        {

            {
                const ScopeMemo_9hVQ scope0 = Scope_snap_gDsn(ss, _helpers);
                /*MOV*/ ScopeSkipMemos_0CE6 ss0 = ss._ss;
                const int helpers_data0 = ss._helpers_data.size();
                fu_DEFER(
                {
                    Scope_pop_gDsn(scope0, ss, _helpers);
                    ss._ss = static_cast<ScopeSkipMemos_0CE6&&>(ss0);
                    ss._helpers_data.shrink(helpers_data0);
                });

                {
                    if (ss._root_scope)
                    {
                        const Target_VZrr* _6;
                        const Ephemeral_xhb4& eph = EPH_gDsn((*(_6 = &(EXT_gDsn(original, ss, ctx, module).spec_of)) ? *_6 : original), ss, module);
                        const ScopeMemo_9hVQ& start = (eph.scope_memo ? eph.scope_memo : ss._root_scope);
                        ss._ss = eph.scope_skip;
                        ScopeSkip_push_gDsn(ss._ss.items, start.items_len, scope0.items_len, ss, ctx, _here, module, options, _helpers);
                        ScopeSkip_push_gDsn(ss._ss.implicits, start.implicits_len, scope0.implicits_len, ss, ctx, _here, module, options, _helpers);
                        ScopeSkip_push_gDsn(ss._ss.imports, start.imports_len, scope0.imports_len, ss, ctx, _here, module, options, _helpers);
                        ScopeSkip_push_gDsn(ss._ss.privates, start.privates_len, scope0.privates_len, ss, ctx, _here, module, options, _helpers);
                        ScopeSkip_push_gDsn(ss._ss.usings, start.usings_len, scope0.usings_len, ss, ctx, _here, module, options, _helpers);
                        ScopeSkip_push_gDsn(ss._ss.converts, start.converts_len, scope0.converts_len, ss, ctx, _here, module, options, _helpers);
                        ScopeSkip_push_gDsn(ss._ss.helpers, start.helpers_len, scope0.helpers_len, ss, ctx, _here, module, options, _helpers);
                    };
                    fu::view<int> imports = tEmplate.imports;
                    for (int i = 0; i < imports.size(); i++)
                    {
                        Scope_import_gDsn(imports[i], ss, ctx, _here);
                        if (i == 0)
                            Scope_import_privates_gDsn(imports[i], ss, ctx, _here);

                    };
                };
                target = (into ? Target_VZrr(into) : Scope_create_z0Qq(ss._scope, Kind_Idfg___no_kind_yet, (*(fu::str*)fu::NIL), (*(Type_OiTm*)fu::NIL), Flags_Lzg8{}, DeclAsserts_taUG{}, SolverStatus_h9em((SolverStatus_h9em_SS_DID_START | SolverStatus_h9em_SS_LAZY)), 0, false, module));
                Ephemeral_xhb4& eph = EPH_mut_FDl5(target, ss, module);
                eph.local_of = parent_idx;
                SpecExtras_JI9K spec_extras = (into ? EPH_gDsn(into, ss, module).spec_extras : (EPH_mut_FDl5(target, ss, module).spec_extras = intoSpecExtras_gDsn(ss._typeParams, ss, ctx, _here, module)));
                const Target_VZrr solvingFnort0 = exchange_GcK8(ss._solvingFnort, Target_VZrr(target));
                const Target_VZrr nestingFnort0 = exchange_GcK8(ss._nestingFnort, Target_VZrr(target));
                fu_DEFER(
                {
                    ss._solvingFnort = solvingFnort0;
                    ss._nestingFnort = nestingFnort0;
                });

                {
                    Ephemeral_xhb4& eph_1 = EPH_mut_FDl5(target, ss, module);
                    const unsigned rev0 = eph_1.revision++;
                    if (rev0)
                    {
                        if ((rev0 >= 1024u))
                            BUG_gDsn((x7E_rA00("Looping forever: "_view, str_FDl5(target, false, ss, ctx, _here, module, options)) + ".revision >= 1024"_view), ss, ctx, _here, module, options, _helpers);
                        else
                        {
                            Extended_z0HS& o = EXT_mut_gDsn(target, ss, module);
                            o.args_n_locals.clear();
                            o.args_neg = 0;
                            const Target_VZrr* t;
                            if (ss._warnings.size() > (t = &(target), int(unsigned((((*t)._packed >> 20ull) & 0xfffffull)))))
                            {
                                const Target_VZrr* t_1;
                                ss._warnings.mutref((t_1 = &(target), int(unsigned((((*t_1)._packed >> 20ull) & 0xfffffull))))) = Warning_9p8u{};
                            };
                            fu::vec<Target_VZrr> specs = fu::vec<Target_VZrr>(EPH_gDsn(target, ss, module).specs.vals);
                            for (int i = 0; i < specs.size(); i++)
                                resetChild_gDsn(Target_VZrr(specs[i]), ss, ctx, _here, module, options, _helpers);

                        };
                    };
                };
                const DeclAsserts_taUG asserts = tEmplate.node.asserts;
                CurrentFn_QbLp out = CurrentFn_QbLp { solved_gDsn(n_fn_FDl5(tEmplate), X_addrofTarget_FDl5(target), (*(fu::vec<SolvedNode_efhg>*)fu::NIL), target, _here), ScopeMemo_9hVQ(scope0), asserts, Flow_oKsD{}, Set_qOJY{}, Effects_bbOX{}, Events_SbUb{}, ((n_fn_FDl5(tEmplate).flags & Flags_Lzg8_F_TEMPLATE) ? 1 : 0), VarUsage_IMaS{}, false, 0, fu::vec<Target_VZrr>{}, 0, 0, Postdom_Vy5u{}, LocidMap_oyma{}, RevSpecPrototype_vWbr{}, 0, 0 };
                const ScopeMemo_9hVQ root_scope0 = ss._root_scope;
                if (!root_scope0)
                    ss._root_scope = scope0;

                std::swap(_current_fn, out);
                fu_DEFER(
                {
                    std::swap(_current_fn, out);
                    ss._root_scope = root_scope0;
                });
                fu::view_mut<Node_JjyR> inItems = n_fn_iUdw(tEmplate).items;
                outItems_gDsn(_current_fn).resize(inItems.size());
                ss._scope.items += spec_extras.scope_items;
                const bool isFirst = (!into || !GET_gDsn(into, ss, ctx, _here, module).solved);
                const Flags_Lzg8 isTemplate = (tEmplate.node.flags & Flags_Lzg8_F_TEMPLATE);
                const bool isSpec = (isTemplate ? (!into || !isFirst) : false);
                const bool isUnspec = (isTemplate ? !isSpec : false);
                for (int i = 0; i < (inItems.size() + FN_ARGS_BACK); i++)
                {
                    Node_JjyR& n_arg = inItems.mutref(i);
                    _here = n_arg.token;
                    if (isUnspec)
                    {
                        Node_JjyR& type_annot = n_arg.items.mutref(LET_TYPE);
                        if ((n_arg.flags & Flags_Lzg8_F_TEMPLATE) || !type_annot)
                        {
                            if (type_annot)
                                TODO_FIX_partialEvalTypeAnnot_gDsn(type_annot, _current_fn, ss, ctx, _here, module, options, _helpers);

                            SolvedNode_efhg init = (n_arg.items[LET_INIT] ? solveNode_gDsn(n_arg.items[LET_INIT], (*(Type_OiTm*)fu::NIL), _current_fn, ss, ctx, _here, module, options, _helpers) : SolvedNode_efhg{});
                            outItems_wyx7(_current_fn).mutref(i) = SolvedNode_gDsn(Kind_Idfg_let, Type_OiTm{}, n_arg.flags, n_arg.value, fu::vec<SolvedNode_efhg> {{ SolvedNode_efhg{}, SolvedNode_efhg(init) }}, Target_VZrr{}, Helpers_DyqV{}, _here);
                            continue;
                        };
                    };
                    const Type_OiTm& specType = (isSpec ? get_Inl8(spec_extras.arg_spec_types, ((n_arg.flags & Flags_Lzg8_F_COMPOUND_ID) ? cleanID_V5Iu(n_arg.value) : n_arg.value)) : (*(Type_OiTm*)fu::NIL));
                    /*MOV*/ SolvedNode_efhg arg = solveLet_gDsn(n_arg, true, specType, _current_fn, ss, ctx, _here, module, options, _helpers);
                    outItems_wyx7(_current_fn).mutref(i) = static_cast<SolvedNode_efhg&&>(arg);
                };
                const Node_JjyR& n_ret = (!isUnspec ? inItems[(inItems.size() + FN_RET_BACK)] : (*(Node_JjyR*)fu::NIL));
                const Node_JjyR& n_body = inItems[(inItems.size() + FN_BODY_BACK)];
                if (n_body)
                {
                    const bool isNative = isNativeBody_gDsn(n_body);
                    Type_OiTm ret_expect = (n_ret ? evalTypeAnnot_gDsn(n_ret, false, _current_fn, ss, ctx, _here, module, options, _helpers) : Type_OiTm{});
                    /*MOV*/ Type_OiTm ret_seed = (n_ret ? (ret_expect ? ret_expect : BUG_gDsn(("falsy ret_expect: "_view + n_fn_wyx7(tEmplate).value), ss, ctx, _here, module, options, _helpers)) : t_AssumeNever_WhileSolvingRecursion);
                    if (ret_seed.lifetime)
                    {
                        ret_seed.lifetime = (isNative ? Lifetime_fromNative_gDsn(inItems, fu::get_view_start0(_current_fn.out.items, (_current_fn.out.items.size() + FN_ARGS_BACK)), ret_seed, ss, ctx, _here, module, options, _helpers) : Lifetime_llCF(Lifetime_static_moveable));
                    }
                    else if (isNative)
                    {
                        for (int i_1 = 0; i_1 < (inItems.size() + FN_ARGS_BACK); i_1++)
                        {
                            const Node_JjyR& arg = inItems[i_1];
                            if ((arg.flags & Flags_Lzg8_F_REF) && !(arg.flags & (Flags_Lzg8_F_MUT | Flags_Lzg8_F_CONST)))
                            {
                                fail_gDsn(((((((((qKW_e44U("ref"_view) + " arguments to "_view) + qKW_e44U("__native"_view)) + " fns must either be ref-returned"_view) + " or explicitly specified "_view) + qKW_e44U("mut"_view)) + " or "_view) + qKW_e44U("const"_view)) + "."_view), fu::view<char>{}, TokenIdx_5581(arg.token), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                            };
                        };
                    };
                    if (isFirst)
                    {
                        /*MOV*/ fu::str name {};
                        FxMask_2dRz fx_mask {};
                        if (isNative)
                        {
                            for (int i_1 = 0; i_1 < n_body.items.size(); i_1++)
                            {
                                fu::view<char> item = n_body.items[i_1].value;
                                if (starts_Sfbf(item, '|'))
                                {
                                    FxMask_2dRz _7;
                                    fx_mask |= ((item == "|output"_view) ? EFFECTS_output : ((_7 = parse_fcZv(fu::get_view(item, 1))) ? _7 : BUG_gDsn(("Invalid |Fx mask: "_view + qBAD_e44U(item)), ss, ctx, _here, module, options, _helpers)));
                                }
                                else
                                    name += ("\n"_view + item);

                            };
                        };
                        if (!(name))
                        {
                            fu::vec_range<char> _8 {};
                            name = ((_8.ptr_reassign(n_fn_FDl5(tEmplate).value)) ? _8 : BUG_gDsn("TODO anonymous fns"_view, ss, ctx, _here, module, options, _helpers));
                        };
                        Overload_aO3i& overload = GET_mut_gDsn(target, ss, module);
                        overload.name = static_cast<fu::str&&>(name);
                        Extended_z0HS& ext = EXT_mut_gDsn(target, ss, module);
                        ext.tEmplate = tEmplate;
                        ext.spec_of = overloadIdx;
                        ext.fx_mask = fx_mask;
                        /*MOV*/ Type_OiTm& retval = ret_seed;
                        const bool maybeLast = (isNative ? !isUnspec : false);
                        const TokenIdx_5581* _9;
                        _here = (*(_9 = &(n_fn_FDl5(tEmplate).token)) ? *_9 : BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers));
                        if (GET_gDsn(target, ss, ctx, _here, module).status & SolverStatus_h9em_SS_DIRTY)
                            GET_mut_gDsn(target, ss, module).status |= SolverStatus_h9em_SS_UPDATED;
                        else
                        {
                            doUpdateScope_gDsn(static_cast<Type_OiTm&&>(retval), target, maybeLast, isNative, isUnspec, asserts, _current_fn, ss, ctx, _here, module, options, _helpers);
                            if (!into)
                            {

                                {
                                    fu::view<Argument_bbKc> args = EXT_gDsn(target, ss, ctx, module).args;
                                    int _10;
                                    const int start = ((_10 = (find_ZKsG(mangle, ' ') + 1)) ? _10 : BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers));
                                    fu::str mangle_1 = (fu::get_view(mangle, 0, start) + mangleArgTypes_VSPO(args));
                                    if (add_JHtk(mangles, mangle_1))
                                    {
                                        const Target_VZrr preexisting = get_1BI4(getSpecs_FDl5(parent_idx, ss), mangle_1);
                                        if (preexisting)
                                        {
                                            if (error)
                                                BUG_gDsn("doTrySpec: resetMangle/preexisting on error path"_view, ss, ctx, _here, module, options, _helpers);
                                            else
                                            {
                                                remove_HljL(mangles, mangle_1);
                                                if (!is_SPECFAIL_gDsn(currentSpec))
                                                    destroyOverload_gDsn(currentSpec, ss, module);

                                                resetSpec_gDsn(preexisting, maybeLast, parent_idx, error, mangles, currentSpec, ss, ctx, _here, module, options, _helpers);
                                                return preexisting;
                                            };
                                        }
                                        else
                                            setSpec_gDsn(mangle_1, currentSpec, true, false, parent_idx, error, ss, ctx, _here, module, options, _helpers);

                                    };
                                };
                                resetSpec_gDsn(target, false, parent_idx, error, mangles, currentSpec, ss, ctx, _here, module, options, _helpers);
                            };
                        };
                    };
                    bool didSetBody = false;
                    if (!isUnspec && !isNative)
                    {
                        if (isFirst)
                        {
                            Extended_z0HS& ext = EXT_mut_gDsn(target, ss, module);
                            for (int i_1 = 0; i_1 < ext.args.size(); i_1++)
                                force_relax_9CJm(ext.args.mutref(i_1).type, (RELAX_all & ~q_USAGE));

                        };

                        {
                            const Target_VZrr* t;
                            const int self = (t = &(target), int(unsigned((((*t)._packed >> 20ull) & 0xfffffull))));
                            CountedSet_C7kV calls = steal_LVBp(EPH_mut_FDl5(target, ss, module).calls);
                            each_8466(calls, target, self, ss, ctx, _here, module, options, _helpers);
                        };
                        const SolverStatus_h9em status = (GET_mut_gDsn(target, ss, module).status &= SolverStatus_h9em(~SolverStatus_h9em_SS_Debug_AllPassesComplete));
                        if (SolverStatus_h9em((status & SolverStatus_h9em((SolverStatus_h9em((SolverStatus_h9em_SS_DIRTY | SolverStatus_h9em_SS_FINALIZED)) | SolverStatus_h9em_SS_DID_START)))) != SolverStatus_h9em_SS_DID_START)
                            BUG_gDsn(x7E_rA00(x7E_rA00(str_FDl5(target, false, ss, ctx, _here, module, options), " is not SS_DID_START just before solve: "_view), str_VyKZ(status)), ss, ctx, _here, module, options, _helpers);
                        else
                        {
                            _current_fn.TODO_FIX_isInline = !!(tEmplate.node.flags & Flags_Lzg8_F_INLINE);
                            /*MOV*/ SolvedNode_efhg s_body {};
                            const Target_VZrr* t;
                            s_body = solveBlock_gDsn(n_body, ret_expect, (t = &(target), int(unsigned((((*t)._packed >> 20ull) & 0xfffffull)))), HelpersMask_w1sv((HelpersMask_w1sv((HelpersMask_w1sv((HelpersMask_w1sv_HM_Function | HelpersMask_w1sv_HM_CanReturn)) | HelpersMask_w1sv_HM_LabelUsed)) | ((n_fn_FDl5(tEmplate).flags & Flags_Lzg8_F_LAMBDA) ? HelpersMask_w1sv_HM_Lambda : HelpersMask_w1sv{}))), n_fn_FDl5(tEmplate).value, 0, _current_fn, ss, ctx, _here, module, options, _helpers);
                            const Helpers_DyqV* h;
                            const Type_OiTm* _11;
                            const Type_OiTm& retval = (*(_11 = &((h = &(s_body.helpers), ((((*h).index >= 0) && ((*h).index < ss._helpers_data.size())) ? ss._helpers_data[(*h).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).ret_actual)) ? *_11 : BUG_gDsn("doTrySpec: no body.ret_actual"_view, ss, ctx, _here, module, options, _helpers));
                            const int idx_body = (outItems_iUdw(_current_fn).size() + FN_BODY_BACK);
                            outItems_wyx7(_current_fn).mutref(idx_body) = static_cast<SolvedNode_efhg&&>((s_body ? s_body : BUG_gDsn("falsy body"_view, ss, ctx, _here, module, options, _helpers)));
                            didSetBody = true;
                            const Type_OiTm& retval_1 = retval;
                            const bool maybeLast = true;
                            const TokenIdx_5581* _12;
                            _here = (*(_12 = &(n_fn_FDl5(tEmplate).token)) ? *_12 : BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers));
                            if (GET_gDsn(target, ss, ctx, _here, module).status & SolverStatus_h9em_SS_DIRTY)
                                GET_mut_gDsn(target, ss, module).status |= SolverStatus_h9em_SS_UPDATED;
                            else
                            {
                                doUpdateScope_gDsn(Type_OiTm(retval_1), target, maybeLast, isNative, isUnspec, asserts, _current_fn, ss, ctx, _here, module, options, _helpers);
                                if (!into)
                                {

                                    {
                                        fu::view<Argument_bbKc> args = EXT_gDsn(target, ss, ctx, module).args;
                                        int _13;
                                        const int start = ((_13 = (find_ZKsG(mangle, ' ') + 1)) ? _13 : BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers));
                                        fu::str mangle_1 = (fu::get_view(mangle, 0, start) + mangleArgTypes_VSPO(args));
                                        if (add_JHtk(mangles, mangle_1))
                                        {
                                            const Target_VZrr preexisting = get_1BI4(getSpecs_FDl5(parent_idx, ss), mangle_1);
                                            if (preexisting)
                                            {
                                                if (error)
                                                    BUG_gDsn("doTrySpec: resetMangle/preexisting on error path"_view, ss, ctx, _here, module, options, _helpers);
                                                else
                                                {
                                                    remove_HljL(mangles, mangle_1);
                                                    if (!is_SPECFAIL_gDsn(currentSpec))
                                                        destroyOverload_gDsn(currentSpec, ss, module);

                                                    resetSpec_gDsn(preexisting, maybeLast, parent_idx, error, mangles, currentSpec, ss, ctx, _here, module, options, _helpers);
                                                    return preexisting;
                                                };
                                            }
                                            else
                                                setSpec_gDsn(mangle_1, currentSpec, true, false, parent_idx, error, ss, ctx, _here, module, options, _helpers);

                                        };
                                    };
                                    resetSpec_gDsn(target, false, parent_idx, error, mangles, currentSpec, ss, ctx, _here, module, options, _helpers);
                                };
                            };
                        };
                    };
                    if (!didSetBody)
                    {
                        if (!(GET_gDsn(target, ss, ctx, _here, module).kind != Kind_Idfg_fn))
                            BUG_gDsn(x7E_rA00("Did not set body on "_view, str_FDl5(target, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

                    };
                }
                else
                    BUG_gDsn("solveFn: no body."_view, ss, ctx, _here, module, options, _helpers);

            };
            lazySolveEnd_gDsn(target, _current_fn, ss, ctx, _here, module, options, _helpers);
            return target;
        };
    };
}

static Target_VZrr trySpecialize_gDsn(const Target_VZrr& overloadIdx, fu::view<SolvedNode_efhg> args, fu::vec_range_mut<char> args_mangled, fu::vec_range_mut<char> error, const int REST_START, const Type_OiTm& REST_TYPE, const Reorder_0MNg& reorder, fu::view<fu::vec<Target_VZrr>> conversions, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    if (!(args_mangled))
        args_mangled = mangleArgTypes_gDsn(args, reorder, conversions, REST_START, REST_TYPE, ss, ctx, _here, module);

    int parent_idx = EPH_gDsn(overloadIdx, ss, module).local_of;
    for (int i = 0; i < args.size(); i++)
    {
        const SolvedNode_efhg& arg_t = args[i];
        if (isAddrOfFn_9CJm(arg_t.type))
            unpackAddrOfFn_gaRf(arg_t.type.vtype.canon, parent_idx, ss, module);

    };
    fu::str mangle = ((x7E_rA00(x7E_rA00(fu::i64dec(int(unsigned(((overloadIdx._packed >> 40ull) & 0xfffffull)))), "#"_view), fu::i64dec(int(unsigned(((overloadIdx._packed >> 20ull) & 0xfffffull))))) + " "_view) + args_mangled);
    const Target_VZrr& preexisting = get_1BI4(getSpecs_FDl5(parent_idx, ss), mangle);
    if (preexisting && (!is_SPECFAIL_gDsn(preexisting) || !error))
        return preexisting;
    else
    {
        Target_VZrr _0;
        return (_0 = doTrySpecialize_gDsn(parent_idx, error, Target_VZrr{}, overloadIdx, args, mangle, reorder, conversions, REST_START, REST_TYPE, _current_fn, ss, ctx, _here, module, options, _helpers)) ? static_cast<Target_VZrr&&>(_0) : BUG_gDsn("doTrySpecialize returns empty target."_view, ss, ctx, _here, module, options, _helpers);
    };
}

static bool isDiscardable_gDsn(const Target_VZrr& t, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const Extended_z0HS& ext = EXT_gDsn(t, ss, ctx, module);
    if (ext.tEmplate.node.asserts & DeclAsserts_taUG_A_NODISCARD)
    {
        fail_gDsn((((((x7E_rA00("Return value of "_view, str_FDl5(t, false, ss, ctx, _here, module, options)) + ": "_view) + qBAD_e44U("nodiscard"_view)) + " "_view) + explainType_gDsn(GET_gDsn(t, ss, ctx, _here, module).type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)) + " is getting discarded here."_view), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
    }
    else if (EXT_gDsn(t, ss, ctx, module).fx_mask & FxMask_2dRz_Fx_NotDeadCode)
        return false;
    else
    {
        fu::view<Argument_bbKc> host_args = ext.args;
        for (int i = 0; i < host_args.size(); i++)
        {
            if (host_args[i].written_to)
                return false;

        };
        return true;
    };
}

static void discardIntoBlock_gDsn(SolvedNode_efhg& node, const Type_OiTm& slot, const unsigned relax_mask, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    node = createBlock_gDsn(slot, node.items, Helpers_DyqV{}, _here);
    propagateType_gDsn(node, slot, relax_mask, Helpers_DyqV{}, _current_fn, ss, ctx, _here, module, options, _helpers);
}

                                #ifndef DEF_iF_97HjSwpbNd3
                                #define DEF_iF_97HjSwpbNd3
inline const Set_qOJY& iF_97Hj(fu::view<Set_qOJY> a, const int i)
{
    if (uNsigned_40Hl(i) < uNsigned_40Hl(a.size()))
        return a[i];
    else
        return (*(Set_qOJY*)fu::NIL);

}
                                #endif

                                #ifndef DEF_iF_uNaKyxhAO18
                                #define DEF_iF_uNaKyxhAO18
inline static const Set_qOJY& iF_uNaK(const LocidMap_oyma& map, const int locid, const CurrentFn_QbLp& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    return iF_97Hj(map._values, (args_neg + locid));
}
                                #endif

                                #ifndef DEF_find_cnEOb0yQcL9
                                #define DEF_find_cnEOb0yQcL9
inline int find_cnEO(fu::view<int> haystack, const int needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_has_b66pz2alRJ0
                                #define DEF_has_b66pz2alRJ0
inline bool has_b66p(fu::view<int> a, const int b)
{
    return (find_cnEO(a, b) >= 0);
}
                                #endif

                                #ifndef DEF_iF_oyqggGA2E38
                                #define DEF_iF_oyqggGA2E38
inline const Lifetime_llCF& iF_oyqg(fu::view<Lifetime_llCF> a, const int i)
{
    if (uNsigned_40Hl(i) < uNsigned_40Hl(a.size()))
        return a[i];
    else
    {
        return (*(Lifetime_llCF*)fu::NIL);
    };
}
                                #endif

                                #ifndef DEF_iF_4knFiVyErN2
                                #define DEF_iF_4knFiVyErN2
inline static const Lifetime_llCF& iF_4knF(const LocidMap_JYql& map, const int locid, const CurrentFn_QbLp& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    return iF_oyqg(map._values, (args_neg + locid));
}
                                #endif

                                #ifndef DEF___9JWPbqggeod
                                #define DEF___9JWPbqggeod
inline static bool _9JWP(const ValueType_JtNg& _, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    return is_reinterpretable_1qjp(_, ctx, _here, module);
}
                                #endif

                                #ifndef DEF_if_sliceable_26hqa0Ifced
                                #define DEF_if_sliceable_26hqa0Ifced
inline bool if_sliceable_26hq(const ValueType_JtNg& type, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    if (is_sliceable_hxWW(type))
        return _9JWP(parseType_1qjp(fu::get_view(type.canon, 1, (type.canon.size() - 1)), ctx, _here, module), ctx, _here, module);
    else
        return false;

}
                                #endif

                                #ifndef DEF_type_maybeInside_8aZ0oNSm6ng
                                #define DEF_type_maybeInside_8aZ0oNSm6ng
inline static bool type_maybeInside_8aZ0(const ValueType_JtNg& host, const ValueType_JtNg& guest, const uint64_t guest_non_triv_mask, Set_pEwD& seen, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    if (isCanonAssignable_Ot6w(host.canon, guest.canon, ctx, _here))
        return true;
    else if (is_sliceable_hxWW(host))
    {
        ValueType_JtNg host_sliceT = parseType_1qjp(fu::get_view(host.canon, 1, (host.canon.size() - 1)), ctx, _here, module);
        return type_maybeInside_8aZ0(host_sliceT, guest, guest_non_triv_mask, seen, ss, ctx, _here, module);
    }
    else
    {
        if (isStruct_p1TN(host))
        {
            const StructCanon_TixV scp = parseStructCanon_p1TN(host.canon);
            const Struct_LDkB& s = lookupUserType_1qjp(scp, module, ctx, _here);
            if ((s.shape.non_triv_mask & guest_non_triv_mask) != guest_non_triv_mask)
                return false;
            else if (add_1NAP(seen, scp))
            {
                for (int i = 0; i < s.items.size(); i++)
                {
                    const Overload_aO3i& f = GET_gDsn(target_z0Qq(s.items[i]), ss, ctx, _here, module);
                    const Type_OiTm& fieldType = f.type;
                    if (type_maybeInside_8aZ0(fieldType.vtype, guest, guest_non_triv_mask, seen, ss, ctx, _here, module))
                        return true;

                };
            };
        };
        return false;
    };
}
                                #endif

                                #ifndef DEF_type_maybeInside_KAHlks6Asr9
                                #define DEF_type_maybeInside_KAHlks6Asr9
inline static bool type_maybeInside_KAHl(const ValueType_JtNg& host, const unsigned usage, const ValueType_JtNg& guest, const uint64_t guest_non_triv_mask, Set_pEwD& seen, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    if (!usage)
        return false;
    else if (isCanonAssignable_Ot6w(host.canon, guest.canon, ctx, _here))
        return true;
    else if (is_sliceable_hxWW(host))
    {
        ValueType_JtNg host_sliceT = parseType_1qjp(fu::get_view(host.canon, 1, (host.canon.size() - 1)), ctx, _here, module);
        return type_maybeInside_8aZ0(host_sliceT, guest, guest_non_triv_mask, seen, ss, ctx, _here, module);
    }
    else
    {
        if (isStruct_p1TN(host))
        {
            const StructCanon_TixV scp = parseStructCanon_p1TN(host.canon);
            const Struct_LDkB& s = lookupUserType_1qjp(scp, module, ctx, _here);
            if ((s.shape.non_triv_mask & guest_non_triv_mask) != guest_non_triv_mask)
                return false;
            else
            {
                for (int i = 0; i < s.items.size(); i++)
                {
                    const Overload_aO3i& f = GET_gDsn(target_z0Qq(s.items[i]), ss, ctx, _here, module);
                    const Type_OiTm& fieldType = f.type;
                    const UnpackedOffset_f7kz _ = field_unpackOffset_gDsn(f, ctx, _here);
                    const ValueType_JtNg* type;
                    const unsigned usage_1 = USAGE_fieldUsageFromStructUsage_CaGD((type = &(f.type.vtype), ((*type).quals & q_USAGE)), usage, _.memberFlatOffset, _.memberFlatCount);
                    if (usage_1 == getMaxUsage_CaGD(_.memberFlatCount))
                    {
                        if (type_maybeInside_8aZ0(fieldType.vtype, guest, guest_non_triv_mask, seen, ss, ctx, _here, module))
                            return true;

                    }
                    else if (type_maybeInside_KAHl(fieldType.vtype, usage_1, guest, guest_non_triv_mask, seen, ss, ctx, _here, module))
                        return true;

                };
            };
        };
        return false;
    };
}
                                #endif

static bool SLOW_type_maybeInside_gDsn(const ValueType_JtNg& host, const ValueType_JtNg& guest, const uint64_t guest_non_triv_mask, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    Set_pEwD seen {};
    const unsigned usage = (host.quals & q_USAGE);
    if (usage == getMaxUsage_CaGD(getFlatCount_1qjp(host, ctx, _here, module)))
        return type_maybeInside_8aZ0(host, guest, guest_non_triv_mask, seen, ss, ctx, _here, module);
    else
        return type_maybeInside_KAHl(host, usage, guest, guest_non_triv_mask, seen, ss, ctx, _here, module);

}

static bool type_mayPointInto_gDsn(const ValueType_JtNg& host, const ValueType_JtNg& guest, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    if (is_reinterpretable_1qjp(guest, ctx, _here, module) || if_sliceable_26hq(guest, ctx, _here, module))
        return !!(host.quals & q_USAGE);
    else
    {
        const uint64_t guest_non_triv_mask = getShape_1qjp(guest, ctx, _here, module).non_triv_mask;
        if (!guest_non_triv_mask)
            return false;
        else
        {
            const uint64_t host_non_triv_mask = getShape_1qjp(host, ctx, _here, module).non_triv_mask;
            if ((host_non_triv_mask & guest_non_triv_mask) != guest_non_triv_mask)
                return false;
            else
                return SLOW_type_maybeInside_gDsn(host, guest, guest_non_triv_mask, ss, ctx, _here, module);

        };
    };
}

                                #ifndef DEF_x3Dx3D_mpRcfMBNdC1
                                #define DEF_x3Dx3D_mpRcfMBNdC1
inline bool operator==(const TokenIdx_5581& a, const TokenIdx_5581& b)
{
    return !x3Cx3E_nZia(a, b);
}
                                #endif

                                #ifndef DEF___7gvJoPCvJk3
                                #define DEF___7gvJoPCvJk3
inline static bool _7gvJ(const COWInside_qvly& cow, const Argument_bbKc& host_arg, const TokenIdx_5581& cow_inside)
{
    const Target_VZrr* t;
    unsigned v;
    if (cow.argTarget == (t = &(host_arg.target), v = unsigned(((*t)._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))))
        return cow.token == cow_inside;
    else
        return false;

}
                                #endif

                                #ifndef DEF_some_aCs13Gm3tb3
                                #define DEF_some_aCs13Gm3tb3
inline bool some_aCs1(fu::view<COWInside_qvly> a, const Argument_bbKc& host_arg, const TokenIdx_5581& cow_inside)
{
    for (int i = 0; i < a.size(); i++)
    {
        const COWInside_qvly& item = a[i];
        if (_7gvJ(item, host_arg, cow_inside))
            return true;

    };
    return false;
}
                                #endif

static fu::str qSTACK_cow_inside_gDsn(const Target_VZrr& target, const SolvedNode_efhg& node, const Argument_bbKc& host_arg, const TokenIdx_5581& cow_inside, fu::view<Target_VZrr> seen, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const Target_VZrr nestingFnort0 = exchange_GcK8(ss._nestingFnort, Target_VZrr(target));
    fu_DEFER(ss._nestingFnort = nestingFnort0);
    const Target_VZrr* t;
    unsigned v;
    const int locid = (t = &(host_arg.target), v = unsigned(((*t)._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
    fu::view<char> candidates = fu::view<char>{};
    fu::vec<Target_VZrr> seen_1 = (seen + target);

    {
        fu::vec<SolvedNode_efhg> stack = fu::vec<SolvedNode_efhg> {{ SolvedNode_efhg(node) }};
        while (stack)
        {
            SolvedNode_efhg node_1 = TODO_FIX_pop_f7Nv(stack);
            const SolvedNode_efhg& node_2 = ((node_1.kind == Kind_Idfg_letdef) ? GET_gDsn(node_1.target, ss, ctx, _here, module).solved : node_1);
            SolvedNode_efhg node_3 = ((node_2.kind == Kind_Idfg___preceding_ref_arg) ? _current_fn.events.preceding_ref_args[node_2.helpers.index].arg : node_2);
            if ((node_3.kind == Kind_Idfg_copy) && (only_S4ER(node_3.items).token == cow_inside))
            {
                return (x7E_rA00(("\n            "_view + "in "_view), str_FDl5(target, false, ss, ctx, _here, module, options)) + " at "_view) + addr_and_snippet_gDsn(cow_inside, CodeFmt_snPx{}, fu::view<char>{}, ctx, module);
            }
            else
            {
                if (!((node_3.kind != Kind_Idfg_call) || !node_3.items))
                {
                    if (!(has_bkvR(seen_1, node_3.target)))
                    {
                        fu::view<Argument_bbKc> host_args = EXT_gDsn(node_3.target, ss, ctx, module).args;
                        for (int i = 0; i < host_args.size(); i++)
                        {
                            const Argument_bbKc& host_arg_1 = host_args[i];
                            if ((host_arg_1.flags & Flags_Lzg8_F_COW_INSIDE) && some_aCs1(EXT_gDsn(node_3.target, ss, ctx, module).cows_inside, host_arg_1, cow_inside) && Lifetime_has_7Yz9(Lifetime_unwind_gDsn(node_3.items[i].type.lifetime, false, ss, ctx, _here, module, options, _helpers), locid))
                            {
                                fu::str peek = qSTACK_cow_inside_gDsn(node_3.target, GET_gDsn(node_3.target, ss, ctx, _here, module).solved, host_arg_1, cow_inside, seen_1, _current_fn, ss, ctx, _here, module, options, _helpers);
                                return (((x7E_rA00((x7E_rA00(("\n            "_view + "in "_view), str_FDl5(target, false, ss, ctx, _here, module, options)) + " via "_view), str_FDl5(node_3.target, false, ss, ctx, _here, module, options)) + " at "_view) + addr_and_snippet_gDsn(node_3.token, CodeFmt_snPx{}, fu::view<char>{}, ctx, module)) + peek) + candidates;
                            };
                        };
                    };
                };
            };
            for (int i = node_3.items.size(); i-- > 0; )
                stack += SolvedNode_efhg(node_3.items[i]);

        };
    };
    return fu::str{};
}

                                #ifndef DEF___ATu9AZtflqd
                                #define DEF___ATu9AZtflqd
inline static void _ATu9(const ValueType_JtNg& vtype, const TokenIdx_5581& token, const Target_VZrr& t, const Overload_aO3i& o, const int parent_locid, const TokenIdx_5581& here, const Target_VZrr& callee, const Argument_bbKc& host_arg, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (type_mayPointInto_gDsn(vtype, o.type.vtype, ss, ctx, _here, module))
    {
        fu::str _0 {};
        fu::str err = (!callee ? fu::str(str_NbejPnXqD7k) : ((_0 = (x7E_rA00(x7E_rA00(str_wyx7(host_arg, false, _current_fn, ss, ctx, _here, module, options), " to "_view), str_FDl5(callee, false, ss, ctx, _here, module, options)) + " is indirectly copied from:\n"_view), (static_cast<fu::str&&>(_0) + qSTACK_cow_inside_gDsn(callee, GET_gDsn(callee, ss, ctx, _here, module).solved, host_arg, token, fu::view<Target_VZrr>{}, _current_fn, ss, ctx, _here, module, options, _helpers))) + "\n\t... but "_view));
        err += ("COW will break due to pre-existing mutref: "_view + explainWhichFn_gDsn(Target_VZrr(t), fu::view<fu::vec<Target_VZrr>>{}, fu::view<char>{}, CodeFmt_snPx_FullContext, _current_fn, ss, ctx, _here, module, options));
        err += ("\n\tBoth refer to: "_view + explainWhichFn_gDsn(nested_FDl5(parent_locid, ss, ctx, _here), fu::view<fu::vec<Target_VZrr>>{}, fu::view<char>{}, CodeFmt_snPx_FullContext, _current_fn, ss, ctx, _here, module, options));
        _here = here;
        fail_gDsn(err, fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
    };
}
                                #endif

                                #ifndef DEF_eachCOWInside_hAlipKSZxnc
                                #define DEF_eachCOWInside_hAlipKSZxnc
inline static void eachCOWInside_hAli(const Target_VZrr& t, const Overload_aO3i& o, const int parent_locid, const SolvedNode_efhg& item, const TokenIdx_5581& here, const Target_VZrr& callee, const Argument_bbKc& host_arg, const bool calleeReturnDiscarded, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (callee)
    {
        fu::vec<COWInside_qvly> callee_cows = fu::vec<COWInside_qvly>(EXT_gDsn(callee, ss, ctx, module).cows_inside);
        for (int i = 0; i < callee_cows.size(); i++)
        {
            const COWInside_qvly& callee_cow = callee_cows[i];
            if (!(calleeReturnDiscarded && !callee_cow.mayEscapeVia))
            {
                const Target_VZrr* t_1;
                unsigned v;
                if (callee_cow.argTarget == (t_1 = &(host_arg.target), v = unsigned(((*t_1)._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))))
                    _ATu9(callee_cow.vtype, callee_cow.token, t, o, parent_locid, here, callee, host_arg, _current_fn, ss, ctx, _here, module, options, _helpers);

            };
        };
    }
    else
        _ATu9(item.type.vtype, _here, t, o, parent_locid, here, callee, host_arg, _current_fn, ss, ctx, _here, module, options, _helpers);

}
                                #endif

                                #ifndef DEF___yT7e9fK7Yb9
                                #define DEF___yT7e9fK7Yb9
inline static void _yT7e(const int child, const Target_VZrr& t, const Overload_aO3i& o, const int parent_locid, const Lifetime_llCF& parent_region, fu::view<int> expected_refs, const SolvedNode_efhg& item, const TokenIdx_5581& here, const Target_VZrr& callee, const Argument_bbKc& host_arg, const bool calleeReturnDiscarded, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (!(has_b66p(expected_refs, child)))
    {
        Lifetime_llCF inter = Lifetime_inter_7Yz9(iF_4knF(_current_fn.flow.rg_parents, child, _current_fn), parent_region, ctx, _here);
        if (!(!inter))
        {
            const LocidMap_IP5H* map;
            if ((map = &(_current_fn.postdom.snap.ever_written), !!iF_BZQz((*map), child, _current_fn)))
                eachCOWInside_hAli(t, o, parent_locid, item, here, callee, host_arg, calleeReturnDiscarded, _current_fn, ss, ctx, _here, module, options, _helpers);

            cannotCOW_descendChildren_gDsn(child, inter, expected_refs, item, here, callee, host_arg, calleeReturnDiscarded, _current_fn, ss, ctx, _here, module, options, _helpers);
        };
    };
}
                                #endif

                                #ifndef DEF_eachLiveChildMutref_xPRv8aSiQM4
                                #define DEF_eachLiveChildMutref_xPRv8aSiQM4
inline static void eachLiveChildMutref_xPRv(const int index, const int parent_locid, const Lifetime_llCF& parent_region, fu::view<int> expected_refs, const SolvedNode_efhg& item, const TokenIdx_5581& here, const Target_VZrr& callee, const Argument_bbKc& host_arg, const bool calleeReturnDiscarded, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const Set_qOJY& children = iF_uNaK(_current_fn.TODO_FIX_children, index, _current_fn);
    for (int i = 0; i < children.keys_asc.size(); i++)
    {
        int i_1;
        const int child = (i_1 = i, children.keys_asc[i_1]);
        const Target_VZrr t = nested_FDl5(child, ss, ctx, _here);
        const Overload_aO3i& o = GET_gDsn(t, ss, ctx, _here, module);
        if (!(!is_mutref_9CJm(o.solved.type, ctx, _here)))
        {
            if (!(has_gDsn(_current_fn.relaxed.done_relaxing, child, _current_fn)))
                _yT7e(child, t, o, parent_locid, parent_region, expected_refs, item, here, callee, host_arg, calleeReturnDiscarded, _current_fn, ss, ctx, _here, module, options, _helpers);

        };
    };
}
                                #endif

static void cannotCOW_descendChildren_gDsn(const int parent_locid, const Lifetime_llCF& parent_region, fu::view<int> expected_refs, const SolvedNode_efhg& item, const TokenIdx_5581& here, const Target_VZrr& callee, const Argument_bbKc& host_arg, const bool calleeReturnDiscarded, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    eachLiveChildMutref_xPRv(parent_locid, parent_locid, parent_region, expected_refs, item, here, callee, host_arg, calleeReturnDiscarded, _current_fn, ss, ctx, _here, module, options, _helpers);
}

                                #ifndef DEF_needsHardRisk_sScESGLczEc
                                #define DEF_needsHardRisk_sScESGLczEc
inline static int needsHardRisk_sScE(const int index, const Overload_aO3i& o, const SolvedNode_efhg& item, const Target_VZrr& callee, const Argument_bbKc& host_arg, const bool calleeReturnDiscarded, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{

    {
        const Set_qOJY& children = iF_uNaK(_current_fn.TODO_FIX_children, index, _current_fn);
        for (int i = 0; i < children.keys_asc.size(); i++)
        {
            int i_1;
            const int child = (i_1 = i, children.keys_asc[i_1]);
            const Target_VZrr t = nested_FDl5(child, ss, ctx, _here);
            const Overload_aO3i& o_1 = GET_gDsn(t, ss, ctx, _here, module);
            if (!(!is_mutref_9CJm(o_1.solved.type, ctx, _here)))
            {
                if (!(has_gDsn(_current_fn.relaxed.done_relaxing, child, _current_fn)))
                {
                    const int reason = needsHardRisk_sScE(child, o, item, callee, host_arg, calleeReturnDiscarded, _current_fn, ss, ctx, _here, module);
                    if (reason)
                        return reason;

                };
            };
        };
    };
    const LocidMap_IP5H* map;
    if ((map = &(_current_fn.postdom.snap.ever_written), !!iF_BZQz((*map), index, _current_fn)))
    {
        if (callee)
        {
            fu::view<COWInside_qvly> callee_cows = EXT_gDsn(callee, ss, ctx, module).cows_inside;
            for (int i = 0; i < callee_cows.size(); i++)
            {
                const COWInside_qvly& callee_cow = callee_cows[i];
                if (!(calleeReturnDiscarded && !callee_cow.mayEscapeVia))
                {
                    const Target_VZrr* t;
                    unsigned v;
                    if (callee_cow.argTarget == (t = &(host_arg.target), v = unsigned(((*t)._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))))
                    {
                        const ValueType_JtNg& vtype = callee_cow.vtype;
                        const bool uncaughtThrowOnly = ((callee_cow.exitPaths == ExitPaths_UXHs_XP_NoReturn) ? !_current_fn.TODO_FIX_catches : false);
                        if (!(uncaughtThrowOnly))
                        {
                            if (type_mayPointInto_gDsn(vtype, o.type.vtype, ss, ctx, _here, module))
                                return index;

                        };
                    };
                };
            };
        }
        else
        {
            const ValueType_JtNg& vtype = item.type.vtype;
            if (type_mayPointInto_gDsn(vtype, o.type.vtype, ss, ctx, _here, module))
                return index;

        };
    };
    return 0;
}
                                #endif

                                #ifndef DEF_ensure_XJ9z16apwui
                                #define DEF_ensure_XJ9z16apwui
inline LocidSet_iAWt& ensure_XJ9z(fu::vec_range_mut<LocidSet_iAWt> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

                                #ifndef DEF_ensure_l3bnBXsqw77
                                #define DEF_ensure_l3bnBXsqw77
inline static LocidSet_iAWt& ensure_l3bn(LocidMap_DNUT& map, const int locid, const CurrentFn_QbLp& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    return ensure_XJ9z(map._values, (args_neg + locid));
}
                                #endif

                                #ifndef DEF_TODO_FIX_slicesAgain_zZesmAOPxIk
                                #define DEF_TODO_FIX_slicesAgain_zZesmAOPxIk
inline static bool TODO_FIX_slicesAgain_zZes(const int t, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    return is_sliceable_hxWW(GET_gDsn(nested_FDl5(t, ss, ctx, _here), ss, ctx, _here, module).type.vtype);
}
                                #endif

static void cannotCOW_climbParents_gDsn(const Lifetime_llCF& lifetime, fu::view<int> expected_refs, const SolvedNode_efhg& item, const TokenIdx_5581& here, const Target_VZrr& callee, const Argument_bbKc& host_arg, const bool calleeReturnDiscarded, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const fu::str& chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const int offset0 = offset;
        const unsigned r = parse7bit_7Yz9(chars, offset);
        int offset0_1;
        int BL_3_v;
        const int sr = (__extension__ (
        {
            offset0_1 = (offset + 0);
            for (; ; )
            {
                bool isLastPath = false;
                bool isFirstSubRegion = true;
                for (; ; )
                {
                    const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                    isLastPath = !(raw_flatCount & 1u);
                    if (isLastSubRegion)
                        break;
                    else
                        isFirstSubRegion = false;

                };
                if (isLastPath)
                    break;

            };
            BL_3_v = (offset0_1);
            (void)0;
        }), BL_3_v);
        unsigned v;
        const int locid = ((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))));
        Lifetime_llCF region = Lifetime_llCF { fu::str(fu::get_range(chars, offset0, offset)) };
        fu::view<char> paths = fu::get_view(chars, sr, offset);
        if (!(!locid))
        {
            const Target_VZrr t = nested_FDl5(locid, ss, ctx, _here);
            if (GET_gDsn(t, ss, ctx, _here, module).kind == Kind_Idfg_var)
            {
                cannotCOW_climbParents_gDsn(Lifetime_op_join_7Yz9(Lifetime_climbType_gDsn(t, ss, ctx, _here, module, options, _helpers).lifetime, paths, ctx, _here), (expected_refs + locid), item, here, callee, host_arg, calleeReturnDiscarded, _current_fn, ss, ctx, _here, module, options, _helpers);
                cannotCOW_descendChildren_gDsn(locid, region, expected_refs, item, here, callee, host_arg, calleeReturnDiscarded, _current_fn, ss, ctx, _here, module, options, _helpers);
                Flow_oKsD& flow = _current_fn.flow;
                unsigned v_1;
                if ((v_1 = unsigned((t._packed & 0xfffffull)), int(((v_1 >> 1u) ^ ((v_1 & 1u) ? 0xffffffffu : 0x0u)))) < 0)
                {
                    fu::view<int> arg_targets = flow.arg_targets;
                    for (int i = 0; i < arg_targets.size(); i++)
                    {
                        const int t_1 = arg_targets[i];
                        if (!(!t_1 || (t_1 == locid)))
                        {
                            const Overload_aO3i& o = GET_gDsn(nested_FDl5(t_1, ss, ctx, _here), ss, ctx, _here, module);
                            if (!(!is_mutref_9CJm(o.solved.type, ctx, _here)))
                            {
                                if (!(has_gDsn(iF_dxP1(flow.at_hard_risk, t_1, _current_fn), locid, _current_fn)))
                                {
                                    const int reason = needsHardRisk_sScE(t_1, o, item, callee, host_arg, calleeReturnDiscarded, _current_fn, ss, ctx, _here, module);
                                    if (reason)
                                    {

                                        {
                                            const SolverNotes_LSla note = SolverNotes_LSla_N_COWRestrict;
                                            if (note & options.break_notes)
                                            {
                                                fu::str reason_1 = x7E_rA00((x7E_rA00(x7E_rA00(str_FDl5(nested_FDl5(locid, ss, ctx, _here), false, ss, ctx, _here, module, options), " at risk from "_view), str_FDl5(nested_FDl5(t_1, ss, ctx, _here), false, ss, ctx, _here, module, options)) + " via "_view), str_FDl5(nested_FDl5(reason, ss, ctx, _here), false, ss, ctx, _here, module, options));
                                                fail_gDsn((("`break_notes`: Unwanted event: "_view + qBAD_e44U(str_kJvr(note))) + (reason_1 ? ("\n\t\t"_view + reason_1) : fu::str("."_fu))), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                                            }
                                            else
                                                ss._notes |= note;

                                        };
                                        add_gDsn(ensure_l3bn(flow.at_soft_risk, t_1, _current_fn), locid, _current_fn);
                                        if ((reason != t_1) || TODO_FIX_slicesAgain_zZes(t_1, ss, ctx, _here, module))
                                            add_gDsn(ensure_l3bn(flow.at_hard_risk, t_1, _current_fn), locid, _current_fn);

                                    };
                                };
                            };
                        };
                    };
                    if (callee)
                    {
                        fu::view<COWInside_qvly> callee_cows = EXT_gDsn(callee, ss, ctx, module).cows_inside;
                        for (int i_1 = 0; i_1 < callee_cows.size(); i_1++)
                        {
                            const COWInside_qvly& callee_cow = callee_cows[i_1];
                            if (!(calleeReturnDiscarded && !callee_cow.mayEscapeVia))
                            {
                                const Target_VZrr* t_1;
                                unsigned v_2;
                                if (callee_cow.argTarget == (t_1 = &(host_arg.target), v_2 = unsigned(((*t_1)._packed & 0xfffffull)), int(((v_2 >> 1u) ^ ((v_2 & 1u) ? 0xffffffffu : 0x0u)))))
                                {
                                    const ValueType_JtNg& vtype = callee_cow.vtype;
                                    const TokenIdx_5581& token = callee_cow.token;
                                    const bool uncaughtThrowOnly = ((callee_cow.exitPaths == ExitPaths_UXHs_XP_NoReturn) ? !_current_fn.TODO_FIX_catches : false);
                                    const MayEscapeVia_5nki mayEscapeVia = _current_fn.postdom.snap.mayEscapeVia;
                                    const ExitPaths_UXHs exitPaths = (uncaughtThrowOnly ? ExitPaths_UXHs_XP_NoReturn : (_current_fn.postdom.snap.exitPaths ? _current_fn.postdom.snap.exitPaths : BUG_gDsn("No current_fn.exitPaths"_view, ss, ctx, _here, module, options, _helpers)));
                                    fu::vec<COWInside_qvly>& my_cows = _current_fn.events.cows_inside;
                                    for (int i_2 = 0; i_2 < my_cows.size(); i_2++)
                                    {
                                        COWInside_qvly& my_cow = my_cows.mutref(i_2);
                                        if ((my_cow.argTarget == locid) && (my_cow.vtype.canon == vtype.canon))
                                        {
                                            my_cow.vtype.quals |= vtype.quals;
                                            my_cow.mayEscapeVia |= mayEscapeVia;
                                            my_cow.exitPaths |= exitPaths;
                                            return;
                                        };
                                    };
                                    my_cows += COWInside_qvly { ValueType_JtNg(vtype), TokenIdx_5581(token), locid, mayEscapeVia, exitPaths };
                                };
                            };
                        };
                    }
                    else
                    {
                        const ValueType_JtNg& vtype = item.type.vtype;
                        const TokenIdx_5581& token = _here;
                        const MayEscapeVia_5nki mayEscapeVia = _current_fn.postdom.snap.mayEscapeVia;
                        const ExitPaths_UXHs exitPaths = (_current_fn.postdom.snap.exitPaths ? _current_fn.postdom.snap.exitPaths : BUG_gDsn("No current_fn.exitPaths"_view, ss, ctx, _here, module, options, _helpers));
                        fu::vec<COWInside_qvly>& my_cows = _current_fn.events.cows_inside;
                        for (int i_1 = 0; i_1 < my_cows.size(); i_1++)
                        {
                            COWInside_qvly& my_cow = my_cows.mutref(i_1);
                            if ((my_cow.argTarget == locid) && (my_cow.vtype.canon == vtype.canon))
                            {
                                my_cow.vtype.quals |= vtype.quals;
                                my_cow.mayEscapeVia |= mayEscapeVia;
                                my_cow.exitPaths |= exitPaths;
                                return;
                            };
                        };
                        my_cows += COWInside_qvly { ValueType_JtNg(vtype), TokenIdx_5581(token), locid, mayEscapeVia, exitPaths };
                    };
                };
            }
            else
                BUG_gDsn(x7E_rA00("cannotCOW_climbParents found a non-var: "_view, str_FDl5(t, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

        };
    };
}

static void validateCOW_gDsn(const SolvedNode_efhg& item, const TokenIdx_5581& here, const Target_VZrr& callee, const Argument_bbKc& host_arg, const bool calleeReturnDiscarded, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    cannotCOW_climbParents_gDsn(item.type.lifetime, fu::view<int>{}, item, here, callee, host_arg, calleeReturnDiscarded, _current_fn, ss, ctx, _here, module, options, _helpers);
}

                                #ifndef DEF_ensure_GSWHiHjEDwb
                                #define DEF_ensure_GSWHiHjEDwb
inline static unsigned& ensure_GSWH(LocidMap_IP5H& map, const int locid, const CurrentFn_QbLp& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    return ensure_6WFe(map._values, (args_neg + locid));
}
                                #endif

static bool add_FDl5(LocidMap_IP5H& map, const int locid, const unsigned quals, const CurrentFn_QbLp& _current_fn)
{
    unsigned& v = ensure_GSWH(map, locid, _current_fn);
    const unsigned v0 = v;
    v |= quals;
    return v != v0;
}

                                #ifndef DEF___4DmZexn42Td
                                #define DEF___4DmZexn42Td
inline static void _4DmZ(const int locid, fu::view<char> paths, const unsigned usage, const SolvedNode_efhg& node, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (!(!locid))
    {
        const unsigned usage_1 = Lifetime_shiftUsage_7Yz9(paths, usage, ctx, _here);
        if (add_FDl5(_current_fn.postdom.snap.ever_written, locid, usage_1, _current_fn))
        {
            const Target_VZrr t = nested_FDl5(locid, ss, ctx, _here);
            const Overload_aO3i* __partcopy_ref;
            Overload_aO3i o = (__partcopy_ref = &(GET_gDsn(t, ss, ctx, _here, module)), Overload_aO3i { {/*unused non-zst*/}, (*__partcopy_ref).flags, {/*unused non-zst*/}, (*__partcopy_ref).asserts, fu::str((*__partcopy_ref).name), {/*unused non-zst*/}, {/*unused non-zst*/} });
            const DeclAsserts_taUG asserts = o.asserts;

            {
                const Target_VZrr& target = _current_fn.out.target;
                Target_VZrr fail_fn = target;
                TokenIdx_5581 fail_arg_token = GET_gDsn(t, ss, ctx, _here, module).solved.token;
                TokenIdx_5581 backtrack_token = _current_fn.out.token;
                const ClosureID_qHEW cid = tryParseClosureID_UvH3(o.name, ctx, _here);
                if (isLocal_gDsn(cid.target))
                {
                    fail_fn = parent_gDsn(cid.target, ctx, _here);
                    fail_arg_token = GET_gDsn(cid.target, ss, ctx, _here, module).solved.token;
                    backtrack_token = GET_gDsn(fail_fn, ss, ctx, _here, module).solved.token;
                };
                if (asserts & DeclAsserts_taUG_A_PURE)
                {
                    fu::str _0 {};
                    fu::str _1 {};
                    (_1 = (_0 = (x7E_rA00(x7E_rA00(str_FDl5(fail_fn, false, ss, ctx, _here, module, options), " is not pure, writes to "_view), str_FDl5(t, false, ss, ctx, _here, module, options)) + ":\n"_view), (static_cast<fu::str&&>(_0) + qSTACK_local_FDl5(target, node, locid, fu::view<Target_VZrr>{}, ArgQuery_O2xW{}, _current_fn, ss, ctx, _here, module, options, _helpers))), fail_gDsn(static_cast<fu::str&&>(_1), "pure"_view, TokenIdx_5581(backtrack_token), fu::view<TokenIdx_5581> {{ TokenIdx_5581(fail_arg_token) }}, ss, ctx, _here, module, options, _helpers));
                }
                else if (DeclAsserts_taUG((asserts & DeclAsserts_taUG_A_PURE_CTX)) && (o.flags & Flags_Lzg8_F_INJECTED))
                {
                    fu::str _2 {};
                    fu::str _3 {};
                    (_3 = (_2 = (x7E_rA00(x7E_rA00(str_FDl5(fail_fn, false, ss, ctx, _here, module, options), " is not purectx, writes to "_view), str_FDl5(t, false, ss, ctx, _here, module, options)) + ":\n"_view), (static_cast<fu::str&&>(_2) + qSTACK_local_FDl5(target, node, locid, fu::view<Target_VZrr>{}, ArgQuery_O2xW{}, _current_fn, ss, ctx, _here, module, options, _helpers))), fail_gDsn(static_cast<fu::str&&>(_3), "purectx"_view, TokenIdx_5581(backtrack_token), fu::view<TokenIdx_5581> {{ TokenIdx_5581(fail_arg_token) }}, ss, ctx, _here, module, options, _helpers));
                };
            };
            const ValueType_JtNg* type;
            if (((type = &(GET_gDsn(t, ss, ctx, _here, module).type.vtype), ((*type).quals & q_USAGE)) & usage_1) == usage_1)
            {
                if (!(o.flags & Flags_Lzg8_F_VAL))
                {
                    callarg_trackWrites_gDsn(Lifetime_climbType_gDsn(t, ss, ctx, _here, module, options, _helpers).lifetime, usage_1, node, _current_fn, ss, ctx, _here, module, options, _helpers);
                };
                unsigned v;
                if ((v = unsigned((t._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))) < 0)
                    add_xQNS(_current_fn.postdom.snap.mayEscapeVia, locid);

            }
            else
            {
                const ValueType_JtNg* type_1;
                BUG_gDsn(x7E_rA00((x7E_rA00((x7E_rA00("callarg_trackWrites: written_to("_view, fu::u64dec(usage_1)) + ") quals("_view), fu::u64dec((type_1 = &(GET_gDsn(t, ss, ctx, _here, module).type.vtype), ((*type_1).quals & q_USAGE)))) + ") "_view), str_FDl5(t, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);
            };
        };
    };
}
                                #endif

                                #ifndef DEF_Lifetime_each_5Cb7DTndgt9
                                #define DEF_Lifetime_each_5Cb7DTndgt9
inline void Lifetime_each_5Cb7(const Lifetime_llCF& lifetime, const unsigned usage, const SolvedNode_efhg& node, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit_7Yz9(chars, offset);
        int offset0;
        int BL_3_v;
        const int sr = (__extension__ (
        {
            offset0 = (offset + 0);
            for (; ; )
            {
                bool isLastPath = false;
                bool isFirstSubRegion = true;
                for (; ; )
                {
                    const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                    isLastPath = !(raw_flatCount & 1u);
                    if (isLastSubRegion)
                        break;
                    else
                        isFirstSubRegion = false;

                };
                if (isLastPath)
                    break;

            };
            BL_3_v = (offset0);
            (void)0;
        }), BL_3_v);
        unsigned v;
        _4DmZ(((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))))), fu::get_view(chars, sr, offset), usage, node, _current_fn, ss, ctx, _here, module, options, _helpers);
    };
}
                                #endif

static void callarg_trackWrites_gDsn(const Lifetime_llCF& lt, const unsigned usage, const SolvedNode_efhg& node, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    Lifetime_each_5Cb7(lt, usage, node, _current_fn, ss, ctx, _here, module, options, _helpers);
}

                                #ifndef DEF___kS9tKpHdB5h
                                #define DEF___kS9tKpHdB5h
inline static void _kS9t(const int i, const Argument_bbKc& host_arg, SolvedNode_efhg& node, const unsigned relax_mask, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    SolvedNode_efhg& arg = node.items.mutref(i);
    if (relax_mask == RELAX_all)
        maybeCopyOrMove_gDsn(arg, host_arg.type, true, (*(fu::str*)fu::NIL), _current_fn, ss, ctx, _here, module, options, _helpers);

    propagateType_gDsn(arg, host_arg.type, relax_mask, Helpers_DyqV{}, _current_fn, ss, ctx, _here, module, options, _helpers);
    if (host_arg.written_to)
    {
        const ValueType_JtNg* type;
        if ((host_arg.written_to & (type = &(arg.type.vtype), ((*type).quals & q_USAGE))) == host_arg.written_to)
        {
            callarg_trackWrites_gDsn(arg.type.lifetime, host_arg.written_to, node, _current_fn, ss, ctx, _here, module, options, _helpers);
        }
        else
        {
            const ValueType_JtNg* type_1;
            BUG_gDsn((x7E_rA00((x7E_rA00("propagateType(call) host_arg.written_to("_view, fu::u64dec(host_arg.written_to)) + ") arg.usage("_view), fu::u64dec((type_1 = &(arg.type.vtype), ((*type_1).quals & q_USAGE)))) + ")"_view), ss, ctx, _here, module, options, _helpers);
        };
    };
    if (!(host_arg.flags & Flags_Lzg8_F_LT_RETURNED))
    {
        if ((arg.kind == Kind_Idfg_letdef) && SolverStatus_h9em((GET_gDsn(arg.target, ss, ctx, _here, module).status & SolverStatus_h9em_SS_NAME_UNUSED)))
            unwrapLetdef_gDsn(arg, relax_mask, ss, ctx, _here, module, options, _helpers);

    };
}
                                #endif

                                #ifndef DEF_argsReverse_wRgfYgh0M0e
                                #define DEF_argsReverse_wRgfYgh0M0e
inline void argsReverse_wRgf(const bool RTL, fu::view<Argument_bbKc> host_args, SolvedNode_efhg& node, const unsigned relax_mask, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    int revSeqIdx = 0;
    int lastPass = 1;
    bool ooe_isLast = true;
    for (int pass = 2; pass-- > lastPass; )
    {
        for (int i = host_args.size(); i-- > 0; )
        {
            const Argument_bbKc& host_arg = host_args[i];
            if (!!pass != (RTL ? !i : !!((host_arg.flags & Flags_Lzg8_F_IMPLICIT) || is_mutref_9CJm(host_arg.type, ctx, _here))))
                lastPass = 0;
            else
            {
                _kS9t(i, host_arg, node, relax_mask, _current_fn, ss, ctx, _here, module, options, _helpers);
                ooe_isLast = false;
                revSeqIdx++;
            };
        };
    };
}
                                #endif

static bool isFieldChain_gDsn(const SolvedNode_efhg& arg, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    if (arg.kind != Kind_Idfg_call)
        return false;
    else
    {
        const Kind_Idfg t = GET_gDsn(arg.target, ss, ctx, _here, module).kind;
        return (t == Kind_Idfg_var) || ((t == Kind_Idfg_field) && isFieldChain_gDsn(only_S4ER(arg.items), ss, ctx, _here, module));
    };
}

static fu::str explainUsedAgain_gDsn(const UsedAgain_5DsR usedAgain, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    unsigned v;
    const int locid = (v = unsigned((usedAgain >> 8u)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
    const UsedAgainReason_wQO7 reason = UsedAgainReason_wQO7(fu::u8(usedAgain));
    if (locid)
    {
        return x7E_rA00(str_FDl5(nested_FDl5(locid, ss, ctx, _here), false, ss, ctx, _here, module, options), ((reason == UsedAgainReason_wQO7_UsedInALoop) ? " is used on next loop iteration."_view : ((reason == UsedAgainReason_wQO7_ArgReference) ? " is a reference argument."_view : ((reason == UsedAgainReason_wQO7_UsedAgain) ? " is used again."_view : fu::view<char>{}))));
    }
    else if (reason == UsedAgainReason_wQO7_StaticReference)
        return fu::str(str_ySWbqrCfvec);
    else
    {
        return fu::str{};
    };
}

                                #ifndef DEF___uCcb6zzoXs4
                                #define DEF___uCcb6zzoXs4
inline static void _uCcb(const int locid, const bool isAlwaysMoveable, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (!locid)
    {
        if (!(isAlwaysMoveable))
            BUG_gDsn("Attempting to move from a non-local, non-temporary region."_view, ss, ctx, _here, module, options, _helpers);

    }
    else
    {
        const Target_VZrr t = nested_FDl5(locid, ss, ctx, _here);
        Overload_aO3i& o = GET_mut_gDsn(t, ss, module);
        if (!(o.status & SolverStatus_h9em_SS_MOVED_FROM))
        {
            o.status |= SolverStatus_h9em_SS_MOVED_FROM;
            const Type_OiTm& init = Lifetime_climbType_gDsn(t, ss, ctx, _here, module, options, _helpers);
            if (is_ref_9CJm(init))
            {
                Lifetime_F_MOVED_FROM_gDsn(Lifetime_llCF(init.lifetime), ss, ctx, _here, module, options, _helpers);
            };
        };
    };
}
                                #endif

                                #ifndef DEF_Lifetime_each_GFmp1nb88f5
                                #define DEF_Lifetime_each_GFmp1nb88f5
inline void Lifetime_each_GFmp(const Lifetime_llCF& lifetime, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit_7Yz9(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        unsigned v;
        _uCcb(((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))))), ((r == 0b0101u) || (r == 0b1001u)), ss, ctx, _here, module, options, _helpers);
    };
}
                                #endif

static void Lifetime_F_MOVED_FROM_gDsn(const Lifetime_llCF& lifetime, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    Lifetime_each_GFmp(lifetime, ss, ctx, _here, module, options, _helpers);
}

static void injectJumps_gDsn(SolvedNode_efhg& expr, const Helpers_DyqV& h, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (!tryInjectJumps_gDsn(expr, h, ss, ctx, _here, module, options, _helpers))
        expr = createJump_gDsn(h, expr, _here);

}

static bool tryInjectJumps_gDsn(SolvedNode_efhg& expr, const Helpers_DyqV& h, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const Helpers_DyqV* h_1;
    if (is_never_9CJm(expr.type.vtype))
        return true;
    else if ((h_1 = &(h), ((((*h_1).index >= 0) && ((*h_1).index < ss._helpers_data.size())) ? ss._helpers_data[(*h_1).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).ret_actual)
    {
        const Helpers_DyqV* h_2;
        if (is_void_9CJm((h_2 = &(h), ((((*h_2).index >= 0) && ((*h_2).index < ss._helpers_data.size())) ? ss._helpers_data[(*h_2).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).ret_actual.vtype) && !is_void_9CJm(expr.type.vtype))
        {
            if (expr.kind != Kind_Idfg_block)
            {
                expr = createBlock_gDsn(t_void, fu::vec<SolvedNode_efhg> {{ SolvedNode_efhg(expr) }}, Helpers_DyqV{}, _here);
            };
            if (is_void_9CJm(if_last_Xdw0(expr.items).type.vtype))
                BUG_gDsn(("tryInjectJumps: Block tail is void, but block.type isn't: "_view + explainType_gDsn(expr.type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);
            else
            {
                expr.items += createEmpty_gDsn(t_void, Target_VZrr{}, ss, ctx, _here, module, options, _helpers);
            };
        };
        const Helpers_DyqV* h_3;
        if ((expr.kind == Kind_Idfg_block) && expr.items && !HelpersMask_w1sv(((h_3 = &(expr.helpers), ((((*h_3).index >= 0) && ((*h_3).index < ss._helpers_data.size())) ? ss._helpers_data[(*h_3).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).mask & HelpersMask_w1sv_HM_LabelUsed)))
        {
            SolvedNode_efhg* _0;
            (_0 = &(last_xZUS(expr.items)), injectJumps_gDsn(*_0, h, ss, ctx, _here, module, options, _helpers));
            expr.type = t_never;
            return true;
        }
        else if (expr.kind == Kind_Idfg_if)
        {
            for (int i = 1; i < expr.items.size(); i++)
            {
                SolvedNode_efhg* _1;
                (_1 = &(expr.items.mutref(i)), injectJumps_gDsn(*_1, h, ss, ctx, _here, module, options, _helpers));
            };
            expr.type = t_never;
            return true;
        };
        return false;
    }
    else
        BUG_gDsn(x7E_rA00("tryInjectJumps: no h.ret_actual on #"_view, fu::i64dec(h.index)), ss, ctx, _here, module, options, _helpers);

}

                                #ifndef DEF_steal_cs1xelerGS4
                                #define DEF_steal_cs1xelerGS4
inline fu::vec<SolvedNode_efhg> steal_cs1x(fu::vec_range_mut<SolvedNode_efhg> a, const int start, const int end)
{
    const int size = (end - start);
    /*MOV*/ fu::vec<SolvedNode_efhg> ret {};
    ret.resize(size);
    for (int i = 0; i < size; i++)
        std::swap(ret.mutref(i), a.mutref((i + start)));

    a.splice(start, size);
    return /*NRVO*/ ret;
}
                                #endif

                                #ifndef DEF___a7d5brollv5
                                #define DEF___a7d5brollv5
inline static void _a7d5(const Target_VZrr& t, const int position, const unsigned relax_mask, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    relaxBlockVar_gDsn(t, relax_mask, false, _current_fn, ss, ctx, _here, module, options, _helpers);
    if (SolverStatus_h9em((GET_gDsn(t, ss, ctx, _here, module).status & SolverStatus_h9em_SS_UNUSED)) && (GET_gDsn(t, ss, ctx, _here, module).flags & Flags_Lzg8_F_IMPLICIT))
    {

        {
            const SolverNotes_LSla note = SolverNotes_LSla_N_UnusedImplicit;
            if (note & options.break_notes)
            {
                fu::view<char> reason = fu::view<char>{};
                fail_gDsn((("`break_notes`: Unwanted event: "_view + qBAD_e44U(str_kJvr(note))) + (reason ? ("\n\t\t"_view + reason) : fu::str("."_fu))), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
            }
            else
                ss._notes |= note;

        };
        if (_current_fn.out.items[position].target == t)
            _current_fn.out.items.splice(position, 1);
        else
        {
            BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers);
        };
    };
}
                                #endif

                                #ifndef DEF__current_fn_eachArg_BACK_la4iuVr4EPc
                                #define DEF__current_fn_eachArg_BACK_la4iuVr4EPc
inline static void _current_fn_eachArg_BACK_la4i(const unsigned relax_mask, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    for (int i = (_current_fn.out.items.size() + FN_ARGS_BACK); i-- > 0; )
    {
        const Target_VZrr t = _current_fn.out.items[i].target;
        if (t)
        {
            unsigned v;
            if ((v = unsigned((t._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))) < 0)
                _a7d5(t, i, relax_mask, _current_fn, ss, ctx, _here, module, options, _helpers);
            else
            {
                BUG_u9Gb(fu::view<char>{}, ctx, _here);
            };
        };
    };
}
                                #endif

extern const FxMask_2dRz EFFECTS_clock;
extern const FxMask_2dRz EFFECTS_input;
static void propagateType_gDsn(SolvedNode_efhg& node, const Type_OiTm& slot, const unsigned relax_mask, const Helpers_DyqV& kills, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    const Kind_Idfg k = node.kind;
    const TokenIdx_5581 here0 = _here;
    _here = node.token;
    fu_DEFER(_here = here0);
    const bool canDiscard = isIrrelevant_9CJm(slot);
    const unsigned relaxed_quals = try_relax_9CJm(node.type, slot, relax_mask);
    TEST_paintNode_gDsn(node, ss, ctx, _here, module, options, _helpers);
    if ((k == Kind_Idfg_let) || (k == Kind_Idfg_letdef))
    {
        if (!(!node.target))
        {
            if (relax_mask == RELAX_all)
            {
                SolvedNode_efhg& node_1 = GET_mut_gDsn(node.target, ss, module).solved;
                SolvedNode_efhg& init = node_1.items.mutref(LET_INIT);
                if (init)
                    maybeCopyOrMove_gDsn(init, node_1.type, false, (*(fu::str*)fu::NIL), _current_fn, ss, ctx, _here, module, options, _helpers);

            };
            if (!canDiscard)
            {
                const Target_VZrr* t;
                unsigned v;
                const bool firstUse = trackVarUsage_gDsn((t = &(node.target), v = unsigned(((*t)._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))), node.type, _current_fn, ss, ctx, _here, module, options, _helpers);
                if (firstUse)
                {
                    Overload_aO3i& o = GET_mut_gDsn(node.target, ss, module);
                    o.status |= SolverStatus_h9em_SS_NAME_UNUSED;
                    warnUnused_gDsn(node.target, o, _current_fn, ss, ctx, _here, module);
                    if (!is_ref_9CJm(slot))
                    {
                        unwrapLetdef_gDsn(node, relax_mask, ss, ctx, _here, module, options, _helpers);
                        propagateType_gDsn(node, slot, relax_mask, kills, _current_fn, ss, ctx, _here, module, options, _helpers);
                        return;
                    };
                };
            };
            relaxBlockVar_gDsn(node.target, relax_mask, canDiscard, _current_fn, ss, ctx, _here, module, options, _helpers);
            if (k == Kind_Idfg_letdef)
            {
                if (GET_gDsn(node.target, ss, ctx, _here, module).status & SolverStatus_h9em_SS_UNUSED)
                {

                    {
                        const SolverNotes_LSla note = SolverNotes_LSla_N_UnusedLet;
                        if (note & options.break_notes)
                        {
                            fu::view<char> reason = fu::view<char>{};
                            fail_gDsn((("`break_notes`: Unwanted event: "_view + qBAD_e44U(str_kJvr(note))) + (reason ? ("\n\t\t"_view + reason) : fu::str("."_fu))), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                        }
                        else
                            ss._notes |= note;

                    };
                    SolvedNode_efhg _0 {};
                    node = ((_0 = SolvedNode_efhg(GET_gDsn(node.target, ss, ctx, _here, module).solved.items[LET_INIT])) ? static_cast<SolvedNode_efhg&&>(_0) : createEmpty_gDsn(t_void, Target_VZrr{}, ss, ctx, _here, module, options, _helpers));
                };
            }
            else
                BUG_gDsn("Unexpected let node."_view, ss, ctx, _here, module, options, _helpers);

        };
    }
    else if ((k == Kind_Idfg_and) || (k == Kind_Idfg_or))
    {
        const Type_OiTm& rest = ((!canDiscard && ((k == Kind_Idfg_or) || !andNodeType_canCleanlyDefinit_gDsn(node.type, ctx, _here))) ? slot : t_proposition);
        Postdom_Vy5u postdom0 = _current_fn.postdom;
        const bool mcomOrItems = (((k == Kind_Idfg_or) && (relax_mask == RELAX_all) && !canDiscard) ? !is_boolean_hxWW(node.type.vtype) : false);
        fu::vec<SolvedNode_efhg>& items = node.items;
        for (int i = items.size(); i-- > 0; )
        {
            SolvedNode_efhg& item = items.mutref(i);
            if (mcomOrItems)
                maybeCopyOrMove_gDsn(item, node.type, false, (*(fu::str*)fu::NIL), _current_fn, ss, ctx, _here, module, options, _helpers);

            propagateType_gDsn(item, ((i == (items.size() - 1)) ? slot : rest), relax_mask, Helpers_DyqV{}, _current_fn, ss, ctx, _here, module, options, _helpers);
            if (canDiscard && (i == (items.size() - 1)) && isDiscardable_FDl5(item, ss, ctx, _here, module, options, _helpers))
            {

                {
                    const SolverNotes_LSla note = SolverNotes_LSla_N_UnusedAndOr;
                    if (note & options.break_notes)
                    {
                        fu::view<char> reason = fu::view<char>{};
                        fail_gDsn((("`break_notes`: Unwanted event: "_view + qBAD_e44U(str_kJvr(note))) + (reason ? ("\n\t\t"_view + reason) : fu::str("."_fu))), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                    }
                    else
                        ss._notes |= note;

                };
                items.pop();
                if (!(_current_fn.postdom == postdom0))
                {
                    BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers);
                };
            };
            if (i)
                branch_gDsn(_current_fn.postdom, postdom0, ctx, _here);

        };
        if (items.size() < 2)
        {
            SolvedNode_efhg _1 {};
            node = ((_1 = SolvedNode_efhg(if_only_RJ7X(items))) ? static_cast<SolvedNode_efhg&&>(_1) : createEmpty_gDsn(slot, Target_VZrr{}, ss, ctx, _here, module, options, _helpers));
        }
        else if (canDiscard)
            node.type = t_bool;

    }
    else if (k == Kind_Idfg_if)
    {
        fu::vec<SolvedNode_efhg>& items = node.items;
        if ((relax_mask == RELAX_all) && !canDiscard && !propositionOK_9CJm(node.type, true, ctx, _here))
        {
            for (int i = items.size(); i-- > 1; )
            {
                SolvedNode_efhg* _2;
                (_2 = &(items.mutref(i)), maybeCopyOrMove_gDsn(*_2, node.type, false, (*(fu::str*)fu::NIL), _current_fn, ss, ctx, _here, module, options, _helpers));
            };
        };
        Postdom_Vy5u postdom0 = _current_fn.postdom;
        bool canDiscard_cond = canDiscard;
        for (int i = items.size(); i-- > 0; )
        {
            if (i == 1)
                std::swap(postdom0, _current_fn.postdom);
            else if (i == 0)
                branch_gDsn(_current_fn.postdom, postdom0, ctx, _here);

            propagateType_gDsn(items.mutref(i), (((i != 0) || canDiscard_cond) ? slot : t_proposition), relax_mask, ((i != 0) ? kills : (*(Helpers_DyqV*)fu::NIL)), _current_fn, ss, ctx, _here, module, options, _helpers);
            if (canDiscard_cond && i && !isDiscardable_FDl5(items[i], ss, ctx, _here, module, options, _helpers))
                canDiscard_cond = false;

        };
        if (canDiscard)
        {
            if (canDiscard_cond)
            {

                {
                    const SolverNotes_LSla note = SolverNotes_LSla_N_UnusedIfElse;
                    if (note & options.break_notes)
                    {
                        fu::view<char> reason = fu::view<char>{};
                        fail_gDsn((("`break_notes`: Unwanted event: "_view + qBAD_e44U(str_kJvr(note))) + (reason ? ("\n\t\t"_view + reason) : fu::str("."_fu))), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                    }
                    else
                        ss._notes |= note;

                };
                node = items[0];
            }
            else if (isDiscardable_FDl5(items[1], ss, ctx, _here, module, options, _helpers))
            {
                node = createOr_gDsn(fu::vec<SolvedNode_efhg> {{ SolvedNode_efhg(items[0]), SolvedNode_efhg(items[2]) }}, Type_OiTm(t_void), _current_fn, ss, ctx, _here, module, options, _helpers);
            }
            else if (isDiscardable_FDl5(items[2], ss, ctx, _here, module, options, _helpers))
                node = createAnd_gDsn(fu::vec<SolvedNode_efhg>(fu::get_range(items, 0, 2)), Type_OiTm(t_void), _current_fn, ss, ctx, _here, module, options, _helpers);
            else
                node.type = t_void;

        }
        else if (kills)
        {
            node.type = superType_neverOK_gDsn("if/else after control flow simplification: "_view, items[1].type, items[2].type, Target_VZrr{}, ss, ctx, _here, module, options, _helpers);
        };
        node._loop_start = _current_fn.postdom.write_loop_start;
    }
    else if (k == Kind_Idfg_try)
    {
        Postdom_Vy5u postdom0 = _current_fn.postdom;
        propagateType_gDsn(recover_gDsn(node), t_void, relax_mask, Helpers_DyqV{}, _current_fn, ss, ctx, _here, module, options, _helpers);
        branch_gDsn(_current_fn.postdom, postdom0, ctx, _here);
        propagateType_gDsn(error_gDsn(node), t_void, relax_mask, Helpers_DyqV{}, _current_fn, ss, ctx, _here, module, options, _helpers);
        const FxMask_2dRz throws0 = FxMask_2dRz((_current_fn.effects.fx_mask & FxMask_2dRz_Fx_Throws));
        _current_fn.effects.fx_mask &= FxMask_2dRz(~FxMask_2dRz_Fx_Throws);
        _current_fn.TODO_FIX_catches++;
        propagateType_gDsn(attempt_gDsn(node), t_void, relax_mask, Helpers_DyqV{}, _current_fn, ss, ctx, _here, module, options, _helpers);
        _current_fn.TODO_FIX_catches--;
        if (!FxMask_2dRz((_current_fn.effects.fx_mask & FxMask_2dRz_Fx_Throws)))
        {

            {
                const SolverNotes_LSla note = SolverNotes_LSla_N_UnusedTry;
                if (note & options.break_notes)
                {
                    fu::view<char> reason = fu::view<char>{};
                    fail_gDsn((("`break_notes`: Unwanted event: "_view + qBAD_e44U(str_kJvr(note))) + (reason ? ("\n\t\t"_view + reason) : fu::str("."_fu))), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                }
                else
                    ss._notes |= note;

            };
            node = attempt_FDl5(node);
        };
        _current_fn.effects.fx_mask &= FxMask_2dRz(~FxMask_2dRz_Fx_Throws);
        _current_fn.effects.fx_mask |= throws0;
    }
    else if (k == Kind_Idfg_loop)
    {
        Breakable_begin_gDsn(true, node, relax_mask, _current_fn, ss, ctx, _here);
        const int read_loop0 = (_current_fn.postdom.read_loop_start ? _current_fn.postdom.read_loop_start : BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers));
        const int write_loop0 = (_current_fn.postdom.write_loop_start ? _current_fn.postdom.write_loop_start : BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers));
        const Helpers_DyqV* h;
        int _3;
        _current_fn.postdom.read_loop_start = (_current_fn.postdom.write_loop_start = ((_3 = (h = &(node.helpers), ((((*h).index >= 0) && ((*h).index < ss._helpers_data.size())) ? ss._helpers_data[(*h).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).locals_start) ? _3 : BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers)));
        if (post_cond_FDl5(node))
        {
            propagateType_gDsn(post_cond_gDsn(node), t_proposition, relax_mask, Helpers_DyqV{}, _current_fn, ss, ctx, _here, module, options, _helpers);
        };
        if (post_FDl5(node))
        {
            if (isDiscardable_FDl5(post_FDl5(node), ss, ctx, _here, module, options, _helpers))
            {
                post_gDsn(node) = SolvedNode_efhg{};
            }
            else
            {
                propagateType_gDsn(post_gDsn(node), t_void, relax_mask, Helpers_DyqV{}, _current_fn, ss, ctx, _here, module, options, _helpers);
            };
        };
        if (body_FDl5(node))
        {
            if (isDiscardable_FDl5(body_FDl5(node), ss, ctx, _here, module, options, _helpers))
            {
                body_gDsn(node) = SolvedNode_efhg{};
            }
            else
            {
                propagateType_gDsn(body_gDsn(node), t_void, relax_mask, Helpers_DyqV{}, _current_fn, ss, ctx, _here, module, options, _helpers);
            };
        };
        if (pre_FDl5(node))
        {
            Postdom_Vy5u postdom0 = _current_fn.postdom;
            if (isDiscardable_FDl5(pre_FDl5(node), ss, ctx, _here, module, options, _helpers))
            {
                pre_gDsn(node) = SolvedNode_efhg{};
            }
            else
            {
                propagateType_gDsn(pre_gDsn(node), t_void, relax_mask, Helpers_DyqV{}, _current_fn, ss, ctx, _here, module, options, _helpers);
            };
            branch_gDsn(_current_fn.postdom, postdom0, ctx, _here);
        };
        if (pre_cond_FDl5(node))
        {
            propagateType_gDsn(pre_cond_gDsn(node), t_proposition, relax_mask, Helpers_DyqV{}, _current_fn, ss, ctx, _here, module, options, _helpers);
        };
        _current_fn.postdom.read_loop_start = read_loop0;
        _current_fn.postdom.write_loop_start = write_loop0;
        Breakable_end_gDsn(true, node, relax_mask, _current_fn, ss, ctx, _here);
        if (_current_fn.postdom.read_loop_start == read_loop0)
        {
            if (!(_current_fn.postdom.write_loop_start == write_loop0))
            {
                BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers);
            };
        }
        else
        {
            BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers);
        };
        if (init_FDl5(node))
        {
            propagateType_gDsn(init_gDsn(node), t_void, relax_mask, Helpers_DyqV{}, _current_fn, ss, ctx, _here, module, options, _helpers);
        };
        if (!node._loop_start || (node._loop_start == _current_fn.postdom.write_loop_start))
        {
            node._loop_start = _current_fn.postdom.write_loop_start;
            if (_current_fn.postdom.read_loop_start == read_loop0)
            {
                if (!(_current_fn.postdom.write_loop_start == write_loop0))
                {
                    BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers);
                };
            }
            else
            {
                BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers);
            };
        }
        else
            BUG_gDsn("The new loop._loop_start thing would mess something else up"_view, ss, ctx, _here, module, options, _helpers);

    }
    else if (k == Kind_Idfg_not)
    {
        if (canDiscard)
        {
            node = only_S4ER(node.items);
            propagateType_gDsn(node, t_void, relax_mask, Helpers_DyqV{}, _current_fn, ss, ctx, _here, module, options, _helpers);
        }
        else
        {
            propagateType_gDsn(only_krrB(node.items), t_proposition, relax_mask, Helpers_DyqV{}, _current_fn, ss, ctx, _here, module, options, _helpers);
        };
    }
    else if (k == Kind_Idfg_call)
    {
        node._loop_start = _current_fn.postdom.write_loop_start;
        const Target_VZrr t = node.target;
        if (GET_gDsn(t, ss, ctx, _here, module).kind == Kind_Idfg_field)
        {
            const UnpackedOffset_f7kz _ = field_unpackOffset_gDsn(GET_gDsn(t, ss, ctx, _here, module), ctx, _here);
            Type_OiTm slot_1 = USAGE_structUsageFromFieldUsage_GgXY(Type_OiTm(slot), _.memberFlatOffset);
            if (canDiscard)
            {
                node = only_S4ER(node.items);
                propagateType_gDsn(node, slot_1, relax_mask, Helpers_DyqV{}, _current_fn, ss, ctx, _here, module, options, _helpers);
            }
            else
            {
                propagateType_gDsn(only_krrB(node.items), slot_1, relax_mask, Helpers_DyqV{}, _current_fn, ss, ctx, _here, module, options, _helpers);
            };
        }
        else if (GET_gDsn(t, ss, ctx, _here, module).kind == Kind_Idfg_var)
        {
            node._loop_start = _current_fn.postdom.read_loop_start;
            if (canDiscard)
            {
                node = createEmpty_gDsn(slot, Target_VZrr{}, ss, ctx, _here, module, options, _helpers);
            }
            else if (isLocal_gDsn(t))
            {
                unsigned v;
                trackVarUsage_gDsn((v = unsigned((t._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))), node.type, _current_fn, ss, ctx, _here, module, options, _helpers);
                trackUsedAgain_gDsn(node.type.lifetime, relax_mask, _current_fn, ss, ctx, _here, module, options, _helpers);
            };
        }
        else
        {
            const unsigned mask_retval_relaxable = mask_retval_relaxable_9CJm(GET_gDsn(t, ss, ctx, _here, module).type, relaxed_quals, ctx, _here);
            if (mask_retval_relaxable && (int(unsigned(((t._packed >> 40ull) & 0xfffffull))) == module.modid))
            {
                if (GET_gDsn(t, ss, ctx, _here, module).kind == Kind_Idfg_fn)
                {
                    const Target_VZrr spec = tryReverseSpecialize_gDsn(Target_VZrr(t), mask_retval_relaxable, ss, ctx, _here, module, options, _helpers);
                    if (spec)
                        redirectCallTarget_gDsn(spec, node, t, _current_fn, ss, ctx, _here, module, options, _helpers);

                }
                else if (EXT_gDsn(t, ss, ctx, module).spec_of)
                {
                    fu::vec<SolvedNode_efhg> relaxed {};
                    for (int i = 0; i < node.items.size(); i++)
                    {
                        const SolvedNode_efhg& orig = node.items[i];
                        if (EXT_gDsn(t, ss, ctx, module).args[i].flags & Flags_Lzg8_F_LT_RETURNED)
                        {
                            const unsigned relax_mask_1 = (relax_mask & ~q_USAGE);
                            Type_OiTm type = orig.type;
                            if (try_relax_9CJm(type, slot, relax_mask_1))
                            {
                                if (!relaxed)
                                    relaxed = fu::get_range(node.items, 0, i);

                                relaxed += SolvedNode_gDsn(Kind_Idfg___relaxed, type, Flags_Lzg8{}, (*(fu::str*)fu::NIL), (*(fu::vec<SolvedNode_efhg>*)fu::NIL), Target_VZrr{}, Helpers_DyqV{}, _here);
                                continue;
                            };
                        };
                        if (relaxed)
                            relaxed += SolvedNode_efhg(orig);

                    };
                    if (relaxed)
                    {
                        fu::str error {};
                        fu::str args_mangled {};
                        const Target_VZrr spec = trySpecialize_gDsn(Target_VZrr(EXT_gDsn(t, ss, ctx, module).spec_of), relaxed, args_mangled, error, relaxed.size(), (*(Type_OiTm*)fu::NIL), (*(Reorder_0MNg*)fu::NIL), fu::view<fu::vec<Target_VZrr>>{}, _current_fn, ss, ctx, _here, module, options, _helpers);
                        if (!is_SPECFAIL_gDsn(spec))
                            redirectCallTarget_gDsn(spec, node, t, _current_fn, ss, ctx, _here, module, options, _helpers);

                    };
                };
            };
            if (canDiscard && isDiscardable_gDsn(node.target, ss, ctx, _here, module, options, _helpers))
            {

                {
                    const SolverNotes_LSla note = SolverNotes_LSla_N_UnusedCall;
                    if (note & options.break_notes)
                    {
                        fu::view<char> reason = fu::view<char>{};
                        fail_gDsn((("`break_notes`: Unwanted event: "_view + qBAD_e44U(str_kJvr(note))) + (reason ? ("\n\t\t"_view + reason) : fu::str("."_fu))), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                    }
                    else
                        ss._notes |= note;

                };
                discardIntoBlock_gDsn(node, slot, relax_mask, _current_fn, ss, ctx, _here, module, options, _helpers);
            }
            else
            {
                if (is_never_9CJm(GET_gDsn(node.target, ss, ctx, _here, module).type.vtype) && !_current_fn.TODO_FIX_catches)
                {
                    _current_fn.postdom.snap = PostdomSnap_cfaM{};
                    _current_fn.postdom.snap.exitPaths = ExitPaths_UXHs_XP_NoReturn;
                };
                _current_fn.effects.fx_mask |= EXT_gDsn(node.target, ss, ctx, module).fx_mask;
                if ((relax_mask == RELAX_all) && node.items)
                {
                    fu::vec<Argument_bbKc> host_args = fu::vec<Argument_bbKc>(EXT_gDsn(t, ss, ctx, module).args);
                    for (int i = 0; i < host_args.size(); i++)
                    {
                        const SolvedNode_efhg& arg = node.items[i];
                        const Argument_bbKc& host_arg = host_args[i];
                        if (is_ref_9CJm(host_arg.type))
                        {
                            trackUsedAgain_gDsn(arg.type.lifetime, relax_mask, _current_fn, ss, ctx, _here, module, options, _helpers);
                        };
                        if (host_arg.flags & Flags_Lzg8_F_COW_INSIDE)
                            validateCOW_gDsn(arg, arg.token, node.target, host_arg, canDiscard, _current_fn, ss, ctx, _here, module, options, _helpers);

                    };
                };
                if (node.items)
                { {
                    if (GET_gDsn(t, ss, ctx, _here, module).kind == Kind_Idfg_type)
                    {
                        const Struct_LDkB* __partcopy_ref;
                        Struct_LDkB s = (__partcopy_ref = &(tryLookupUserType_1qjp(GET_gDsn(t, ss, ctx, _here, module).type.vtype, ctx, _here, module)), Struct_LDkB { (*__partcopy_ref).kind, {/*unused non-zst*/}, {/*unused non-zst*/}, fu::vec<ScopeItem_xiLD>((*__partcopy_ref).items), {/*unused non-zst*/}, {/*unused non-zst*/}, {/*unused non-zst*/}, {/*unused non-zst*/} });
                        if (!(s.kind != Kind_Idfg_struct))
                        {
                            if (s.items.size() == node.items.size())
                            {
                                for (int i = node.items.size(); i-- > 0; )
                                {
                                    const Overload_aO3i& field = GET_gDsn(target_z0Qq(s.items[i]), ss, ctx, _here, module);
                                    SolvedNode_efhg& arg = node.items.mutref(i);
                                    const UnpackedOffset_f7kz _ = field_unpackOffset_gDsn(field, ctx, _here);
                                    const ValueType_JtNg* type;
                                    Type_OiTm slot_1 = USAGE_fieldUsageFromStructUsage_GgXY(Type_OiTm(field.type), (type = &(slot.vtype), ((*type).quals & q_USAGE)), _.memberFlatOffset, _.memberFlatCount);
                                    if (relax_mask == RELAX_all)
                                        maybeCopyOrMove_gDsn(arg, slot_1, true, (*(fu::str*)fu::NIL), _current_fn, ss, ctx, _here, module, options, _helpers);

                                    propagateType_gDsn(arg, slot_1, relax_mask, Helpers_DyqV{}, _current_fn, ss, ctx, _here, module, options, _helpers);
                                };
                                goto BL_104;
                            }
                            else
                                BUG_gDsn("Call(type): struct.items.len != call.items.len"_view, ss, ctx, _here, module, options, _helpers);

                        };
                    };
                    fu::vec<Argument_bbKc> host_args = fu::vec<Argument_bbKc>(EXT_gDsn(node.target, ss, ctx, module).args);
                    const bool RTL = isRTL_xQNS(GET_gDsn(node.target, ss, ctx, _here, module));
                    if (host_args.size() == node.items.size())
                        argsReverse_wRgf(RTL, host_args, node, relax_mask, _current_fn, ss, ctx, _here, module, options, _helpers);
                    else
                        BUG_gDsn(x7E_rA00("propagateType(call) args.len != host_args.len at call to "_view, str_FDl5(node.target, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

                  } BL_104:;
                };
            };
        };
    }
    else if (isImmediatelyDiscardable_UVY6(k))
    {
        if (canDiscard || (k == Kind_Idfg_definit))
        {
            if (node.items)
                BUG_gDsn((x7E_rA00("propagateType canDiscard("_view, str_eN8k(k)) + ") has items."_view), ss, ctx, _here, module, options, _helpers);
            else
                intoEmpty_gDsn(node, ss, ctx, _here, module, options, _helpers);

        };
    }
    else if (k == Kind_Idfg_copy)
    {
        if (canDiscard)
            BUG_gDsn(x7E_rA00("Trying to discard a copy: "_view, str_iUdw(node, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);
        else if (relax_mask != RELAX_all)
            BUG_gDsn(x7E_rA00("Found a copy node during first relax: "_view, str_iUdw(node, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);
        else
        {
            const SolvedNode_efhg& item = only_S4ER(node.items);
            bool isCopy = true;
            UsedAgain_5DsR usedAgain {};
            if (!is_trivial_1qjp(item.type.vtype, ctx, _here, module))
            {
                if (!(usedAgain = trackUsedAgain_gDsn(item.type.lifetime, relax_mask, _current_fn, ss, ctx, _here, module, options, _helpers)))
                    isCopy = false;
                else
                {
                    if (!is_trivial_1qjp(item.type.vtype, ctx, _here, module))
                    {
                        validateCOW_gDsn(item, TokenIdx_5581(_here), Target_VZrr{}, (*(Argument_bbKc*)fu::NIL), false, _current_fn, ss, ctx, _here, module, options, _helpers);
                    };
                    const ValueType_JtNg* type;
                    const unsigned usage = (type = &(node.type.vtype), ((*type).quals & q_USAGE));
                    const int flatCount = getFlatCount_1qjp(node.type.vtype, ctx, _here, module);
                    const unsigned maxUsage = getMaxUsage_CaGD(flatCount);
                    if ((usage != maxUsage) && is_rx_copy_9CJm(node.type.vtype))
                    {
                        const Struct_LDkB* __partcopy_ref;
                        Struct_LDkB s = (__partcopy_ref = &(tryLookupUserType_1qjp(node.type.vtype, ctx, _here, module)), Struct_LDkB { (*__partcopy_ref).kind, {/*unused non-zst*/}, Target_VZrr((*__partcopy_ref).target), fu::vec<ScopeItem_xiLD>((*__partcopy_ref).items), {/*unused non-zst*/}, {/*unused non-zst*/}, {/*unused non-zst*/}, {/*unused non-zst*/} });
                        if (!(s.kind != Kind_Idfg_struct))
                        {
                            if (!USAGE_justOneThing_9CJm(usage, flatCount) && !isFieldChain_gDsn(item, ss, ctx, _here, module))
                            {
                                /*MOV*/ SolvedNode_efhg letdef = createLet_gDsn(str_lCD7BgjpDp0, Flags_Lzg8{}, DeclAsserts_taUG{}, item, false, _current_fn, ss, ctx, _here, module, options, _helpers);
                                only_krrB(node.items) = CallerNode_gDsn(str_lCD7BgjpDp0, Target_VZrr((letdef.target ? letdef.target : BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers))), fu::vec<SolvedNode_efhg>{}, (*(Reorder_0MNg*)fu::NIL), fu::view<fu::vec<Target_VZrr>>{}, _current_fn, ss, ctx, _here, module, options, _helpers);
                                node = createBlock_FDl5(static_cast<SolvedNode_efhg&&>(letdef), SolvedNode_efhg(node), ss, ctx, _here, module);
                            }
                            else
                            {
                                /*MOV*/ fu::vec<SolvedNode_efhg> args {};
                                for (int i = 0; i < s.items.size(); i++)
                                {
                                    const Target_VZrr fieldTarget = target_z0Qq(s.items[i]);
                                    const Overload_aO3i& field = GET_gDsn(fieldTarget, ss, ctx, _here, module);
                                    const UnpackedOffset_f7kz _ = field_unpackOffset_gDsn(field, ctx, _here);
                                    /*MOV*/ Type_OiTm usedFieldType = USAGE_fieldUsageFromStructUsage_GgXY(Type_OiTm(field.type), usage, _.memberFlatOffset, _.memberFlatCount);
                                    if (isIrrelevant_9CJm(usedFieldType))
                                    {
                                        args += createEmpty_gDsn(usedFieldType, Target_VZrr{}, ss, ctx, _here, module, options, _helpers);
                                    }
                                    else
                                    {
                                        /*MOV*/ SolvedNode_efhg copy = node;
                                        copy.type = static_cast<Type_OiTm&&>(usedFieldType);
                                        copy.items = fu::vec<SolvedNode_efhg> {{ CallerNode_gDsn(str_xRMjr6luuKd, Target_VZrr(fieldTarget), fu::vec<SolvedNode_efhg> {{ SolvedNode_efhg(item) }}, (*(Reorder_0MNg*)fu::NIL), fu::view<fu::vec<Target_VZrr>>{}, _current_fn, ss, ctx, _here, module, options, _helpers) }};
                                        args += static_cast<SolvedNode_efhg&&>(copy);
                                    };
                                };
                                /*MOV*/ Type_OiTm type0 = node.type;
                                node = CallerNode_gDsn(str_Indt9JqHbva, Target_VZrr(s.target), static_cast<fu::vec<SolvedNode_efhg>&&>(args), (*(Reorder_0MNg*)fu::NIL), fu::view<fu::vec<Target_VZrr>>{}, _current_fn, ss, ctx, _here, module, options, _helpers);
                                node.type = static_cast<Type_OiTm&&>(type0);
                            };
                            propagateType_gDsn(node, slot, relax_mask, kills, _current_fn, ss, ctx, _here, module, options, _helpers);
                            return;
                        };
                    };
                };
            };
            SolvedNode_efhg& item_1 = only_krrB(node.items);
            if (is_ref_9CJm(item_1.type))
            {
                if (!(isCopy ? is_rx_copy_9CJm(item_1.type.vtype) : is_rx_move_9CJm(item_1.type)))
                {
                    fu::str extra = explainUsedAgain_gDsn(usedAgain, ss, ctx, _here, module, options);
                    fail_gDsn(((((!isCopy && is_sliceable_hxWW(item_1.type.vtype)) ? "An array value is needed, but cannot be copied or moved from a slice: "_view : "A value is needed, but cannot be copied or moved from: "_view) + explainType_gDsn(item_1.type, false, true, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)) + (extra ? ("\n\n\tCannot move: "_view + extra) : fu::str{})), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                }
                else
                {
                    if (isCopy && !is_trivial_1qjp(node.type.vtype, ctx, _here, module))
                    {
                        const SolverNotes_LSla note = SolverNotes_LSla_N_NonTrivAutoCopy;
                        if (note & options.break_notes)
                        {
                            fu::view<char> reason = fu::view<char>{};
                            fail_gDsn((("`break_notes`: Unwanted event: "_view + qBAD_e44U(str_kJvr(note))) + (reason ? ("\n\t\t"_view + reason) : fu::str("."_fu))), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                        }
                        else
                            ss._notes |= note;

                    };
                    Type_OiTm itemSlot = (isCopy ? make_copyable_9CJm(Type_OiTm(slot)) : make_moveable_9CJm(Type_OiTm(slot)));
                    propagateType_gDsn(item_1, itemSlot, relax_mask, Helpers_DyqV{}, _current_fn, ss, ctx, _here, module, options, _helpers);
                    if (!is_ref_9CJm(item_1.type))
                        node = item_1;
                    else if (!isCopy)
                    {
                        Lifetime_F_MOVED_FROM_gDsn(item_1.type.lifetime, ss, ctx, _here, module, options, _helpers);
                        node.kind = Kind_Idfg_move;
                    };
                };
            }
            else
                BUG_gDsn(x7E_rA00("Nothing to copy, item is not a ref: "_view, str_iUdw(item_1, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

        };
    }
    else if (k == Kind_Idfg_arrlit)
    {
        if (!node.items.size())
            intoEmpty_gDsn(node, ss, ctx, _here, module, options, _helpers);
        else if (canDiscard)
        {

            {
                const SolverNotes_LSla note = SolverNotes_LSla_N_UnusedArrlit;
                if (note & options.break_notes)
                {
                    fu::view<char> reason = fu::view<char>{};
                    fail_gDsn((("`break_notes`: Unwanted event: "_view + qBAD_e44U(str_kJvr(note))) + (reason ? ("\n\t\t"_view + reason) : fu::str("."_fu))), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                }
                else
                    ss._notes |= note;

            };
            discardIntoBlock_gDsn(node, slot, relax_mask, _current_fn, ss, ctx, _here, module, options, _helpers);
        }
        else
        {
            fu::view_mut<SolvedNode_efhg> items = node.items;
            Type_OiTm itemSlot = clear_sliceable_1qjp(node.type.vtype, ctx, _here, module);
            if (relax_mask == RELAX_all)
            {
                for (int i = 0; i < items.size(); i++)
                {
                    SolvedNode_efhg* _4;
                    (_4 = &(items.mutref(i)), maybeCopyOrMove_gDsn(*_4, itemSlot, false, (*(fu::str*)fu::NIL), _current_fn, ss, ctx, _here, module, options, _helpers));
                };
            };
            for (int i = 0; i < items.size(); i++)
            {
                propagateType_gDsn(items.mutref(i), itemSlot, relax_mask, Helpers_DyqV{}, _current_fn, ss, ctx, _here, module, options, _helpers);
            };
        };
    }
    else if ((k == Kind_Idfg_argid) || (k == Kind_Idfg___litfix_bound))
    {
        node = first_GSzO(node.items);
        propagateType_gDsn(node, slot, relax_mask, Helpers_DyqV{}, _current_fn, ss, ctx, _here, module, options, _helpers);
    }
    else if (k == Kind_Idfg_jump)
    {
        Helpers_DyqV h = node.helpers;
        const Helpers_DyqV* h_1;
        while ((h_1 = &(h), ((((*h_1).index >= 0) && ((*h_1).index < ss._helpers_data.size())) ? ss._helpers_data[(*h_1).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).kills)
        {
            const Helpers_DyqV* h_2;
            h = (node.helpers = (h_2 = &(h), ((((*h_2).index >= 0) && ((*h_2).index < ss._helpers_data.size())) ? ss._helpers_data[(*h_2).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).kills);
        };
        const Helpers_DyqV* h_2;
        if ((h_2 = &(h), ((((*h_2).index >= 0) && ((*h_2).index < ss._helpers_data.size())) ? ss._helpers_data[(*h_2).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).ret_actual)
        {
            SolvedNode_efhg& expr = only_krrB(node.items);

            {
                const int read_loop0 = _current_fn.postdom.read_loop_start;
                const Helpers_DyqV* h_3;
                const Postdom_Vy5u* _5;
                _current_fn.postdom = (*(_5 = &((h_3 = &(h), ((((*h_3).index >= 0) && ((*h_3).index < ss._helpers_data.size())) ? ss._helpers_data[(*h_3).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).postdom)) ? *_5 : BUG_gDsn(x7E_rA00("propagateType(jump): h.loop_start not available: #"_view, fu::i64dec(h.index)), ss, ctx, _here, module, options, _helpers));
                _current_fn.postdom.read_loop_start = read_loop0;
                const Helpers_DyqV* h_4;
                if ((h_4 = &(h), ((((*h_4).index >= 0) && ((*h_4).index < ss._helpers_data.size())) ? ss._helpers_data[(*h_4).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).mask & HelpersMask_w1sv_HM_Function)
                {
                    const Kind_Idfg kind = expr.kind;
                    _current_fn.postdom.snap.exitPaths = (((kind == Kind_Idfg_empty) || (kind == Kind_Idfg_definit)) ? ExitPaths_UXHs_XP_EmptyReturn : ExitPaths_UXHs_XP_NonEmptyReturn);
                };
            };
            const bool redundant = (kills ? (kills.index <= h.index) : false);
            const Helpers_DyqV& kills_1 = (redundant ? kills : h);
            if (relax_mask == RELAX_all)
            {
                const Helpers_DyqV* h_3;
                maybeCopyOrMove_gDsn(expr, (h_3 = &(h), ((((*h_3).index >= 0) && ((*h_3).index < ss._helpers_data.size())) ? ss._helpers_data[(*h_3).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).ret_actual, false, (*(fu::str*)fu::NIL), _current_fn, ss, ctx, _here, module, options, _helpers);
            };
            const Helpers_DyqV* h_3;
            propagateType_gDsn(expr, Type_OiTm((h_3 = &(h), ((((*h_3).index >= 0) && ((*h_3).index < ss._helpers_data.size())) ? ss._helpers_data[(*h_3).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).ret_actual), relax_mask, kills_1, _current_fn, ss, ctx, _here, module, options, _helpers);
            if (redundant)
                node = expr;
            else
            {
                const Helpers_DyqV* h_4;
                (h_4 = &(h), ((((*h_4).index >= 0) && ((*h_4).index < ss._helpers_data.size())) ? ss._helpers_data.mutref((*h_4).index) : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).mask |= HelpersMask_w1sv_HM_LabelUsed;
                const Helpers_DyqV* h_5;
                if (isIrrelevant_9CJm((h_5 = &(h), ((((*h_5).index >= 0) && ((*h_5).index < ss._helpers_data.size())) ? ss._helpers_data[(*h_5).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).ret_actual))
                {
                    if (expr.kind == Kind_Idfg_empty)
                    {
                        const Helpers_DyqV* h_6;
                        expr.type = (h_6 = &(h), ((((*h_6).index >= 0) && ((*h_6).index < ss._helpers_data.size())) ? ss._helpers_data[(*h_6).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).ret_actual;
                        intoEmpty_gDsn(expr, ss, ctx, _here, module, options, _helpers);
                    }
                    else
                    {
                        const Helpers_DyqV* h_6;
                        /*MOV*/ SolvedNode_efhg not_empty = createEmpty_gDsn((h_6 = &(h), ((((*h_6).index >= 0) && ((*h_6).index < ss._helpers_data.size())) ? ss._helpers_data[(*h_6).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).ret_actual, Target_VZrr{}, ss, ctx, _here, module, options, _helpers);
                        std::swap(expr, not_empty);
                        node = createBlock_FDl5(static_cast<SolvedNode_efhg&&>(not_empty), SolvedNode_efhg(node), ss, ctx, _here, module);
                    };
                }
                else if (tryInjectJumps_gDsn(expr, h, ss, ctx, _here, module, options, _helpers))
                    node = expr;

            };
        }
        else
            BUG_gDsn(x7E_rA00("propagateType(jump): h.ret_actual not available: #"_view, fu::i64dec(h.index)), ss, ctx, _here, module, options, _helpers);

    }
    else if (k == Kind_Idfg_block)
    {
        const Helpers_DyqV& h = node.helpers;
        if ((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).ret_actual)
        {
            if ((relax_mask == RELAX_all) && HelpersMask_w1sv(((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).mask & HelpersMask_w1sv_HM_Function)))
                mcom_FnReturn_CopyOrMoveDecision_gDsn(h, _current_fn, ss, ctx, _here, module, options, _helpers);

            try_relax_9CJm((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data.mutref(h.index) : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).ret_actual, slot, relax_mask);
            if ((relax_mask == RELAX_all) && !canDiscard && !is_never_9CJm((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).ret_actual.vtype))
            {
                const Type_OiTm* _6;
                SolvedNode_efhg* _7;
                (_6 = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).ret_actual), _7 = &(last_xZUS(node.items)), maybeCopyOrMove_gDsn(*_7, *_6, false, (*(fu::str*)fu::NIL), _current_fn, ss, ctx, _here, module, options, _helpers));
            };
        };
        if (h)
        {
            (((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data.mutref(h.index) : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).mask &= HelpersMask_w1sv(~HelpersMask_w1sv_HM_LabelUsed);
            (((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data.mutref(h.index) : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).kills = Helpers_DyqV(kills);
        };
        fu::vec<SolvedNode_efhg>& items = node.items;

        {
            for (int i = 0; i < (items.size() - 1); i++)
            {
                SolvedNode_efhg& node_1 = items.mutref(i);
                const Kind_Idfg k_1 = node_1.kind;
                if (k_1 == Kind_Idfg_defer)
                {
                    TEST_paintNode_gDsn(node_1, ss, ctx, _here, module, options, _helpers);
                    SolvedNode_efhg& expr = only_krrB(node_1.items);
                    propagateType_gDsn(expr, t_void, relax_mask, Helpers_DyqV{}, _current_fn, ss, ctx, _here, module, options, _helpers);
                    if (isDiscardable_FDl5(expr, ss, ctx, _here, module, options, _helpers))
                    {

                        {
                            const SolverNotes_LSla note = SolverNotes_LSla_N_UnusedDefer;
                            if (note & options.break_notes)
                            {
                                fu::view<char> reason = fu::view<char>{};
                                fail_gDsn((("`break_notes`: Unwanted event: "_view + qBAD_e44U(str_kJvr(note))) + (reason ? ("\n\t\t"_view + reason) : fu::str("."_fu))), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                            }
                            else
                                ss._notes |= note;

                        };
                        items.splice(i--, 1);
                    };
                }
                else if ((k_1 == Kind_Idfg_and) || (k_1 == Kind_Idfg_or))
                {
                    if (is_never_9CJm(last_c4M9(node_1.items).type.vtype))
                    {
                        /*MOV*/ fu::vec<SolvedNode_efhg> cond = fu::vec<SolvedNode_efhg>(fu::get_range(node_1.items, 0, (node_1.items.size() - 1)));
                        /*MOV*/ SolvedNode_efhg cons = node_1.items[(node_1.items.size() - 1)];
                        fu::vec<SolvedNode_efhg> alt = fu::vec<SolvedNode_efhg>(fu::get_range(items, (i + 1), items.size()));
                        items.splice((i + 1), alt.size());
                        SolvedNode_efhg cond_1 = ((k_1 == Kind_Idfg_and) ? createAnd_gDsn(cond.destructive_move(), Type_OiTm(t_proposition), _current_fn, ss, ctx, _here, module, options, _helpers) : createOr_gDsn(cond.destructive_move(), Type_OiTm(t_proposition), _current_fn, ss, ctx, _here, module, options, _helpers));
                        /*MOV*/ SolvedNode_efhg alt_1 = createBlock_gDsn(last_c4M9(alt).type, alt, Helpers_DyqV{}, _here);
                        /*MOV*/ SolvedNode_efhg replacement = createIf_gDsn(cond_1, SolvedNode_efhg(((k_1 == Kind_Idfg_and) ? cons : alt_1)), static_cast<SolvedNode_efhg&&>(((k_1 == Kind_Idfg_and) ? alt_1 : cons)), Type_OiTm{}, _current_fn, ss, ctx, _here, module, options, _helpers);
                        items.mutref(i) = static_cast<SolvedNode_efhg&&>(replacement);
                    };
                }
                else if (k_1 == Kind_Idfg_block)
                {
                    if (if_last_Xdw0(node_1.items).kind == Kind_Idfg_unwrap)
                    {
                        if (relax_mask == RELAX_before_bck)
                        {
                            const Helpers_DyqV* h_1;
                            if ((node_1.kind == Kind_Idfg_block) && !HelpersMask_w1sv(((h_1 = &(node_1.helpers), ((((*h_1).index >= 0) && ((*h_1).index < ss._helpers_data.size())) ? ss._helpers_data[(*h_1).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).mask & HelpersMask_w1sv_HM_LabelUsed)))
                            {
                                fu::vec<SolvedNode_efhg> _8 {};
                                (_8 = steal_cs1x(node_1.items, 0, (node_1.items.size() - 1)), items.splice(i, 1, static_cast<fu::vec<SolvedNode_efhg>&&>(_8)));
                                i--;
                                continue;
                            }
                            else
                            {
                                fail_gDsn(str_27qCj4870pa, fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                            };
                        }
                        else
                            BUG_gDsn("Unwrapping a `defer` after BCK, changes control flow."_view, ss, ctx, _here, module, options, _helpers);

                    };
                };
            };
            Breakable_begin_gDsn(false, node, relax_mask, _current_fn, ss, ctx, _here);
            fu_DEFER(Breakable_end_gDsn(false, node, relax_mask, _current_fn, ss, ctx, _here));
            while (items)
            {
                SolvedNode_efhg& tail = last_xZUS(items);
                if (tail.kind == Kind_Idfg_defer)
                {
                    tail = ((tail.value == "err"_view) ? createEmpty_gDsn(t_void, Target_VZrr{}, ss, ctx, _here, module, options, _helpers) : SolvedNode_efhg(only_S4ER(tail.items)));
                    break;
                }
                else
                {
                    const Helpers_DyqV& kills_1 = (!(HelpersMask_w1sv(((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).mask & HelpersMask_w1sv_HM_Function)) && !is_void_9CJm((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).ret_actual.vtype)) ? (kills ? kills : h) : (*(Helpers_DyqV*)fu::NIL));
                    propagateType_gDsn(tail, slot, relax_mask, kills_1, _current_fn, ss, ctx, _here, module, options, _helpers);
                    if (!canDiscard || !isDiscardable_FDl5(tail, ss, ctx, _here, module, options, _helpers))
                        break;
                    else
                        items.pop();

                };
            };
            for (int i_1 = (items.size() - 1); i_1-- > 0; )
            {
                SolvedNode_efhg& expr = items.mutref(i_1);
                if (expr.kind != Kind_Idfg_defer)
                {
                    propagateType_gDsn(expr, t_void, relax_mask, Helpers_DyqV{}, _current_fn, ss, ctx, _here, module, options, _helpers);
                    if (isDiscardable_FDl5(expr, ss, ctx, _here, module, options, _helpers))
                        items.splice(i_1, 1);

                };
            };
        };
        if ((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).target == _current_fn.out.target)
            _current_fn_eachArg_BACK_la4i(relax_mask, _current_fn, ss, ctx, _here, module, options, _helpers);

        if (!items && !HelpersMask_w1sv(((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).mask & HelpersMask_w1sv_HM_Function)))
        {
            if (!canDiscard)
                BUG_gDsn(("Empty block type is relevant: "_view + explainType_gDsn(node.type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);
            else
                intoEmpty_gDsn(node, ss, ctx, _here, module, options, _helpers);

        }
        else if ((items.size() == 1) && !HelpersMask_w1sv(((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).mask & HelpersMask_w1sv((HelpersMask_w1sv_HM_LabelUsed | HelpersMask_w1sv_HM_Function)))))
            node = only_S4ER(items);
        else
        {
            if (canDiscard)
                node.type = slot;
            else if (kills)
            {
                if (items)
                {
                    const SolvedNode_efhg& tail = last_c4M9(items);
                    if ((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).ret_actual)
                    {
                        reportReturnType_gDsn(h, tail.type, false, _current_fn, ss, ctx, _here, module, options, _helpers);
                        node.type = (((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).ret_actual;
                    }
                    else
                        node.type = tail.type;

                };
            };
            const SolvedNode_efhg& tail = if_last_Xdw0(node.items);
            const Helpers_DyqV* h_1;
            if ((tail.kind == Kind_Idfg_block) && !HelpersMask_w1sv(((h_1 = &(tail.helpers), ((((*h_1).index >= 0) && ((*h_1).index < ss._helpers_data.size())) ? ss._helpers_data[(*h_1).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).mask & HelpersMask_w1sv_HM_LabelUsed)))
                node.items.splice((node.items.size() - 1), 1, fu::vec<SolvedNode_efhg>(tail.items));

        };
    }
    else if (k == Kind_Idfg_root)
    {
        for (int i = node.items.size(); i-- > 0; )
        {
            propagateType_gDsn(node.items.mutref(i), t_void, relax_mask, Helpers_DyqV{}, _current_fn, ss, ctx, _here, module, options, _helpers);
        };
    }
    else if (k == Kind_Idfg_pragma)
    {
        node._loop_start = _current_fn.postdom.write_loop_start;
        for (int i = 0; i < node.items.size(); i++)
        {
            SolvedNode_efhg& item = node.items.mutref(i);
            propagateType_gDsn(item, Type_OiTm(node.items[i].type), relax_mask, Helpers_DyqV{}, _current_fn, ss, ctx, _here, module, options, _helpers);
            if (is_mutref_9CJm(item.type, ctx, _here))
            {
                const ValueType_JtNg* type;
                callarg_trackWrites_gDsn(item.type.lifetime, (type = &(item.type.vtype), ((*type).quals & q_USAGE)), node, _current_fn, ss, ctx, _here, module, options, _helpers);
            };
        };
        if (node.value == "clock"_view)
            _current_fn.effects.fx_mask |= EFFECTS_clock;
        else if (node.value == "input"_view)
            _current_fn.effects.fx_mask |= EFFECTS_input;
        else if (node.value == "output"_view)
            _current_fn.effects.fx_mask |= EFFECTS_output;

    }
    else if (k == Kind_Idfg_unwrap)
    {
        fu::str what = (node.target ? str_FDl5(node.target, false, ss, ctx, _here, module, options) : fu::str("block"_fu));
        fail_gDsn((((((("Attempting to use an "_view + qKW_e44U("unwrap"_view)) + " "_view) + what) + " as a value."_view) + "\n\n\tUnwrapping here would complete any defers inside immediately."_view) + "\n\n\tIf this is intended, wrap it in a block to disambiguate."_view), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
    }
    else
        BUG_gDsn(("relax: Unexpected "_view + str_eN8k(k)), ss, ctx, _here, module, options, _helpers);

}

static fu::view<SolvedNode_efhg> args_iUdw(const SolvedNode_efhg& callsite)
{
    return callsite.items;
}

static const Target_VZrr& target_FDl5(const SolvedNode_efhg& callsite)
{
    return callsite.target;
}

static const Events_SbUb& events_iUdw(const CurrentFn_QbLp& _current_fn)
{
    return _current_fn.events;
}

                                #ifndef DEF_iF_KukUgGeMQHb
                                #define DEF_iF_KukUgGeMQHb
inline const Set_LKfa& iF_KukU(fu::view<Set_LKfa> a, const int i)
{
    if (uNsigned_40Hl(i) < uNsigned_40Hl(a.size()))
        return a[i];
    else
        return (*(Set_LKfa*)fu::NIL);

}
                                #endif

                                #ifndef DEF_iF_ezs9DFFIlH4
                                #define DEF_iF_ezs9DFFIlH4
inline static const Set_LKfa& iF_ezs9(const LocidMap_m07i& map, const int locid, const CurrentFn_QbLp& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    return iF_KukU(map._values, (args_neg + locid));
}
                                #endif

static int locid_gDsn(const WriteID_LxbZ& w)
{
    const unsigned v = (w._locid_and_hash & 0xfffffu);
    return int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)));
}

static bool acceptsTempCopies_FDl5(const Overload_aO3i& o, const Context_noPA& ctx, const TokenIdx_5581& _here)
{
    if ((o.kind == Kind_Idfg_var) && !(o.flags & (Flags_Lzg8_F_IMPLICIT | Flags_Lzg8_F_REF)))
        return !is_mutref_9CJm(o.type, ctx, _here);
    else
        return false;

}

static bool acceptsSoftRisk_FDl5(const Target_VZrr& t, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    unsigned v;
    if ((v = unsigned((t._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))) < 0)
        return !acceptsTempCopies_FDl5(GET_gDsn(t, ss, ctx, _here, module), ctx, _here);
    else
        return false;

}

static bool RESOLVE_byAAR_gDsn(const int read, const int write, const bool trySoft, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (pass == BorrowCheckPass_i0wt_BCK_aar)
    {
        if (read != write)
        {
            if ((!trySoft || !acceptsSoftRisk_FDl5(nested_FDl5(read, ss, ctx, _here), ss, ctx, _here, module)) && !add_gDsn(ensure_l3bn(_current_fn.flow.at_hard_risk, write, _current_fn), read, _current_fn))
                return true;
            else if (!add_gDsn(ensure_l3bn(_current_fn.flow.at_soft_risk, write, _current_fn), read, _current_fn))
                return true;
            else
            {
                const bool firstTry_to_ascendWrites = (write > read);
                for (int i = 0; i < 2; i++)
                {
                    if (!i == firstTry_to_ascendWrites)
                    {
                        Set_qOJY parents = iF_uNaK(_current_fn.flow.arg_parents, write, _current_fn);
                        if (parents)
                        {
                            for (int i_1 = 0; i_1 < parents.keys_asc.size(); i_1++)
                            {
                                int i_2;
                                const int parent = (i_2 = i_1, parents.keys_asc[i_2]);
                                if (parent != read)
                                    RESOLVE_byAAR_gDsn(read, parent, trySoft, pass, _current_fn, ss, ctx, _here, module, options, _helpers);

                            };
                            return true;
                        };
                    }
                    else
                    {
                        Set_qOJY parents = iF_uNaK(_current_fn.flow.arg_parents, read, _current_fn);
                        if (parents)
                        {
                            for (int i_1 = 0; i_1 < parents.keys_asc.size(); i_1++)
                            {
                                int i_2;
                                const int parent = (i_2 = i_1, parents.keys_asc[i_2]);
                                if (parent != write)
                                    RESOLVE_byAAR_gDsn(parent, write, false, pass, _current_fn, ss, ctx, _here, module, options, _helpers);

                            };
                            return true;
                        };
                    };
                };
                return true;
            };
        }
        else
            BUG_gDsn("RESOLVE_byAAR: read == write"_view, ss, ctx, _here, module, options, _helpers);

    }
    else
    {
        BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers);
    };
}

static bool RESOLVE_byAAR_wyx7(fu::view<WriteID_LxbZ> writes, const int read, const bool trySoft, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    for (int i = 0; i < writes.size(); i++)
        RESOLVE_byAAR_gDsn(read, locid_gDsn(writes[i]), trySoft, pass, _current_fn, ss, ctx, _here, module, options, _helpers);

    return true;
}

static const Overload_aO3i& GET_mut_FDl5(const Target_VZrr& target, const SolverState_aGlN& ss, const Module_wo7O& module)
{
    const int globid = int(unsigned(((target._packed >> 20ull) & 0xfffffull)));
    unsigned v;
    const int locid = (v = unsigned((target._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
    if ((globid > 0) && (int(unsigned(((target._packed >> 40ull) & 0xfffffull))) == module.modid))
    {
        if (locid)
        {
            const Extended_z0HS& ext = ss._scope.extended[globid];
            const Extended_z0HS* ext_1;
            return ext.args_n_locals[(ext_1 = &(ext), (((*ext_1).args_neg - ((locid > 0) ? 1 : 0)) + locid))];
        }
        else
            return ss._scope.overloads[(globid - 1)];

    }
    else
        fu::fail(fu::str(str_gRoMTrquoqa));

}

static Flow_oKsD& flow_gDsn(CurrentFn_QbLp& _current_fn)
{
    return _current_fn.flow;
}

static bool RESOLVE_byMutvar_FDl5(const int locid, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (pass == BorrowCheckPass_i0wt_BCK_bck)
    {
        const Target_VZrr t = nested_FDl5(locid, ss, ctx, _here);
        const Overload_aO3i& o = GET_mut_FDl5(t, ss, module);
        if (!acceptsTempCopies_FDl5(o, ctx, _here))
            return false;
        else if (is_mutref_9CJm(o.type, ctx, _here))
            BUG_gDsn((x7E_rA00(str_FDl5(t, false, ss, ctx, _here, module, options), ": Not F_REF but type.is_mutref"_view) + " in RESOLVE_byMutvar: is this a problem?"_view), ss, ctx, _here, module, options, _helpers);
        else if (o.kind == Kind_Idfg_var)
        {
            TEST_varLifetime_gDsn(o.type.lifetime, false, 0, ss, ctx, _here, module, options, _helpers);
            if (!is_rx_copy_9CJm(o.type.vtype))
                return false;
            else
            {
                add_gDsn(flow_gDsn(_current_fn).bck_consider_copy, locid, _current_fn);
                return true;
            };
        }
        else
            BUG_gDsn(x7E_rA00("RESOLVE_byMutvar: Not a variable: "_view, str_FDl5(t, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

    }
    else
    {
        BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers);
    };
}

                                #ifndef DEF_first_tIwR5wuSkD4
                                #define DEF_first_tIwR5wuSkD4
inline const WriteID_LxbZ& first_tIwR(fu::view<WriteID_LxbZ> a)
{
    return a[0];
}
                                #endif

static unsigned tokenHash_gDsn(const TokenIdx_5581& token)
{
    return ((unsigned(token.modid) * 9973u) ^ unsigned(token.tokidx)) << 20u;
}

static unsigned tokenHash_FDl5(const WriteID_LxbZ& w)
{
    return w._locid_and_hash & 0xfff00000u;
}

static fu::str RWEvent_stack_gDsn(const WriteID_LxbZ& write, const SolvedNode_efhg& root, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const int locid = locid_gDsn(write);

    {
        const SolvedNode_efhg& node = root;
        fu::vec<SolvedNode_efhg> stack = fu::vec<SolvedNode_efhg> {{ SolvedNode_efhg(node) }};
        while (stack)
        {
            SolvedNode_efhg node_1 = TODO_FIX_pop_f7Nv(stack);
            const SolvedNode_efhg& node_2 = ((node_1.kind == Kind_Idfg_letdef) ? GET_gDsn(node_1.target, ss, ctx, _here, module).solved : node_1);
            const SolvedNode_efhg& node_3 = ((node_2.kind == Kind_Idfg___preceding_ref_arg) ? _current_fn.events.preceding_ref_args[node_2.helpers.index].arg : node_2);
            if (!(tokenHash_gDsn(node_3.token) != tokenHash_FDl5(write)))
            {
                if (!((node_3.kind != Kind_Idfg_call) && (node_3.kind != Kind_Idfg_pragma)))
                {
                    if (node_3.kind == Kind_Idfg_call)
                    {
                        for (int i = 0; i < node_3.items.size(); i++)
                        {
                            const SolvedNode_efhg& arg = node_3.items[i];
                            if (Lifetime_has_7Yz9(arg.type.lifetime, locid))
                            {
                                const Argument_bbKc& host_arg = EXT_gDsn(node_3.target, ss, ctx, module).args[i];
                                if (host_arg.written_to)
                                {
                                    fu::str _0 {};
                                    return (_0 = x7E_rA00((addr_and_snippet_gDsn(node_3.token, CodeFmt_snPx{}, fu::view<char>{}, ctx, module) + "\n\tAt call to "_view), str_FDl5(node_3.target, false, ss, ctx, _here, module, options)), (static_cast<fu::str&&>(_0) + qSTACK_arg_gDsn(node_3.target, i, fu::view<Target_VZrr>{}, ArgQuery_O2xW{}, _current_fn, ss, ctx, _here, module, options, _helpers)));
                                };
                            };
                        };
                    }
                    else if (node_3.kind == Kind_Idfg_pragma)
                    {
                        for (int i = 0; i < node_3.items.size(); i++)
                        {
                            const SolvedNode_efhg& arg = node_3.items[i];
                            if (is_mutref_9CJm(arg.type, ctx, _here) && Lifetime_has_7Yz9(arg.type.lifetime, locid))
                            {
                                return (addr_and_snippet_gDsn(arg.token, CodeFmt_snPx{}, fu::view<char>{}, ctx, module) + "\n\tvia pragma "_view) + qID_e44U(node_3.value);
                            };
                        };
                    };
                };
            };
            for (int i = node_3.items.size(); i-- > 0; )
                stack += SolvedNode_efhg(node_3.items[i]);

        };
    };
    return x7E_rA00("\n\n\tCOMPILER BUG: RWEvent_stack could not find write to "_view, str_FDl5(nested_FDl5(locid_gDsn(write), ss, ctx, _here), false, ss, ctx, _here, module, options));
}

                                #ifndef DEF_str_jJhbv4RyfO2
                                #define DEF_str_jJhbv4RyfO2
inline fu::str str_jJhb(const BorrowCheckPass_i0wt n)
{
    if (n == BorrowCheckPass_i0wt_BCK_bck)
        return fu::str("BCK_bck"_fu);
    else if (n == BorrowCheckPass_i0wt_BCK_aar)
        return fu::str("BCK_aar"_fu);
    else if (n == BorrowCheckPass_i0wt_BCK_ooe)
        return fu::str("BCK_ooe"_fu);

    return fu::i64dec(int64_t(n));
}
                                #endif

[[noreturn]] static fu::never cannotFailAfterBCK_gDsn(fu::vec_range<char> reason, const BorrowCheckPass_i0wt pass, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (pass == BorrowCheckPass_i0wt_BCK_bck)
    {
        fail_gDsn(reason, fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
    }
    else
        BUG_gDsn((x7E_rA00(str_jJhb(pass), " is trying to emit an error:\n\n\t"_view) + reason), ss, ctx, _here, module, options, _helpers);

}

static Events_SbUb& events_wyx7(CurrentFn_QbLp& _current_fn)
{
    return _current_fn.events;
}

                                #ifndef DEF_x5Bx5D_yXynwDGUloe
                                #define DEF_x5Bx5D_yXynwDGUloe
inline static Set_LKfa& x5Bx5D_yXyn(LocidMap_m07i& map, const int locid, const CurrentFn_QbLp& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    return map._values.mutref((args_neg + locid));
}
                                #endif

static Events_SbUb& events_gDsn(CurrentFn_QbLp& _current_fn)
{
    return _current_fn.events;
}

static void bck_trackRead_gDsn(const SolvedNode_efhg& callsite, const SolvedNode_efhg& root, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (!(!isLocal_gDsn(callsite.target)))
    {
        _here = callsite.token;
        const Target_VZrr* t;
        unsigned v;
        const int target = (t = &(callsite.target), v = unsigned(((*t)._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        const int loop_start = (callsite._loop_start ? callsite._loop_start : BUG_gDsn("bck_trackRead: loop_start not set on callsite."_view, ss, ctx, _here, module, options, _helpers));
        TEST_varLifetime_gDsn(callsite.type.lifetime, TODO_FIX_static_ZSTs, target, ss, ctx, _here, module, options, _helpers);
        Set_LKfa u = iF_ezs9(events_iUdw(_current_fn).snap.invalidated_by, target, _current_fn);
        if (u)
        {
            if (((pass == BorrowCheckPass_i0wt_BCK_aar) ? !RESOLVE_byAAR_wyx7(u.keys_asc, target, true, pass, _current_fn, ss, ctx, _here, module, options, _helpers) : !RESOLVE_byMutvar_FDl5(target, pass, _current_fn, ss, ctx, _here, module, options, _helpers)))
            {
                const WriteID_LxbZ& first = first_tIwR(u.keys_asc);
                fu::str _0 {};
                fu::str _1 {};
                (_1 = (_0 = (x7E_rA00(((x7E_rA00(("Cannot access"_view + " "_view), str_FDl5(nested_FDl5(target, ss, ctx, _here), false, ss, ctx, _here, module, options)) + ", reference invalidated by write to"_view) + " "_view), str_FDl5(nested_FDl5(locid_gDsn(first), ss, ctx, _here), false, ss, ctx, _here, module, options)) + " at "_view), (static_cast<fu::str&&>(_0) + RWEvent_stack_gDsn(first, root, _current_fn, ss, ctx, _here, module, options, _helpers))), cannotFailAfterBCK_gDsn(static_cast<fu::str&&>(_1), pass, ss, ctx, _here, module, options, _helpers));
            }
            else
            {
                x5Bx5D_yXyn(events_wyx7(_current_fn).snap.invalidated_by, target, _current_fn) = Set_LKfa{};
            };
        };
        if (target < loop_start)
            add_gDsn(events_gDsn(_current_fn).used_in_a_loop, target, _current_fn);

    };
}

static fu::view_mut<SolvedNode_efhg> args_FDl5(SolvedNode_efhg& callsite)
{
    return callsite.items;
}

                                #ifndef DEF___FY6lt6Pg491
                                #define DEF___FY6lt6Pg491
inline static void _FY6l(const int i, const Argument_bbKc& host_arg, const bool ooe_isLast, SolvedNode_efhg& callsite, Lifetime_llCF& bck_writes, int& num_ref_args, int& pra_first, const SolvedNode_efhg& root, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if ((pra_first >= 0))
        _current_fn.events.preceding_ref_args.mutref(pra_first).w = i;

    SolvedNode_efhg& arg = args_FDl5(callsite).mutref(i);
    bck_node_gDsn(arg, root, pass, _current_fn, ss, ctx, _here, module, options, _helpers);
    if (!(!(is_ref_9CJm(host_arg.type) && is_ref_9CJm(arg.type))))
    {
        num_ref_args++;
        if (host_arg.written_to)
        {
            if (is_mutref_9CJm(host_arg.type, ctx, _here))
            {
                if (!(is_mutref_9CJm(arg.type, ctx, _here)))
                    BUG_gDsn((qID_e44U(human_gDsn(host_arg.name, ss, ctx, _here, module, options)) + ": host_arg.written but !arg.is_mutref"_view), ss, ctx, _here, module, options, _helpers);

            }
            else
                BUG_gDsn((qID_e44U(human_gDsn(host_arg.name, ss, ctx, _here, module, options)) + ": host_arg.written but !host_arg.is_mutref"_view), ss, ctx, _here, module, options, _helpers);

            Lifetime_add_7Yz9(bck_writes, arg.type.lifetime, false, ctx, _here);
        };
        if (!ooe_isLast)
        {
            /*MOV*/ SolvedNode_efhg pra {};
            pra.kind = Kind_Idfg___preceding_ref_arg;
            const int pra_index = _current_fn.events.preceding_ref_args.size();
            pra.helpers.index = pra_index;
            if (pra_first < 0)
                pra_first = pra_index;

            std::swap(pra, arg);
            _current_fn.events.preceding_ref_args += PrecedingRefArg_Bnyy { TokenIdx_5581(callsite.token), Target_VZrr(target_FDl5(callsite)), i, -1, static_cast<SolvedNode_efhg&&>(pra) };
        };
    };
}
                                #endif

                                #ifndef DEF_argsForward_VvPa7Md8lqk
                                #define DEF_argsForward_VvPa7Md8lqk
inline void argsForward_VvPa(const bool RTL, fu::view<Argument_bbKc> host_args, const int seqIdx_start, SolvedNode_efhg& callsite, Lifetime_llCF& bck_writes, int& num_ref_args, int& pra_first, const SolvedNode_efhg& root, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    int seqIdx = 0;
    int lastPass = 1;
    for (int pass_1 = 0; pass_1 < lastPass; pass_1++)
    {
        for (int i = 0; i < host_args.size(); i++)
        {
            const Argument_bbKc& host_arg = host_args[i];
            if (!!pass_1 != (RTL ? !i : !!((host_arg.flags & Flags_Lzg8_F_IMPLICIT) || is_mutref_9CJm(host_arg.type, ctx, _here))))
                lastPass = 2;
            else
            {
                if ((seqIdx_start <= seqIdx))
                    _FY6l(i, host_arg, (seqIdx == (host_args.size() - 1)), callsite, bck_writes, num_ref_args, pra_first, root, pass, _current_fn, ss, ctx, _here, module, options, _helpers);

                seqIdx++;
            };
        };
    };
}
                                #endif

                                #ifndef DEF___7GeJ9pmxmlh
                                #define DEF___7GeJ9pmxmlh
inline static void _7GeJ(const int locid, int& arg_first, int& arg_last, const int i0)
{
    if (locid)
    {
        arg_first = ((arg_first < 0) ? i0 : arg_first);
        arg_last = i0;
    };
}
                                #endif

                                #ifndef DEF_Lifetime_each_JmyGBZHavTh
                                #define DEF_Lifetime_each_JmyGBZHavTh
inline void Lifetime_each_JmyG(const Lifetime_llCF& lifetime, int& arg_first, int& arg_last, const int i0)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit_7Yz9(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        unsigned v;
        _7GeJ(((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))))), arg_first, arg_last, i0);
    };
}
                                #endif

static bool softRiskSafe_gDsn(const SolvedNode_efhg& arg, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    return isFieldChain_gDsn(arg, ss, ctx, _here, module);
}

                                #ifndef DEF___Z0VtFwjyxG7
                                #define DEF___Z0VtFwjyxG7
inline static void _Z0Vt(const int region1, const int region0, const int i1, const Argument_bbKc& host_arg1, const SolvedNode_efhg& arg1, const int i0, const Argument_bbKc& host_arg0, const SolvedNode_efhg& arg0, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (!(!(region1 && (region0 != region1))))
    {
        if (host_arg0.written_to)
            RESOLVE_byAAR_gDsn(region1, region0, (has_ZwXY(host_arg0.may_alias, i1) ? softRiskSafe_gDsn(arg1, ss, ctx, _here, module) : false), pass, _current_fn, ss, ctx, _here, module, options, _helpers);

        if (host_arg1.written_to)
            RESOLVE_byAAR_gDsn(region0, region1, (has_ZwXY(host_arg1.may_alias, i0) ? softRiskSafe_gDsn(arg0, ss, ctx, _here, module) : false), pass, _current_fn, ss, ctx, _here, module, options, _helpers);

    };
}
                                #endif

                                #ifndef DEF_Lifetime_each_5cimEb6F7Nk
                                #define DEF_Lifetime_each_5cimEb6F7Nk
inline void Lifetime_each_5cim(const Lifetime_llCF& lifetime, const int region0, const int i1, const Argument_bbKc& host_arg1, const SolvedNode_efhg& arg1, const int i0, const Argument_bbKc& host_arg0, const SolvedNode_efhg& arg0, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit_7Yz9(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        unsigned v;
        _Z0Vt(((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))))), region0, i1, host_arg1, arg1, i0, host_arg0, arg0, pass, _current_fn, ss, ctx, _here, module, options, _helpers);
    };
}
                                #endif

                                #ifndef DEF___dpr9V7ktYV6
                                #define DEF___dpr9V7ktYV6
inline static void _dpr9(const int region0, const int i1, const Argument_bbKc& host_arg1, const SolvedNode_efhg& arg1, const Lifetime_llCF& shallow1, const int i0, const Argument_bbKc& host_arg0, const SolvedNode_efhg& arg0, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (!(!region0))
    {
        Lifetime_each_5cim(shallow1, region0, i1, host_arg1, arg1, i0, host_arg0, arg0, pass, _current_fn, ss, ctx, _here, module, options, _helpers);
    };
}
                                #endif

                                #ifndef DEF_Lifetime_each_9fTMR7Mh9o8
                                #define DEF_Lifetime_each_9fTMR7Mh9o8
inline void Lifetime_each_9fTM(const Lifetime_llCF& lifetime, const int i1, const Argument_bbKc& host_arg1, const SolvedNode_efhg& arg1, const Lifetime_llCF& shallow1, const int i0, const Argument_bbKc& host_arg0, const SolvedNode_efhg& arg0, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit_7Yz9(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        unsigned v;
        _dpr9(((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))))), i1, host_arg1, arg1, shallow1, i0, host_arg0, arg0, pass, _current_fn, ss, ctx, _here, module, options, _helpers);
    };
}
                                #endif

extern const fu::static_ref<fu::str> SR_empty;
                                #ifndef DEF_onPathStart_mtwqzC8nqp6
                                #define DEF_onPathStart_mtwqzC8nqp6
inline static void onPathStart_mtwq(fu::vec<SubRegion_jsU3>& path)
{
    path.clear();
}
                                #endif

                                #ifndef DEF_onSubRegion_08qGw1gtU53
                                #define DEF_onSubRegion_08qGw1gtU53
inline static void onSubRegion_08qG(const int flatCount, const int flatOffset, fu::vec<SubRegion_jsU3>& path)
{
    path += SubRegion_jsU3 { flatCount, flatOffset };
}
                                #endif

                                #ifndef DEF_TEST_verifyUsageBitRanges_UXXij53WiC3
                                #define DEF_TEST_verifyUsageBitRanges_UXXij53WiC3
inline static void TEST_verifyUsageBitRanges_UXXi(const SubRegion_jsU3& a, const RWQuals_ELUY& rw, const Context_noPA& ctx, const TokenIdx_5581& _here)
{
    const unsigned range = getRegionUsage_CaGD(a.flatOffset, a.flatCount);
    if (!(((range & rw.usage) == rw.usage) && (range & rw.usage) && ((rw.written_to & rw.usage) == rw.written_to)))
        BUG_u9Gb((x7E_rA00((x7E_rA00((x7E_rA00("range("_view, fu::u64dec(range)) + ") rw.usage("_view), fu::u64dec(rw.usage)) + ") rw.written_to("_view), fu::u64dec(rw.written_to)) + ")"_view), ctx, _here);

}
                                #endif

                                #ifndef DEF_Paths_hasInter_RHfkdHzoDO9
                                #define DEF_Paths_hasInter_RHfkdHzoDO9
inline static bool Paths_hasInter_RHfk(fu::view<char> a, fu::view<char> b, const RWQuals_ELUY& rw_left, const RWQuals_ELUY& rw_right, const Context_noPA& ctx, const TokenIdx_5581& _here)
{

    {
        fu::vec<SubRegion_jsU3> path {};
        int _o = 0;
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            onPathStart_mtwq(path);
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit_7Yz9(a, _o);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(a, _o) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                const int flatCount = int((raw_flatCount >> 1u));
                const int flatOffset = int((raw_flatOffset >> 1u));
                onSubRegion_08qG(flatCount, flatOffset, path);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };

            {
                fu::view<SubRegion_jsU3> a_path = path;
                fu::vec<SubRegion_jsU3> path_1 {};
                int _o_1 = 0;
                for (; ; )
                {
                    bool isLastPath_1 = false;
                    bool isFirstSubRegion_1 = true;
                    onPathStart_mtwq(path_1);
                    for (; ; )
                    {
                        const unsigned raw_flatOffset = parse7bit_7Yz9(b, _o_1);
                        const bool isLastSubRegion = !(raw_flatOffset & 1u);
                        const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(b, _o_1) : 3u);
                        isLastPath_1 = !(raw_flatCount & 1u);
                        const int flatCount = int((raw_flatCount >> 1u));
                        const int flatOffset = int((raw_flatOffset >> 1u));
                        onSubRegion_08qG(flatCount, flatOffset, path_1);
                        if (isLastSubRegion)
                            break;
                        else
                            isFirstSubRegion_1 = false;

                    };

                    { {
                        fu::view<SubRegion_jsU3> b_path = path_1;
                        const int N = min_DbqN(a_path.size(), b_path.size());
                        SubRegion_jsU3 a_1 {};
                        SubRegion_jsU3 b_1 {};
                        for (int i = 0; i < N; i++)
                        {
                            a_1 = a_path[i];
                            b_1 = b_path[i];
                            const int overlap = min_DbqN(((b_1.flatOffset + b_1.flatCount) - a_1.flatOffset), ((a_1.flatOffset + a_1.flatCount) - b_1.flatOffset));
                            if ((overlap <= 0))
                                goto BL_15;

                        };
                        RWQuals_ELUY abs_left {};
                        if ((a_path.size() <= b_path.size()))
                        {
                            abs_left = USAGE_structUsageFromFieldUsage_z5tF(rw_left, a_1.flatOffset);
                            TEST_verifyUsageBitRanges_UXXi(a_1, abs_left, ctx, _here);
                            const SubRegion_jsU3& a_2 = b_1;
                            const unsigned rw = (rw_right.written_to ? abs_left.usage : abs_left.written_to);
                            const unsigned range = getRegionUsage_CaGD(a_2.flatOffset, a_2.flatCount);
                            if (!(range & rw))
                                goto BL_15;

                        };
                        if ((b_path.size() <= a_path.size()))
                        {
                            const RWQuals_ELUY abs_right = USAGE_structUsageFromFieldUsage_z5tF(rw_right, b_1.flatOffset);
                            TEST_verifyUsageBitRanges_UXXi(b_1, abs_right, ctx, _here);

                            {
                                const SubRegion_jsU3& a_2 = a_1;
                                const unsigned rw = (rw_left.written_to ? abs_right.usage : abs_right.written_to);
                                const unsigned range = getRegionUsage_CaGD(a_2.flatOffset, a_2.flatCount);
                                if (!(range & rw))
                                    goto BL_15;

                            };
                            if (b_path.size() == a_path.size())
                            {
                                if (!((abs_right.written_to & abs_left.usage) || (abs_left.written_to & abs_right.usage)))
                                    goto BL_15;

                            };
                        };
                        return true;
                      } BL_15:;
                    };
                    if (isLastPath_1)
                        break;

                };
                if (!(_o_1 == b.size()))
                    BUG_u9Gb("walkPaths(!tailOK): excess bytes"_view, ctx, _here);

            };
            if (isLastPath)
                break;

        };
        if (!(_o == a.size()))
            BUG_u9Gb("walkPaths(!tailOK): excess bytes"_view, ctx, _here);

    };
    return false;
}
                                #endif

                                #ifndef DEF_Lifetime_hasInter_bsLKiWft1T4
                                #define DEF_Lifetime_hasInter_bsLKiWft1T4
inline bool Lifetime_hasInter_bsLK(const Lifetime_llCF& a, const Lifetime_llCF& b, const RWQuals_ELUY& rw_left, const RWQuals_ELUY& rw_right, const Context_noPA& ctx, const TokenIdx_5581& _here)
{
    if (!(rw_left.written_to || rw_right.written_to))
        return false;
    else
    {

        { {
            fu::view<char> l_chars = a.uni0n;
            fu::view<char> r_chars = b.uni0n;
            int l_start {};
            int r_start {};
            int l_paths0 {};
            int r_paths0 {};
            int l_offset {};
            int r_offset {};
            unsigned l {};
            unsigned r {};
            bool l_dirty = true;
            bool r_dirty = true;
            const bool l_done = false;
            const bool r_done = false;
            for (; ; )
            {
                if (l_dirty)
                {
                    l_dirty = false;
                    l_start = l_offset;
                    if (l_offset < l_chars.size())
                    {
                        l = parse7bit_7Yz9(l_chars, l_offset);
                        int offset0;
                        int BL_8_v;
                        l_paths0 = (__extension__ (
                        {
                            offset0 = (l_offset + 0);
                            for (; ; )
                            {
                                bool isLastPath = false;
                                bool isFirstSubRegion = true;
                                for (; ; )
                                {
                                    const unsigned raw_flatOffset = parse7bit_7Yz9(l_chars, l_offset);
                                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(l_chars, l_offset) : 3u);
                                    isLastPath = !(raw_flatCount & 1u);
                                    if (isLastSubRegion)
                                        break;
                                    else
                                        isFirstSubRegion = false;

                                };
                                if (isLastPath)
                                    break;

                            };
                            BL_8_v = (offset0);
                            (void)0;
                        }), BL_8_v);
                    }
                    else
                        goto BL_3;

                };
                if (r_dirty)
                {
                    r_dirty = false;
                    r_start = r_offset;
                    if (r_offset < r_chars.size())
                    {
                        r = parse7bit_7Yz9(r_chars, r_offset);
                        int offset0;
                        int BL_19_v;
                        r_paths0 = (__extension__ (
                        {
                            offset0 = (r_offset + 0);
                            for (; ; )
                            {
                                bool isLastPath = false;
                                bool isFirstSubRegion = true;
                                for (; ; )
                                {
                                    const unsigned raw_flatOffset = parse7bit_7Yz9(r_chars, r_offset);
                                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(r_chars, r_offset) : 3u);
                                    isLastPath = !(raw_flatCount & 1u);
                                    if (isLastSubRegion)
                                        break;
                                    else
                                        isFirstSubRegion = false;

                                };
                                if (isLastPath)
                                    break;

                            };
                            BL_19_v = (offset0);
                            (void)0;
                        }), BL_19_v);
                    }
                    else
                        goto BL_3;

                };
                unsigned r_1;
                unsigned r_2;
                unsigned r_3;
                unsigned r_4;
                unsigned r_5;
                unsigned r_6;
                const int cmp = (l_done ? (r_done ? (__extension__ (
                {
                    goto BL_3;
                    (void)0;
                }), fu::unreachable) : +1) : (r_done ? -1 : (((r_1 = l, ((r_1 & 11u) == 1u)) != (r_2 = r, ((r_2 & 11u) == 1u))) ? ((r_3 = r, ((r_3 & 11u) == 1u)) ? -1 : +1) : (((r_4 = l, (r_4 == 0b1001u)) != (r_5 = r, (r_5 == 0b1001u))) ? ((r_6 = r, (r_6 == 0b1001u)) ? +1 : -1) : (((l & 3u) == 2u) ? (((r & 3u) == 2u) ? x3Cx3E_Rgh3(l, r) : +1) : (((r & 3u) == 2u) ? -1 : x3Cx3E_Rgh3(r, l)))))));
                if (cmp == 0)
                {
                    l_dirty = true;
                    r_dirty = true;
                    fu::view<char> sr_left = fu::get_view(l_chars, l_paths0, l_offset);
                    fu::view<char> sr_right = fu::get_view(r_chars, r_paths0, r_offset);
                    if (((sr_left == sr_right) ? !!((rw_left.written_to & rw_right.usage) || (rw_right.written_to & rw_left.usage)) : ((sr_left == SR_empty.ref) || (sr_right == SR_empty.ref) || Paths_hasInter_RHfk(sr_left, sr_right, rw_left, rw_right, ctx, _here))))
                        return true;

                }
                else if (cmp < 0)
                    l_dirty = true;
                else
                    r_dirty = true;

            };
          } BL_3:;
        };
        return false;
    };
}
                                #endif

static const Flow_oKsD& flow_wyx7(const CurrentFn_QbLp& _current_fn)
{
    return _current_fn.flow;
}

                                #ifndef DEF_Paths_hasInter_XCYjZuM95eb
                                #define DEF_Paths_hasInter_XCYjZuM95eb
inline static bool Paths_hasInter_XCYj(fu::view<char> a, fu::view<char> b, const Context_noPA& ctx, const TokenIdx_5581& _here)
{

    {
        fu::vec<SubRegion_jsU3> path {};
        int _o = 0;
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            onPathStart_mtwq(path);
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit_7Yz9(a, _o);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(a, _o) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                const int flatCount = int((raw_flatCount >> 1u));
                const int flatOffset = int((raw_flatOffset >> 1u));
                onSubRegion_08qG(flatCount, flatOffset, path);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };

            {
                fu::view<SubRegion_jsU3> a_path = path;
                fu::vec<SubRegion_jsU3> path_1 {};
                int _o_1 = 0;
                for (; ; )
                {
                    bool isLastPath_1 = false;
                    bool isFirstSubRegion_1 = true;
                    onPathStart_mtwq(path_1);
                    for (; ; )
                    {
                        const unsigned raw_flatOffset = parse7bit_7Yz9(b, _o_1);
                        const bool isLastSubRegion = !(raw_flatOffset & 1u);
                        const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(b, _o_1) : 3u);
                        isLastPath_1 = !(raw_flatCount & 1u);
                        const int flatCount = int((raw_flatCount >> 1u));
                        const int flatOffset = int((raw_flatOffset >> 1u));
                        onSubRegion_08qG(flatCount, flatOffset, path_1);
                        if (isLastSubRegion)
                            break;
                        else
                            isFirstSubRegion_1 = false;

                    };

                    { {
                        fu::view<SubRegion_jsU3> b_path = path_1;
                        const int N = min_DbqN(a_path.size(), b_path.size());
                        SubRegion_jsU3 a_1 {};
                        SubRegion_jsU3 b_1 {};
                        for (int i = 0; i < N; i++)
                        {
                            a_1 = a_path[i];
                            b_1 = b_path[i];
                            const int overlap = min_DbqN(((b_1.flatOffset + b_1.flatCount) - a_1.flatOffset), ((a_1.flatOffset + a_1.flatCount) - b_1.flatOffset));
                            if ((overlap <= 0))
                                goto BL_15;

                        };
                        return true;
                      } BL_15:;
                    };
                    if (isLastPath_1)
                        break;

                };
                if (!(_o_1 == b.size()))
                    BUG_u9Gb("walkPaths(!tailOK): excess bytes"_view, ctx, _here);

            };
            if (isLastPath)
                break;

        };
        if (!(_o == a.size()))
            BUG_u9Gb("walkPaths(!tailOK): excess bytes"_view, ctx, _here);

    };
    return false;
}
                                #endif

                                #ifndef DEF_Lifetime_hasInter_cxIR4vDsSwf
                                #define DEF_Lifetime_hasInter_cxIR4vDsSwf
inline bool Lifetime_hasInter_cxIR(const Lifetime_llCF& a, const Lifetime_llCF& b, const Context_noPA& ctx, const TokenIdx_5581& _here)
{

    { {
        fu::view<char> l_chars = a.uni0n;
        fu::view<char> r_chars = b.uni0n;
        int l_start {};
        int r_start {};
        int l_paths0 {};
        int r_paths0 {};
        int l_offset {};
        int r_offset {};
        unsigned l {};
        unsigned r {};
        bool l_dirty = true;
        bool r_dirty = true;
        const bool l_done = false;
        const bool r_done = false;
        for (; ; )
        {
            if (l_dirty)
            {
                l_dirty = false;
                l_start = l_offset;
                if (l_offset < l_chars.size())
                {
                    l = parse7bit_7Yz9(l_chars, l_offset);
                    int offset0;
                    int BL_6_v;
                    l_paths0 = (__extension__ (
                    {
                        offset0 = (l_offset + 0);
                        for (; ; )
                        {
                            bool isLastPath = false;
                            bool isFirstSubRegion = true;
                            for (; ; )
                            {
                                const unsigned raw_flatOffset = parse7bit_7Yz9(l_chars, l_offset);
                                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(l_chars, l_offset) : 3u);
                                isLastPath = !(raw_flatCount & 1u);
                                if (isLastSubRegion)
                                    break;
                                else
                                    isFirstSubRegion = false;

                            };
                            if (isLastPath)
                                break;

                        };
                        BL_6_v = (offset0);
                        (void)0;
                    }), BL_6_v);
                }
                else
                    goto BL_1;

            };
            if (r_dirty)
            {
                r_dirty = false;
                r_start = r_offset;
                if (r_offset < r_chars.size())
                {
                    r = parse7bit_7Yz9(r_chars, r_offset);
                    int offset0;
                    int BL_17_v;
                    r_paths0 = (__extension__ (
                    {
                        offset0 = (r_offset + 0);
                        for (; ; )
                        {
                            bool isLastPath = false;
                            bool isFirstSubRegion = true;
                            for (; ; )
                            {
                                const unsigned raw_flatOffset = parse7bit_7Yz9(r_chars, r_offset);
                                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(r_chars, r_offset) : 3u);
                                isLastPath = !(raw_flatCount & 1u);
                                if (isLastSubRegion)
                                    break;
                                else
                                    isFirstSubRegion = false;

                            };
                            if (isLastPath)
                                break;

                        };
                        BL_17_v = (offset0);
                        (void)0;
                    }), BL_17_v);
                }
                else
                    goto BL_1;

            };
            unsigned r_1;
            unsigned r_2;
            unsigned r_3;
            unsigned r_4;
            unsigned r_5;
            unsigned r_6;
            const int cmp = (l_done ? (r_done ? (__extension__ (
            {
                goto BL_1;
                (void)0;
            }), fu::unreachable) : +1) : (r_done ? -1 : (((r_1 = l, ((r_1 & 11u) == 1u)) != (r_2 = r, ((r_2 & 11u) == 1u))) ? ((r_3 = r, ((r_3 & 11u) == 1u)) ? -1 : +1) : (((r_4 = l, (r_4 == 0b1001u)) != (r_5 = r, (r_5 == 0b1001u))) ? ((r_6 = r, (r_6 == 0b1001u)) ? +1 : -1) : (((l & 3u) == 2u) ? (((r & 3u) == 2u) ? x3Cx3E_Rgh3(l, r) : +1) : (((r & 3u) == 2u) ? -1 : x3Cx3E_Rgh3(r, l)))))));
            if (cmp == 0)
            {
                l_dirty = true;
                r_dirty = true;
                fu::view<char> sr_left = fu::get_view(l_chars, l_paths0, l_offset);
                fu::view<char> sr_right = fu::get_view(r_chars, r_paths0, r_offset);
                if (((sr_left == sr_right) ? true : ((sr_left == SR_empty.ref) || (sr_right == SR_empty.ref) || Paths_hasInter_XCYj(sr_left, sr_right, ctx, _here))))
                    return true;

            }
            else if (cmp < 0)
                l_dirty = true;
            else
                r_dirty = true;

        };
      } BL_1:;
    };
    return false;
}
                                #endif

static bool isInvalidatedBy_gDsn(const Lifetime_llCF& read, const Lifetime_llCF& write, const CurrentFn_QbLp& _current_fn, const Context_noPA& ctx, const TokenIdx_5581& _here)
{

    {
        fu::view<char> chars = write.uni0n;
        int offset = 0;
        while (offset < chars.size())
        {
            const unsigned r = parse7bit_7Yz9(chars, offset);
            for (; ; )
            {
                bool isLastPath = false;
                bool isFirstSubRegion = true;
                for (; ; )
                {
                    const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                    isLastPath = !(raw_flatCount & 1u);
                    if (isLastSubRegion)
                        break;
                    else
                        isFirstSubRegion = false;

                };
                if (isLastPath)
                    break;

            };
            unsigned v;
            const int w = ((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))));
            if (w && Lifetime_hasInter_cxIR(read, iF_4knF(flow_wyx7(_current_fn).rg_invalidates, w, _current_fn), ctx, _here))
                return true;

        };
    };
    return false;
}

                                #ifndef DEF___F6DVeaoHACc
                                #define DEF___F6DVeaoHACc
inline static bool _F6DV(const int locid, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    if (locid)
        return !(GET_gDsn(nested_FDl5(locid, ss, ctx, _here), ss, ctx, _here, module).flags & Flags_Lzg8_F_INJECTED);
    else
        return false;

}
                                #endif

                                #ifndef DEF_Lifetime_some_peXAuOFxI0k
                                #define DEF_Lifetime_some_peXAuOFxI0k
inline bool Lifetime_some_peXA(const Lifetime_llCF& lifetime, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{

    {
        fu::view<char> chars = lifetime.uni0n;
        int offset = 0;
        while (offset < chars.size())
        {
            const unsigned r = parse7bit_7Yz9(chars, offset);
            for (; ; )
            {
                bool isLastPath = false;
                bool isFirstSubRegion = true;
                for (; ; )
                {
                    const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                    isLastPath = !(raw_flatCount & 1u);
                    if (isLastSubRegion)
                        break;
                    else
                        isFirstSubRegion = false;

                };
                if (isLastPath)
                    break;

            };
            unsigned v;
            const int locid = ((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))));
            if (_F6DV(locid, ss, ctx, _here, module))
                return true;

        };
    };
    return false;
}
                                #endif

static ArgRationale_mffC requireVal_gDsn(const Argument_bbKc& other, const SolvedNode_efhg& other_arg, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    if (!(other.flags & Flags_Lzg8_F_INJECTED) || !Lifetime_some_peXA(other_arg.type.lifetime, ss, ctx, _here, module))
    {
        return ArgRationale_mffC{};
    }
    else
        return ArgRationale_mffC_RequireVal_AliasesMutatedInjectedArgument;

}

static bool RESOLVE_byMutvar_gDsn(const Target_VZrr& target, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const Target_VZrr* t;
    if (int(unsigned(((target._packed >> 20ull) & 0xfffffull))) == (t = &(_current_fn.out.target), int(unsigned((((*t)._packed >> 20ull) & 0xfffffull)))))
    {
        unsigned v;
        return RESOLVE_byMutvar_FDl5((v = unsigned((target._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))), pass, _current_fn, ss, ctx, _here, module, options, _helpers);
    }
    else
        return false;

}

static ArgRationale_mffC RESOLVE_byTempCopy_FDl5(SolvedNode_efhg& arg, const Target_VZrr& target, const int position, fu::vec_range<char> debug, const ArgRationale_mffC requireVal, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (pass == BorrowCheckPass_i0wt_BCK_bck)
    {
        if (_current_fn.asserts & DeclAsserts_taUG_A_FAST)
            return ArgRationale_mffC_CantTempCopy_FastFn;
        else
        {
            fu::view<Argument_bbKc> host_args = EXT_gDsn(target, ss, ctx, module).args;
            const Argument_bbKc& host_arg = host_args[position];
            if (!is_rx_copy_9CJm(arg.type.vtype))
                return ArgRationale_mffC_CantTempCopy_NonCopiable;
            else if ((arg.kind == Kind_Idfg_call) && RESOLVE_byMutvar_gDsn(arg.target, pass, _current_fn, ss, ctx, _here, module, options, _helpers))
            {
                return ArgRationale_mffC{};
            }
            else
            {
                const ArgRationale_mffC r = rejectsTempCopies_gDsn(host_arg, requireVal, ctx, _here);
                if (r)
                    return r;
                else if (host_arg.flags & Flags_Lzg8_F_LT_RETURNED)
                    return ArgRationale_mffC_CantTempCopy_ReturnedFromFn;
                else
                {
                    const Type_OiTm& slot = host_args[position].type;
                    Type_OiTm slot_1 = make_copyable_9CJm(clear_refs_9CJm(Type_OiTm(slot)));
                    maybeCopyOrMove_gDsn(arg, slot_1, false, debug, _current_fn, ss, ctx, _here, module, options, _helpers);
                    return ArgRationale_mffC{};
                };
            };
        };
    }
    else
    {
        BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers);
    };
}

static ArgRationale_mffC RESOLVE_byTempCopy_gDsn(SolvedNode_efhg& callsite, const int position, fu::vec_range<char> debug, const ArgRationale_mffC requireVal, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const Target_VZrr& target = callsite.target;
    SolvedNode_efhg& arg = callsite.items.mutref(position);
    return RESOLVE_byTempCopy_FDl5(arg, target, position, debug, requireVal, pass, _current_fn, ss, ctx, _here, module, options, _helpers);
}

                                #ifndef DEF___FC6kGQpKDj0
                                #define DEF___FC6kGQpKDj0
inline static fu::view<char> _FC6k(const int locid, fu::vec_range_mut<char> err, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    return (err += ("\n\t    "_view + explainWhichFn_gDsn(nested_FDl5(locid, ss, ctx, _here), fu::view<fu::vec<Target_VZrr>>{}, fu::view<char>{}, CodeFmt_snPx_FullContext, _current_fn, ss, ctx, _here, module, options)));
}
                                #endif

                                #ifndef DEF_each_709HNucwtTg
                                #define DEF_each_709HNucwtTg
inline void each_709H(fu::vec_range<int> a, fu::vec_range_mut<char> err, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    for (int i = 0; i < a.size(); i++)
        _FC6k(a[i], err, _current_fn, ss, ctx, _here, module, options);

}
                                #endif

static fu::str ArgRationale_explain_gDsn(const ArgRationale_mffC r, const Target_VZrr& callee, const SolvedNode_efhg& arg, const Argument_bbKc& host_arg, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (r == ArgRationale_mffC_CantTempCopy_FastFn)
        return fu::str(str_dmj5RVL83Ti);
    else if (r == ArgRationale_mffC_CantTempCopy_NonCopiable)
        return x7E_rA00(str_wyx7(host_arg, false, _current_fn, ss, ctx, _here, module, options), " is non-copyable: "_view) + explainType_gDsn(arg.type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options);
    else if (r == ArgRationale_mffC_CantTempCopy_HostArg_Ref)
        return x7E_rA00(str_wyx7(host_arg, false, _current_fn, ss, ctx, _here, module, options), " is "_view) + qBAD_e44U("ref"_view);
    else if (r == ArgRationale_mffC_CantTempCopy_HostArg_Implicit)
        return x7E_rA00(str_wyx7(host_arg, false, _current_fn, ss, ctx, _here, module, options), " is "_view) + qBAD_e44U("implicit"_view);
    else if (r == ArgRationale_mffC_CantTempCopy_HostArg_MutRef)
        return x7E_rA00(str_wyx7(host_arg, false, _current_fn, ss, ctx, _here, module, options), " is a mutref: "_view) + explainType_gDsn(arg.type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options);
    else if (r == ArgRationale_mffC_CantTempCopy_ReturnedFromFn)
        return x7E_rA00(x7E_rA00(str_wyx7(host_arg, false, _current_fn, ss, ctx, _here, module, options), " is ref-returned from "_view), str_FDl5(callee, false, ss, ctx, _here, module, options));
    else if (r == ArgRationale_mffC_RequireVal_AliasesMutatedInjectedArgument)
    {
        return x7E_rA00(((((((((((((((x7E_rA00(str_wyx7(host_arg, false, _current_fn, ss, ctx, _here, module, options), " needs an explicit "_view) + qKW_e44U("ref"_view)) + " or "_view) + qKW_e44U("val"_view)) + " for disambiguation:"_view) + "\n\n\t\t- Use "_view) + qKW_e44U("ref"_view)) + " if you want "_view) + str_wyx7(host_arg, true, _current_fn, ss, ctx, _here, module, options)) + " to reflect changes made to the aliased injected arg."_view) + "\n\n\t\t- Use "_view) + qKW_e44U("val"_view)) + " if you want "_view) + str_wyx7(host_arg, true, _current_fn, ss, ctx, _here, module, options)) + " to remain constant throughout "_view), str_FDl5(callee, false, ss, ctx, _here, module, options));
    }
    else
        BUG_gDsn("Unknown reason."_view, ss, ctx, _here, module, options, _helpers);

}

static void validate_gDsn(const int i1, SolvedNode_efhg& callsite, fu::view<Argument_bbKc> host_args, fu::view<Lifetime_llCF> bck_unwound, const int arg_first, const int arg_last, const int i0, const Argument_bbKc& host_arg0, const SolvedNode_efhg& arg0, const Lifetime_llCF& shallow0, const Lifetime_llCF& unwound0, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const Argument_bbKc& host_arg1 = host_args[i1];
    if (!(has_ZwXY(host_arg0.may_invalidate, i1) && has_ZwXY(host_arg1.may_invalidate, i0)))
    {
        const SolvedNode_efhg* __partcopy_ref;
        SolvedNode_efhg arg1 = (__partcopy_ref = &(args_iUdw(callsite)[i1]), SolvedNode_efhg { (*__partcopy_ref).kind, {/*unused non-zst*/}, {/*unused non-zst*/}, {/*unused non-zst*/}, {/*unused non-zst*/}, fu::vec<SolvedNode_efhg>((*__partcopy_ref).items), {/*unused non-zst*/}, Type_OiTm((*__partcopy_ref).type), Target_VZrr((*__partcopy_ref).target) });
        const Lifetime_llCF& shallow1 = arg1.type.lifetime;
        if (pass == BorrowCheckPass_i0wt_BCK_aar)
        {
            if ((i0 >= arg_first) && (i0 <= arg_last) && (i1 >= arg_first) && (i1 <= arg_last))
            {
                Lifetime_each_9fTM(shallow0, i1, host_arg1, arg1, shallow1, i0, host_arg0, arg0, pass, _current_fn, ss, ctx, _here, module, options, _helpers);
            };
        }
        else
        {
            const Lifetime_llCF& unwound1 = bck_unwound[i1];
            const ValueType_JtNg* type;
            const ValueType_JtNg* type_1;
            const ValueType_JtNg* type_2;
            const ValueType_JtNg* type_3;
            if (((type = &(host_arg0.type.vtype), ((*type).quals & q_USAGE)) == (type_1 = &(arg0.type.vtype), ((*type_1).quals & q_USAGE))) && ((type_2 = &(host_arg1.type.vtype), ((*type_2).quals & q_USAGE)) == (type_3 = &(arg1.type.vtype), ((*type_3).quals & q_USAGE))))
            {
                const ValueType_JtNg* type_4;
                const ValueType_JtNg* type_5;
                if (!(!Lifetime_hasInter_bsLK(unwound0, unwound1, RWQuals_ELUY { (type_4 = &(host_arg0.type.vtype), ((*type_4).quals & q_USAGE)), host_arg0.written_to }, RWQuals_ELUY { (type_5 = &(host_arg1.type.vtype), ((*type_5).quals & q_USAGE)), host_arg1.written_to }, ctx, _here)))
                {
                    if (has_ZwXY(host_arg0.may_alias, i1) && has_ZwXY(host_arg1.may_alias, i0))
                    {
                        if ((has_ZwXY(host_arg0.may_invalidate, i1) || (softRiskSafe_gDsn(arg1, ss, ctx, _here, module) && !isInvalidatedBy_gDsn(shallow1, shallow0, _current_fn, ctx, _here))) && (has_ZwXY(host_arg1.may_invalidate, i0) || (softRiskSafe_gDsn(arg0, ss, ctx, _here, module) && !isInvalidatedBy_gDsn(shallow0, shallow1, _current_fn, ctx, _here))))
                        {

                            {
                                const SolverNotes_LSla note = SolverNotes_LSla_N_AARSoftRisk;
                                if (note & options.break_notes)
                                {
                                    fu::view<char> reason = fu::view<char>{};
                                    fail_gDsn((("`break_notes`: Unwanted event: "_view + qBAD_e44U(str_kJvr(note))) + (reason ? ("\n\t\t"_view + reason) : fu::str("."_fu))), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                                }
                                else
                                    ss._notes |= note;

                            };
                            return;
                        };
                    };
                    ArgRationale_mffC noTempCopy0 {};
                    ArgRationale_mffC noTempCopy1 {};
                    if ((noTempCopy0 = RESOLVE_byTempCopy_gDsn(callsite, i0, x7E_rA00("bck:vi "_view, fu::i64dec(i1)), requireVal_gDsn(host_arg1, arg1, ss, ctx, _here, module), pass, _current_fn, ss, ctx, _here, module, options, _helpers)) && (noTempCopy1 = RESOLVE_byTempCopy_gDsn(callsite, i1, x7E_rA00("bck:vi "_view, fu::i64dec(i0)), requireVal_gDsn(host_arg0, arg0, ss, ctx, _here, module), pass, _current_fn, ss, ctx, _here, module, options, _helpers)))
                    {
                        fu::str err = ("At call to "_view + str_FDl5(target_FDl5(callsite), false, ss, ctx, _here, module, options));
                        err += (((host_args.size() == 2) && (GET_gDsn(target_FDl5(callsite), ss, ctx, _here, module).flags & Flags_Lzg8_F_OPERATOR)) ? fu::str(str_oI6kwP1Lao1) : (x7E_rA00((x7E_rA00((x7E_rA00((x7E_rA00(", arguments:\n\n\t    "_view, fu::i64dec((i0 + 1))) + ":\t"_view), str_wyx7(host_arg0, false, _current_fn, ss, ctx, _here, module, options)) + " and\n\t    "_view), fu::i64dec((i1 + 1))) + ":\t"_view), str_wyx7(host_arg1, false, _current_fn, ss, ctx, _here, module, options)) + "\n\n\t    both alias:\n"_view));
                        each_709H(Lifetime_interLocids_7Yz9(unwound0, unwound1, ctx, _here), err, _current_fn, ss, ctx, _here, module, options);
                        fu::str noTempCopy0_1 = ArgRationale_explain_gDsn(noTempCopy0, target_FDl5(callsite), arg0, host_arg0, _current_fn, ss, ctx, _here, module, options, _helpers);
                        fu::str noTempCopy1_1 = ArgRationale_explain_gDsn(noTempCopy1, target_FDl5(callsite), arg1, host_arg1, _current_fn, ss, ctx, _here, module, options, _helpers);
                        err += "\n\tCannot resolve aliasing by a temporary copy:"_view;
                        err += ("\n\n\t    "_view + noTempCopy0_1);
                        if (noTempCopy0_1 != noTempCopy1_1)
                            err += ("\n\n\t    "_view + noTempCopy1_1);

                        _here = args_iUdw(callsite)[i0].token;
                        cannotFailAfterBCK_gDsn(err, pass, ss, ctx, _here, module, options, _helpers);
                    };
                };
            }
            else
                BUG_gDsn("host_arg/arg.usage mismatch"_view, ss, ctx, _here, module, options, _helpers);

        };
    };
}

                                #ifndef DEF_visit_WP8l6IIetG6
                                #define DEF_visit_WP8l6IIetG6
inline static void visit_WP8l(const Lifetime_llCF& lifetime, Lifetime_llCF& result, const bool maybeOutOfOrder, const Lifetime_llCF& all_written, const CurrentFn_QbLp& _current_fn, const Context_noPA& ctx, const TokenIdx_5581& _here)
{
    const fu::str& chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const int offset0 = offset;

        { {
            const unsigned r = parse7bit_7Yz9(chars, offset);
            for (; ; )
            {
                bool isLastPath = false;
                bool isFirstSubRegion = true;
                for (; ; )
                {
                    const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                    isLastPath = !(raw_flatCount & 1u);
                    if (isLastSubRegion)
                        break;
                    else
                        isFirstSubRegion = false;

                };
                if (isLastPath)
                    break;

            };

            {
                unsigned v;
                const int invalidatee = ((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))));
                const Lifetime_llCF& parents = iF_4knF(flow_wyx7(_current_fn).rg_parents, invalidatee, _current_fn);
                if (Lifetime_hasInter_cxIR(parents, all_written, ctx, _here))
                    goto BL_3;

            };
            continue;
          } BL_3:;
        };
        if (maybeOutOfOrder)
        {
            result = Lifetime_union_7Yz9(result, Lifetime_llCF { fu::str(fu::get_range(chars, offset0, offset)) }, false, ctx, _here);
        }
        else
            result.uni0n += fu::get_view(chars, offset0, offset);

    };
}
                                #endif

                                #ifndef DEF_Lifetime_process_yd6hyRasLei
                                #define DEF_Lifetime_process_yd6hyRasLei
inline Lifetime_llCF Lifetime_process_yd6h(const Lifetime_llCF& lifetime, const Lifetime_llCF& all_written, const CurrentFn_QbLp& _current_fn, const Context_noPA& ctx, const TokenIdx_5581& _here)
{
    /*MOV*/ Lifetime_llCF result {};
    const bool maybeOutOfOrder = false;
    visit_WP8l(lifetime, result, maybeOutOfOrder, all_written, _current_fn, ctx, _here);
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF___f2qHrpETuM1
                                #define DEF___f2qHrpETuM1
inline static int _f2qH(const Postdom_Vy5u& _)
{
    return _.write_loop_start;
}
                                #endif

                                #ifndef DEF___AFwnsiU8qn9
                                #define DEF___AFwnsiU8qn9
inline static fu::view<int> _AFwn(const int loop_id, fu::vec<int>& loop_ids)
{
    return (loop_ids += loop_id);
}
                                #endif

                                #ifndef DEF_eachLoopStart_75oVXngWv5d
                                #define DEF_eachLoopStart_75oVXngWv5d
inline static void eachLoopStart_75oV(int search, fu::vec<int>& loop_ids, const SolverState_aGlN& ss)
{
    for (int i = ss._helpers_data.size(); i-- > 0; )
    {
        const HelpersData_uG6I& h = ss._helpers_data[i];
        if (h.locals_start == search)
        {
            const int parent = _f2qH(h.postdom);
            _AFwn(search, loop_ids);
            search = parent;
        };
    };
}
                                #endif

                                #ifndef DEF___JnBWDQw7Ugg
                                #define DEF___JnBWDQw7Ugg
inline static int _JnBW(const Postdom_Vy5u& _)
{
    return _.read_loop_start;
}
                                #endif

static bool checkReadLoopStart_gDsn(const int read_loop_start, fu::view<int> loop_ids, const SolverState_aGlN& ss)
{

    {
        int search = read_loop_start;
        for (int i = ss._helpers_data.size(); i-- > 0; )
        {
            const HelpersData_uG6I& h = ss._helpers_data[i];
            if (h.locals_start == search)
            {
                const int parent = _JnBW(h.postdom);

                {
                    const int loop_id = search;
                    if (has_b66p(loop_ids, loop_id))
                        return true;

                };
                search = parent;
            };
        };
    };
    return false;
}

                                #ifndef DEF___5YdQripMCwl
                                #define DEF___5YdQripMCwl
inline static bool _5YdQ(const SolvedNode_efhg& node, const int read, fu::view<int> loop_ids, const SolverState_aGlN& ss)
{
    const Target_VZrr* t;
    unsigned v;
    if ((node.kind == Kind_Idfg_call) && isLocal_gDsn(node.target) && ((t = &(node.target), v = unsigned(((*t)._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))) == read))
        return checkReadLoopStart_gDsn(node._loop_start, loop_ids, ss);
    else
        return false;

}
                                #endif

                                #ifndef DEF_SLOW_find_2UlY2j3Q3sg
                                #define DEF_SLOW_find_2UlY2j3Q3sg
inline static SolvedNode_efhg SLOW_find_2UlY(const int read, fu::view<int> loop_ids, const SolvedNode_efhg& root, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{

    {
        const SolvedNode_efhg& node = root;
        fu::vec<SolvedNode_efhg> stack = fu::vec<SolvedNode_efhg> {{ SolvedNode_efhg(node) }};
        while (stack)
        {
            SolvedNode_efhg node_1 = TODO_FIX_pop_f7Nv(stack);
            const SolvedNode_efhg& node_2 = ((node_1.kind == Kind_Idfg_letdef) ? GET_gDsn(node_1.target, ss, ctx, _here, module).solved : node_1);
            const SolvedNode_efhg& node_3 = ((node_2.kind == Kind_Idfg___preceding_ref_arg) ? _current_fn.events.preceding_ref_args[node_2.helpers.index].arg : node_2);
            if (_5YdQ(node_3, read, loop_ids, ss))
                return SolvedNode_efhg(node_3);
            else
                for (int i = node_3.items.size(); i-- > 0; )
                    stack += SolvedNode_efhg(node_3.items[i]);
;
        };
    };
    return SolvedNode_efhg{};
}
                                #endif

static SolvedNode_efhg SLOW_findByReadID_gDsn(const int read, const int write_loop_start, const SolvedNode_efhg& root, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    fu::vec<int> loop_ids {};
    eachLoopStart_75oV(write_loop_start, loop_ids, ss);
    SolvedNode_efhg _0 {};
    return (_0 = SLOW_find_2UlY(read, loop_ids, root, _current_fn, ss, ctx, _here, module)) ? static_cast<SolvedNode_efhg&&>(_0) : BUG_gDsn((x7E_rA00((x7E_rA00("Cannot find read("_view, str_FDl5(nested_FDl5(read, ss, ctx, _here), false, ss, ctx, _here, module, options)) + ") in loop("_view), fu::i64dec(write_loop_start)) + ")."_view), ss, ctx, _here, module, options, _helpers);
}

static fu::str qSTACK_rwevent_gDsn(const SolvedNode_efhg& callsite, const int write, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    fu::view<SolvedNode_efhg> args = callsite.items;
    fu::view<Argument_bbKc> host_args = ((callsite.kind == Kind_Idfg_call) ? EXT_gDsn(callsite.target, ss, ctx, module).args : fu::view<Argument_bbKc>{});
    if (args.size() == host_args.size())
    {
        for (int i = 0; i < host_args.size(); i++)
        {
            const Argument_bbKc& host_arg = host_args[i];
            if (!(!host_arg.written_to))
            {
                const SolvedNode_efhg& arg = args[i];
                if (!(!Lifetime_has_7Yz9(arg.type.lifetime, write)))
                {
                    return qSTACK_arg_gDsn(callsite.target, i, fu::view<Target_VZrr>{}, ArgQuery_O2xW{}, _current_fn, ss, ctx, _here, module, options, _helpers);
                };
            };
        };
    };
    return fu::str{};
}

                                #ifndef DEF___wIdpjgw7sri
                                #define DEF___wIdpjgw7sri
inline static void _wIdp(const int read, const int write, const SolvedNode_efhg& callOrPragma, const int loop_start, const SolvedNode_efhg& root, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (read)
    {
        if (read < loop_start)
        {
            if (has_gDsn(events_iUdw(_current_fn).used_in_a_loop, read, _current_fn))
            {
                if (pass == BorrowCheckPass_i0wt_BCK_aar)
                    RESOLVE_byAAR_gDsn(read, write, true, pass, _current_fn, ss, ctx, _here, module, options, _helpers);
                else
                {
                    if (!(RESOLVE_byMutvar_FDl5(read, pass, _current_fn, ss, ctx, _here, module, options, _helpers)))
                    {
                        fu::str _0 {};
                        fu::str _1 {};
                        (_1 = (_0 = (((x7E_rA00(((x7E_rA00("Write to "_view, str_FDl5(nested_FDl5(write, ss, ctx, _here), false, ss, ctx, _here, module, options)) + ((callOrPragma.kind == Kind_Idfg_call) ? x7E_rA00(" at call to "_view, str_FDl5(callOrPragma.target, false, ss, ctx, _here, module, options)) : fu::str{})) + " invalidates the use of "_view), str_FDl5(nested_FDl5(read, ss, ctx, _here), false, ss, ctx, _here, module, options)) + " at "_view) + addr_and_snippet_gDsn(SLOW_findByReadID_gDsn(read, loop_start, root, _current_fn, ss, ctx, _here, module, options, _helpers).token, CodeFmt_snPx{}, fu::view<char>{}, ctx, module)) + "\n\t... on next loop iteration.\n\n\tWritten"_view), (static_cast<fu::str&&>(_0) + qSTACK_rwevent_gDsn(callOrPragma, write, _current_fn, ss, ctx, _here, module, options, _helpers))), cannotFailAfterBCK_gDsn(static_cast<fu::str&&>(_1), pass, ss, ctx, _here, module, options, _helpers));
                    };
                };
            };
        };
    }
    else
        BUG_gDsn("bck_trackWrites: invalidates contains non-locals."_view, ss, ctx, _here, module, options, _helpers);

}
                                #endif

                                #ifndef DEF_Lifetime_each_dVOPFZ7dWl9
                                #define DEF_Lifetime_each_dVOPFZ7dWl9
inline void Lifetime_each_dVOP(const Lifetime_llCF& lifetime, const int write, const SolvedNode_efhg& callOrPragma, const int loop_start, const SolvedNode_efhg& root, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit_7Yz9(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        unsigned v;
        _wIdp(((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))))), write, callOrPragma, loop_start, root, pass, _current_fn, ss, ctx, _here, module, options, _helpers);
    };
}
                                #endif

static WriteID_LxbZ WriteID_gDsn(const int locid, const TokenIdx_5581& token, const BorrowCheckPass_i0wt pass)
{
    return WriteID_LxbZ { (((unsigned(locid) << 1u) ^ ((locid < 0) ? 0xffffffffu : 0x0u)) | ((pass == BorrowCheckPass_i0wt_BCK_bck) ? tokenHash_gDsn(token) : 0u)) };
}

                                #ifndef DEF_steal_slbS3chojD6
                                #define DEF_steal_slbS3chojD6
inline PrecedingRefArg_Bnyy steal_slbS(PrecedingRefArg_Bnyy& v)
{
    /*MOV*/ PrecedingRefArg_Bnyy ret {};
    std::swap(v, ret);
    return /*NRVO*/ ret;
}
                                #endif

                                #ifndef DEF___9e6JlDezIha
                                #define DEF___9e6JlDezIha
inline static void _9e6J(const int read, const int write, const bool trySoft, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (read && (read != write))
        RESOLVE_byAAR_gDsn(read, write, trySoft, pass, _current_fn, ss, ctx, _here, module, options, _helpers);

}
                                #endif

                                #ifndef DEF_each_2t9vYhizf0j
                                #define DEF_each_2t9vYhizf0j
inline void each_2t9v(fu::view<int> a, const int write, const bool trySoft, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    for (int i = 0; i < a.size(); i++)
        _9e6J(a[i], write, trySoft, pass, _current_fn, ss, ctx, _here, module, options, _helpers);

}
                                #endif

static bool RESOLVE_byAAR_FDl5(const int write, fu::view<int> reads, const bool trySoft, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    each_2t9v(reads, write, trySoft, pass, _current_fn, ss, ctx, _here, module, options, _helpers);
    return true;
}

                                #ifndef DEF_ensure_6R8XzLviXUc
                                #define DEF_ensure_6R8XzLviXUc
inline Set_LKfa& ensure_6R8X(fu::vec_range_mut<Set_LKfa> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

                                #ifndef DEF_ensure_M0haIw9fwr6
                                #define DEF_ensure_M0haIw9fwr6
inline static Set_LKfa& ensure_M0ha(LocidMap_m07i& map, const int locid, const CurrentFn_QbLp& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    return ensure_6R8X(map._values, (args_neg + locid));
}
                                #endif

                                #ifndef DEF_x3Cx3E_0ZGFTu3GUai
                                #define DEF_x3Cx3E_0ZGFTu3GUai
inline int x3Cx3E_0ZGF(const WriteID_LxbZ& a, const WriteID_LxbZ& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_Rgh3(a._locid_and_hash, b._locid_and_hash)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_add_hx7j5RkuCi6
                                #define DEF_add_hx7j5RkuCi6
inline bool add_hx7j(Set_LKfa& _, const WriteID_LxbZ& key)
{
    fu::view<WriteID_LxbZ> keys_asc = _.keys_asc;
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_0ZGF(keys_asc[i], key);
        if (cmp == 0)
            return false;
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    const int i = lo;
    _.keys_asc.insert(i, WriteID_LxbZ(key));
    return true;
}
                                #endif

                                #ifndef DEF___CTY693vVSn9
                                #define DEF___CTY693vVSn9
inline static void _CTY6(const int invalidatee, const int write, const WriteID_LxbZ& writeID, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    Set_LKfa& set = ensure_M0ha(events_gDsn(_current_fn).snap.invalidated_by, invalidatee, _current_fn);
    unsigned v;
    if (pass == BorrowCheckPass_i0wt_BCK_bck)
    {
        fu::vec<WriteID_LxbZ>& a = set.keys_asc;
        if (!(a))
        {
            a = fu::vec<WriteID_LxbZ> {{ WriteID_LxbZ(writeID) }};
        };
    }
    else if ((v = writeID._locid_and_hash, int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))) == write)
        add_hx7j(set, writeID);
    else
        BUG_gDsn("AAR: writeID._locid != write locid, set::add wont be able to dedupe"_view, ss, ctx, _here, module, options, _helpers);

}
                                #endif

                                #ifndef DEF_Lifetime_each_pG9R9BFRoZa
                                #define DEF_Lifetime_each_pG9R9BFRoZa
inline void Lifetime_each_pG9R(const Lifetime_llCF& lifetime, const int write, const WriteID_LxbZ& writeID, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit_7Yz9(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        unsigned v;
        _CTY6(((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))))), write, writeID, pass, _current_fn, ss, ctx, _here, module, options, _helpers);
    };
}
                                #endif

                                #ifndef DEF___HQuitXKb17k
                                #define DEF___HQuitXKb17k
inline static void _HQui(const int write, const Lifetime_llCF& write_region, fu::view<char> write_paths, const SolvedNode_efhg& callOrPragma, const int loop_start, const bool OPTI_isLoop, const bool OPTI_hasPRA, const SolvedNode_efhg& root, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (!(!write))
    {
        /*MOV*/ Lifetime_llCF all_written = write_region;
        Lifetime_add_7Yz9(all_written, Lifetime_op_join_7Yz9(iF_4knF(flow_wyx7(_current_fn).rg_parents, write, _current_fn), write_paths, ctx, _here), false, ctx, _here);
        const Lifetime_llCF& invalidates = iF_4knF(flow_wyx7(_current_fn).rg_invalidates, write, _current_fn);
        if (Lifetime_has_7Yz9(invalidates, write))
            BUG_gDsn(x7E_rA00("flow.invalidates[write].has(write): "_view, str_FDl5(nested_FDl5(write, ss, ctx, _here), false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);
        else
        {
            Lifetime_llCF invalidates_1 = Lifetime_process_yd6h(invalidates, all_written, _current_fn, ctx, _here);
            if (OPTI_isLoop)
            {
                Lifetime_each_dVOP(invalidates_1, write, callOrPragma, loop_start, root, pass, _current_fn, ss, ctx, _here, module, options, _helpers);
            };
            const WriteID_LxbZ writeID = WriteID_gDsn(write, callOrPragma.token, pass);
            if (OPTI_hasPRA)
            {
                Lifetime_llCF all_written_and_invalidated = static_cast<Lifetime_llCF&&>(all_written);
                Lifetime_add_7Yz9(all_written_and_invalidated, invalidates_1, true, ctx, _here);
                int w = -1;
                for (int i = 0; i < _current_fn.events.preceding_ref_args.size(); i++)
                {
                    PrecedingRefArg_Bnyy pra = steal_slbS(_current_fn.events.preceding_ref_args.mutref(i));
                    fu_DEFER(std::swap(_current_fn.events.preceding_ref_args.mutref(i), pra));
                    if (pra.w < 0)
                    {
                        if (!((w >= 0)))
                            BUG_gDsn("preceding_ref_args: No leading .w position."_view, ss, ctx, _here, module, options, _helpers);

                    }
                    else
                        w = pra.w;

                    const int r = pra.r;
                    const Lifetime_llCF& bound = pra.arg.type.lifetime;
                    fu::vec<int> inter = Lifetime_interLocids_7Yz9(bound, all_written_and_invalidated, ctx, _here);
                    if (!(!inter))
                    {
                        if (((pass == BorrowCheckPass_i0wt_BCK_aar) ? !RESOLVE_byAAR_FDl5(write, inter, softRiskSafe_gDsn(pra.arg, ss, ctx, _here, module), pass, _current_fn, ss, ctx, _here, module, options, _helpers) : !!RESOLVE_byTempCopy_FDl5(pra.arg, pra.target, r, x7E_rA00("bck:pra "_view, fu::i64dec(write)), ArgRationale_mffC{}, pass, _current_fn, ss, ctx, _here, module, options, _helpers)))
                        {
                            _here = pra.callsite_token;
                            fu::str _0 {};
                            fu::str _1 {};
                            (_1 = (_0 = (x7E_rA00((x7E_rA00((x7E_rA00((((x7E_rA00((x7E_rA00((x7E_rA00("At call to "_view, str_FDl5(pra.target, false, ss, ctx, _here, module, options)) + ", binding for "_view), str_wyx7(EXT_gDsn(pra.target, ss, ctx, module).args[r], false, _current_fn, ss, ctx, _here, module, options)) + " (arg #"_view), fu::i64dec(r)) + ") at "_view) + addr_and_snippet_gDsn(pra.arg.token, CodeFmt_snPx{}, fu::view<char>{}, ctx, module)) + "\n\t... invalidated by subsequent write to "_view), str_FDl5(nested_FDl5(write, ss, ctx, _here), false, ss, ctx, _here, module, options)) + " upon evaluation of "_view), str_wyx7(EXT_gDsn(pra.target, ss, ctx, module).args[w], false, _current_fn, ss, ctx, _here, module, options)) + " (arg #"_view), fu::i64dec(w)) + ") at "_view), (static_cast<fu::str&&>(_0) + RWEvent_stack_gDsn(writeID, root, _current_fn, ss, ctx, _here, module, options, _helpers))), cannotFailAfterBCK_gDsn(static_cast<fu::str&&>(_1), pass, ss, ctx, _here, module, options, _helpers));
                        };
                    };
                };
            };
            Lifetime_each_pG9R(invalidates_1, write, writeID, pass, _current_fn, ss, ctx, _here, module, options, _helpers);
        };
    };
}
                                #endif

                                #ifndef DEF_Lifetime_each_o22Wlrl1zR6
                                #define DEF_Lifetime_each_o22Wlrl1zR6
inline void Lifetime_each_o22W(const Lifetime_llCF& lifetime, const SolvedNode_efhg& callOrPragma, const int loop_start, const bool OPTI_isLoop, const bool OPTI_hasPRA, const SolvedNode_efhg& root, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const fu::str& chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const int offset0 = offset;
        const unsigned r = parse7bit_7Yz9(chars, offset);
        int offset0_1;
        int BL_3_v;
        const int sr = (__extension__ (
        {
            offset0_1 = (offset + 0);
            for (; ; )
            {
                bool isLastPath = false;
                bool isFirstSubRegion = true;
                for (; ; )
                {
                    const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                    isLastPath = !(raw_flatCount & 1u);
                    if (isLastSubRegion)
                        break;
                    else
                        isFirstSubRegion = false;

                };
                if (isLastPath)
                    break;

            };
            BL_3_v = (offset0_1);
            (void)0;
        }), BL_3_v);
        unsigned v;
        _HQui(((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))))), Lifetime_llCF { fu::str(fu::get_range(chars, offset0, offset)) }, fu::get_view(chars, sr, offset), callOrPragma, loop_start, OPTI_isLoop, OPTI_hasPRA, root, pass, _current_fn, ss, ctx, _here, module, options, _helpers);
    };
}
                                #endif

static void bck_trackWrites_gDsn(const SolvedNode_efhg& callOrPragma, const Lifetime_llCF& lifetime, const SolvedNode_efhg& root, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const int loop_start = (callOrPragma._loop_start ? callOrPragma._loop_start : BUG_gDsn("bck_trackWrites: _loop_start not set on callsite."_view, ss, ctx, _here, module, options, _helpers));
    const bool OPTI_isLoop = ((loop_start != NO_LOOP) ? !!events_iUdw(_current_fn).used_in_a_loop : false);
    const bool OPTI_hasPRA = !!events_iUdw(_current_fn).preceding_ref_args;
    Lifetime_each_o22W(lifetime, callOrPragma, loop_start, OPTI_isLoop, OPTI_hasPRA, root, pass, _current_fn, ss, ctx, _here, module, options, _helpers);
}

static void bck_call_gDsn(SolvedNode_efhg& callsite, const SolvedNode_efhg& root, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (!args_iUdw(callsite))
    {
        if (GET_gDsn(target_FDl5(callsite), ss, ctx, _here, module).kind == Kind_Idfg_var)
            bck_trackRead_gDsn(callsite, root, pass, _current_fn, ss, ctx, _here, module, options, _helpers);

    }
    else
    {
        const bool RTL = isRTL_xQNS(GET_gDsn(target_FDl5(callsite), ss, ctx, _here, module));
        fu::vec<Argument_bbKc> host_args = fu::vec<Argument_bbKc>(EXT_gDsn(target_FDl5(callsite), ss, ctx, module).args);
        Lifetime_llCF bck_writes {};
        int num_ref_args {};

        {
            const int pra_len0 = _current_fn.events.preceding_ref_args.size();
            int pra_first = -1;
            argsForward_VvPa(RTL, host_args, 0, callsite, bck_writes, num_ref_args, pra_first, root, pass, _current_fn, ss, ctx, _here, module, options, _helpers);
            for (int i = 0; i < args_iUdw(callsite).size(); i++)
            {
                SolvedNode_efhg& arg = args_FDl5(callsite).mutref(i);
                if (arg.kind == Kind_Idfg___preceding_ref_arg)
                {
                    PrecedingRefArg_Bnyy& pra = _current_fn.events.preceding_ref_args.mutref(arg.helpers.index);
                    if ((pra.target == target_FDl5(callsite)) && (pra.r == i))
                        std::swap(arg, pra.arg);
                    else
                        BUG_gDsn("preceding_ref_args got messed up"_view, ss, ctx, _here, module, options, _helpers);

                };
            };
            _current_fn.events.preceding_ref_args.shrink(pra_len0);
        };
        if (!(!bck_writes))
        {
            if (num_ref_args > 1)
            {
                int mutref_first = -1;
                int mutref_last = -1;
                int ref_first = -1;
                int ref_last = -1;
                fu::vec<Lifetime_llCF> bck_unwound {};
                bck_unwound.resize(args_iUdw(callsite).size());
                int arg_first = -1;
                int arg_last = -1;
                for (int i0 = 0; i0 < args_iUdw(callsite).size(); i0++)
                {
                    const Argument_bbKc& host_arg0 = host_args[i0];
                    const Type_OiTm& expect = host_arg0.type;
                    if (!(!is_ref_9CJm(expect)))
                    {
                        const SolvedNode_efhg* __partcopy_ref;
                        SolvedNode_efhg arg0 = (__partcopy_ref = &(args_iUdw(callsite)[i0]), SolvedNode_efhg { (*__partcopy_ref).kind, {/*unused non-zst*/}, {/*unused non-zst*/}, {/*unused non-zst*/}, {/*unused non-zst*/}, fu::vec<SolvedNode_efhg>((*__partcopy_ref).items), {/*unused non-zst*/}, Type_OiTm((*__partcopy_ref).type), Target_VZrr((*__partcopy_ref).target) });
                        const Lifetime_llCF& shallow0 = arg0.type.lifetime;
                        const Lifetime_llCF& unwound0 = (bck_unwound.mutref(i0) = Lifetime_unwind_gDsn(shallow0, true, ss, ctx, _here, module, options, _helpers));
                        Lifetime_each_JmyG(unwound0, arg_first, arg_last, i0);
                        if ((ref_first >= 0))
                        {
                            if (is_mutref_9CJm(expect, ctx, _here))
                            {
                                for (int i = ref_first; (i <= ref_last); i++)
                                {
                                    if (is_ref_9CJm(host_args[i].type))
                                        validate_gDsn(i, callsite, host_args, bck_unwound, arg_first, arg_last, i0, host_arg0, arg0, shallow0, unwound0, pass, _current_fn, ss, ctx, _here, module, options, _helpers);

                                };
                            }
                            else if ((mutref_first >= 0))
                            {
                                for (int i = mutref_first; (i <= mutref_last); i++)
                                {
                                    if (is_mutref_9CJm(host_args[i].type, ctx, _here))
                                        validate_gDsn(i, callsite, host_args, bck_unwound, arg_first, arg_last, i0, host_arg0, arg0, shallow0, unwound0, pass, _current_fn, ss, ctx, _here, module, options, _helpers);

                                };
                            };
                        };

                        {
                            if (ref_first < 0)
                                ref_first = i0;

                            ref_last = i0;
                        };
                        if (is_mutref_9CJm(expect, ctx, _here))
                        {
                            if (mutref_first < 0)
                                mutref_first = i0;

                            mutref_last = i0;
                        };
                    };
                };
            };
            _here = callsite.token;
            bck_trackWrites_gDsn(callsite, bck_writes, root, pass, _current_fn, ss, ctx, _here, module, options, _helpers);
        };
    };
}

static void bck_loop_gDsn(SolvedNode_efhg& node, const SolvedNode_efhg& root, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    /*MOV*/ LocidSet_iAWt used_in_a_loop0 = _current_fn.events.used_in_a_loop;
    clear_FDl5(_current_fn.events.used_in_a_loop, node._loop_start, _current_fn);
    fu::view_mut<SolvedNode_efhg> items = node.items;
    SolvedNode_efhg* _0;
    (_0 = &(items.mutref(0)), bck_node_gDsn(*_0, root, pass, _current_fn, ss, ctx, _here, module, options, _helpers));
    for (int i = 1; i < items.size(); i++)
    {
        SolvedNode_efhg* _1;
        (_1 = &(items.mutref(i)), bck_node_gDsn(*_1, root, pass, _current_fn, ss, ctx, _here, module, options, _helpers));
    };
    const Helpers_DyqV* h;
    int _2;
    const int read_loop_start = ((_2 = (h = &(node.helpers), ((((*h).index >= 0) && ((*h).index < ss._helpers_data.size())) ? ss._helpers_data[(*h).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).postdom.read_loop_start) ? _2 : BUG_gDsn("bck_loop: read_loop_start not set."_view, ss, ctx, _here, module, options, _helpers));
    clear_FDl5(_current_fn.events.used_in_a_loop, read_loop_start, _current_fn);
    LocidSet_iAWt& set = _current_fn.events.used_in_a_loop;
    add_Na55(set._bitset, static_cast<BitSet_mmp7&&>(used_in_a_loop0._bitset));
}

static bool willPassByValue_FDl5(const Overload_aO3i& o, const Context_noPA& ctx, const TokenIdx_5581& _here)
{
    if (acceptsTempCopies_FDl5(o, ctx, _here))
        return isPassByValue_hxWW(o.type.vtype);
    else
        return false;

}

                                #ifndef DEF___ZNsT0K5ihBj
                                #define DEF___ZNsT0K5ihBj
inline static void _ZNsT(const int locid, const bool isStatic, int& left, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (!(isStatic))
    {
        (!left ? left : BUG_gDsn("Lifetime_getRefLocid_unlessStatic: multiple locids in left_lt"_view, ss, ctx, _here, module, options, _helpers)) = (locid ? locid : BUG_gDsn("Lifetime_getRefLocid_unlessStatic: non-locid/non-static in left_lt"_view, ss, ctx, _here, module, options, _helpers));
    };
}
                                #endif

                                #ifndef DEF_Lifetime_each_NABWI3yhpi8
                                #define DEF_Lifetime_each_NABWI3yhpi8
inline void Lifetime_each_NABW(const Lifetime_llCF& lifetime, int& left, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit_7Yz9(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        unsigned v;
        _ZNsT(((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))))), ((r & 11u) == 1u), left, ss, ctx, _here, module, options, _helpers);
    };
}
                                #endif

static int Lifetime_getRefLocid_unlessStatic_gDsn(const Lifetime_llCF& lifetime, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    int left {};
    Lifetime_each_NABW(lifetime, left, ss, ctx, _here, module, options, _helpers);
    return left;
}

                                #ifndef DEF_visit_GdqtD00DVB8
                                #define DEF_visit_GdqtD00DVB8
inline static void visit_Gdqt(const Lifetime_llCF& lifetime, Lifetime_llCF& result, const bool maybeOutOfOrder, const Context_noPA& ctx, const TokenIdx_5581& _here)
{
    const fu::str& chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const int offset0 = offset;

        { {
            const unsigned r = parse7bit_7Yz9(chars, offset);
            for (; ; )
            {
                bool isLastPath = false;
                bool isFirstSubRegion = true;
                for (; ; )
                {
                    const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                    isLastPath = !(raw_flatCount & 1u);
                    if (isLastSubRegion)
                        break;
                    else
                        isFirstSubRegion = false;

                };
                if (isLastPath)
                    break;

            };

            {
                unsigned v;
                const int locid = ((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))));
                if (locid)
                    goto BL_3;

            };
            continue;
          } BL_3:;
        };
        if (maybeOutOfOrder)
        {
            result = Lifetime_union_7Yz9(result, Lifetime_llCF { fu::str(fu::get_range(chars, offset0, offset)) }, false, ctx, _here);
        }
        else
            result.uni0n += fu::get_view(chars, offset0, offset);

    };
}
                                #endif

                                #ifndef DEF_Lifetime_process_rb8qlCtWwOc
                                #define DEF_Lifetime_process_rb8qlCtWwOc
inline Lifetime_llCF Lifetime_process_rb8q(const Lifetime_llCF& lifetime, const Context_noPA& ctx, const TokenIdx_5581& _here)
{
    /*MOV*/ Lifetime_llCF result {};
    const bool maybeOutOfOrder = false;
    visit_Gdqt(lifetime, result, maybeOutOfOrder, ctx, _here);
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF_ensure_SVfBgrQBYy3
                                #define DEF_ensure_SVfBgrQBYy3
inline Set_qOJY& ensure_SVfB(fu::vec_range_mut<Set_qOJY> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

                                #ifndef DEF_ensure_Rpt9DTvKilg
                                #define DEF_ensure_Rpt9DTvKilg
inline static Set_qOJY& ensure_Rpt9(LocidMap_oyma& map, const int locid, const CurrentFn_QbLp& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    return ensure_SVfB(map._values, (args_neg + locid));
}
                                #endif

                                #ifndef DEF___SuL09clMhB3
                                #define DEF___SuL09clMhB3
inline static void _SuL0(const int right, fu::view<char> paths, const Type_OiTm& t_left, const int left, Lifetime_llCF& parents, Lifetime_llCF& siblings, CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (!(!right))
    {
        if (!right)
            BUG_gDsn("Reference_trackLocalRef: right has non-locals."_view, ss, ctx, _here, module, options, _helpers);
        else
        {
            const Type_OiTm& t_right = GET_gDsn(nested_FDl5(right, ss, ctx, _here), ss, ctx, _here, module).type;
            if (!(type_mayPointInto_gDsn(t_right.vtype, t_left.vtype, ss, ctx, _here, module)))
                BUG_gDsn(x7E_rA00((x7E_rA00("type_mayPointInto fails for "_view, str_FDl5(nested_FDl5(left, ss, ctx, _here), false, ss, ctx, _here, module, options)) + " := "_view), str_FDl5(nested_FDl5(right, ss, ctx, _here), false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

        };
        int _0;
        (_0 = left, add_q7Be(ensure_Rpt9(flow_gDsn(_current_fn).rg_children, right, _current_fn), _0));
        Lifetime_add_7Yz9(parents, Lifetime_op_join_7Yz9(iF_4knF(flow_wyx7(_current_fn).rg_parents, right, _current_fn), paths, ctx, _here), false, ctx, _here);
        Lifetime_add_7Yz9(siblings, iF_4knF(flow_wyx7(_current_fn).rg_invalidates, right, _current_fn), false, ctx, _here);
        if (has_gDsn(flow_wyx7(_current_fn).is_arg, right, _current_fn))
        {
            add_gDsn(flow_gDsn(_current_fn).is_arg, left, _current_fn);
            add_q7Be(ensure_Rpt9(flow_gDsn(_current_fn).arg_parents, left, _current_fn), right);
        };
    };
}
                                #endif

                                #ifndef DEF_Lifetime_each_21bvAm4aAOb
                                #define DEF_Lifetime_each_21bvAm4aAOb
inline void Lifetime_each_21bv(const Lifetime_llCF& lifetime, const Type_OiTm& t_left, const int left, Lifetime_llCF& parents, Lifetime_llCF& siblings, CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit_7Yz9(chars, offset);
        int offset0;
        int BL_3_v;
        const int sr = (__extension__ (
        {
            offset0 = (offset + 0);
            for (; ; )
            {
                bool isLastPath = false;
                bool isFirstSubRegion = true;
                for (; ; )
                {
                    const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                    isLastPath = !(raw_flatCount & 1u);
                    if (isLastSubRegion)
                        break;
                    else
                        isFirstSubRegion = false;

                };
                if (isLastPath)
                    break;

            };
            BL_3_v = (offset0);
            (void)0;
        }), BL_3_v);
        unsigned v;
        _SuL0(((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))))), fu::get_view(chars, sr, offset), t_left, left, parents, siblings, _current_fn, ss, ctx, _here, module, options, _helpers);
    };
}
                                #endif

                                #ifndef DEF_visit_UunUVuVZrha
                                #define DEF_visit_UunUVuVZrha
inline static void visit_UunU(const Lifetime_llCF& lifetime, Lifetime_llCF& result, const bool maybeOutOfOrder, const Type_OiTm& t_left, const unsigned left_ever_written, const Lifetime_llCF& parents, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    const fu::str& chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const int offset0 = offset;

        { {
            const unsigned r = parse7bit_7Yz9(chars, offset);
            for (; ; )
            {
                bool isLastPath = false;
                bool isFirstSubRegion = true;
                for (; ; )
                {
                    const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                    isLastPath = !(raw_flatCount & 1u);
                    if (isLastSubRegion)
                        break;
                    else
                        isFirstSubRegion = false;

                };
                if (isLastPath)
                    break;

            };

            {
                unsigned v;
                const int sibling = ((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))));
                const Type_OiTm& t_sibling = GET_gDsn(nested_FDl5(sibling, ss, ctx, _here), ss, ctx, _here, module).type;
                const unsigned sibling_written = iF_BZQz(_current_fn.postdom.snap.ever_written, sibling, _current_fn);
                const Lifetime_llCF& sibling_parents = iF_4knF(flow_wyx7(_current_fn).rg_parents, sibling, _current_fn);
                const ValueType_JtNg* type;
                const ValueType_JtNg* type_1;
                if (Lifetime_hasInter_bsLK(parents, sibling_parents, RWQuals_ELUY { (type = &(t_left.vtype), ((*type).quals & q_USAGE)), left_ever_written }, RWQuals_ELUY { (type_1 = &(t_sibling.vtype), ((*type_1).quals & q_USAGE)), sibling_written }, ctx, _here))
                    goto BL_3;

            };
            continue;
          } BL_3:;
        };
        if (maybeOutOfOrder)
        {
            result = Lifetime_union_7Yz9(result, Lifetime_llCF { fu::str(fu::get_range(chars, offset0, offset)) }, false, ctx, _here);
        }
        else
            result.uni0n += fu::get_view(chars, offset0, offset);

    };
}
                                #endif

                                #ifndef DEF_Lifetime_process_Xl3N585Qrcd
                                #define DEF_Lifetime_process_Xl3N585Qrcd
inline Lifetime_llCF Lifetime_process_Xl3N(const Lifetime_llCF& lifetime, const Type_OiTm& t_left, const unsigned left_ever_written, const Lifetime_llCF& parents, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    /*MOV*/ Lifetime_llCF result {};
    const bool maybeOutOfOrder = false;
    visit_UunU(lifetime, result, maybeOutOfOrder, t_left, left_ever_written, parents, _current_fn, ss, ctx, _here, module);
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF_ensure_Aa1PriV0gog
                                #define DEF_ensure_Aa1PriV0gog
inline Lifetime_llCF& ensure_Aa1P(fu::vec_range_mut<Lifetime_llCF> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

                                #ifndef DEF_ensure_8OzuEKG9NR4
                                #define DEF_ensure_8OzuEKG9NR4
inline static Lifetime_llCF& ensure_8Ozu(LocidMap_JYql& map, const int locid, const CurrentFn_QbLp& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    return ensure_Aa1P(map._values, (args_neg + locid));
}
                                #endif

                                #ifndef DEF___acsP8tgHZ2i
                                #define DEF___acsP8tgHZ2i
inline static void _acsP(const int sibling, const Type_OiTm& t_left, CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (!sibling)
        BUG_gDsn("Reference_trackLocalRef: siblings has non-locals."_view, ss, ctx, _here, module, options, _helpers);
    else
    {
        Lifetime_add_7Yz9(ensure_8Ozu(flow_gDsn(_current_fn).rg_invalidates, sibling, _current_fn), t_left.lifetime, false, ctx, _here);
    };
}
                                #endif

                                #ifndef DEF_Lifetime_each_dcKhOdRfWm3
                                #define DEF_Lifetime_each_dcKhOdRfWm3
inline void Lifetime_each_dcKh(const Lifetime_llCF& lifetime, const Type_OiTm& t_left, CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit_7Yz9(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        unsigned v;
        _acsP(((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))))), t_left, _current_fn, ss, ctx, _here, module, options, _helpers);
    };
}
                                #endif

                                #ifndef DEF___slGKDoBQqNh
                                #define DEF___slGKDoBQqNh
inline static void _slGK(const int parent, const Type_OiTm& t_left, CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (!parent)
        BUG_gDsn("Reference_trackLocalRef: parents has non-locals."_view, ss, ctx, _here, module, options, _helpers);
    else
    {
        Lifetime_add_7Yz9(ensure_8Ozu(flow_gDsn(_current_fn).rg_invalidates, parent, _current_fn), t_left.lifetime, false, ctx, _here);
    };
}
                                #endif

                                #ifndef DEF_Lifetime_each_zRJCytVraN1
                                #define DEF_Lifetime_each_zRJCytVraN1
inline void Lifetime_each_zRJC(const Lifetime_llCF& lifetime, const Type_OiTm& t_left, CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit_7Yz9(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        unsigned v;
        _slGK(((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))))), t_left, _current_fn, ss, ctx, _here, module, options, _helpers);
    };
}
                                #endif

static void Reference_trackLocalRef_gDsn(const Type_OiTm& t_left, const Lifetime_llCF& right, CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const int left = Lifetime_getRefLocid_unlessStatic_gDsn(t_left.lifetime, ss, ctx, _here, module, options, _helpers);
    if (!(!left))
    {
        const unsigned left_ever_written = iF_BZQz(_current_fn.postdom.snap.ever_written, left, _current_fn);
        Lifetime_llCF right_1 = Lifetime_process_rb8q(right, ctx, _here);
        Lifetime_llCF parents {};
        Lifetime_llCF siblings {};
        Lifetime_add_7Yz9(parents, right_1, false, ctx, _here);
        Lifetime_each_21bv(right_1, t_left, left, parents, siblings, _current_fn, ss, ctx, _here, module, options, _helpers);
        siblings = Lifetime_process_Xl3N(siblings, t_left, left_ever_written, parents, _current_fn, ss, ctx, _here, module);
        if (siblings)
        {
            if (Lifetime_has_7Yz9(siblings, left))
                BUG_gDsn("siblings.has(left)"_view, ss, ctx, _here, module, options, _helpers);
            else
            {
                Lifetime_llCF* _0;
                (!*(_0 = &(ensure_8Ozu(flow_gDsn(_current_fn).rg_invalidates, left, _current_fn))) ? *_0 : BUG_gDsn("rg_invalidates already set"_view, ss, ctx, _here, module, options, _helpers)) = Lifetime_llCF(siblings);
                Lifetime_each_dcKh(siblings, t_left, _current_fn, ss, ctx, _here, module, options, _helpers);
            };
        };
        if (parents)
        {
            Lifetime_llCF* _1;
            (!*(_1 = &(ensure_8Ozu(flow_gDsn(_current_fn).rg_parents, left, _current_fn))) ? *_1 : BUG_gDsn("rg_parents already set"_view, ss, ctx, _here, module, options, _helpers)) = Lifetime_llCF(parents);
            Lifetime_each_zRJC(parents, t_left, _current_fn, ss, ctx, _here, module, options, _helpers);
        };
    };
}

static void bck_trackInit_gDsn(const Target_VZrr& target, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    unsigned v;
    const int index = (v = unsigned((target._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
    if (!(!index))
    {
        if (iF_ezs9(events_iUdw(_current_fn).snap.invalidated_by, index, _current_fn))
        {
            BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers);
        };
    };
}

static void bck_let_gDsn(SolvedNode_efhg& node, const SolvedNode_efhg& root, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    SolvedNode_efhg* _0;
    (_0 = &(node.items.mutref(LET_INIT)), bck_node_gDsn(*_0, root, pass, _current_fn, ss, ctx, _here, module, options, _helpers));
    if (is_ref_9CJm(node.type) && !willPassByValue_FDl5(GET_gDsn(node.target, ss, ctx, _here, module), ctx, _here))
    {
        const Target_VZrr* target;
        unsigned v;
        if ((target = &(node.target), ((v = unsigned(((*target)._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))) < 0)))
            BUG_gDsn("bck_let: Found an argument!"_view, ss, ctx, _here, module, options, _helpers);
        else
        {
            const SolvedNode_efhg& init = node.items[LET_INIT];
            if (is_ref_9CJm(init.type))
            {
                Reference_trackLocalRef_gDsn(GET_gDsn(node.target, ss, ctx, _here, module).type, init.type.lifetime, _current_fn, ss, ctx, _here, module, options, _helpers);
            }
            else
                BUG_gDsn("What!"_view, ss, ctx, _here, module, options, _helpers);

        };
    };
    bck_trackInit_gDsn(node.target, _current_fn, ss, ctx, _here, module, options, _helpers);
}

                                #ifndef DEF_Events_restore_wwYpuLRCH53
                                #define DEF_Events_restore_wwYpuLRCH53
inline static void Events_restore_wwYp(fu::vec_range_mut<Set_LKfa> dest, fu::view<Set_LKfa> src, const int write_loop_start)
{
    if (dest.size() > write_loop_start)
        dest.shrink(write_loop_start);

    if (src.size() > write_loop_start)
    {
        dest.grow(write_loop_start);
        dest += fu::get_view(src, write_loop_start);
    };
}
                                #endif

static void Events_restore_gDsn(Events_SbUb& events, const EventsSnap_elmt& restore, const int write_loop_start, const Context_noPA& ctx, const TokenIdx_5581& _here)
{
    if (!write_loop_start)
        BUG_u9Gb("Events_restore: no write_loop_start, cant decide which events need to survive"_view, ctx, _here);
    else if (write_loop_start == NO_LOOP)
        events.snap = restore;
    else
        Events_restore_wwYp(events.snap.invalidated_by._values, restore.invalidated_by._values, write_loop_start);

}

                                #ifndef DEF_add_MrF50mUeX01
                                #define DEF_add_MrF50mUeX01
inline void add_MrF5(fu::vec_range_mut<WriteID_LxbZ> a, fu::view<WriteID_LxbZ> b)
{
    int x = 0;
    int y = 0;
    while ((x < a.size()) && (y < b.size()))
    {
        const WriteID_LxbZ& X = a[x];
        const WriteID_LxbZ& Y = b[y];
        const int cmp = x3Cx3E_0ZGF(X, Y);
        if ((cmp >= 0))
        {
            if (cmp != 0)
            {
                a.insert(x, WriteID_LxbZ(Y));
                y++;
            }
            else
                y++;

        };
        x++;
    };
    if (y < b.size())
        a += fu::get_view(b, y);

}
                                #endif

                                #ifndef DEF_Events_merge_dJLpnQGeiz6
                                #define DEF_Events_merge_dJLpnQGeiz6
inline static void Events_merge_dJLp(fu::vec_range_mut<Set_LKfa> dest, fu::view<Set_LKfa> src)
{
    if (dest.size() < src.size())
        dest.grow(src.size());

    for (int i = 0; i < src.size(); i++)
    {
        const Set_LKfa& src_1 = src[i];
        if (src_1)
            add_MrF5(dest.mutref(i).keys_asc, src_1.keys_asc);

    };
}
                                #endif

static void Events_merge_gDsn(EventsSnap_elmt& events, const EventsSnap_elmt& snap)
{
    Events_merge_dJLp(events.invalidated_by._values, snap.invalidated_by._values);
}

static void bck_if_gDsn(SolvedNode_efhg& node, const SolvedNode_efhg& root, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    fu::view_mut<SolvedNode_efhg> items = node.items;
    SolvedNode_efhg& cond = items.mutref(0);
    bck_node_gDsn(cond, root, pass, _current_fn, ss, ctx, _here, module, options, _helpers);
    const StaticEval_IZio ae_cond = tryAbstractEvalAsBool_gDsn(cond, false, _current_fn, ss, ctx, _here, module, options, _helpers);
    if (ae_cond)
    {
        SolvedNode_efhg& cons = items.mutref(((ae_cond == StaticEval_IZio_SE_True) ? 1 : 2));
        bck_node_gDsn(cons, root, pass, _current_fn, ss, ctx, _here, module, options, _helpers);
        node = createBlock_FDl5(SolvedNode_efhg(items[0]), SolvedNode_efhg(cons), ss, ctx, _here, module);
    }
    else
    {
        EventsSnap_elmt e_Restore_AfterCond = _current_fn.events.snap;
        SolvedNode_efhg* _0;
        (_0 = &(items.mutref(1)), bck_node_gDsn(*_0, root, pass, _current_fn, ss, ctx, _here, module, options, _helpers));
        EventsSnap_elmt e_Merge_AfterCons = _current_fn.events.snap;
        Events_restore_gDsn(_current_fn.events, e_Restore_AfterCond, node._loop_start, ctx, _here);
        SolvedNode_efhg* _1;
        (_1 = &(items.mutref(2)), bck_node_gDsn(*_1, root, pass, _current_fn, ss, ctx, _here, module, options, _helpers));
        Events_merge_gDsn(_current_fn.events.snap, e_Merge_AfterCons);
    };
}

static void bck_and_or_gDsn(SolvedNode_efhg& node, const SolvedNode_efhg& root, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    fu::vec<SolvedNode_efhg>& items = node.items;
    for (int i = 0; i < items.size(); i++)
    {
        SolvedNode_efhg& expr = items.mutref(i);
        bck_node_gDsn(expr, root, pass, _current_fn, ss, ctx, _here, module, options, _helpers);
        const StaticEval_IZio ae_expr = tryAbstractEvalAsBool_gDsn(expr, (i == (items.size() - 1)), _current_fn, ss, ctx, _here, module, options, _helpers);
        if (ae_expr)
        {
            const bool isAnd = (node.kind == Kind_Idfg_and);
            if (isAnd == (ae_expr == StaticEval_IZio_SE_False))
            {
                items.shrink((i + 1));
                node.type.vtype.vfacts |= (isAnd ? VFacts_xhRf_AlwaysFalse : VFacts_xhRf_AlwaysTrue);
                break;
            }
            else if (i < (items.size() - 1))
            {
                /*MOV*/ SolvedNode_efhg cond = steal_bX67(expr);
                items.splice(i, 1);
                SolvedNode_efhg& cons = items.mutref(i--);
                cons = createBlock_FDl5(static_cast<SolvedNode_efhg&&>(cond), SolvedNode_efhg(cons), ss, ctx, _here, module);
            };
        };
    };
    if (node.items.size() < 2)
        node = only_S4ER(node.items);

}

static void bck_not_gDsn(SolvedNode_efhg& node, const SolvedNode_efhg& root, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    SolvedNode_efhg& expr = only_krrB(node.items);
    bck_node_gDsn(expr, root, pass, _current_fn, ss, ctx, _here, module, options, _helpers);
    const StaticEval_IZio ae_expr = tryAbstractEvalAsBool_gDsn(expr, false, _current_fn, ss, ctx, _here, module, options, _helpers);
    if (ae_expr)
        node.type.vtype.vfacts |= ((ae_expr == StaticEval_IZio_SE_True) ? VFacts_xhRf_AlwaysFalse : VFacts_xhRf_AlwaysTrue);

}

static void bck_block_gDsn(SolvedNode_efhg& node, const SolvedNode_efhg& root, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    fu::vec<int> defers {};
    const int TODO_FIX_nesteDefers0 = _current_fn.TODO_FIX_bckCantDealWithNestedDefers;
    fu::vec<SolvedNode_efhg>& items = node.items;
    for (int i = 0; i < items.size(); i++)
    {
        SolvedNode_efhg& stmt = items.mutref(i);
        if (stmt.kind == Kind_Idfg_defer)
        {
            const Helpers_DyqV* h;
            if (!defers && ((h = &(node.helpers), ((((*h).index >= 0) && ((*h).index < ss._helpers_data.size())) ? ss._helpers_data[(*h).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).target != _current_fn.out.target))
                _current_fn.TODO_FIX_bckCantDealWithNestedDefers++;

            defers += i;
            if (is_never_9CJm(stmt.type.vtype))
                BUG_gDsn("bck, block: defer.is_never"_view, ss, ctx, _here, module, options, _helpers);

        }
        else
        {
            bck_node_gDsn(stmt, root, pass, _current_fn, ss, ctx, _here, module, options, _helpers);
            if (is_never_9CJm(stmt.type.vtype))
            {
                items.shrink((i + 1));
                const Helpers_DyqV* h;
                if (!HelpersMask_w1sv(((h = &(node.helpers), ((((*h).index >= 0) && ((*h).index < ss._helpers_data.size())) ? ss._helpers_data[(*h).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).mask & HelpersMask_w1sv_HM_LabelUsed)))
                    node.type = t_never;

                break;
            };
        };
    };
    const Helpers_DyqV* h;
    Events_merge_gDsn(_current_fn.events.snap, (h = &(node.helpers), ((((*h).index >= 0) && ((*h).index < ss._helpers_data.size())) ? ss._helpers_data[(*h).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).postevt);
    for (int i_1 = defers.size(); i_1-- > 0; )
    {
        SolvedNode_efhg* _0;
        (_0 = &(only_krrB(node.items.mutref(defers[i_1]).items)), bck_node_gDsn(*_0, root, pass, _current_fn, ss, ctx, _here, module, options, _helpers));
    };
    _current_fn.TODO_FIX_bckCantDealWithNestedDefers = TODO_FIX_nesteDefers0;
}

static void bck_node_gDsn(SolvedNode_efhg& node, const SolvedNode_efhg& root, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const Kind_Idfg k = node.kind;
    if (k == Kind_Idfg_call)
        bck_call_gDsn(node, root, pass, _current_fn, ss, ctx, _here, module, options, _helpers);
    else if (k == Kind_Idfg_loop)
        bck_loop_gDsn(node, root, pass, _current_fn, ss, ctx, _here, module, options, _helpers);
    else if (k == Kind_Idfg_letdef)
    {
        std::swap(GET_mut_gDsn(node.target, ss, module).solved, node);
        bck_node_gDsn(node, root, pass, _current_fn, ss, ctx, _here, module, options, _helpers);
        std::swap(GET_mut_gDsn(node.target, ss, module).solved, node);
    }
    else if (k == Kind_Idfg_let)
        bck_let_gDsn(node, root, pass, _current_fn, ss, ctx, _here, module, options, _helpers);
    else if (k == Kind_Idfg_if)
    {
        bck_if_gDsn(node, root, pass, _current_fn, ss, ctx, _here, module, options, _helpers);
    }
    else if ((k == Kind_Idfg_and) || (k == Kind_Idfg_or))
        bck_and_or_gDsn(node, root, pass, _current_fn, ss, ctx, _here, module, options, _helpers);
    else if (k == Kind_Idfg_not)
        bck_not_gDsn(node, root, pass, _current_fn, ss, ctx, _here, module, options, _helpers);
    else if (k == Kind_Idfg_block)
        bck_block_gDsn(node, root, pass, _current_fn, ss, ctx, _here, module, options, _helpers);
    else if ((k == Kind_Idfg_root) || (k == Kind_Idfg_jump) || (k == Kind_Idfg_try) || (k == Kind_Idfg_copy) || (k == Kind_Idfg_move) || (k == Kind_Idfg_arrlit))
    {
        fu::view_mut<SolvedNode_efhg> items = node.items;
        for (int i = 0; i < items.size(); i++)
        {
            SolvedNode_efhg* _0;
            (_0 = &(items.mutref(i)), bck_node_gDsn(*_0, root, pass, _current_fn, ss, ctx, _here, module, options, _helpers));
        };
        if (k == Kind_Idfg_jump)
        {
            const Helpers_DyqV* h;
            if ((h = &(node.helpers), ((((*h).index >= 0) && ((*h).index < ss._helpers_data.size())) ? ss._helpers_data[(*h).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).postevt)
            {
                const Helpers_DyqV* h_1;
                Events_merge_gDsn((h_1 = &(node.helpers), ((((*h_1).index >= 0) && ((*h_1).index < ss._helpers_data.size())) ? ss._helpers_data.mutref((*h_1).index) : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).postevt, _current_fn.events.snap);
            }
            else
            {
                const Helpers_DyqV* h_1;
                (h_1 = &(node.helpers), ((((*h_1).index >= 0) && ((*h_1).index < ss._helpers_data.size())) ? ss._helpers_data.mutref((*h_1).index) : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).postevt = EventsSnap_elmt(_current_fn.events.snap);
            };
            if (!_current_fn.TODO_FIX_bckCantDealWithNestedDefers)
            {
                const Helpers_DyqV* h_1;
                int _1;
                Events_restore_gDsn(_current_fn.events, (*(EventsSnap_elmt*)fu::NIL), ((_1 = (h_1 = &(node.helpers), ((((*h_1).index >= 0) && ((*h_1).index < ss._helpers_data.size())) ? ss._helpers_data[(*h_1).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).postdom.write_loop_start) ? _1 : BUG_gDsn("bck_node(jump): helpers.postdom.write_loop_start not set."_view, ss, ctx, _here, module, options, _helpers)), ctx, _here);
            };
        };
    }
    else if (k == Kind_Idfg_pragma)
    {
        for (int i = 0; i < node.items.size(); i++)
        {
            SolvedNode_efhg& item = node.items.mutref(i);
            bck_node_gDsn(item, root, pass, _current_fn, ss, ctx, _here, module, options, _helpers);
            if (is_mutref_9CJm(item.type, ctx, _here))
            {
                _here = item.token;
                bck_trackWrites_gDsn(node, item.type.lifetime, root, pass, _current_fn, ss, ctx, _here, module, options, _helpers);
            };
        };
    }
    else if (node.items)
        BUG_gDsn(x7E_rA00("bck: Unexpected "_view, str_eN8k(k)), ss, ctx, _here, module, options, _helpers);

}

static void PASS_borrowCheck_gDsn(SolvedNode_efhg& root, const BorrowCheckPass_i0wt pass, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    bck_node_gDsn(root, root, pass, _current_fn, ss, ctx, _here, module, options, _helpers);
}

                                #ifndef DEF_Lifetime_each_jlu1BW34LIf
                                #define DEF_Lifetime_each_jlu1BW34LIf
inline void Lifetime_each_jlu1(const Lifetime_llCF& lifetime, bool& notPointless, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit_7Yz9(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        unsigned v;
        const int locid = ((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))));
        if (!(!locid))
        {
            const LocidMap_IP5H* map;
            if ((map = &(_current_fn.postdom.snap.ever_written), !!iF_BZQz((*map), locid, _current_fn)))
                notPointless = true;
            else if (!(locid < 0))
            {
                verifyCopyNotRedundant_PNkz(GET_gDsn(nested_FDl5(locid, ss, ctx, _here), ss, ctx, _here, module).solved.type.lifetime, notPointless, _current_fn, ss, ctx, _here, module);
            };
            if (notPointless)
                return;

        };
    };
}
                                #endif

                                #ifndef DEF_verifyCopyNotRedundant_PNkz12MPHxl
                                #define DEF_verifyCopyNotRedundant_PNkz12MPHxl
inline static void verifyCopyNotRedundant_PNkz(const Lifetime_llCF& lt, bool& notPointless, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    Lifetime_each_jlu1(lt, notPointless, _current_fn, ss, ctx, _here, module);
}
                                #endif

                                #ifndef DEF___wphbTXacyl5
                                #define DEF___wphbTXacyl5
inline static void _wphb(const int locid, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    Overload_aO3i& o = GET_mut_gDsn(nested_FDl5(locid, ss, ctx, _here), ss, module);
    if (is_ref_9CJm(o.solved.type))
    {
        bool notPointless = false;
        verifyCopyNotRedundant_PNkz(o.solved.type.lifetime, notPointless, _current_fn, ss, ctx, _here, module);
        if (notPointless)
            o.solved.type = clear_refs_9CJm(Type_OiTm(o.type));

    }
    else
        BUG_gDsn("PASS_BCK_applyCopies: not a ref"_view, ss, ctx, _here, module, options, _helpers);

}
                                #endif

                                #ifndef DEF___GGLKcHVIuul
                                #define DEF___GGLKcHVIuul
inline static void _GGLK(const int locid, const int args_neg, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    _wphb((locid - args_neg), _current_fn, ss, ctx, _here, module, options, _helpers);
}
                                #endif

                                #ifndef DEF_each_Bv0ylklQ3N3
                                #define DEF_each_Bv0ylklQ3N3
inline void each_Bv0y(const BitSet_mmp7& _, const int args_neg, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    for (int i = 0; i < _._data.size(); i++)
    {
        const fu::u8 item = _._data[i];
        if (item)
        {
            for (int b = 0; b < 8; b++)
            {
                const fu::u8 mask = fu::u8((fu::u8(1u) << fu::u8(unsigned(b))));
                if (item & mask)
                    _GGLK(((i << 3) | int(b)), args_neg, _current_fn, ss, ctx, _here, module, options, _helpers);

            };
        };
    };
}
                                #endif

                                #ifndef DEF_each_XyjfQm3Pue8
                                #define DEF_each_XyjfQm3Pue8
inline static void each_Xyjf(const LocidSet_iAWt& set, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const int args_neg = _current_fn.args_neg;
    each_Bv0y(set._bitset, args_neg, _current_fn, ss, ctx, _here, module, options, _helpers);
}
                                #endif

static void PASS_BCK_applyCopies_gDsn(const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    each_Xyjf(_current_fn.flow.bck_consider_copy, _current_fn, ss, ctx, _here, module, options, _helpers);
}

                                #ifndef DEF___UWCiktn3Ig9
                                #define DEF___UWCiktn3Ig9
inline static void _UWCi(const Target_VZrr& target, Lifetime_llCF& consts, Lifetime_llCF& refs, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const Target_VZrr* t;
    if (int(unsigned(((target._packed >> 20ull) & 0xfffffull))) == (t = &(_current_fn.out.target), int(unsigned((((*t)._packed >> 20ull) & 0xfffffull)))))
    {
        const Type_OiTm& type = GET_gDsn(target, ss, ctx, _here, module).solved.type;
        unsigned v;
        Lifetime_llCF region = Lifetime_AAR_7Yz9((v = unsigned((target._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))), ctx, _here);
        if (!(!Lifetime_getRefLocid_unlessStatic_gDsn(region, ss, ctx, _here, module, options, _helpers)))
        {
            int locid;
            unsigned v_1;
            const LocidMap_IP5H* map;
            if (is_mutref_9CJm(type, ctx, _here) && (locid = (v_1 = unsigned((target._packed & 0xfffffull)), int(((v_1 >> 1u) ^ ((v_1 & 1u) ? 0xffffffffu : 0x0u)))), map = &(_current_fn.postdom.snap.ever_written), !!iF_BZQz((*map), locid, _current_fn)))
            {
                Lifetime_add_7Yz9(refs, region, false, ctx, _here);
            }
            else if (is_ref_9CJm(type) && !willPassByValue_FDl5(GET_gDsn(target, ss, ctx, _here, module), ctx, _here))
            {
                Lifetime_add_7Yz9(consts, region, false, ctx, _here);
            };
        };
    }
    else
    {
        BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers);
    };
}
                                #endif

                                #ifndef DEF__current_fn_eachArg_FWD_dXwrkY6ZBWd
                                #define DEF__current_fn_eachArg_FWD_dXwrkY6ZBWd
inline static void _current_fn_eachArg_FWD_dXwr(Lifetime_llCF& consts, Lifetime_llCF& refs, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    for (int i = 0; i < (_current_fn.out.items.size() + FN_ARGS_BACK); i++)
    {
        const Target_VZrr& t = _current_fn.out.items[i].target;
        if (t)
        {
            unsigned v;
            if ((v = unsigned((t._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))) < 0)
                _UWCi(t, consts, refs, _current_fn, ss, ctx, _here, module, options, _helpers);
            else
            {
                BUG_u9Gb(fu::view<char>{}, ctx, _here);
            };
        };
    };
}
                                #endif

                                #ifndef DEF___P1peowy5RFj
                                #define DEF___P1peowy5RFj
inline static void _P1pe(const int locid, int& refs_len, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (locid)
        refs_len++;
    else
        BUG_gDsn("AAR: refs contains non-locals"_view, ss, ctx, _here, module, options, _helpers);

}
                                #endif

                                #ifndef DEF_Lifetime_each_kpIAe40O5f3
                                #define DEF_Lifetime_each_kpIAe40O5f3
inline void Lifetime_each_kpIA(const Lifetime_llCF& lifetime, int& refs_len, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit_7Yz9(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        unsigned v;
        _P1pe(((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))))), refs_len, ss, ctx, _here, module, options, _helpers);
    };
}
                                #endif

static void clear_wyx7(Flow_oKsD& flow)
{
    if (flow.at_hard_risk || flow.at_soft_risk)
        fu::fail(fu::str(str_Vczw5Cti8xf));
    else
    {

        {
            LocidMap_JYql& map = flow.rg_parents;
            map._values.clear();
        };

        {
            LocidMap_JYql& map = flow.rg_invalidates;
            map._values.clear();
        };

        {
            LocidMap_oyma& map = flow.rg_children;
            map._values.clear();
        };

        {
            LocidMap_DNUT& map = flow.at_soft_risk;
            map._values.clear();
        };

        {
            LocidMap_DNUT& map = flow.at_hard_risk;
            map._values.clear();
        };

        {
            LocidSet_iAWt& set = flow.bck_consider_copy;
            clear_ZwXY(set._bitset);
        };

        {
            LocidSet_iAWt& set = flow.is_arg;
            clear_ZwXY(set._bitset);
        };

        {
            LocidMap_oyma& map = flow.arg_parents;
            map._values.clear();
        };
        flow.arg_targets.clear();
    };
}

static void clear_gDsn(Events_SbUb& events)
{
    events = Events_SbUb{};
}

                                #ifndef DEF___6FJSPPTVNo6
                                #define DEF___6FJSPPTVNo6
inline static void _6FJS(const Target_VZrr& target, const int position, CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const Target_VZrr* t;
    if (int(unsigned(((target._packed >> 20ull) & 0xfffffull))) == (t = &(_current_fn.out.target), int(unsigned((((*t)._packed >> 20ull) & 0xfffffull)))))
    {
        unsigned v;
        const int target_1 = (v = unsigned((target._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        if ((_current_fn.flow.arg_targets.size() <= position))
        {
            _current_fn.flow.arg_targets.grow((position + 1));
            _current_fn.flow.arg_targets.mutref(position) = target_1;
            add_gDsn(_current_fn.flow.is_arg, target_1, _current_fn);
        }
        else
            BUG_gDsn("Reference_trackArgument: positions out of order."_view, ss, ctx, _here, module, options, _helpers);

    }
    else
        BUG_gDsn(x7E_rA00("Arg target not local to current-fn: "_view, str_FDl5(target, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

}
                                #endif

                                #ifndef DEF__current_fn_eachArg_FWD_GHzGDhEYehc
                                #define DEF__current_fn_eachArg_FWD_GHzGDhEYehc
inline static void _current_fn_eachArg_FWD_GHzG(CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    for (int i = 0; i < (_current_fn.out.items.size() + FN_ARGS_BACK); i++)
    {
        const Target_VZrr& t = _current_fn.out.items[i].target;
        if (t)
        {
            unsigned v;
            if ((v = unsigned((t._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))) < 0)
                _6FJS(t, i, _current_fn, ss, ctx, _here, module, options, _helpers);
            else
            {
                BUG_u9Gb(fu::view<char>{}, ctx, _here);
            };
        };
    };
}
                                #endif

                                #ifndef DEF___2ADr5NxBklb
                                #define DEF___2ADr5NxBklb
inline static void _2ADr(const int target, const Lifetime_llCF& other_refs, const Lifetime_llCF& consts, Flow_oKsD& flow, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (target)
    {
        if (consts)
        {
            Lifetime_llCF* _0;
            (!*(_0 = &(ensure_8Ozu(flow.rg_invalidates, target, _current_fn))) ? *_0 : BUG_gDsn("AAR: ref arg already has invalidates."_view, ss, ctx, _here, module, options, _helpers)) = Lifetime_llCF(consts);
        };
        if (other_refs)
        {
            Lifetime_add_7Yz9(ensure_8Ozu(flow.rg_invalidates, target, _current_fn), other_refs, false, ctx, _here);
        };
        if (consts || other_refs)
        {
            const Lifetime_llCF* _1;
            Lifetime_llCF* _2;
            (!*(_2 = &(ensure_8Ozu(flow.rg_parents, target, _current_fn))) ? *_2 : BUG_gDsn("AAR: ref arg already has parents."_view, ss, ctx, _here, module, options, _helpers)) = Lifetime_llCF((*(_1 = &(iF_4knF(flow.rg_invalidates, target, _current_fn))) ? *_1 : BUG_gDsn("AAR: (refs.len > 1 || consts), but no invalidates."_view, ss, ctx, _here, module, options, _helpers)));
        };
    }
    else
    {
        BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers);
    };
}
                                #endif

                                #ifndef DEF_Lifetime_each_ZrLQmH9T0u5
                                #define DEF_Lifetime_each_ZrLQmH9T0u5
inline void Lifetime_each_ZrLQ(const Lifetime_llCF& lifetime, const Lifetime_llCF& consts, Flow_oKsD& flow, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const int offset0 = offset;
        const unsigned r = parse7bit_7Yz9(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        unsigned v;
        _2ADr(((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))))), Lifetime_llCF { (fu::get_view_start0(chars, offset0) + fu::get_view(chars, offset)) }, consts, flow, _current_fn, ss, ctx, _here, module, options, _helpers);
    };
}
                                #endif

                                #ifndef DEF___2vXBA81a8w9
                                #define DEF___2vXBA81a8w9
inline static void _2vXB(const int target, const Lifetime_llCF& refs, Flow_oKsD& flow, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (target)
    {
        Lifetime_llCF* _0;
        (!*(_0 = &(ensure_8Ozu(flow.rg_invalidates, target, _current_fn))) ? *_0 : BUG_gDsn("AAR: const arg already has invalidates."_view, ss, ctx, _here, module, options, _helpers)) = Lifetime_llCF(refs);
        Lifetime_llCF* _1;
        (!*(_1 = &(ensure_8Ozu(flow.rg_parents, target, _current_fn))) ? *_1 : BUG_gDsn("AAR: const arg already has parents."_view, ss, ctx, _here, module, options, _helpers)) = Lifetime_llCF(refs);
    }
    else
    {
        BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers);
    };
}
                                #endif

                                #ifndef DEF_Lifetime_each_jPL99OGZWzh
                                #define DEF_Lifetime_each_jPL99OGZWzh
inline void Lifetime_each_jPL9(const Lifetime_llCF& lifetime, const Lifetime_llCF& refs, Flow_oKsD& flow, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit_7Yz9(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        unsigned v;
        _2vXB(((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))))), refs, flow, _current_fn, ss, ctx, _here, module, options, _helpers);
    };
}
                                #endif

static bool PASS_AAR_prepare_gDsn(CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    Lifetime_llCF consts {};
    Lifetime_llCF refs {};
    _current_fn_eachArg_FWD_dXwr(consts, refs, _current_fn, ss, ctx, _here, module, options, _helpers);
    int refs_len = 0;
    Lifetime_each_kpIA(refs, refs_len, ss, ctx, _here, module, options, _helpers);
    if (!refs_len || ((refs_len == 1) && !consts))
        return false;
    else
    {
        clear_wyx7(_current_fn.flow);
        clear_gDsn(_current_fn.events);
        _current_fn_eachArg_FWD_GHzG(_current_fn, ss, ctx, _here, module, options, _helpers);
        Flow_oKsD& flow = _current_fn.flow;
        Lifetime_each_ZrLQ(refs, consts, flow, _current_fn, ss, ctx, _here, module, options, _helpers);
        if (refs)
        {
            Lifetime_each_jPL9(consts, refs, flow, _current_fn, ss, ctx, _here, module, options, _helpers);
        };
        if (refs)
        {
            _current_fn.events = Events_SbUb{};
            return true;
        }
        else
            BUG_gDsn("Wasting time on AAR without ref args."_view, ss, ctx, _here, module, options, _helpers);

    };
}

static void runAllPasses_gDsn(SolvedNode_efhg& node, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    if (_current_fn)
    {
        if (currentFn_mustBecomeInline_gDsn(_current_fn))
            return;
        else if (GET_gDsn(_current_fn.out.target, ss, ctx, _here, module).status & SolverStatus_h9em_SS_Debug_AllPassesComplete)
            BUG_gDsn("runAllPasses: All passes already complete."_view, ss, ctx, _here, module, options, _helpers);
        else
            _current_fn.args_neg = EXT_gDsn(_current_fn.out.target, ss, ctx, module).args_neg;

    };
    fu_DEFER(if (_current_fn)
    {
        if (_current_fn.args_neg == EXT_gDsn(_current_fn.out.target, ss, ctx, module).args_neg)
            _current_fn.args_neg = 0;
        else
        {
            BUG_gDsn("runAllPasses: args_neg drifted"_view, ss, ctx, _here, module, options, _helpers);
        };
    });
    const Helpers_DyqV* h;
    TEST_pass_gDsn(node, (h = &(node.helpers), ((((*h).index >= 0) && ((*h).index < ss._helpers_data.size())) ? ss._helpers_data[(*h).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).pass, false, _current_fn, ss, ctx, _here, module, options, _helpers);

    {
        const Helpers_DyqV* h_1;
        (h_1 = &(node.helpers), ((((*h_1).index >= 0) && ((*h_1).index < ss._helpers_data.size())) ? ss._helpers_data.mutref((*h_1).index) : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).pass = SolverPass_zVQ2_RelaxMut;
        if (_current_fn.relaxed.var_usage)
            BUG_gDsn("_current_fn.var_usage not empty before propagateType."_view, ss, ctx, _here, module, options, _helpers);
        else if (_current_fn.postdom)
            BUG_gDsn("_current_fn.postdom not empty before propagateType."_view, ss, ctx, _here, module, options, _helpers);
        else
        {
            Postdom_resetAtFnEnd_gDsn(_current_fn.postdom);
            propagateType_gDsn(node, Type_OiTm(node.type), RELAX_before_bck, Helpers_DyqV{}, _current_fn, ss, ctx, _here, module, options, _helpers);
            if (_current_fn.postdom.read_loop_start == NO_LOOP)
            {
                if (!(_current_fn.postdom.write_loop_start == NO_LOOP))
                    BUG_gDsn((x7E_rA00("RelaxMut.end: write_loop_start("_view, fu::i64dec(_current_fn.postdom.write_loop_start)) + ")"_view), ss, ctx, _here, module, options, _helpers);

            }
            else
                BUG_gDsn((x7E_rA00("RelaxMut.end: read_loop_start("_view, fu::i64dec(_current_fn.postdom.read_loop_start)) + ")"_view), ss, ctx, _here, module, options, _helpers);

        };
    };
    const Helpers_DyqV* h_1;
    TEST_pass_gDsn(node, (h_1 = &(node.helpers), ((((*h_1).index >= 0) && ((*h_1).index < ss._helpers_data.size())) ? ss._helpers_data[(*h_1).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).pass, true, _current_fn, ss, ctx, _here, module, options, _helpers);

    {
        const Helpers_DyqV* h_2;
        (h_2 = &(node.helpers), ((((*h_2).index >= 0) && ((*h_2).index < ss._helpers_data.size())) ? ss._helpers_data.mutref((*h_2).index) : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).pass = SolverPass_zVQ2_BorrowCheck;
        PASS_borrowCheck_gDsn(node, BorrowCheckPass_i0wt_BCK_bck, _current_fn, ss, ctx, _here, module, options, _helpers);
        PASS_BCK_applyCopies_gDsn(_current_fn, ss, ctx, _here, module, options, _helpers);
    };

    {
        const Helpers_DyqV* h_2;
        (h_2 = &(node.helpers), ((((*h_2).index >= 0) && ((*h_2).index < ss._helpers_data.size())) ? ss._helpers_data.mutref((*h_2).index) : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).pass = SolverPass_zVQ2_ArgumentsAtRisk;
        _current_fn.TODO_FIX_children = _current_fn.flow.rg_children;
        if (PASS_AAR_prepare_gDsn(_current_fn, ss, ctx, _here, module, options, _helpers))
            PASS_borrowCheck_gDsn(node, BorrowCheckPass_i0wt_BCK_aar, _current_fn, ss, ctx, _here, module, options, _helpers);

    };
    const Helpers_DyqV* h_2;
    TEST_pass_gDsn(node, (h_2 = &(node.helpers), ((((*h_2).index >= 0) && ((*h_2).index < ss._helpers_data.size())) ? ss._helpers_data[(*h_2).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).pass, false, _current_fn, ss, ctx, _here, module, options, _helpers);

    {
        const Helpers_DyqV* h_3;
        (h_3 = &(node.helpers), ((((*h_3).index >= 0) && ((*h_3).index < ss._helpers_data.size())) ? ss._helpers_data.mutref((*h_3).index) : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).pass = SolverPass_zVQ2_RelaxCopyResize;
        _current_fn.effects.fx_mask = FxMask_2dRz{};
        _current_fn.relaxed = VarUsage_IMaS{};
        if (_current_fn.postdom.read_loop_start == NO_LOOP)
        {
            if (_current_fn.postdom.write_loop_start == NO_LOOP)
            {
                Postdom_resetAtFnEnd_gDsn(_current_fn.postdom);
                propagateType_gDsn(node, Type_OiTm(node.type), RELAX_all, Helpers_DyqV{}, _current_fn, ss, ctx, _here, module, options, _helpers);
                if (_current_fn.postdom.read_loop_start == NO_LOOP)
                {
                    if (!(_current_fn.postdom.write_loop_start == NO_LOOP))
                        BUG_gDsn((x7E_rA00("RelaxCopyResize.end: write_loop_start("_view, fu::i64dec(_current_fn.postdom.write_loop_start)) + ")"_view), ss, ctx, _here, module, options, _helpers);

                }
                else
                    BUG_gDsn((x7E_rA00("RelaxCopyResize.end: read_loop_start("_view, fu::i64dec(_current_fn.postdom.read_loop_start)) + ")"_view), ss, ctx, _here, module, options, _helpers);

            }
            else
                BUG_gDsn((x7E_rA00("RelaxCopyResize: write_loop_start("_view, fu::i64dec(_current_fn.postdom.write_loop_start)) + ")"_view), ss, ctx, _here, module, options, _helpers);

        }
        else
            BUG_gDsn((x7E_rA00("RelaxCopyResize: read_loop_start("_view, fu::i64dec(_current_fn.postdom.read_loop_start)) + ")"_view), ss, ctx, _here, module, options, _helpers);

    };
    const Helpers_DyqV* h_3;
    TEST_pass_gDsn(node, (h_3 = &(node.helpers), ((((*h_3).index >= 0) && ((*h_3).index < ss._helpers_data.size())) ? ss._helpers_data[(*h_3).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).pass, true, _current_fn, ss, ctx, _here, module, options, _helpers);
    if (_current_fn)
    {
        if (currentFn_mustBecomeInline_gDsn(_current_fn))
            BUG_gDsn("runAllPasses: currentFn_mustBecomeInline after all."_view, ss, ctx, _here, module, options, _helpers);
        else
            GET_mut_gDsn(_current_fn.out.target, ss, module).status |= SolverStatus_h9em_SS_Debug_AllPassesComplete;

    };
}

                                #ifndef DEF_str_OQywDAAoQnb
                                #define DEF_str_OQywDAAoQnb
inline fu::str str_OQyw(const FxMask_2dRz n)
{
    /*MOV*/ fu::str res {};

    {
        if (n & FxMask_2dRz_Fx_NotDeadCode)
            res += ("Fx_NotDeadCode"_view + ", "_view);

        if (n & FxMask_2dRz_Fx_NonDeterministic)
            res += ("Fx_NonDeterministic"_view + ", "_view);

        if (n & FxMask_2dRz_Fx_DontMoveUp)
            res += ("Fx_DontMoveUp"_view + ", "_view);

        if (n & FxMask_2dRz_Fx_DontMoveDown)
            res += ("Fx_DontMoveDown"_view + ", "_view);

        if (n & FxMask_2dRz_Fx_Input)
            res += ("Fx_Input"_view + ", "_view);

        if (n & FxMask_2dRz_Fx_Output)
            res += ("Fx_Output"_view + ", "_view);

        if (n & FxMask_2dRz_Fx_Throws)
            res += ("Fx_Throws"_view + ", "_view);

        if (n & FxMask_2dRz_Fx_Crashes)
            res += ("Fx_Crashes"_view + ", "_view);

        if (n & FxMask_2dRz_Fx_Crashes_Div0)
            res += ("Fx_Crashes_Div0"_view + ", "_view);

        if (n & FxMask_2dRz_Fx_Crashes_OOB)
            res += ("Fx_Crashes_OOB"_view + ", "_view);

        if (n & FxMask_2dRz_Fx_Crashes_Assert)
            res += ("Fx_Crashes_Assert"_view + ", "_view);

        if (n & FxMask_2dRz_Fx_Crashes_Exit)
            res += ("Fx_Crashes_Exit"_view + ", "_view);

        if (n & FxMask_2dRz_Fx_Syscall)
            res += ("Fx_Syscall"_view + ", "_view);

        if (n & FxMask_2dRz_Fx_Blocks)
            res += ("Fx_Blocks"_view + ", "_view);

        if (n & FxMask_2dRz_Fx_Blocks_Alloc)
            res += ("Fx_Blocks_Alloc"_view + ", "_view);

        if (n & FxMask_2dRz_Fx_Blocks_Await)
            res += ("Fx_Blocks_Await"_view + ", "_view);

    };
    if (res)
        res.shrink((res.size() - 2));

    return /*NRVO*/ res;
}
                                #endif

static void TEST_FunctionNarrowing_gDsn(const Target_VZrr& wider, const Target_VZrr& narrower, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    fu::view<Argument_bbKc> w_args = EXT_gDsn(wider, ss, ctx, module).args;
    fu::view<Argument_bbKc> n_args = EXT_gDsn(narrower, ss, ctx, module).args;
    if (w_args.size() == n_args.size())
    {
        for (int i = 0; i < w_args.size(); i++)
        {
            const Argument_bbKc& w = w_args[i];
            const Argument_bbKc& n = n_args[i];
            if (w.name == n.name)
            {

                {
                    const Type_OiTm& host = n.type;
                    const Type_OiTm& guest = w.type;
                    const bool asArgument = false;
                    if (!(isAssignable_9CJm(host, guest, false, asArgument, ctx, _here)))
                        BUG_gDsn((((x7E_rA00("n.type !<- w.type ("_view, str_wyx7(n, false, _current_fn, ss, ctx, _here, module, options)) + ")"_view) + ": "_view) + explainNotAssignable_gDsn(host, guest, _current_fn, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

                };
                const unsigned uNion = (n.written_to | w.written_to);
                if (uNion == w.written_to)
                {
                    if (has_missing_ZwXY(n.may_invalidate, w.may_invalidate))
                        BUG_gDsn((x7E_rA00("n.may_invalidate less ("_view, str_wyx7(n, false, _current_fn, ss, ctx, _here, module, options)) + ")"_view), ss, ctx, _here, module, options, _helpers);
                    else if (has_missing_ZwXY(n.may_alias, w.may_alias))
                        BUG_gDsn((x7E_rA00("n.may_alias less ("_view, str_wyx7(n, false, _current_fn, ss, ctx, _here, module, options)) + ")"_view), ss, ctx, _here, module, options, _helpers);

                }
                else
                    BUG_gDsn((x7E_rA00((x7E_rA00((x7E_rA00("n.written_to("_view, fu::u64dec(n.written_to)) + ") w.written_to("_view), fu::u64dec(w.written_to)) + ") union("_view), fu::u64dec(uNion)) + ")"_view), ss, ctx, _here, module, options, _helpers);

            }
            else
                BUG_gDsn((x7E_rA00((x7E_rA00("w.name("_view, str_wyx7(w, false, _current_fn, ss, ctx, _here, module, options)) + ") == n.name("_view), str_wyx7(n, false, _current_fn, ss, ctx, _here, module, options)) + ")"_view), ss, ctx, _here, module, options, _helpers);

        };
        const FxMask_2dRz w_fx = EXT_gDsn(wider, ss, ctx, module).fx_mask;
        const FxMask_2dRz n_fx = EXT_gDsn(narrower, ss, ctx, module).fx_mask;
        if (!(FxMask_2dRz((n_fx & w_fx)) == n_fx))
            BUG_gDsn((x7E_rA00((x7E_rA00("n_fx("_view, str_OQyw(n_fx)) + ") !<= w_fx("_view), str_OQyw(w_fx)) + ")"_view), ss, ctx, _here, module, options, _helpers);

    }
    else
        BUG_gDsn((x7E_rA00((x7E_rA00("w_args("_view, fu::i64dec(w_args.size())) + ") != n_args("_view), fu::i64dec(n_args.size())) + ")"_view), ss, ctx, _here, module, options, _helpers);

}

static void doReverseSpecialize_gDsn(const Target_VZrr& target, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    const RevSpecInstance_Td5T& instance = EPH_gDsn(target, ss, module).rev_spec.instance;
    const Target_VZrr original = instance.original;
    const unsigned relaxed_quals = instance.relaxed_quals;
    const RevSpecPrototype_vWbr& prototype = EPH_gDsn(original, ss, module).rev_spec.prototype;
    SolvedNode_efhg solved = (prototype.solved ? prototype.solved : BUG_gDsn("doReverseSpecialize: no rev_spec.prototype.solved"_view, ss, ctx, _here, module, options, _helpers));
    /*MOV*/ fu::vec<Overload_aO3i> args_n_locals = fu::vec<Overload_aO3i>(prototype.args_n_locals);
    const int args_neg = prototype.args_neg;
    const int helpers0 = _helpers.size();
    const int helpers_data0 = ss._helpers_data.size();
    CurrentFn_QbLp current_fn0 = steal_MnHl(_current_fn);
    const Target_VZrr solvingFnort0 = exchange_GcK8(ss._solvingFnort, Target_VZrr(target));
    const Target_VZrr nestingFnort0 = exchange_GcK8(ss._nestingFnort, Target_VZrr(target));
    fu_DEFER(
    {
        _helpers.shrink(helpers0);
        ss._helpers_data.shrink(helpers_data0);
        std::swap(current_fn0, _current_fn);
        ss._solvingFnort = solvingFnort0;
        ss._nestingFnort = nestingFnort0;
    });

    {
        fu::vec<Helpers_DyqV> helpersReplicas {};
        int lastKnownLocal {};
        relinkNode_gDsn(solved, target, original, args_n_locals, args_neg, helpersReplicas, lastKnownLocal, _current_fn, ss, ctx, _here, _helpers);
    };

    {
        Extended_z0HS& ext = EXT_mut_gDsn(target, ss, module);
        ext.args_n_locals = static_cast<fu::vec<Overload_aO3i>&&>(args_n_locals);
        ext.args_neg = args_neg;
    };
    GET_mut_gDsn(target, ss, module).status &= SolverStatus_h9em(~SolverStatus_h9em_SS_Debug_AllPassesComplete);

    {
        solved.target = target;
        SolvedNode_efhg& n_body = last_xZUS(solved.items);
        const Helpers_DyqV* h;
        (h = &(n_body.helpers), ((((*h).index >= 0) && ((*h).index < ss._helpers_data.size())) ? ss._helpers_data.mutref((*h).index) : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).target = Target_VZrr(target);
        const Helpers_DyqV* h_1;
        (h_1 = &(n_body.helpers), ((((*h_1).index >= 0) && ((*h_1).index < ss._helpers_data.size())) ? ss._helpers_data.mutref((*h_1).index) : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).mask = HelpersMask_w1sv_HM_Function;
        Type_OiTm slot = Type_OiTm { ValueType_JtNg { n_body.type.vtype.quals, {/*unused non-zst*/}, {/*unused non-zst*/} }, {/*unused non-zst*/} };
        force_relax_9CJm(slot, relaxed_quals);
        const unsigned did_relax = try_relax_9CJm(n_body.type, slot, relaxed_quals);
        if (!(did_relax == relaxed_quals))
            BUG_gDsn((x7E_rA00(((x7E_rA00("doReverseSpecialize: did_relax("_view, fu::u64dec(did_relax)) + ")"_view) + " != relaxed_quals("_view), fu::u64dec(relaxed_quals)) + ")"_view), ss, ctx, _here, module, options, _helpers);

    };
    /*MOV*/ Type_OiTm retval {};

    {
        SolvedNode_efhg n_body = steal_bX67(last_xZUS(solved.items));
        std::swap(_current_fn.out, solved);
        runAllPasses_gDsn(n_body, _current_fn, ss, ctx, _here, module, options, _helpers);
        const Helpers_DyqV* h;
        retval = (h = &(n_body.helpers), ((((*h).index >= 0) && ((*h).index < ss._helpers_data.size())) ? ss._helpers_data[(*h).index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))).ret_actual;
        if (retval.vtype.quals & relaxed_quals)
            BUG_gDsn("reported retval intersects relaxed_quals"_view, ss, ctx, _here, module, options, _helpers);
        else
            std::swap(last_xZUS(_current_fn.out.items), n_body);

    };
    doUpdateScope_gDsn(static_cast<Type_OiTm&&>(retval), target, true, false, false, DeclAsserts_taUG{}, _current_fn, ss, ctx, _here, module, options, _helpers);
    TEST_FunctionNarrowing_gDsn(original, target, _current_fn, ss, ctx, _here, module, options, _helpers);
    lazySolveEnd_gDsn(target, _current_fn, ss, ctx, _here, module, options, _helpers);
}

static bool lazySolveStart_gDsn(const Target_VZrr& target, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    if (SolverStatus_h9em((GET_gDsn(target, ss, ctx, _here, module).status & SolverStatus_h9em((SolverStatus_h9em_SS_DID_START | SolverStatus_h9em_SS_LAZY)))) != SolverStatus_h9em_SS_LAZY)
        return false;
    else
    {
        Overload_aO3i& o = GET_mut_gDsn(target, ss, module);
        if (o.status & SolverStatus_h9em((SolverStatus_h9em((SolverStatus_h9em_SS_FINALIZED | SolverStatus_h9em_SS_DID_START)) | SolverStatus_h9em_SS_DIRTY)))
            BUG_gDsn(x7E_rA00("SS_DID_START: non-zero solver status: "_view, str_VyKZ(o.status)), ss, ctx, _here, module, options, _helpers);
        else
        {
            o.status |= SolverStatus_h9em_SS_DID_START;
            if ((o.kind == Kind_Idfg_fn) || (o.kind == Kind_Idfg_inline) || (o.kind == Kind_Idfg_template))
            {
                fu::str error {};
                if (EPH_gDsn(target, ss, module).rev_spec.instance.original)
                    doReverseSpecialize_gDsn(target, _current_fn, ss, ctx, _here, module, options, _helpers);
                else
                {
                    doTrySpecialize_gDsn(EPH_gDsn(target, ss, module).local_of, error, target, Target_VZrr{}, fu::view<SolvedNode_efhg>{}, fu::view<char>{}, (*(Reorder_0MNg*)fu::NIL), fu::view<fu::vec<Target_VZrr>>{}, 0, (*(Type_OiTm*)fu::NIL), _current_fn, ss, ctx, _here, module, options, _helpers);
                };
            }
            else if (o.kind == Kind_Idfg_type)
                __solveStruct_gDsn(true, Node_JjyR(EXT_gDsn(target, ss, ctx, module).tEmplate.node), target, false, _current_fn, ss, ctx, _here, module, options, _helpers);
            else
                BUG_gDsn((x7E_rA00("lazySolveStart: kind is `"_view, str_eN8k(o.kind)) + "`."_view), ss, ctx, _here, module, options, _helpers);

            return true;
        };
    };
}

static void ensureLazySolved_gDsn(const Target_VZrr& target, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    int repeats = 0;
    while (lazySolveStart_gDsn(target, _current_fn, ss, ctx, _here, module, options, _helpers))
    {
        if (repeats++ > 1000)
            BUG_gDsn(x7E_rA00("Repeat-solved too many times: "_view, str_FDl5(target, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

    };
}

static fu::str str_q5Q6(const int min, const int max)
{
    if (min != max)
        return x7E_rA00((x7E_rA00("["_view, fu::i64dec(min)) + " upto "_view), fu::i64dec(max)) + "]"_view;
    else
        return fu::i64dec(min);

}

static void reorderByNumUsings_gDsn(Reorder_0MNg& reorder, fu::view<Argument_bbKc> host_args, const int num_args, const int num_usings)
{
    reorder.map.clear();
    if (num_usings)
    {
        for (int i = 0; i < host_args.size(); i++)
        {
            const int x = (i - num_usings);
            reorder.map.push((((x >= 0) && (x < num_args)) ? x : -1));
        };
    };
    reorder.applicable = !!reorder.map;
}

                                #ifndef DEF_iF_W0gOTTCOJG9
                                #define DEF_iF_W0gOTTCOJG9
inline int iF_W0gO(fu::view<int> a, const int i, const int eLse)
{
    if (uNsigned_40Hl(i) < uNsigned_40Hl(a.size()))
        return a[i];
    else
        return eLse;

}
                                #endif

                                #ifndef DEF_each_57iUYR7OXtf
                                #define DEF_each_57iUYR7OXtf
inline void each_57iU(fu::view<Argument_bbKc> a, const Reorder_0MNg& reorder, fu::str& error, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    for (int i = 0; i < a.size(); i++)
    {
        const Argument_bbKc& host_arg = a[i];
        const int i_1 = i;
        const int callsiteIndex = iF_W0gO(reorder.map, i_1, -1);
        if (callsiteIndex < 0)
        {
            error += (x7E_rA00(("\n\n\t\tExpected "_view + (host_arg.dEfault ? "optional "_view : fu::view<char>{})), str_wyx7(host_arg, false, _current_fn, ss, ctx, _here, module, options)) + " not provided."_view);
            return;
        };
    };
}
                                #endif

                                #ifndef DEF___tXnMs8SgSni
                                #define DEF___tXnMs8SgSni
inline static bool _tXnM(const Argument_bbKc& a, fu::view<char> name)
{
    return a.name == name;
}
                                #endif

                                #ifndef DEF_some_nrjJTjo5Cd8
                                #define DEF_some_nrjJTjo5Cd8
inline bool some_nrjJ(fu::view<Argument_bbKc> a, fu::view<char> name)
{
    for (int i = 0; i < a.size(); i++)
    {
        const Argument_bbKc& item = a[i];
        if (_tXnM(item, name))
            return true;

    };
    return false;
}
                                #endif

                                #ifndef DEF_each_N0CwuynJaxl
                                #define DEF_each_N0CwuynJaxl
inline void each_N0Cw(fu::view<fu::str> a, fu::view<Argument_bbKc> host_args, fu::str& error)
{
    for (int i = 0; i < a.size(); i++)
    {
        fu::view<char> name = a[i];
        if (name && !some_nrjJ(host_args, name))
        {
            error += (((("\n\n\t\tOptional :named argument mismatch: no "_view + qBAD_KW_e44U("arg"_view)) + " "_view) + qBAD_e44U(name)) + "."_view);
            return;
        };
    };
}
                                #endif

static fu::str ERRMSG_optionalArgumentAmbiguity_gDsn(fu::view<Argument_bbKc> host_args, const Reorder_0MNg& reorder, fu::view<fu::str> names, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    /*MOV*/ fu::str error = fu::str(str_ZKTh9Sexw6k);
    each_57iU(host_args, reorder, error, _current_fn, ss, ctx, _here, module, options);
    each_N0Cw(names, host_args, error);
    return (error += "\n\n\t\tCannot distinguish from a typo."_view).destructive_move();
}

                                #ifndef DEF_ensure_UbhdsPaYb5g
                                #define DEF_ensure_UbhdsPaYb5g
inline fu::vec_range_mut<Target_VZrr> ensure_Ubhd(fu::vec_range_mut<fu::vec<Target_VZrr>> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

static const Node_JjyR& annot_gDsn(const Target_VZrr& overloadIdx, const int host_argIdx, const SolverState_aGlN& ss, const Context_noPA& ctx, const Module_wo7O& module)
{
    return EXT_gDsn(overloadIdx, ss, ctx, module).tEmplate.node.items[host_argIdx].items[LET_TYPE];
}

                                #ifndef DEF_tryConvert_GJ9L8qNipRg
                                #define DEF_tryConvert_GJ9L8qNipRg
inline static fu::vec<Target_VZrr> tryConvert_GJ9L(const Node_JjyR& expect, const Type_OiTm& actual, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    /*MOV*/ fu::vec<Target_VZrr> match {};
    ConvCache_ColsAndBakes_2n47 cc = exploreConversions_FDl5(actual.vtype, _current_fn, ss, ctx, _here, module, options, _helpers);
    for (int i = 0; i < cc.columns.types.size(); i++)
    { {
        const ValueType_JtNg& convertType = cc.columns.types[i];
        bool BL_3_v;
        if ((__extension__ (
        {
            fu::str error {};
            Map_v4nV tp = steal_ew2w(ss._typeParams);
            fu_DEFER(std::swap(ss._typeParams, tp));
            BL_3_v = (trySolveTypeParams_gDsn(expect, Type_OiTm { ValueType_JtNg(convertType), Lifetime_llCF(Lifetime_temporary) }, error, false, _current_fn, ss, ctx, _here, module, options, _helpers));
            (void)0;
        }), BL_3_v))
        {
            fu::vec_range<Target_VZrr> path = cc.columns.paths[i];
            fu::view<int> ms = cc.columns.must_see[i];
            for (int i_1 = 0; i_1 < ms.size(); i_1++)
            {
                const int ms_1 = ms[i_1];
                const bool isUsing = (ms_1 < 0);
                const int index = ((isUsing ? -ms_1 : +ms_1) - 1);
                fu::view<ScopeSkip_iozY> skips = (isUsing ? ss._ss.usings : ss._ss.converts);
                fu::view<Target_VZrr> which = (isUsing ? ss._scope.usings : ss._scope.converts);
                if ((index >= 0) && (index < which.size()))
                {
                    for (int i_2 = 0; i_2 < skips.size(); i_2++)
                    {
                        const ScopeSkip_iozY& skip = skips[i_2];
                        if ((skip.start <= index) && (skip.end > index))
                            goto BL_2;

                    };
                }
                else
                    BUG_gDsn((x7E_rA00((x7E_rA00((x7E_rA00((x7E_rA00("ConvCache.must_see ms("_view, fu::i64dec(ms_1)) + ") isUsing("_view), fu::booldec(isUsing)) + ") index("_view), fu::i64dec(index)) + ") is out of bounds("_view), fu::i64dec(which.size())) + ")"_view), ss, ctx, _here, module, options, _helpers);

            };
            if (match)
            {
                fu::str suffix = ((("\n"_view + explainConversion_gDsn(match, fu::view<char>{}, _current_fn, ss, ctx, _here, module, options)) + "\n\tand:\n"_view) + explainConversion_gDsn(path, fu::view<char>{}, _current_fn, ss, ctx, _here, module, options));
                if (actual)
                {
                    fail_gDsn(((((("Conversion ambiguity, multiple ways to convert "_view + explainType_gDsn(actual, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)) + " into "_view) + "[TODO pattern str]"_view) + ":"_view) + suffix), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                }
                else
                {
                    fail_gDsn(((((qBAD_e44U("using"_view) + " ambiguity, multiple ways to obtain a "_view) + "[TODO pattern str]"_view) + " in this scope:"_view) + suffix), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                };
            }
            else
                match = (path ? path : BUG_gDsn("Empty conversion path in cache."_view, ss, ctx, _here, module, options, _helpers));

        };
      } BL_2:;
    };
    return /*NRVO*/ match;
}
                                #endif

                                #ifndef DEF_find_7SLcWgAQSl4
                                #define DEF_find_7SLcWgAQSl4
inline int find_7SLc(fu::view<char> haystack, fu::view<char> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_ZKsG(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const char needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_BNNwXhPzgU8
                                #define DEF_find_BNNwXhPzgU8
inline int find_BNNw(fu::view<char> haystack, fu::view<char> needle, const int start)
{
    fu::view<char> slice = fu::get_view(haystack, start);
    const int res = find_7SLc(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF_replace_4fXW2QLS6G4
                                #define DEF_replace_4fXW2QLS6G4
inline fu::str replace_4fXW(fu::vec_range<char> str, fu::view<char> all, fu::view<char> with)
{
    /*MOV*/ fu::str result {};

    {
        int last = 0;
        int next = 0;
        const int N = all.size();
        if (N)
        {
            while (((next = find_BNNw(str, all, last)) >= 0))
            {

                {
                    fu::view<char> substr = fu::get_view(str, last, next);
                    const bool first = !last;
                    if (!first)
                        result += with;

                    result += substr;
                };
                last = (next + N);
            };
        };
        if (last)
        {
            fu::view<char> substr = fu::get_view(str, last);
            result += with;
            result += substr;
        }
        else
            return fu::str(str);

    };
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF___VC65SQ7prhd
                                #define DEF___VC65SQ7prhd
inline static fu::str _VC65(const SolvedNode_efhg& _, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    return explainType_gDsn(_.type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options);
}
                                #endif

                                #ifndef DEF_map_vuLiGlTDCza
                                #define DEF_map_vuLiGlTDCza
inline fu::vec<fu::str> map_vuLi(fu::view<SolvedNode_efhg> a, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    /*MOV*/ fu::vec<fu::str> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _VC65(a[i], ss, ctx, _here, module, options);

    return /*NRVO*/ res;
}
                                #endif

static fu::str explainBadCallArguments_gDsn(fu::view<char> id, fu::view<Target_VZrr> targets, fu::view<SolvedNode_efhg> args, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options)
{
    return ((targets.size() == 1) ? str_FDl5(targets[0], false, ss, ctx, _here, module, options) : qID_e44U(id)) + (args ? ((" with args ("_view + join_yqDb(map_vuLi(args, ss, ctx, _here, module, options), ", "_view)) + ")"_view) : fu::str{});
}

                                #ifndef DEF_last_lPg0jsdpkFd
                                #define DEF_last_lPg0jsdpkFd
inline fu::vec_range<char> last_lPg0(fu::view<fu::str> a)
{
    return a[(a.size() - 1)];
}
                                #endif

static Target_VZrr tryMatchCall_gDsn(fu::str&& id, Reorder_0MNg& reorder_out, fu::vec_range_mut<fu::vec<Target_VZrr>> conversions_out, fu::vec_range_mut<char> error, const bool local_scope, const Scope_blWT& misc_scope, fu::view<SolvedNode_efhg> args, const Flags_Lzg8 flags, fu::view<Target_VZrr> targets, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    const int error_len0 = error.size();
    for (int i = 0; i < args.size(); i++)
    {
        if (!args[i].kind)
            BUG_gDsn("Falsy arg.kind!"_view, ss, ctx, _here, module, options, _helpers);

    };
    Target_VZrr matchIdx {};
    Target_VZrr ambigOkIdx {};
    int minArity = args.size();
    const int numUsings = count_VLWP(ss._scope.usings, ss._ss.usings);
    const int explicitArity = minArity;
    const int maxArity = (explicitArity + numUsings);
    NamedArgs_UjiQ namedArgs = ((flags & Flags_Lzg8_F_CALL_HAS_NAMED_ARGS) ? collectNamedArgs_5Te1(args, minArity, ss, ctx, _here, module, options, _helpers) : NamedArgs_UjiQ{});
    fu::str reusable_mangle {};
    const int considerFieldItems = ((!targets && ((flags & Flags_Lzg8_F_CALL_HAS_DOT) || !minArity) && (minArity <= 1)) ? maxArity : 0);
    fu::vec<fu::str> alternate_ids {};
    fu::vec<fu::vec<Target_VZrr>> conversions {};
    Reorder_0MNg reorder {};
    for (bool isExplicitConversion = false; ; (isExplicitConversion = true))
    {
        const SolvedNode_efhg& explore = ((flags & Flags_Lzg8_F_CALL_HAS_DOT) ? first_GSzO(args) : (*(SolvedNode_efhg*)fu::NIL));
        fu::vec<ScopeItem_xiLD> field_items = fu::vec<ScopeItem_xiLD>((considerFieldItems ? ((is_zeroes_9CJm(explore.type.vtype) || error) ? (local_scope ? ss._scope.globals : misc_scope.globals) : convCache_considerFieldItems_gDsn(explore.type, flags, _current_fn, ss, ctx, _here, module, options, _helpers)) : (*(fu::vec<ScopeItem_xiLD>*)fu::NIL)));
        fu::vec<Target_VZrr> extra_items {};
        if (local_scope && !targets)
        {
            BitSet_mmp7 seen {};
            if (flags & (Flags_Lzg8_F_CALL_HAS_DOT | Flags_Lzg8_F_OPERATOR))
            {
                const int N = ((flags & Flags_Lzg8_F_CALL_HAS_DOT) ? 1 : args.size());
                for (int i_1 = 0; i_1 < N; i_1++)
                    visitTypeImports_gDsn(args[i_1].type, id, local_scope, extra_items, seen, ss, ctx, _here, module);

            }
            else if (numUsings)
                each_VZN2(ss._scope.usings, ss._ss.usings, 0, id, local_scope, extra_items, seen, ss, ctx, _here, module);

        };
        int scope_iterator {};
        Target_VZrr overloadIdx {};
        if (!local_scope && extra_items)
            BUG_gDsn("!local_scope but extra_items"_view, ss, ctx, _here, module, options, _helpers);
        else
        {
            bool shadows {};
            while ((overloadIdx = (targets ? Target_VZrr(search_FjkY(targets, scope_iterator)) : (local_scope ? search_z0Qq(((flags & Flags_Lzg8_F_IMPLICIT) ? ss._scope.implicits : ss._scope.items), id, scope_iterator, ((flags & Flags_Lzg8_F_IMPLICIT) ? ss._ss.implicits : ss._ss.items), shadows, extra_items, field_items, ctx, _here) : search_KHWe(fu::get_view_start0(misc_scope.items, misc_scope.pub_items), id, scope_iterator, field_items)))))
            { {
                if (!local_scope && shadows)
                    BUG_gDsn("!local_scope but shadows"_view, ss, ctx, _here, module, options, _helpers);
                else
                {
                    bool TODO_FIX_dontBotherSpecializing = false;
                    conversions.clear();
                    clear_iUdw(reorder);
                    ensureLazySolved_gDsn(overloadIdx, _current_fn, ss, ctx, _here, module, options, _helpers);
                    const Overload_aO3i& overload = GET_gDsn(overloadIdx, ss, ctx, _here, module);
                    const Kind_Idfg kind = overload.kind;
                    const bool isType = (kind == Kind_Idfg_type);
                    if (minArity && isType && !targets)
                    { {
                        const Struct_LDkB& s = tryLookupUserType_1qjp(overload.type.vtype, ctx, _here, module);
                        fu::vec_range<char> alt = (s ? (s.name ? s.name : BUG_gDsn("No usertype.name"_view, ss, ctx, _here, module, options, _helpers)) : (is_primitive_hxWW(overload.type.vtype) ? overload.type.vtype.canon : (__extension__ (
                        {
                            goto BL_17;
                            (void)0;
                        }), fu::unreachable)));
                        if (alt != id)
                            alternate_ids.push(fu::str(alt));

                      } BL_17:;
                    };
                    const Extended_z0HS& arity = EXT_gDsn(overloadIdx, ss, ctx, module);
                    const bool isZeroInit = (isType ? !explicitArity : false);
                    if (!isZeroInit && ((arity.max < minArity) || (arity.min > maxArity)))
                    {
                        if (arity.min > arity.max)
                        {
                            if (error)
                            {
                                error += ((("\n\n\t"_view + explainWhichFn_gDsn(Target_VZrr(overloadIdx), fu::view<fu::vec<Target_VZrr>>{}, fu::view<char>{}, CodeFmt_snPx_NoContext, _current_fn, ss, ctx, _here, module, options)) + "\n\t    "_view) + (((x7E_rA00(((("Declaration cycle, signature not yet available."_view + "\n\n\t    To fix this, you might need to shuffle functions around"_view) + "\n\t\tuntil every dependency (type annot or arg default expr)"_view) + "\n\t\tof "_view), str_FDl5(overloadIdx, false, ss, ctx, _here, module, options)) + " is declared above it."_view) + "\n\n\t    This borders on a compiler bug, sorry about it,"_view) + "\n\t\twe gotta come up with a better solve order algorithm."_view));
                            };
                        }
                        else if (error)
                        {
                            error += ((("\n\n\t"_view + explainWhichFn_gDsn(Target_VZrr(overloadIdx), fu::view<fu::vec<Target_VZrr>>{}, fu::view<char>{}, CodeFmt_snPx_NoContext, _current_fn, ss, ctx, _here, module, options)) + "\n\t    "_view) + (((("Wrong number of arguments: expects "_view + str_q5Q6(arity.min, arity.max)) + ", got "_view) + str_q5Q6(minArity, maxArity)) + "."_view));
                        };
                    }
                    else
                    {
                        if (isExplicitConversion)
                        {
                            if (overload.kind == Kind_Idfg_fn)
                            {
                                if (is_Typename_9CJm(overload.type))
                                {
                                    if (error)
                                    {
                                        error += ((("\n\n\t"_view + explainWhichFn_gDsn(Target_VZrr(overloadIdx), fu::view<fu::vec<Target_VZrr>>{}, fu::view<char>{}, CodeFmt_snPx_NoContext, _current_fn, ss, ctx, _here, module, options)) + "\n\t    "_view) + "Not a conversion function: returns a type."_view);
                                    };
                                    continue;
                                };
                            }
                            else if (overload.kind != Kind_Idfg_template)
                            {
                                if (error)
                                {
                                    error += ((("\n\n\t"_view + explainWhichFn_gDsn(Target_VZrr(overloadIdx), fu::view<fu::vec<Target_VZrr>>{}, fu::view<char>{}, CodeFmt_snPx_NoContext, _current_fn, ss, ctx, _here, module, options)) + "\n\t    "_view) + "Not a conversion function."_view);
                                };
                                continue;
                            };
                        };
                        fu::vec<Argument_bbKc> host_args = fu::vec<Argument_bbKc>(arity.args);
                        const int num_usings = ((!isZeroInit && (arity.min > explicitArity)) ? (arity.min - explicitArity) : 0);
                        if (!namedArgs.names)
                            reorderByNumUsings_gDsn(reorder, host_args, args.size(), num_usings);
                        else if (!reorderByArgIDs_gDsn(reorder, namedArgs.names, BitSet_mmp7(namedArgs.optional), host_args, num_usings, ss, ctx, _here, module, options, _helpers))
                        {
                            if (error)
                            {
                                error += ((("\n\n\t"_view + explainWhichFn_gDsn(Target_VZrr(overloadIdx), fu::view<fu::vec<Target_VZrr>>{}, fu::view<char>{}, CodeFmt_snPx_NoContext, _current_fn, ss, ctx, _here, module, options)) + "\n\t    "_view) + ERRMSG_findUnmatchedArgName_gDsn(reorder, namedArgs.names, host_args, Target_VZrr{}, _current_fn, ss, ctx, _here, module, options));
                            };
                            continue;
                        };
                        if (namedArgs.optional && reorder && (reorder.map.size() < args.size()) && (reorder.map.size() < arity.max))
                        {
                            if (error)
                            {
                                error += ((("\n\n\t"_view + explainWhichFn_gDsn(Target_VZrr(overloadIdx), fu::view<fu::vec<Target_VZrr>>{}, fu::view<char>{}, CodeFmt_snPx_NoContext, _current_fn, ss, ctx, _here, module, options)) + "\n\t    "_view) + ERRMSG_optionalArgumentAmbiguity_gDsn(host_args, reorder, namedArgs.names, _current_fn, ss, ctx, _here, module, options));
                            };
                        }
                        else
                        {
                            Type_OiTm REST_TYPE {};
                            const int REST_START = findRestStart_gDsn(arity);
                            if ((REST_START < host_args.size()) && reorder && (reorder.map.size() < args.size()))
                            {
                                for (int i_1 = 0; i_1 < args.size(); i_1++)
                                {
                                    if (!has_ZwXY(namedArgs.optional, i_1) && !has_b66p(reorder.map, i_1))
                                        reorder.map += i_1;

                                };
                            };
                            const int N = max_BjFA((reorder ? reorder.map.size() : args.size()), (!isZeroInit ? arity.min : 0));
                            if (N)
                            {
                                if (REST_START < N)
                                {
                                    const Type_OiTm& expect = host_args[REST_START].type;
                                    if (expect)
                                    {
                                        Type_OiTm _0 {};
                                        REST_TYPE = ((_0 = tryClear_sliceable_1qjp(expect.vtype, ctx, _here, module)) ? static_cast<Type_OiTm&&>(_0) : fail_gDsn(((GET_gDsn(overloadIdx, ss, ctx, _here, module).name + ": Rest argument annotation is not an array: "_view) + explainType_gDsn(expect, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers));
                                    };
                                };
                                if ((reorder.map.size() >= args.size()) || !reorder || namedArgs.optional)
                                {
                                    for (int i_1 = 0; i_1 < N; i_1++)
                                    {
                                        const bool rest = (i_1 >= REST_START);
                                        const int host_argIdx = (rest ? REST_START : i_1);
                                        const Argument_bbKc& host_arg = host_args[host_argIdx];
                                        Type_OiTm expect = (rest ? REST_TYPE : host_arg.type);
                                        const int callsiteIndex = (reorder ? reorder.map[i_1] : ((i_1 < args.size()) ? i_1 : -1));
                                        if (callsiteIndex < 0)
                                        {
                                            if (host_arg.dEfault || (host_arg.flags & Flags_Lzg8_F_IMPLICIT))
                                                continue;
                                            else
                                            {
                                                if (!((host_arg.flags & Flags_Lzg8_F_MUSTNAME) || (flags & Flags_Lzg8_F_CONVERSION)))
                                                {
                                                    if (expect)
                                                    {
                                                        /*MOV*/ fu::vec<Target_VZrr> conversion = tryConvert_GKse(expect, (*(Type_OiTm*)fu::NIL), _current_fn, ss, ctx, _here, module, options, _helpers);
                                                        if (conversion)
                                                        {
                                                            ensure_Ubhd(conversions, i_1) = static_cast<fu::vec<Target_VZrr>&&>(conversion);
                                                            continue;
                                                        };
                                                    };
                                                };
                                                if (error)
                                                {
                                                    error += ((("\n\n\t"_view + explainWhichFn_gDsn(Target_VZrr(overloadIdx), fu::view<fu::vec<Target_VZrr>>{}, fu::view<char>{}, CodeFmt_snPx_NoContext, _current_fn, ss, ctx, _here, module, options)) + "\n\t    "_view) + x7E_rA00("Cannot infer missing "_view, str_wyx7(host_arg, false, _current_fn, ss, ctx, _here, module, options)));
                                                };
                                                goto BL_14;
                                            };
                                        }
                                        else if (!expect)
                                        {
                                            const Node_JjyR& a = annot_gDsn(overloadIdx, host_argIdx, ss, ctx, module);
                                            if (a.items || (a.kind == Kind_Idfg___serialized_type))
                                            {
                                                fu::str error_1 {};
                                                const Type_OiTm& actual = args[callsiteIndex].type;
                                                Map_v4nV tp = steal_ew2w(ss._typeParams);
                                                fu_DEFER(std::swap(ss._typeParams, tp));
                                                const bool ok = trySolveTypeParams_gDsn(Node_JjyR(a), Type_OiTm(actual), error_1, false, _current_fn, ss, ctx, _here, module, options, _helpers);
                                                if (!ok)
                                                {
                                                    fu::vec<Target_VZrr> conversion = tryConvert_GJ9L(Node_JjyR(annot_gDsn(overloadIdx, host_argIdx, ss, ctx, module)), actual, _current_fn, ss, ctx, _here, module, options, _helpers);
                                                    if (conversion)
                                                        ensure_Ubhd(conversions, i_1) += conversion;

                                                };
                                            };
                                        };
                                        if (host_arg.flags & Flags_Lzg8_F_MUSTNAME)
                                        {
                                            if ((namedArgs.names.size() <= callsiteIndex) || !namedArgs.names[callsiteIndex])
                                            {
                                                if (error)
                                                {
                                                    error += ((("\n\n\t"_view + explainWhichFn_gDsn(Target_VZrr(overloadIdx), fu::view<fu::vec<Target_VZrr>>{}, fu::view<char>{}, CodeFmt_snPx_NoContext, _current_fn, ss, ctx, _here, module, options)) + "\n\t    "_view) + x7E_rA00(str_wyx7(host_arg, false, _current_fn, ss, ctx, _here, module, options), " must be :named explicitly."_view));
                                                };
                                                goto BL_14;
                                            };
                                        };
                                        if (host_arg.autocall)
                                        {
                                            fu::vec<SolvedNode_efhg> autocall_args {};
                                            Reorder_0MNg autocall_reorder {};
                                            fu::vec<fu::vec<Target_VZrr>> autocall_conversions {};
                                            autocall_args.resize(1);
                                            autocall_args.mutref(0) = SolvedNode_efhg(args[callsiteIndex]);
                                            fu::str autocall_error = (error ? (((x7E_rA00("Cannot match "_view, str_wyx7(host_arg, false, _current_fn, ss, ctx, _here, module, options)) + " autocall "_view) + qID_e44U(host_arg.autocall)) + ": "_view) : fu::str{});
                                            const Target_VZrr t = tryMatchCall_gDsn(fu::str(host_arg.autocall), autocall_reorder, autocall_conversions, autocall_error, true, (*(Scope_blWT*)fu::NIL), autocall_args, (Flags_Lzg8_F_CALL_HAS_DOT | (flags & Flags_Lzg8_F_CONVERSION)), fu::view<Target_VZrr>{}, _current_fn, ss, ctx, _here, module, options, _helpers);
                                            if (!t)
                                            {
                                                if (error)
                                                {
                                                    error += ((("\n\n\t"_view + explainWhichFn_gDsn(Target_VZrr(overloadIdx), fu::view<fu::vec<Target_VZrr>>{}, fu::view<char>{}, CodeFmt_snPx_NoContext, _current_fn, ss, ctx, _here, module, options)) + "\n\t    "_view) + replace_4fXW(autocall_error, "\t"_view, "\t\t"_view));
                                                };
                                                goto BL_14;
                                            }
                                            else
                                            {
                                                if (autocall_conversions)
                                                    ensure_Ubhd(conversions, i_1) += only_WwIr(autocall_conversions);

                                                ensure_Ubhd(conversions, i_1) += Target_VZrr(t);
                                                if (!(autocall_reorder.map.size() < 2))
                                                    BUG_gDsn("autocall: reorder"_view, ss, ctx, _here, module, options, _helpers);

                                            };
                                        };
                                        fu::view<Target_VZrr> argConv = ((conversions.size() > i_1) ? conversions[i_1] : fu::view<Target_VZrr>{});
                                        Type_OiTm actual = conversionTailType_gDsn(args[callsiteIndex].type, argConv, ss, ctx, _here, module);
                                        if (is_never_9CJm(actual.vtype))
                                        {
                                            if (!(host_arg.flags & Flags_Lzg8_F_INLINE))
                                                TODO_FIX_dontBotherSpecializing = true;

                                        }
                                        else if (!expect)
                                        {
                                            if ((host_arg.flags & Flags_Lzg8_F_TYPENAME) && !is_Typename_9CJm(actual))
                                            {
                                                if (error)
                                                {
                                                    error += ((("\n\n\t"_view + explainWhichFn_gDsn(Target_VZrr(overloadIdx), fu::view<fu::vec<Target_VZrr>>{}, fu::view<char>{}, CodeFmt_snPx_NoContext, _current_fn, ss, ctx, _here, module, options)) + "\n\t    "_view) + (x7E_rA00(str_wyx7(host_arg, false, _current_fn, ss, ctx, _here, module, options), " expects a type, got a value: "_view) + explainType_gDsn(actual, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)));
                                                };
                                                goto BL_14;
                                            };
                                        }
                                        else
                                        {
                                            if (!(isAssignableAsArgument_9CJm(expect.vtype, (actual ? actual : BUG_gDsn("tryMatch: !actual"_view, ss, ctx, _here, module, options, _helpers)).vtype, false, ctx, _here)))
                                            {
                                                if (!argConv)
                                                {
                                                    const SolvedNode_efhg& arg = args[callsiteIndex];
                                                    const SolvedNode_efhg& arg_1 = ((arg.kind == Kind_Idfg_argid) ? only_S4ER(arg.items) : arg);
                                                    Type_OiTm retype = tryRetyping_gDsn(arg_1, expect, ss, ctx, _here, module, options, _helpers);
                                                    if (retype && isAssignableAsArgument_9CJm(expect.vtype, retype.vtype, false, ctx, _here))
                                                        continue;

                                                };
                                                if (!(flags & Flags_Lzg8_F_CONVERSION))
                                                {
                                                    fu::vec<Target_VZrr> conversion = tryConvert_GKse(expect, actual, _current_fn, ss, ctx, _here, module, options, _helpers);
                                                    if (conversion)
                                                    {
                                                        ensure_Ubhd(conversions, i_1) += conversion;
                                                        continue;
                                                    };
                                                };
                                                if (error)
                                                {
                                                    error += ((("\n\n\t"_view + explainWhichFn_gDsn(Target_VZrr(overloadIdx), fu::view<fu::vec<Target_VZrr>>{}, fu::view<char>{}, CodeFmt_snPx_NoContext, _current_fn, ss, ctx, _here, module, options)) + "\n\t    "_view) + (x7E_rA00(str_wyx7(host_arg, false, _current_fn, ss, ctx, _here, module, options), " "_view) + explainNotAssignable_gDsn(expect, actual, _current_fn, ss, ctx, _here, module, options)));
                                                };
                                                goto BL_14;
                                            };
                                        };
                                    };
                                    if (REST_START < N)
                                    {
                                        for (int i_2 = REST_START; i_2 < N; i_2++)
                                        {
                                            const int callsiteIndex = (reorder ? reorder.map[i_2] : i_2);
                                            Type_OiTm actual = conversionTailType_gDsn(args[callsiteIndex].type, ((conversions.size() > i_2) ? conversions[i_2] : fu::view<Target_VZrr>{}), ss, ctx, _here, module);
                                            Type_OiTm _1 {};
                                            REST_TYPE = ((i_2 == REST_START) ? solveArrlit_itemType_init_gDsn(actual, ss, ctx, _here, module, options, _helpers) : ((_1 = type_trySuper_9CJm(REST_TYPE, actual, false, ctx, _here)) ? static_cast<Type_OiTm&&>(_1) : (__extension__ (
                                            {
                                                if (error)
                                                {
                                                    error += ((("\n\n\t"_view + explainWhichFn_gDsn(Target_VZrr(overloadIdx), fu::view<fu::vec<Target_VZrr>>{}, fu::view<char>{}, CodeFmt_snPx_NoContext, _current_fn, ss, ctx, _here, module, options)) + "\n\t    "_view) + ((("Rest arguments have no common supertype: "_view + explainType_gDsn(REST_TYPE, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)) + " <- "_view) + explainType_gDsn(actual, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)));
                                                };
                                                goto BL_14;
                                                (void)0;
                                            }), fu::unreachable)));
                                        };
                                        REST_TYPE = solveArrlit_done_gDsn(REST_TYPE, -1, options);
                                    };
                                }
                                else
                                    BUG_gDsn(x7E_rA00((x7E_rA00("reorder < args:\n\t\treorder="_view, fu::i64dec(reorder.map.size())) + "\n\t\t#args="_view), fu::i64dec(args.size())), ss, ctx, _here, module, options, _helpers);

                            };
                            if ((kind == Kind_Idfg_template) && !TODO_FIX_dontBotherSpecializing)
                            {
                                fu::str cant_reuse {};
                                fu::str& args_mangled = ((reorder || conversions) ? cant_reuse : reusable_mangle);
                                const int err0 = error.size();
                                if (error)
                                {
                                    error += ((("\n\n\t"_view + explainWhichFn_gDsn(Target_VZrr(overloadIdx), fu::view<fu::vec<Target_VZrr>>{}, fu::view<char>{}, CodeFmt_snPx_NoContext, _current_fn, ss, ctx, _here, module, options)) + "\n\t    "_view) + fu::view<char>{});
                                };
                                const Target_VZrr specIdx = trySpecialize_gDsn(overloadIdx, args, args_mangled, error, REST_START, REST_TYPE, reorder, conversions, _current_fn, ss, ctx, _here, module, options, _helpers);
                                if (is_SPECFAIL_gDsn(specIdx))
                                {
                                    if (!err0 || (err0 < error.size()))
                                        continue;
                                    else
                                        BUG_gDsn("tryMatch: is_SPECFAIL but trySpec provides no error message."_view, ss, ctx, _here, module, options, _helpers);

                                }
                                else
                                {
                                    ensureLazySolved_gDsn((overloadIdx = specIdx), _current_fn, ss, ctx, _here, module, options, _helpers);
                                    if (isExplicitConversion && is_Typename_9CJm(GET_gDsn(overloadIdx, ss, ctx, _here, module).type))
                                    {
                                        if (error)
                                        {
                                            error += ((("\n\n\t"_view + explainWhichFn_gDsn(Target_VZrr(overloadIdx), fu::view<fu::vec<Target_VZrr>>{}, fu::view<char>{}, CodeFmt_snPx_NoContext, _current_fn, ss, ctx, _here, module, options)) + "\n\t    "_view) + "Not a conversion function: returns a type."_view);
                                        };
                                        continue;
                                    };
                                };
                            };
                            if (ambigOkIdx && !TODO_FIX_dontBotherSpecializing)
                                matchIdx = ambigOkIdx;

                            if (matchIdx)
                            {
                                if (matchIdx == overloadIdx)
                                {
                                    if (!(GET_gDsn(matchIdx, ss, ctx, _here, module).kind == Kind_Idfg_enumv))
                                    {
                                        BUG_gDsn(("tryMatchCall: Tested the same overload twice: "_view + explainWhichFn_gDsn(Target_VZrr(matchIdx), conversions_out, fu::view<char>{}, CodeFmt_snPx_NoContext, _current_fn, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);
                                    };
                                }
                                else
                                {
                                    fail_gDsn((((((("Ambiguous call to "_view + explainBadCallArguments_gDsn(id, targets, args, ss, ctx, _here, module, options)) + ", matches multiple items in scope:\n"_view) + "\n\t"_view) + explainWhichFn_gDsn(Target_VZrr(matchIdx), conversions_out, fu::view<char>{}, CodeFmt_snPx_NoContext, _current_fn, ss, ctx, _here, module, options)) + "\n\t"_view) + explainWhichFn_gDsn(Target_VZrr(overloadIdx), conversions, fu::view<char>{}, CodeFmt_snPx_NoContext, _current_fn, ss, ctx, _here, module, options)), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                                };
                            }
                            else
                            {
                                if (TODO_FIX_dontBotherSpecializing)
                                    ambigOkIdx = overloadIdx;
                                else
                                    matchIdx = overloadIdx;

                                std::swap(reorder, reorder_out);
                                conversions.swap(conversions_out);
                                if (shadows)
                                    break;

                            };
                        };
                    };
                };
              } BL_14:;
            };
            if (!alternate_ids)
                break;
            else
            {
                id = last_lPg0(alternate_ids);
                alternate_ids.pop();
            };
        };
    };
    if (error && (error.size() == error_len0) && !matchIdx)
        error += isNotDefinedHere_gDsn(id);

    return (matchIdx ? matchIdx : ambigOkIdx);
}

static Target_VZrr matchCall_gDsn(const Scope_blWT& misc_scope, const bool local_scope, fu::vec_range<char> id, fu::view<SolvedNode_efhg> args, Reorder_0MNg& reorder, fu::vec_range_mut<fu::vec<Target_VZrr>> conversions, const Flags_Lzg8 flags, fu::view<Target_VZrr> targets, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    fu::str error {};
    const Target_VZrr ret = tryMatchCall_gDsn(fu::str(id), reorder, conversions, error, local_scope, misc_scope, args, flags, targets, _current_fn, ss, ctx, _here, module, options, _helpers);
    if (ret)
        return ret;
    else
    {
        error = (("Bad call to "_view + explainBadCallArguments_gDsn(id, targets, args, ss, ctx, _here, module, options)) + ": "_view);
        const Target_VZrr debug = tryMatchCall_gDsn(fu::str(id), reorder, conversions, error, local_scope, misc_scope, args, flags, targets, _current_fn, ss, ctx, _here, module, options, _helpers);
        if (debug)
            BUG_gDsn(x7E_rA00("Did match on second pass: "_view, str_FDl5(debug, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);
        else
        {
            fail_gDsn(error, fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
        };
    };
}

static SolvedNode_efhg solveCall_FDl5(fu::str&& id, /*MOV*/ fu::vec<SolvedNode_efhg>&& args, const Flags_Lzg8 flags, fu::view<Target_VZrr> targets, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    if (id || targets)
    {
        const Flags_Lzg8 qualified = (flags & Flags_Lzg8_F_COMPOUND_ID);
        const Scope_blWT& misc_scope = (qualified ? dequalify_andGetScope_gDsn(id, ss, ctx, _here, module, options, _helpers) : (*(Scope_blWT*)fu::NIL));
        Reorder_0MNg reorder {};
        fu::vec<fu::vec<Target_VZrr>> conversions {};
        const Target_VZrr callTargIdx = matchCall_gDsn(misc_scope, !qualified, id, args, reorder, conversions, flags, targets, _current_fn, ss, ctx, _here, module, options, _helpers);
        return CallerNode_gDsn(id, Target_VZrr(callTargIdx), args.destructive_move(), reorder, conversions, _current_fn, ss, ctx, _here, module, options, _helpers);
    }
    else
        BUG_gDsn("solveCall: No id, no target."_view, ss, ctx, _here, module, options, _helpers);

}

static Type_OiTm Scope_lookupType_gDsn(fu::vec_range<char> id, const Flags_Lzg8 flags, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    /*MOV*/ SolvedNode_efhg callsite = solveCall_FDl5(fu::str(id), fu::vec<SolvedNode_efhg>{}, flags, fu::view<Target_VZrr>{}, _current_fn, ss, ctx, _here, module, options, _helpers);
    if (callsite.kind != Kind_Idfg_empty)
    {
        fail_gDsn((("No type "_view + qBAD_e44U(id)) + " in scope."_view), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
    }
    else if (callsite.type.vtype.vfacts & VFacts_xhRf_Typename)
        return static_cast<Type_OiTm&&>(callsite.type);
    else
        BUG_gDsn("Scope_lookupType: empty, but no vfacts.Typename"_view, ss, ctx, _here, module, options, _helpers);

}

static Type_OiTm evalTypeParam_gDsn(fu::vec_range<char> id, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    Type_OiTm _0 {};
    return (_0 = Type_OiTm(get_mPhm(ss._typeParams, id).matched)) ? static_cast<Type_OiTm&&>(_0) : (_0 = Scope_lookupType_gDsn((id ? id : fail_gDsn(str_t1l2m4rwGi0, fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers)), Flags_Lzg8{}, _current_fn, ss, ctx, _here, module, options, _helpers)) ? static_cast<Type_OiTm&&>(_0) : fail_gDsn((("No type param "_view + qID_e44U(id)) + " in scope."_view), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
}

static Type_OiTm evalTypeAnnot_gDsn(const Node_JjyR& node, const bool TODO_FIX_typeof_dontStripRefs, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    const TokenIdx_5581 here0 = _here;
    fu_DEFER(_here = here0);
    _here = node.token;
    if (node.kind == Kind_Idfg_call)
    {
        fu::view<Node_JjyR> items = node.items;
        if (items.size() == 1)
        {
            if (node.value == "&"_view)
            {
                return add_ref_9CJm(T_gDsn(node, _current_fn, ss, ctx, _here, module, options, _helpers), Lifetime_temporary, ctx, _here);
            }
            else if (node.value == "&mut"_view)
            {
                return add_mutref_9CJm(T_gDsn(node, _current_fn, ss, ctx, _here, module, options, _helpers), Lifetime_temporary, ctx, _here);
            }
            else if (node.value == "[]"_view)
                return createArray_9CJm(T_gDsn(node, _current_fn, ss, ctx, _here, module, options, _helpers));
            else if (node.value == "[..]"_view)
            {
                return createSlice_9CJm(T_gDsn(node, _current_fn, ss, ctx, _here, module, options, _helpers), Lifetime_temporary, ctx, _here);
            }
            else if (node.value == "typeof"_view)
            {
                /*MOV*/ Type_OiTm type = solveNode_gDsn(only_hN9E(node.items), (*(Type_OiTm*)fu::NIL), _current_fn, ss, ctx, _here, module, options, _helpers).type;
                if (is_Typename_9CJm(type))
                {
                    _here = only_hN9E(node.items).token;
                    fail_gDsn(((("Redundant "_view + qBAD_e44U("typeof"_view)) + ", this is a type, not a value: "_view) + explainType_gDsn(type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                }
                else
                {
                    if (!TODO_FIX_typeof_dontStripRefs)
                        type = clear_Typename_9CJm(relax_typeParam_9CJm(Type_OiTm(type)), false);

                    return /*NRVO*/ type;
                };
            };
        };
    }
    else if (node.kind == Kind_Idfg_definit)
        return Type_OiTm(t_zeroes);
    else if (node.kind == Kind_Idfg___serialized_type)
    {
        return Type_OiTm { parseType_1qjp(node.value, ctx, _here, module), Lifetime_llCF{} };
    };
    /*MOV*/ Type_OiTm exprType = ((node.kind == Kind_Idfg_typeparam) ? evalTypeParam_gDsn(node.value, _current_fn, ss, ctx, _here, module, options, _helpers) : solveNode_gDsn(node, (*(Type_OiTm*)fu::NIL), _current_fn, ss, ctx, _here, module, options, _helpers).type);
    if (!is_Typename_9CJm(exprType))
    {
        fail_gDsn(("Invalid type annotation: evaluates to a value, not a type."_view + " Consider wrapping it in typeof()."_view), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
    }
    else
        return clear_Typename_9CJm(static_cast<Type_OiTm&&>(exprType), true);

}

static const fu::str& getBasePrim_gDsn(const Type_OiTm& type, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const int offset = basePrimPrefixLen_hxWW(type.vtype.canon);
    if (offset < type.vtype.canon.size())
        return lookupUserType_gDsn(type, ss, ctx, _here, module, options, _helpers).shape.basePrim;
    else
        return type.vtype.canon;

}

static fu::str TODO_FIX_getSpecPat_gDsn(const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    const Target_VZrr& spec_of = (_current_fn.out.target ? EXT_gDsn(_current_fn.out.target, ss, ctx, module).spec_of : (*(Target_VZrr*)fu::NIL));
    if (!spec_of)
    {
        return fu::str{};
    }
    else
    {
        /*MOV*/ fu::str specPat {};
        for (int i = 0; i < (_current_fn.out.items.size() + FN_ARGS_BACK); i++)
        {
            const SolvedNode_efhg& arg = _current_fn.out.items[i];
            const SolvedNode_efhg& arg_1 = ((arg.kind == Kind_Idfg_letdef) ? GET_gDsn(arg.target, ss, ctx, _here, module).solved : arg);
            if (!specPat)
            {
                specPat = fu::str("("_fu);
                appendGlobal_xQNS(specPat, spec_of);
            }
            else
                specPat += ":"_view;

            specPat += serializeType_1qjp(arg_1.type.vtype, "TODO_FIX_getSpecPat"_view);
        };
        if (specPat)
            specPat += ")"_view;

        return /*NRVO*/ specPat;
    };
}

static Type_OiTm initStruct_gDsn(const Kind_Idfg kind, const Shape_fvCX& shape, fu::vec_range<char> name, const DeclAsserts_taUG asserts, fu::view<char> specPat, const uint64_t initialHash, Module_wo7O& module)
{
    if (fu::u8((fu::u8(fu::u8(name[0])) - fu::u8(fu::u8('0')))) > fu::u8(unsigned(9)))
    {
        const int index = module.out.types.size();
        module.out.types += Struct_LDkB { kind, fu::str(name), Target_VZrr{}, fu::vec<ScopeItem_xiLD>{}, fu::vec<ScopeItem_xiLD>{}, Set_qOJY{}, fu::vec<Target_VZrr>{}, Shape_fvCX(shape) };
        /*MOV*/ fu::str canon = createStructCanon_p1TN(kind, shape.basePrim, module.modid, index, specPat, initialHash);
        return Type_OiTm { ValueType_JtNg { speculateStruct_9CJm(asserts, shape.flatCount), VFacts_xhRf{}, canon.destructive_move() }, Lifetime_llCF{} };
    }
    else
        fu::fail((("Bad struct name, leading digit: `"_view + name) + "`."_view));

}

static SolvedNode_efhg solveMember_gDsn(const Node_JjyR& node, const bool isPrimDecl, const Type_OiTm& primType, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    if (node.kind == Kind_Idfg_let)
    {
        if (!isPrimDecl && node.items[LET_INIT] && (node.items[LET_INIT].kind != Kind_Idfg_definit))
        {
            fail_gDsn(((("All structs must be zerofilled by default."_view + " Please remove the initializer of struct member "_view) + qBAD_e44U(node.value)) + "."_view), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
        }
        else
        {
            /*MOV*/ SolvedNode_efhg ret = solveLetLike_dontTouchScope_gDsn(node, false, (*(Type_OiTm*)fu::NIL), primType, _current_fn, ss, ctx, _here, module, options, _helpers);
            ret.type.vtype.vfacts = VFacts_xhRf{};
            return /*NRVO*/ ret;
        };
    }
    else
        BUG_gDsn(x7E_rA00("solveStructMembers_1: "_view, str_eN8k(node.kind)), ss, ctx, _here, module, options, _helpers);

}

                                #ifndef DEF_map_d6DhBUpLHr8
                                #define DEF_map_d6DhBUpLHr8
inline fu::vec<SolvedNode_efhg> map_d6Dh(fu::view<Node_JjyR> a, const bool isPrimDecl, const Type_OiTm& primType, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    /*MOV*/ fu::vec<SolvedNode_efhg> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = solveMember_gDsn(a[i], isPrimDecl, primType, _current_fn, ss, ctx, _here, module, options, _helpers);

    return /*NRVO*/ res;
}
                                #endif

static void field_setParentStruct_gDsn(Overload_aO3i& o, const Target_VZrr& structTarget, const Context_noPA& ctx, const TokenIdx_5581& _here)
{
    (!o.solved.target ? o.solved.target : BUG_u9Gb("field_setParentStruct: solved.target already set."_view, ctx, _here)) = Target_VZrr(structTarget);
}

                                #ifndef DEF___kYpp7KAjxng
                                #define DEF___kYpp7KAjxng
inline static void _kYpp(const ScopeItem_xiLD& item, Struct_LDkB& s, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    if (GET_gDsn(target_z0Qq(item), ss, ctx, _here, module).flags & Flags_Lzg8_F_IMPLICIT)
        s.implicits.push(ScopeItem_xiLD(item));

}
                                #endif

                                #ifndef DEF_each_9F58oo66zDk
                                #define DEF_each_9F58oo66zDk
inline void each_9F58(fu::view<ScopeItem_xiLD> a, Struct_LDkB& s, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    for (int i = 0; i < a.size(); i++)
        _kYpp(a[i], s, ss, ctx, _here, module);

}
                                #endif

static fu::str TODO_FIX_getRecursionError_gDsn(const Struct_LDkB& other, const Type_OiTm& instType, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    for (int i = 0; i < other.items.size(); i++)
    {
        const Target_VZrr item = target_z0Qq(other.items[i]);
        const Type_OiTm& itemType = GET_gDsn(item, ss, ctx, _here, module).type;
        if (isStruct_p1TN(itemType.vtype))
        {
            fu::str rec {};
            if ((itemType.vtype.canon == instType.vtype.canon) || (rec = TODO_FIX_getRecursionError_gDsn(lookupUserType_gDsn(itemType, ss, ctx, _here, module, options, _helpers), instType, _current_fn, ss, ctx, _here, module, options, _helpers)))
            {
                return ("\n\t\tvia "_view + explainWhichFn_gDsn(Target_VZrr(item), fu::view<fu::vec<Target_VZrr>>{}, fu::view<char>{}, CodeFmt_snPx_FullContext, _current_fn, ss, ctx, _here, module, options)) + rec;
            };
        };
    };
    return fu::str{};
}

                                #ifndef DEF_add_zDVnYxPphb1
                                #define DEF_add_zDVnYxPphb1
inline void add_zDVn(fu::vec_range_mut<int> a, fu::view<int> b)
{
    int x = 0;
    int y = 0;
    while ((x < a.size()) && (y < b.size()))
    {
        const int X = a[x];
        const int Y = b[y];
        const int cmp = x3Cx3E_odNT(X, Y);
        if ((cmp >= 0))
        {
            if (cmp != 0)
            {
                a.insert(x, Y);
                y++;
            }
            else
                y++;

        };
        x++;
    };
    if (y < b.size())
        a += fu::get_view(b, y);

}
                                #endif

static void field_packOffset_gDsn(Overload_aO3i& o, const int memberFlatOffset, const int memberFlatCount, const Context_noPA& ctx, const TokenIdx_5581& _here)
{
    const int packed = (memberFlatOffset | (memberFlatCount << 16));
    if (o.kind == Kind_Idfg_field)
    {
        o.solved.helpers = Helpers_DyqV { packed };
    }
    else
        BUG_u9Gb("field_packOffset: Not a field."_view, ctx, _here);

}

                                #ifndef DEF_iF_Z5B6QQ08PF4
                                #define DEF_iF_Z5B6QQ08PF4
inline const Node_JjyR& iF_Z5B6(fu::view<Node_JjyR> a, const int i)
{
    if (uNsigned_40Hl(i) < uNsigned_40Hl(a.size()))
        return a[i];
    else
        return (*(Node_JjyR*)fu::NIL);

}
                                #endif

                                #ifndef DEF___xCFC7ltsSj5
                                #define DEF___xCFC7ltsSj5
inline static bool _xCFC(const int import, Set_qOJY& structImports)
{
    return add_q7Be(structImports, import);
}
                                #endif

                                #ifndef DEF_each_uxD7mDaemkd
                                #define DEF_each_uxD7mDaemkd
inline void each_uxD7(fu::view<int> items, fu::view<ScopeSkip_iozY> scope_skip, const int start, Set_qOJY& structImports)
{
    const ScopeSkip_iozY END_DUMMY = ScopeSkip_iozY { items.size(), items.size() };
    int i0 = start;
    for (int i = 0; i < (scope_skip.size() + 1); i++)
    {
        const ScopeSkip_iozY& ss = ((i < scope_skip.size()) ? scope_skip[i] : END_DUMMY);
        if (!((ss.end <= i0)))
        {
            const int i1 = ss.start;
            for (int i_1 = i0; i_1 < i1; i_1++)
                _xCFC(items[i_1], structImports);

            i0 = ss.end;
        };
    };
}
                                #endif

                                #ifndef DEF___BsEYL6oledg
                                #define DEF___BsEYL6oledg
inline static bool _BsEY(const SolvedNode_efhg& member)
{
    return !is_rx_copy_9CJm(member.type.vtype);
}
                                #endif

                                #ifndef DEF_some_nX91LwovFVa
                                #define DEF_some_nX91LwovFVa
inline bool some_nX91(fu::view<SolvedNode_efhg> a)
{
    for (int i = 0; i < a.size(); i++)
    {
        const SolvedNode_efhg& item = a[i];
        if (_BsEY(item))
            return true;

    };
    return false;
}
                                #endif

                                #ifndef DEF_x3Cx3E_SMCEgyf3j84
                                #define DEF_x3Cx3E_SMCEgyf3j84
inline int x3Cx3E_SMCE(const Shape_fvCX& a, const Shape_fvCX& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_XvO8(a.non_triv_mask, b.non_triv_mask)))
        return cmp;
    else if ((cmp = x3Cx3E_XvO8(a.hash, b.hash)))
        return cmp;
    else if ((cmp = x3Cx3E_odNT(a.flatCount, b.flatCount)))
        return cmp;
    else if ((cmp = x3Cx3E_odNT(a.declDepth, b.declDepth)))
        return cmp;

    if ((cmp = x3Cx3E_j5CR(a.basePrim, b.basePrim)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x21x3D_1j9SIVh6Vhj
                                #define DEF_x21x3D_1j9SIVh6Vhj
inline bool operator!=(const Shape_fvCX& a, const Shape_fvCX& b)
{
    return !!x3Cx3E_SMCE(a, b);
}
                                #endif

static SolvedNode_efhg __solveStruct_gDsn(const bool solve, const Node_JjyR& node, const Target_VZrr& into, const bool TODO_FIX_useSpecPath, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    const fu::str& origId = node.value;
    fu::vec_range<char> _0 {};
    fu::str name = fu::str((origId ? origId : (_0.ptr_reassign((_current_fn.out.target ? GET_gDsn(_current_fn.out.target, ss, ctx, _here, module).name : (*(fu::str*)fu::NIL)))) ? _0 : str_6Ccun4v3P95));
    const Kind_Idfg kind = node.kind;
    const bool isStruct = (kind == Kind_Idfg_struct);
    const bool isUnion = (kind == Kind_Idfg_union);
    const bool isPrimDecl = (!isStruct ? !isUnion : false);
    fu::view<Node_JjyR> items = (node.items ? node.items[STRUCT_MEMBERS].items : fu::view<Node_JjyR>{});
    /*MOV*/ Type_OiTm basePrimType {};
    fu::str basePrim {};
    if (isPrimDecl)
    {
        const Node_JjyR& baseannot = node.items[STRUCT_BASE];
        basePrimType = (baseannot ? evalTypeAnnot_gDsn(baseannot, false, _current_fn, ss, ctx, _here, module, options, _helpers) : Type_OiTm(t_u8));
        basePrim = getBasePrim_gDsn(basePrimType, ss, ctx, _here, module, options, _helpers);
    };
    TEA_0Daz shape_hasher = hash_s9RC(name);
    if (isPrimDecl)
        hash_l6RU(shape_hasher, ss.shortModuleName);
    else
    {
        for (int i = 0; i < items.size(); i++)
        {
            const fu::str* assertion;
            fu::vec_range<char> _1 {};
            hash_l6RU(shape_hasher, ((_1.ptr_reassign((*(assertion = &(items[i].value))))) ? _1 : BUG_u9Gb(fu::view<char>{}, ctx, _here)));
        };
    };
    const TEA_0Daz* tea;
    Shape_fvCX shape = Shape_fvCX { fu::str(basePrim), 0ull, (tea = &(shape_hasher), (uint64_t((*tea).v0) | (uint64_t((*tea).v1) << 32ull))), (isPrimDecl ? 1 : 0), 0 };
    if (isPrimDecl)
        hash_l6RU(shape_hasher, basePrim);

    const DeclAsserts_taUG asserts = node.asserts;
    Target_VZrr out_target_1;
    fu::str specPat {};
    Type_OiTm _2 {};
    const Target_VZrr& out_target = (into ? into : (specPat = ((!origId && TODO_FIX_useSpecPath) ? TODO_FIX_getSpecPat_gDsn(_current_fn, ss, ctx, _here, module) : fu::str{}), out_target_1 = (_2 = initStruct_gDsn(kind, shape, name, asserts, specPat, shape.hash, module), createRawTypedef_gDsn(origId, static_cast<Type_OiTm&&>(_2), node.flags, name, SolverStatus_h9em_SS_LAZY, ss, module)), (EXT_mut_gDsn(out_target_1, ss, module).tEmplate = createTemplate_gDsn(node, _current_fn, ss)), out_target_1));
    Type_OiTm out_Typename = GET_gDsn(out_target, ss, ctx, _here, module).type;
    /*MOV*/ Type_OiTm instType = clear_Typename_9CJm(Type_OiTm(out_Typename), false);
    if (!solve)
        return createEmpty_gDsn(t_void, out_target, ss, ctx, _here, module, options, _helpers);
    else
    {
        const Target_VZrr solvingFnort0 = exchange_GcK8(ss._solvingFnort, Target_VZrr(out_target));
        fu_DEFER(ss._solvingFnort = solvingFnort0);
        GET_mut_gDsn(out_target, ss, module).status |= SolverStatus_h9em_SS_DID_START;
        const int helpers0 = _helpers.size();
        const int helpers_data0 = ss._helpers_data.size();
        fu_DEFER(
        {
            _helpers.shrink(helpers0);
            ss._helpers_data.shrink(helpers_data0);
        });
        push_gDsn(HelpersData_uG6I { Target_VZrr((out_target ? out_target : BUG_gDsn((("solveStruct: no out_target: `"_view + origId) + "`."_view), ss, ctx, _here, module, options, _helpers))), SolverPass_zVQ2{}, HelpersMask_w1sv_HM_Struct, fu::str{}, 0, 0, Type_OiTm{}, Type_OiTm{}, Postdom_Vy5u{}, Postdom_Vy5u{}, EventsSnap_elmt{}, Helpers_DyqV{} }, ss, _helpers);
        /*MOV*/ fu::vec<Target_VZrr> structConverts {};
        /*MOV*/ Set_qOJY structImports {};
        int non_triv_reason = (!is_rx_copy_9CJm(instType.vtype) ? -1 : 0);
        const Type_OiTm& primType = (isPrimDecl ? (instType ? instType : BUG_gDsn("Falsy isPrimDecl.instType"_view, ss, ctx, _here, module, options, _helpers)) : (*(Type_OiTm*)fu::NIL));
        fu::vec<SolvedNode_efhg> members = map_d6Dh(items, isPrimDecl, primType, _current_fn, ss, ctx, _here, module, options, _helpers);

        {
            Struct_LDkB& s = lookupUserType_mut_1qjp(instType.vtype.canon, module, ctx, _here);
            if (!s.items && members)
            {
                const bool isUnscoped = !!(node.flags & Flags_Lzg8_F_USING);
                fu::vec<Argument_bbKc> args = (!isPrimDecl ? fu::vec<Argument_bbKc> {{ Argument_bbKc { fu::str("this"_fu), fu::str{}, despeculateStruct_9CJm(Type_OiTm(instType)), SolvedNode_efhg{}, Target_VZrr{}, Flags_Lzg8{}, 0u, BitSet_mmp7{}, BitSet_mmp7{} } }} : fu::vec<Argument_bbKc> {{ Argument_bbKc { fu::str("This"_fu), fu::str{}, Type_OiTm(out_Typename), (isUnscoped ? createEmpty_gDsn(out_Typename, Target_VZrr{}, ss, ctx, _here, module, options, _helpers) : SolvedNode_efhg{}), Target_VZrr{}, Flags_Lzg8{}, 0u, BitSet_mmp7{}, BitSet_mmp7{} } }});
                for (int i = 0; i < members.size(); i++)
                {
                    const Node_JjyR& item = items[i];
                    const fu::str& id = item.value;
                    const Flags_Lzg8 flags = (item.flags & (Flags_Lzg8_F_PREDICATE | Flags_Lzg8_F_IMPLICIT));
                    if (flags && isPrimDecl)
                    {
                        fail_gDsn((((("Unexpected "_view + qKW_e44U("true"_view)) + " or "_view) + qKW_e44U("implicit"_view)) + " qualifier."_view), fu::view<char>{}, TokenIdx_5581(item.token), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                    }
                    else
                    {
                        const Target_VZrr target = Scope_create_z0Qq(ss._scope, (!isPrimDecl ? Kind_Idfg_field : Kind_Idfg_enumv), (id ? id : BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers)), (*(Type_OiTm*)fu::NIL), (Flags_Lzg8_F_PUB | flags), DeclAsserts_taUG{}, SolverStatus_h9em{}, 0, false, module);
                        Extended_z0HS& ext = EXT_mut_gDsn(target, ss, module);
                        ext.args = args;
                        ext.min = ((isUnscoped && isPrimDecl) ? 0 : args.size());
                        ext.max = args.size();
                        ext.tEmplate.node.token = items[i].token;
                        Scope_set_FjkY(s.items, id, target, false);
                        field_setParentStruct_gDsn(GET_mut_gDsn(target, ss, module), out_target, ctx, _here);
                    };
                };
                if (isPrimDecl)
                    ss._scope.items += s.items;
                else
                {
                    each_9F58(s.items, s, ss, ctx, _here, module);
                    if (!_current_fn)
                        ss._scope.globals += s.items;

                };
            };
            if (s.items.size() == members.size())
            {
                for (int i = 0; i < s.items.size(); i++)
                {
                    const ScopeItem_xiLD& item = s.items[i];
                    const SolvedNode_efhg& member = members[i];
                    if (item.id == member.value)
                    {
                        const Target_VZrr field_target = target_z0Qq(item);
                        Overload_aO3i& field = GET_mut_gDsn(field_target, ss, module);
                        field.type = member.type;
                        Shape_fvCX member_shape = getShape_1qjp(member.type.vtype, ctx, _here, module);
                        int memberFlatOffset = 0;
                        if (!isPrimDecl)
                        {
                            hash_qRo1(shape_hasher, member_shape.hash);
                            shape.declDepth = max_BjFA(shape.declDepth, (member_shape.declDepth + 1));
                            memberFlatOffset = shape.flatCount;
                            shape.flatCount += member_shape.flatCount;
                            if (member_shape.non_triv_mask)
                            {
                                if (!(non_triv_reason))
                                    non_triv_reason = (non_triv_reason = (i + 1));

                                shape.non_triv_mask |= member_shape.non_triv_mask;
                            };
                        };

                        {
                            const int expect = min_DbqN(member_shape.flatCount, q_USAGE_bitsize);
                            const ValueType_JtNg* type;
                            const int actual = __builtin_popcount((type = &(member.type.vtype), ((*type).quals & q_USAGE)));
                            if ((actual == expect) || isStruct_p1TN(member.type.vtype))
                            {
                                if ((!is_trivial_1qjp(member.type.vtype, ctx, _here, module) != !!member_shape.non_triv_mask) && member_shape.flatCount)
                                    BUG_gDsn((x7E_rA00(((x7E_rA00("member.is_trivial("_view, fu::booldec(is_trivial_1qjp(member.type.vtype, ctx, _here, module))) + "),"_view) + " but non_triv_mask("_view), fu::u64dec(member_shape.non_triv_mask)) + ")"_view), ss, ctx, _here, module, options, _helpers);

                            }
                            else
                                BUG_gDsn((x7E_rA00(((x7E_rA00("member.type.usage popcount("_view, fu::i64dec(actual)) + ")"_view) + " != member_shape.flatCount("_view), fu::i64dec(member_shape.flatCount)) + ")"_view), ss, ctx, _here, module, options, _helpers);

                        };
                        fu::str recursionError = (isStruct_p1TN(member.type.vtype) ? TODO_FIX_getRecursionError_gDsn(tryLookupUserType_1qjp(member.type.vtype, ctx, _here, module), instType, _current_fn, ss, ctx, _here, module, options, _helpers) : fu::str{});
                        if (recursionError)
                        {
                            fail_gDsn(((("Type "_view + qBAD_e44U(name)) + " is self-recursive:\n"_view) + recursionError), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                        }
                        else
                        {
                            if (member.flags & Flags_Lzg8_F_USING)
                            {
                                structConverts.push(target_z0Qq(item));
                                const int m = modidOfOrigin_p1TN(field.type);
                                if (m && (m != module.modid))
                                    add_q7Be(structImports, m);

                                add_zDVn(structImports.keys_asc, lookupTypeImports_1qjp(field.type.vtype, ctx, _here, module).keys_asc);
                            };
                            if (!isPrimDecl)
                                field_packOffset_gDsn(field, memberFlatOffset, member_shape.flatCount, ctx, _here);

                        };
                    }
                    else
                        BUG_gDsn("solveStructMembers_4: field id mismatch."_view, ss, ctx, _here, module, options, _helpers);

                };
                if (isPrimDecl)
                {
                    const bool sIgned = (basePrim[0] == 'i');
                    const bool uNsigned = (basePrim[0] == 'u');
                    fu::view<char> size_str = fu::get_view(basePrim, 1);
                    const fu::u8 size = ((size_str == "8"_view) ? fu::u8(8u) : ((size_str == "16"_view) ? fu::u8(16u) : ((size_str == "32"_view) ? fu::u8(32u) : ((size_str == "64"_view) ? fu::u8(64u) : ((size_str == "128"_view) ? fu::u8(128u) : BUG_gDsn(("Enum auto-incrementer: unknown prim size: "_view + size_str), ss, ctx, _here, module, options, _helpers))))));
                    Intlit_tw2d last {};
                    for (int i_1 = 0; i_1 < s.items.size(); i_1++)
                    {
                        SolvedNode_efhg& init = GET_mut_gDsn(target_z0Qq(s.items[i_1]), ss, module).solved;
                        const SolvedNode_efhg& member = members[i_1];
                        init = member.items[LET_INIT];
                        _here = member.token;
                        if (init)
                        {
                            _here = init.token;
                            if (init.kind == Kind_Idfg_int)
                            {
                                last = Intlit_u8re(init.value);
                                if (last.error)
                                {
                                    fail_gDsn(last.error, fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                                }
                                else
                                    continue;

                            }
                            else
                                last.error = fu::str(str_enZrSJzQdHb);

                        };
                        if (last.error)
                        {
                            fail_gDsn(last.error, fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                        }
                        else if (last.negative)
                        {
                            fail_gDsn(str_K6dO536A7u6, fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                        }
                        else
                        {
                            Intlit_tw2d next = Intlit_MpuZ(((kind == Kind_Idfg_flags) ? (i_1 ? (last.absval << 1ull) : 1ull) : (last.absval + 1ull)), false, fu::str{}, uNsigned, sIgned, 10ull);
                            if (next.error || (next.absval > last.absval))
                            {
                                const fu::u8 minsize = (sIgned ? next.minsize_i : next.minsize_u);
                                if (minsize > size)
                                {
                                    fail_gDsn((x7E_rA00((x7E_rA00("Primitive range exhausted: requires "_view, fu::u64dec(minsize)) + " bits, got "_view), fu::u64dec(size)) + "."_view), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                                }
                                else
                                {
                                    last = next;
                                    if (sIgned || uNsigned)
                                    {
                                        init = SolvedNode_gDsn(Kind_Idfg_int, primType, Flags_Lzg8{}, x7E_rA00((next.negative ? "-"_view : fu::view<char>{}), fu::u64dec(next.absval)), (*(fu::vec<SolvedNode_efhg>*)fu::NIL), Target_VZrr{}, Helpers_DyqV{}, _here);
                                    }
                                    else
                                    {
                                        fail_gDsn(("Cannot auto-increment this type: "_view + basePrim), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                                    };
                                };
                            }
                            else
                            {
                                fail_gDsn((next.error ? next.error : str_6z696lkGred), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                            };
                        };
                    };
                };
            }
            else
                BUG_gDsn((((x7E_rA00((x7E_rA00((x7E_rA00("solveStructMembers_3: field lens mismatch: "_view, fu::i64dec(s.items.size())) + " vs "_view), fu::i64dec(members.size())) + "/"_view), fu::i64dec(items.size())) + ": `struct "_view) + name) + "`."_view), ss, ctx, _here, module, options, _helpers);

        };
        const TEA_0Daz* tea_1;
        shape.hash = (tea_1 = &(shape_hasher), (uint64_t((*tea_1).v0) | (uint64_t((*tea_1).v1) << 32ull)));
        if (EPH_gDsn(out_target, ss, module).callers)
            shape.hash = lookupUserType_gDsn(instType, ss, ctx, _here, module, options, _helpers).shape.hash;

        if (non_triv_reason)
        {
            if (asserts & DeclAsserts_taUG_A_TRIVIAL)
            {
                fail_gDsn((("Struct is not "_view + qKW_e44U("trivial"_view)) + ((non_triv_reason < 1) ? ((" because it is "_view + qKW_e44U("nocopy"_view)) + "."_view) : (" because of non-trivial member "_view + qID_e44U(iF_Z5B6(items, (non_triv_reason - 1)).value)))), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
            }
            else if (shape.non_triv_mask || (non_triv_reason < 0))
                shape.non_triv_mask |= (1ull << (shape.hash & 63ull));
            else
                BUG_gDsn("solveStruct: Empty non_triv_mask, but some member is non-trivial."_view, ss, ctx, _here, module, options, _helpers);

        };
        each_uxD7(ss._scope.imports, ss._ss.imports, 0, structImports);
        /*MOV*/ Type_OiTm instType_1 = static_cast<Type_OiTm&&>(instType);

        {
            bool CHANGE = false;
            if (is_rx_copy_9CJm(instType_1.vtype) && some_nX91(members))
            {
                CHANGE = true;
                instType_1 = make_non_copyable_9CJm(Type_OiTm(instType_1));
            };
            if (!isStruct && !isUnion)
            {
                if (!(shape.flatCount == 1))
                    BUG_gDsn(((x7E_rA00((x7E_rA00("solveStruct: Bad flatCount("_view, fu::i64dec(shape.flatCount)) + "): "_view), str_eN8k(kind)) + " "_view) + name), ss, ctx, _here, module, options, _helpers);

            };

            {
                Struct_LDkB& s = lookupUserType_mut_1qjp(instType_1.vtype.canon, module, ctx, _here);
                s.target = (out_target ? out_target : BUG_gDsn("solveStruct: No struct/out_target."_view, ss, ctx, _here, module, options, _helpers));
                s.converts = static_cast<fu::vec<Target_VZrr>&&>(structConverts);
                s.imports = static_cast<Set_qOJY&&>(structImports);

                {
                    Shape_fvCX shape0 = s.shape;
                    s.shape = shape;
                    if (!(CHANGE))
                        CHANGE = (shape0 != shape);

                };
                if (GET_gDsn(s.target, ss, ctx, _here, module).status & SolverStatus_h9em_SS_DID_START)
                {

                    {
                        const int actual = getFlatCount_1qjp(instType_1.vtype, ctx, _here, module);
                        if (actual != shape.flatCount)
                            BUG_gDsn((x7E_rA00((x7E_rA00("solveStruct: getFlatCount("_view, fu::i64dec(actual)) + ") !== shape.flatCount("_view), fu::i64dec(shape.flatCount)) + ")"_view), ss, ctx, _here, module, options, _helpers);

                    };
                    USAGE_setMaxUsage_CaGD(instType_1, shape.flatCount);
                }
                else
                    BUG_gDsn("solveStruct: Setting stuff but missing SS_DID_START."_view, ss, ctx, _here, module, options, _helpers);

            };
            /*MOV*/ Type_OiTm& instType_2 = instType_1;
            /*MOV*/ Type_OiTm out_Typename_1 = into_Typename_9CJm(static_cast<Type_OiTm&&>(instType_2));
            int min = 0;
            /*MOV*/ fu::vec<Argument_bbKc> args {};
            if (isPrimDecl)
            {
                args.push(Argument_bbKc { fu::str("value"_fu), fu::str{}, static_cast<Type_OiTm&&>(basePrimType), SolvedNode_efhg{}, Target_VZrr{}, Flags_Lzg8{}, 0u, BitSet_mmp7{}, BitSet_mmp7{} });
            }
            else
            {
                int N = members.size();
                if (N && isUnion)
                    N = 1;

                for (int i = 0; i < N; i++)
                {
                    const SolvedNode_efhg& member = members[i];
                    SolvedNode_efhg _3 {};
                    /*MOV*/ Argument_bbKc arg = Argument_bbKc { fu::str((member.value ? member.value : BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers))), fu::str{}, Type_OiTm((member.type ? member.type : BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers))), ((_3 = SolvedNode_efhg(member.items[LET_INIT])) ? static_cast<SolvedNode_efhg&&>(_3) : (isUnion ? createEmpty_gDsn(member.type, Target_VZrr{}, ss, ctx, _here, module, options, _helpers) : SolvedNode_efhg{})), Target_VZrr{}, (member.flags & Flags_Lzg8_F_MUSTNAME), 0u, BitSet_mmp7{}, BitSet_mmp7{} };
                    if (!arg.dEfault)
                        min++;

                    args.push(static_cast<Argument_bbKc&&>(arg));
                };
            };
            const int max = args.size();
            if (max && !min)
                min++;

            Extended_z0HS& ext = EXT_mut_gDsn(out_target, ss, module);
            ext.min = min;
            ext.max = max;
            ext.args = static_cast<fu::vec<Argument_bbKc>&&>(args);
            const CountedSet_C7kV* _;
            const Set_qOJY* __1;
            const int mustUpdate = (CHANGE ? (_ = &(EPH_gDsn(out_target, ss, module).callers), __1 = &((*_).counts.keys), (*__1).keys_asc.size()) : 0);
            Overload_aO3i& overload = GET_mut_gDsn(out_target, ss, module);
            overload.type = static_cast<Type_OiTm&&>(out_Typename_1);
            if (mustUpdate)
                overload.status |= SolverStatus_h9em_SS_UPDATED;

        };
        lazySolveEnd_gDsn(out_target, _current_fn, ss, ctx, _here, module, options, _helpers);
        return SolvedNode_efhg{};
    };
}

static SolvedNode_efhg uPrepStruct_gDsn(const Node_JjyR& node, const bool TODO_FIX_useSpecPath, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    return __solveStruct_gDsn(false, node, Target_VZrr{}, TODO_FIX_useSpecPath, _current_fn, ss, ctx, _here, module, options, _helpers);
}

static SolvedNode_efhg unorderedPrep_A_gDsn(const Node_JjyR& node, const bool TODO_FIX_useSpecPath, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    const Kind_Idfg kind = node.kind;
    if (kind == Kind_Idfg_fn)
        return uPrepFn_A_gDsn(node, _current_fn, ss, ctx, _here, module, options, _helpers);
    else if (isTypeDecl_gDsn(kind))
        return uPrepStruct_gDsn(node, TODO_FIX_useSpecPath, _current_fn, ss, ctx, _here, module, options, _helpers);
    else
        BUG_gDsn((x7E_rA00("TODO: unorderedPrep_A("_view, str_eN8k(node.kind)) + ")."_view), ss, ctx, _here, module, options, _helpers);

}

static void unorderedPrep_B_gDsn(fu::view<Node_JjyR> nodes, fu::view<SolvedNode_efhg> results, const int unorderedClass, SolverState_aGlN& ss, const Module_wo7O& module)
{
    if (!(unorderedClass != 1))
    {
        bool hasSnap = false;
        ScopeMemo_9hVQ lastSnap {};
        for (int i = nodes.size(); i-- > 0; )
        {
            const Target_VZrr& target = results[i].target;
            Ephemeral_xhb4& eph = EPH_mut_FDl5(target, ss, module);
            if (eph.scope_memo)
            {
                if (!hasSnap)
                {
                    hasSnap = true;
                    lastSnap = eph.scope_memo;
                }
                else
                    eph.scope_memo = lastSnap;

            };
        };
    };
}

static fu::vec<SolvedNode_efhg> solveNodes_gDsn(fu::view<Node_JjyR> nodes, const DeadBreak_Z4ob dead_brk, const Type_OiTm& type_all, const Type_OiTm& type_last, const bool use_type_last, const StaticEval_IZio static_eval_brk, const bool TODO_FIX_useSpecPath, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    /*MOV*/ fu::vec<SolvedNode_efhg> result {};
    const TokenIdx_5581 here0 = _here;
    fu_DEFER(_here = here0);
    for (int i = 0; i < nodes.size(); i++)
    {
        const Node_JjyR& node = nodes[i];
        if (!(!node))
        {
            const int unorderedClass = unorderedClassify_gDsn(node.kind);
            if (!unorderedClass)
            {

                {
                    const TokenIdx_5581& node_1 = node.token;
                    if (node_1)
                        _here = node_1;

                };
                const bool last = (i == (nodes.size() - 1));
                const Type_OiTm& type = ((last && use_type_last) ? type_last : type_all);
                SolvedNode_efhg solved = solveNode_gDsn(node, type, _current_fn, ss, ctx, _here, module, options, _helpers);
                result += SolvedNode_efhg(solved);
                if (is_never_9CJm(solved.type.vtype) && dead_brk && ((dead_brk != DeadBreak_Z4ob_DeadBreak_Only_WhileSolvingRecursion) || is_AssumeNever_WhileSolvingRecursion_9CJm(solved.type.vtype)))
                {
                    if (i < (nodes.size() - 1))
                    {
                        const SolverNotes_LSla note = SolverNotes_LSla_N_DeadCode;
                        if (note & options.break_notes)
                        {
                            fu::view<char> reason = fu::view<char>{};
                            fail_gDsn((("`break_notes`: Unwanted event: "_view + qBAD_e44U(str_kJvr(note))) + (reason ? ("\n\t\t"_view + reason) : fu::str("."_fu))), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                        }
                        else
                            ss._notes |= note;

                    };
                    break;
                }
                else if (static_eval_brk)
                {
                    const StaticEval_IZio ae_item = tryAbstractEvalAsBool_gDsn(solved, (i == (nodes.size() - 1)), _current_fn, ss, ctx, _here, module, options, _helpers);
                    if (ae_item == static_eval_brk)
                        break;

                };
            }
            else
            {
                const int i0 = i;
                int i1 = nodes.size();
                const int offset = (result.size() - i0);
                for (int i_1 = i0; i_1 < nodes.size(); i_1++)
                {
                    const Node_JjyR* _0;
                    const Node_JjyR& node_1 = (*(_0 = &(nodes[i_1])) ? *_0 : BUG_gDsn("solveNodes, prep-a: falsy node"_view, ss, ctx, _here, module, options, _helpers));
                    if ((unorderedClassify_gDsn(node_1.kind) != unorderedClass) || ((node_1.flags & Flags_Lzg8_F_SHADOW) && (i_1 > i0)))
                    {
                        i1 = i_1;
                        break;
                    }
                    else
                    {

                        {
                            const TokenIdx_5581& node_2 = node_1.token;
                            if (node_2)
                                _here = node_2;

                        };
                        result += unorderedPrep_A_gDsn(node_1, TODO_FIX_useSpecPath, _current_fn, ss, ctx, _here, module, options, _helpers);
                        if (node_1.flags & (Flags_Lzg8_F_CONVERSION | Flags_Lzg8_F_USING))
                        {
                            i1 = (i_1 + 1);
                            break;
                        };
                    };
                };
                if (i1 > i0)
                {
                    i = (i1 - 1);
                    unorderedPrep_B_gDsn(fu::get_view(nodes, i0, i1), fu::get_view(result, (i0 + offset), (i1 + offset)), unorderedClass, ss, module);
                    bool repeat = true;
                    while (repeat)
                    {
                        repeat = false;
                        for (int i_2 = i0; i_2 < i1; i_2++)
                        {
                            const Node_JjyR* _1;
                            const Node_JjyR& node_1 = (*(_1 = &(nodes[i_2])) ? *_1 : BUG_gDsn("solveNodes, solve: falsy node"_view, ss, ctx, _here, module, options, _helpers));

                            {
                                const TokenIdx_5581& node_2 = node_1.token;
                                if (node_2)
                                    _here = node_2;

                            };
                            const Target_VZrr& into = result[(i_2 + offset)].target;
                            if (lazySolveStart_gDsn(into, _current_fn, ss, ctx, _here, module, options, _helpers))
                                repeat = true;

                        };
                    };
                }
                else
                {
                    BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers);
                };
            };
        };
    };
    return /*NRVO*/ result;
}

static SolvedNode_efhg solveRoot_gDsn(const Node_JjyR& node, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    const Helpers_DyqV helpers = Helpers_DyqV { _helpers.size() };
    push_gDsn(HelpersData_uG6I{}, ss, _helpers);
    fu::vec<SolvedNode_efhg> items = solveNodes_gDsn(node.items, DeadBreak_Z4ob_DeadBreak_Always, t_void, (*(Type_OiTm*)fu::NIL), false, StaticEval_IZio{}, false, _current_fn, ss, ctx, _here, module, options, _helpers);
    if (is_never_9CJm(if_last_Xdw0(items).type.vtype))
    {
        _here = last_c4M9(items).token;
        fail_gDsn(str_ytIqXmnhNJh, fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
    }
    else
    {
        /*MOV*/ SolvedNode_efhg root = SolvedNode_gDsn(Kind_Idfg_root, t_void, Flags_Lzg8{}, (*(fu::str*)fu::NIL), items, Target_VZrr{}, helpers, _here);
        runAllPasses_gDsn(root, _current_fn, ss, ctx, _here, module, options, _helpers);
        return /*NRVO*/ root;
    };
}

static SolvedNode_efhg solveArgID_gDsn(const Node_JjyR& node, const Type_OiTm& type, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    SolvedNode_efhg expr = solveNode_gDsn(only_hN9E(node.items), type, _current_fn, ss, ctx, _here, module, options, _helpers);
    return solved_gDsn(node, expr.type, fu::vec<SolvedNode_efhg> {{ SolvedNode_efhg(expr) }}, Target_VZrr{}, _here);
}

static SolvedNode_efhg solveArrlit_gDsn(const Node_JjyR& node, const Type_OiTm& type, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    Type_OiTm itemType = (type ? tryClear_sliceable_1qjp(type.vtype, ctx, _here, module) : Type_OiTm{});
    if (!itemType && type && isStruct_p1TN(type.vtype))
    {
        return solveCall_gDsn(node, fu::view<Target_VZrr> {{ Target_VZrr(lookupUserType_gDsn(type, ss, ctx, _here, module, options, _helpers).target) }}, _current_fn, ss, ctx, _here, module, options, _helpers);
    }
    else
    {
        fu::vec<SolvedNode_efhg> args = solveNodes_gDsn(node.items, DeadBreak_Z4ob_DeadBreak_Always, itemType, (*(Type_OiTm*)fu::NIL), false, StaticEval_IZio{}, false, _current_fn, ss, ctx, _here, module, options, _helpers);
        if (is_never_9CJm(if_last_Xdw0(args).type.vtype))
        {

            {
                const SolverNotes_LSla note = SolverNotes_LSla_N_DeadArrlit;
                if (note & options.break_notes)
                {
                    fu::view<char> reason = fu::view<char>{};
                    fail_gDsn((("`break_notes`: Unwanted event: "_view + qBAD_e44U(str_kJvr(note))) + (reason ? ("\n\t\t"_view + reason) : fu::str("."_fu))), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                }
                else
                    ss._notes |= note;

            };
            return createBlock_gDsn(t_never, args, Helpers_DyqV{}, _here);
        }
        else if (!(node.flags & Flags_Lzg8_F_CALL_HAS_NAMED_ARGS))
            return createArrlit_gDsn(args, itemType, ss, ctx, _here, module, options, _helpers);
        else
        {
            fail_gDsn(str_vfStRkdMxK7, fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
        };
    };
}

static SolvedNode_efhg createBool_wyx7(fu::vec_range<char> value, Type_OiTm&& type, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    type.vtype.vfacts = ((value == "true"_view) ? VFacts_xhRf_AlwaysTrue : ((value == "false"_view) ? VFacts_xhRf_AlwaysFalse : BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers)));
    return SolvedNode_gDsn(Kind_Idfg_bool, type, Flags_Lzg8{}, value, (*(fu::vec<SolvedNode_efhg>*)fu::NIL), Target_VZrr{}, Helpers_DyqV{}, _here);
}

static SolvedNode_efhg createBool_FDl5(const bool value, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    return createBool_wyx7((value ? str_OzCq7wxwyT6 : str_5ReVUUJ8X27), Type_OiTm(t_bool), ss, ctx, _here, module, options, _helpers);
}

static SolvedNode_efhg createNot_gDsn(const SolvedNode_efhg& item, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (item.kind == Kind_Idfg_bool)
    {
        if (item.value == "true"_view)
            return createBool_FDl5(false, ss, ctx, _here, module, options, _helpers);
        else if (item.value == "false"_view)
            return createBool_FDl5(true, ss, ctx, _here, module, options, _helpers);
        else
            BUG_gDsn(("Invalid bool literal: "_view + qBAD_e44U(item.value)), ss, ctx, _here, module, options, _helpers);

    }
    else
    {
        Type_OiTm type = t_bool;
        const StaticEval_IZio ae = tryAbstractEvalAsBool_gDsn(item, false, _current_fn, ss, ctx, _here, module, options, _helpers);
        if (ae)
            type.vtype.vfacts = ((ae == StaticEval_IZio_SE_True) ? VFacts_xhRf_AlwaysFalse : VFacts_xhRf_AlwaysTrue);

        return SolvedNode_gDsn(Kind_Idfg_not, type, Flags_Lzg8{}, (*(fu::str*)fu::NIL), fu::vec<SolvedNode_efhg> {{ SolvedNode_efhg(item) }}, Target_VZrr{}, Helpers_DyqV{}, _here);
    };
}

static SolvedNode_efhg solveNot_gDsn(const Node_JjyR& node, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    SolvedNode_efhg item = solveNode_gDsn(only_hN9E(node.items), t_proposition, _current_fn, ss, ctx, _here, module, options, _helpers);
    _here = node.token;
    return createNot_gDsn(item, _current_fn, ss, ctx, _here, module, options, _helpers);
}

static SolvedNode_efhg solveIf_gDsn(const Node_JjyR& node, const Type_OiTm& type, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    const ScopeMemo_9hVQ scope0 = Scope_snap_gDsn(ss, _helpers);
    fu_DEFER(Scope_pop_gDsn(scope0, ss, _helpers));
    /*MOV*/ SolvedNode_efhg cond = solveNode_gDsn(node.items[0], t_proposition, _current_fn, ss, ctx, _here, module, options, _helpers);
    if (is_never_9CJm(cond.type.vtype))
        return /*NRVO*/ cond;
    else
    {
        const StaticEval_IZio ae_cond = tryAbstractEvalAsBool_gDsn(cond, false, _current_fn, ss, ctx, _here, module, options, _helpers);
        if (ae_cond)
            return createBlock_FDl5(static_cast<SolvedNode_efhg&&>(cond), solveNode_gDsn(node.items[((ae_cond == StaticEval_IZio_SE_True) ? 1 : 2)], type, _current_fn, ss, ctx, _here, module, options, _helpers), ss, ctx, _here, module);
        else
        {
            /*MOV*/ SolvedNode_efhg cons = solveNode_gDsn(node.items[1], type, _current_fn, ss, ctx, _here, module, options, _helpers);
            fu_DEFER(Scope_pop_gDsn(scope0, ss, _helpers));
            /*MOV*/ SolvedNode_efhg alt = solveNode_gDsn(node.items[2], type, _current_fn, ss, ctx, _here, module, options, _helpers);
            _here = node.token;
            return createIf_gDsn(cond, static_cast<SolvedNode_efhg&&>(cons), static_cast<SolvedNode_efhg&&>(alt), Type_OiTm(type), _current_fn, ss, ctx, _here, module, options, _helpers);
        };
    };
}

static SolvedNode_efhg solveOr_gDsn(const Node_JjyR& node, const Type_OiTm& type, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    const ScopeMemo_9hVQ scope0 = Scope_snap_gDsn(ss, _helpers);
    fu_DEFER(Scope_pop_gDsn(scope0, ss, _helpers));
    /*MOV*/ fu::vec<SolvedNode_efhg> items = solveNodes_gDsn(node.items, DeadBreak_Z4ob_DeadBreak_Always, (is_void_9CJm(type.vtype) ? t_proposition : type), type, true, StaticEval_IZio_SE_True, false, _current_fn, ss, ctx, _here, module, options, _helpers);
    return createOr_gDsn(static_cast<fu::vec<SolvedNode_efhg>&&>(items), Type_OiTm(type), _current_fn, ss, ctx, _here, module, options, _helpers);
}

static SolvedNode_efhg solveAnd_gDsn(const Node_JjyR& node, const Type_OiTm& type, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    const ScopeMemo_9hVQ scope0 = Scope_snap_gDsn(ss, _helpers);
    fu_DEFER(Scope_pop_gDsn(scope0, ss, _helpers));
    const bool staticEvalBrk = is_void_or_propositionOK_9CJm(type, false, ctx, _here);
    /*MOV*/ fu::vec<SolvedNode_efhg> items = solveNodes_gDsn(node.items, (staticEvalBrk ? DeadBreak_Z4ob_DeadBreak_Always : DeadBreak_Z4ob{}), t_proposition, type, true, (staticEvalBrk ? StaticEval_IZio_SE_False : StaticEval_IZio{}), false, _current_fn, ss, ctx, _here, module, options, _helpers);
    return createAnd_gDsn(static_cast<fu::vec<SolvedNode_efhg>&&>(items), Type_OiTm(type), _current_fn, ss, ctx, _here, module, options, _helpers);
}

static SolvedNode_efhg solveLetStatement_gDsn(const Node_JjyR& node, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    if (node.kind == Kind_Idfg_let)
        return solveNode_gDsn(node, t_void, _current_fn, ss, ctx, _here, module, options, _helpers);
    else
        BUG_gDsn((x7E_rA00("Expected a `let` statement, got: `"_view, str_eN8k(node.kind)) + "`."_view), ss, ctx, _here, module, options, _helpers);

}

static SolvedNode_efhg solveLoop_gDsn(const Node_JjyR& node, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    const ScopeMemo_9hVQ scope0 = Scope_snap_gDsn(ss, _helpers);
    fu_DEFER(Scope_pop_gDsn(scope0, ss, _helpers));
    const int brk_idx = _helpers.size();
    const Target_VZrr* t;
    push_gDsn(HelpersData_uG6I { Target_VZrr{}, SolverPass_zVQ2{}, HelpersMask_w1sv((HelpersMask_w1sv_HM_Anon | HelpersMask_w1sv_HM_CanBreak)), fu::str(node.value), (t = &(_current_fn.out.target), int(unsigned((((*t)._packed >> 20ull) & 0xfffffull)))), GET_next_local_index_gDsn(_current_fn, ss, ctx, _here), Type_OiTm{}, Type_OiTm(t_void), Postdom_Vy5u{}, Postdom_Vy5u{}, EventsSnap_elmt{}, Helpers_DyqV{} }, ss, _helpers);
    const Node_JjyR& n_init = node.items[LOOP_INIT];
    const Node_JjyR& n_pre_cond = node.items[LOOP_PRE_COND];
    const Node_JjyR& n_pre = node.items[LOOP_PRE];
    const Node_JjyR& n_body = node.items[LOOP_BODY];
    const Node_JjyR& n_post = node.items[LOOP_POST];
    const Node_JjyR& n_post_cond = node.items[LOOP_POST_COND];
    /*MOV*/ SolvedNode_efhg init = (n_init ? solveLetStatement_gDsn(n_init, _current_fn, ss, ctx, _here, module, options, _helpers) : SolvedNode_efhg{});
    if (is_never_9CJm(init.type.vtype))
    {

        {
            const SolverNotes_LSla note = SolverNotes_LSla_N_DeadLoopInit;
            if (note & options.break_notes)
            {
                fu::view<char> reason = fu::view<char>{};
                fail_gDsn((("`break_notes`: Unwanted event: "_view + qBAD_e44U(str_kJvr(note))) + (reason ? ("\n\t\t"_view + reason) : fu::str("."_fu))), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
            }
            else
                ss._notes |= note;

        };
        return /*NRVO*/ init;
    }
    else
    {
        /*MOV*/ SolvedNode_efhg pre_cond = (n_pre_cond ? solveNode_gDsn(n_pre_cond, t_proposition, _current_fn, ss, ctx, _here, module, options, _helpers) : SolvedNode_efhg{});
        /*MOV*/ SolvedNode_efhg pre = (n_pre ? solveBlock_gDsn(n_pre, t_void, 0, HelpersMask_w1sv_HM_LoopPreheader, (*(fu::str*)fu::NIL), 0, _current_fn, ss, ctx, _here, module, options, _helpers) : SolvedNode_efhg{});
        /*MOV*/ SolvedNode_efhg body = (n_body ? solveBlock_gDsn(n_body, t_void, 0, HelpersMask_w1sv_HM_LoopBody, (*(fu::str*)fu::NIL), 0, _current_fn, ss, ctx, _here, module, options, _helpers) : SolvedNode_efhg{});
        /*MOV*/ SolvedNode_efhg post = (n_post ? solveBlock_gDsn(n_post, t_void, 0, HelpersMask_w1sv_HM_CanBreak, (*(fu::str*)fu::NIL), 0, _current_fn, ss, ctx, _here, module, options, _helpers) : SolvedNode_efhg{});
        /*MOV*/ SolvedNode_efhg post_cond = (n_post_cond ? solveNode_gDsn(n_post_cond, t_proposition, _current_fn, ss, ctx, _here, module, options, _helpers) : SolvedNode_efhg{});
        const Helpers_DyqV& h = _helpers[brk_idx];
        const Type_OiTm& type = ((!pre_cond && !post_cond && !HelpersMask_w1sv(((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).mask & HelpersMask_w1sv_HM_LabelUsed))) ? t_never : t_void);

        {
            const TokenIdx_5581& node_1 = node.token;
            if (node_1)
                _here = node_1;

        };
        return SolvedNode_gDsn(Kind_Idfg_loop, type, Flags_Lzg8{}, (*(fu::str*)fu::NIL), fu::vec<SolvedNode_efhg> {{ static_cast<SolvedNode_efhg&&>(init), static_cast<SolvedNode_efhg&&>(pre_cond), static_cast<SolvedNode_efhg&&>(pre), static_cast<SolvedNode_efhg&&>(body), static_cast<SolvedNode_efhg&&>(post), static_cast<SolvedNode_efhg&&>(post_cond) }}, Target_VZrr{}, h, _here);
    };
}

static const Helpers_DyqV& Scope_lookupReturn_gDsn(fu::view<char> id, const bool lambdaOK, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{

    {
        fu::view<Helpers_DyqV> items = _helpers;
        fu::view<ScopeSkip_iozY> ss_1 = ss._ss.helpers;
        int ssi = (ss_1.size() - 1);
        int ssN = ((ssi >= 0) ? (ss_1[ssi].end - 1) : 0);
        for (int i = items.size(); i-- > 0; )
        {
            if ((ssi >= 0) && (i == ssN))
            {
                i = ss_1[ssi--].start;
                ssN = ((ssi >= 0) ? (ss_1[ssi].end - 1) : 0);
            }
            else
            {
                const Helpers_DyqV& item = items[i];
                if (!(!HelpersMask_w1sv(((((item.index >= 0) && (item.index < ss._helpers_data.size())) ? ss._helpers_data[item.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).mask & HelpersMask_w1sv_HM_CanReturn))))
                {
                    if (!(HelpersMask_w1sv(((((item.index >= 0) && (item.index < ss._helpers_data.size())) ? ss._helpers_data[item.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).mask & HelpersMask_w1sv_HM_Lambda)) && !lambdaOK))
                    {
                        if (!(id && ((((item.index >= 0) && (item.index < ss._helpers_data.size())) ? ss._helpers_data[item.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).id != id)))
                            return item;

                    };
                };
            };
        };
    };
    fail_gDsn((("No return "_view + qBAD_e44U(id)) + " in scope."_view), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
}

                                #ifndef DEF_each_LMc0b8r27sb
                                #define DEF_each_LMc0b8r27sb
inline void each_LMc0(fu::view<ScopeSkip_iozY> a, int& i)
{
    for (int i_1 = 0; i_1 < a.size(); i_1++)
    {
        const ScopeSkip_iozY& skip = a[i_1];
        if (i == skip.start)
            i = skip.end;
        else if (i < skip.start)
            return;

    };
}
                                #endif

static const Helpers_DyqV& Scope_lookupLabel_FDl5(fu::view<char> id, const bool cont, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    int CONTINUE_BELOW {};

    {
        fu::view<Helpers_DyqV> items = _helpers;
        fu::view<ScopeSkip_iozY> ss_1 = ss._ss.helpers;
        int ssi = (ss_1.size() - 1);
        int ssN = ((ssi >= 0) ? (ss_1[ssi].end - 1) : 0);
        for (int i = items.size(); i-- > 0; )
        {
            if ((ssi >= 0) && (i == ssN))
            {
                i = ss_1[ssi--].start;
                ssN = ((ssi >= 0) ? (ss_1[ssi].end - 1) : 0);
            }
            else
            {
                const Helpers_DyqV& item = items[i];
                if (i < (CONTINUE_BELOW - 1))
                    i++;

                if (!HelpersMask_w1sv(((((item.index >= 0) && (item.index < ss._helpers_data.size())) ? ss._helpers_data[item.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).mask & HelpersMask_w1sv_HM_CanBreak)))
                {
                    if (!CONTINUE_BELOW)
                    {
                        if (id || !HelpersMask_w1sv(((((item.index >= 0) && (item.index < ss._helpers_data.size())) ? ss._helpers_data[item.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).mask & HelpersMask_w1sv_HM_Lambda)))
                            continue;
                        else if (!cont)
                        {
                            CONTINUE_BELOW = i;
                            continue;
                        };
                    };
                }
                else if (!CONTINUE_BELOW)
                {
                    if (!(id ? ((((item.index >= 0) && (item.index < ss._helpers_data.size())) ? ss._helpers_data[item.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).id == id) : !!HelpersMask_w1sv(((((item.index >= 0) && (item.index < ss._helpers_data.size())) ? ss._helpers_data[item.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).mask & HelpersMask_w1sv_HM_Anon))))
                        continue;
                    else if (cont)
                    {
                        i++;
                        each_LMc0(ss._ss.helpers, i);
                        if (!(i < _helpers.size()))
                        {
                            fail_gDsn((((("Cannot "_view + qBAD_e44U(("continue :"_view + id))) + " from here, did you mean to "_view) + qKW_e44U("break"_view)) + "?"_view), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                        };
                    };
                };
                return _helpers[i];
            };
        };
    };
    if (id)
    {
        fail_gDsn((("No label "_view + qBAD_e44U(id)) + " in scope."_view), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
    }
    else
    {
        fail_gDsn((("Nothing to "_view + qBAD_e44U((cont ? "continue"_view : "break"_view))) + " from here."_view), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
    };
}

static SolvedNode_efhg solveDeclExpr_gDsn(const Node_JjyR& node, const bool TODO_FIX_useSpecPath, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    /*MOV*/ SolvedNode_efhg res = only_S4ER(solveNodes_gDsn(fu::view<Node_JjyR> {{ Node_JjyR(node) }}, DeadBreak_Z4ob_DeadBreak_Dont, (*(Type_OiTm*)fu::NIL), (*(Type_OiTm*)fu::NIL), false, StaticEval_IZio{}, TODO_FIX_useSpecPath, _current_fn, ss, ctx, _here, module, options, _helpers));
    if (res.target && (GET_gDsn(res.target, ss, ctx, _here, module).kind == Kind_Idfg_type))
        res.type = GET_gDsn(res.target, ss, ctx, _here, module).type;

    return /*NRVO*/ res;
}

static SolvedNode_efhg solveJump_gDsn(const Node_JjyR& node, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    const Helpers_DyqV h = ((node.kind == Kind_Idfg_return) ? Scope_lookupReturn_gDsn(node.value, !!(node.flags & F_TODO_FIX_TRAILING_RETURN), ss, ctx, _here, module, options, _helpers) : Scope_lookupLabel_FDl5(node.value, (node.kind == Kind_Idfg_continue), ss, ctx, _here, module, options, _helpers));
    if (h)
    {
        const Node_JjyR& n_expr = if_only_Ywo8(node.items);
        /*MOV*/ SolvedNode_efhg expr = (!n_expr ? createEmpty_gDsn(t_void, Target_VZrr{}, ss, ctx, _here, module, options, _helpers) : (unorderedClassify_gDsn(n_expr.kind) ? solveDeclExpr_gDsn(n_expr, ((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).target == _current_fn.out.target), _current_fn, ss, ctx, _here, module, options, _helpers) : solveNode_gDsn(n_expr, ((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).ret_actual ? clear_vfacts_9CJm(Type_OiTm((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).ret_actual)) : Type_OiTm((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).ret_expect)), _current_fn, ss, ctx, _here, module, options, _helpers)));
        if (is_never_9CJm(expr.type.vtype))
            return /*NRVO*/ expr;
        else
        {
            if ((node.flags & F_TODO_FIX_TRAILING_RETURN) && TODO_FIX_optionalSemis_blockWantsVoid_gDsn((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here))))
            {
                expr = createBlock_FDl5(SolvedNode_efhg(expr), createEmpty_gDsn(t_void, Target_VZrr{}, ss, ctx, _here, module, options, _helpers), ss, ctx, _here, module);
            };
            if ((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).ret_expect)
                tryConvertIfNeeded_gDsn(expr, Type_OiTm((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).ret_expect), false, _current_fn, ss, ctx, _here, module, options, _helpers);

            const Target_VZrr* t;
            if ((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).local_of != (t = &(_current_fn.out.target), int(unsigned((((*t)._packed >> 20ull) & 0xfffffull)))))
            {
                add_q7Be(_current_fn.far_jumps, (((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gb("Helpers.GET: h.index is oob"_view, ctx, _here)).local_of);
                return SolvedNode_gDsn(Kind_Idfg___far_jump, t_never, node.flags, (*(fu::str*)fu::NIL), fu::vec<SolvedNode_efhg> {{ static_cast<SolvedNode_efhg&&>(expr) }}, Target_VZrr{}, h, _here);
            }
            else
            {
                _here = node.token;
                return solveJump_finish_gDsn(node.flags, expr, h, _current_fn, ss, ctx, _here, module, options, _helpers);
            };
        };
    }
    else
        BUG_gDsn("solveJump: empty jump target"_view, ss, ctx, _here, module, options, _helpers);

}

static SolvedNode_efhg solveInt_FDl5(const Node_JjyR& node, const Type_OiTm& type, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    return solved_gDsn(node, solveInt_gDsn(node.value, type, ss, ctx, _here, module, options, _helpers), (*(fu::vec<SolvedNode_efhg>*)fu::NIL), Target_VZrr{}, _here);
}

static SolvedNode_efhg solveReal_FDl5(const Node_JjyR& node, const Type_OiTm& type, const TokenIdx_5581& _here)
{
    return solved_gDsn(node, solveReal_gDsn(type), (*(fu::vec<SolvedNode_efhg>*)fu::NIL), Target_VZrr{}, _here);
}

static SolvedNode_efhg solveString_FDl5(const Node_JjyR& node, const Type_OiTm& type, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    Type_OiTm type_1 = solveString_gDsn(node.value, type, ss, ctx, _here, module, options);
    if (type_1.vtype.vfacts & VFacts_xhRf_AlwaysFalse)
    {
        if (node.value)
            BUG_gDsn((("solveString: AlwaysFalse but non-empty: `"_view + node.value) + "`."_view), ss, ctx, _here, module, options, _helpers);
        else
        {
            return createEmpty_gDsn(type_1, Target_VZrr{}, ss, ctx, _here, module, options, _helpers);
        };
    }
    else
    {
        return solved_gDsn(node, type_1, (*(fu::vec<SolvedNode_efhg>*)fu::NIL), Target_VZrr{}, _here);
    };
}

                                #ifndef DEF_only_ugv96g8F9Zg
                                #define DEF_only_ugv96g8F9Zg
inline char only_ugv9(fu::view<char> a)
{
    fu_ASSERT((a.size() == 1));
    return a[0];
}
                                #endif

static SolvedNode_efhg solveChar_gDsn(const Node_JjyR& node, const TokenIdx_5581& _here, const Options_TBgD& options)
{
    Type_OiTm type = t_byte;
    if (!DevOptions_QEya((options.dev & DevOptions_QEya_DEV_DontFoldLiterals)))
        type.vtype.vfacts = (only_ugv9(node.value) ? VFacts_xhRf_AlwaysTrue : VFacts_xhRf_AlwaysFalse);

    return solved_gDsn(node, type, (*(fu::vec<SolvedNode_efhg>*)fu::NIL), Target_VZrr{}, _here);
}

static SolvedNode_efhg solveBool_gDsn(fu::vec_range<char> value, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    /*MOV*/ SolvedNode_efhg ret = createBool_wyx7(value, Type_OiTm(t_bool), ss, ctx, _here, module, options, _helpers);
    if (options.dev & DevOptions_QEya_DEV_DontFoldLiterals)
    {
        ret.type.vtype.vfacts = VFacts_xhRf{};
    };
    return /*NRVO*/ ret;
}

static void visit_gDsn(const int modid, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here)
{
    if (!(!Scope_import_gDsn(modid, ss, ctx, _here)))
    {
        const Scope_blWT& s = ctx.modules[modid].out.solve.scope;
        for (int i = 0; i < s.imports.size(); i++)
            visit_gDsn(s.imports[i], ss, ctx, _here);

    };
}

static SolvedNode_efhg solveImport_gDsn(const Node_JjyR& node, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    int offset = 0;
    const Module_wo7O& m = findModule_gDsn(node.value, offset, ss, ctx, _here, module, options, _helpers);
    visit_gDsn(m.modid, ss, ctx, _here);
    if (node.flags & Flags_Lzg8_F_PUB)
    {
        if (_current_fn.scope0)
        {
            fail_gDsn(str_UwlyW7OQ2E0, fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
        }
        else
            add_q7Be(ss._pub_imports, m.modid);

    };
    return createEmpty_gDsn(t_void, Target_VZrr{}, ss, ctx, _here, module, options, _helpers);
}

static SolvedNode_efhg solveDefer_gDsn(const Node_JjyR& node, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    /*MOV*/ SolvedNode_efhg item = solveNode_gDsn(only_hN9E(node.items), t_void, _current_fn, ss, ctx, _here, module, options, _helpers);
    return solved_gDsn(node, t_void, fu::vec<SolvedNode_efhg> {{ static_cast<SolvedNode_efhg&&>(item) }}, Target_VZrr{}, _here);
}

extern const Type_OiTm t_string;
static SolvedNode_efhg solveTryCatch_gDsn(const Node_JjyR& node, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    if (node.items.size() == 3)
    {
        const ScopeMemo_9hVQ scope0 = Scope_snap_gDsn(ss, _helpers);
        /*MOV*/ SolvedNode_efhg tRy = solveNode_gDsn(node.items[0], t_void, _current_fn, ss, ctx, _here, module, options, _helpers);
        Scope_pop_gDsn(scope0, ss, _helpers);
        const ScopeMemo_9hVQ scope0_1 = Scope_snap_gDsn(ss, _helpers);
        /*MOV*/ SolvedNode_efhg err = solveLetStatement_gDsn(node.items[1], _current_fn, ss, ctx, _here, module, options, _helpers);
        /*MOV*/ SolvedNode_efhg cAtch = solveNode_gDsn(node.items[2], t_void, _current_fn, ss, ctx, _here, module, options, _helpers);
        Scope_pop_gDsn(scope0_1, ss, _helpers);
        if ((err.kind == Kind_Idfg_letdef) && isAssignableAsArgument_9CJm(GET_gDsn(err.target, ss, ctx, _here, module).solved.type.vtype, definitType_9CJm(Type_OiTm(t_string), false, ctx, _here).vtype, false, ctx, _here))
        {
            const Type_OiTm& type = ((is_never_9CJm(tRy.type.vtype) && is_never_9CJm(cAtch.type.vtype)) ? t_never : t_void);
            return solved_gDsn(node, type, fu::vec<SolvedNode_efhg> {{ static_cast<SolvedNode_efhg&&>(tRy), static_cast<SolvedNode_efhg&&>(err), static_cast<SolvedNode_efhg&&>(cAtch) }}, Target_VZrr{}, _here);
        }
        else
        {
            fail_gDsn(("catch: exceptions are strings,"_view + " consider dropping the annotation."_view), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
        };
    }
    else
    {
        BUG_gDsn(fu::view<char>{}, ss, ctx, _here, module, options, _helpers);
    };
}

static SolvedNode_efhg solveTypeCast_gDsn(const Node_JjyR& node, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    const Node_JjyR& left = node.items[0];
    const Node_JjyR& right = node.items[1];
    Type_OiTm expect = evalTypeAnnot_gDsn(right, false, _current_fn, ss, ctx, _here, module, options, _helpers);
    /*MOV*/ SolvedNode_efhg actual = solveNode_gDsn(left, expect, _current_fn, ss, ctx, _here, module, options, _helpers);
    convertIfNeeded_gDsn(actual, expect, "Cannot convert: "_view, false, _current_fn, ss, ctx, _here, module, options, _helpers);
    return /*NRVO*/ actual;
}

static SolvedNode_efhg solveTypeAssert_gDsn(const Node_JjyR& node, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    Map_v4nV typeParams0 = steal_ew2w(ss._typeParams);
    fu_DEFER(std::swap(ss._typeParams, typeParams0));
    bool _0;
    return (_0 = evalTypePattern_gDsn(node, _current_fn, ss, ctx, _here, module, options, _helpers), createBool_FDl5(_0, ss, ctx, _here, module, options, _helpers));
}

static SolvedNode_efhg solveTypeParam_gDsn(const Node_JjyR& node, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    Type_OiTm _0 {};
    return (_0 = evalTypeParam_gDsn(node.value, _current_fn, ss, ctx, _here, module, options, _helpers), solved_gDsn(node, static_cast<Type_OiTm&&>(_0), (*(fu::vec<SolvedNode_efhg>*)fu::NIL), Target_VZrr{}, _here));
}

static SolvedNode_efhg solveAddrOfFn_gDsn(const Node_JjyR& node, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, const fu::vec<Helpers_DyqV>& _helpers)
{
    const fu::str& id = node.value;
    Type_OiTm type = X_addrofTarget_gDsn(solveAddrOfFn_FDl5(fu::str(id), node.token, node.flags, ss, ctx, _here, module, options, _helpers));
    return createEmpty_gDsn(type, Target_VZrr{}, ss, ctx, _here, module, options, _helpers);
}

                                #ifndef DEF_starts_ojopLVekF87
                                #define DEF_starts_ojopLVekF87
inline bool starts_ojop(fu::view<char> a, fu::view<char> with)
{
    return (a.size() >= with.size()) && (fu::get_view_start0(a, with.size()) == with);
}
                                #endif

                                #ifndef DEF___IdNFyjW5YO3
                                #define DEF___IdNFyjW5YO3
inline static void _IdNF(Node_JjyR& item, fu::view<char> placeholder, fu::view<char> prefix, fu::view<char> suffix, fu::view<char> inside, const ScopeItem_xiLD& field)
{
    const int idx = ((item.value == placeholder) ? 0 : (starts_ojop(item.value, prefix) ? 0 : (ends_OW45(item.value, suffix) ? (item.value.size() - placeholder.size()) : find_7SLc(item.value, inside))));
    if ((idx >= 0))
    {
        if (item.kind == Kind_Idfg_call)
            item.value.splice(idx, placeholder.size(), field.id);
        else if (item.kind == Kind_Idfg_str)
            item.value.splice(idx, placeholder.size(), field.id);

    };
}
                                #endif

                                #ifndef DEF_walk_w5BwoIlRaB1
                                #define DEF_walk_w5BwoIlRaB1
inline static void walk_w5Bw(Node_JjyR& node, fu::view<char> placeholder, fu::view<char> prefix, fu::view<char> suffix, fu::view<char> inside, const ScopeItem_xiLD& field)
{
    for (int i = 0; i < node.items.size(); i++)
    {
        Node_JjyR* _0;
        (_0 = &(node.items.mutref(i)), walk_w5Bw(*_0, placeholder, prefix, suffix, inside, field));
    };
    _IdNF(node, placeholder, prefix, suffix, inside, field);
}
                                #endif

                                #ifndef DEF_astReplace_NzH5WtvFjZj
                                #define DEF_astReplace_NzH5WtvFjZj
inline static Node_JjyR astReplace_NzH5(const Node_JjyR& node, fu::view<char> placeholder, fu::view<char> prefix, fu::view<char> suffix, fu::view<char> inside, const ScopeItem_xiLD& field)
{
    /*MOV*/ Node_JjyR node_1 = node;
    walk_w5Bw(node_1, placeholder, prefix, suffix, inside, field);
    return /*NRVO*/ node_1;
}
                                #endif

static SolvedNode_efhg solveForFieldsOf_gDsn(const Node_JjyR& node, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    fu::view<char> placeholder = node.value;
    const Node_JjyR& body_template = node.items[1];
    fu::str prefix = (placeholder + "_"_view);
    fu::str suffix = ("_"_view + placeholder);
    fu::str inside = (("_"_view + placeholder) + "_"_view);
    Type_OiTm _0 {};
    fu::view<ScopeItem_xiLD> fields = (_0 = evalTypeAnnot_gDsn(node.items[0], false, _current_fn, ss, ctx, _here, module, options, _helpers), lookupUserType_gDsn(static_cast<Type_OiTm&&>(_0), ss, ctx, _here, module, options, _helpers)).items;
    fu::vec<Node_JjyR> items_ast {};
    for (int i = 0; i < fields.size(); i++)
    {
        const ScopeItem_xiLD& field = fields[i];
        items_ast += astReplace_NzH5(body_template, placeholder, prefix, suffix, inside, field);
    };
    fu::vec<SolvedNode_efhg> items = solveNodes_gDsn(items_ast, DeadBreak_Z4ob_DeadBreak_Always, t_void, (*(Type_OiTm*)fu::NIL), false, StaticEval_IZio{}, false, _current_fn, ss, ctx, _here, module, options, _helpers);
    const Type_OiTm& type = (is_never_9CJm(if_last_Xdw0(items).type.vtype) ? t_never : t_void);
    return createBlock_gDsn(type, items, Helpers_DyqV{}, _here);
}

static void compilerBreak_gDsn()
{
    const fu::str* x;
    fu::println(fu::view<fu::str> {{ fu::str((x = &(str_UkSW0DUvQBi), (*x))) }});
}

static SolvedNode_efhg executeCompilerPragma_gDsn(const Node_JjyR& node, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    if (node.value != "break"_view)
    {
        fu::vec<SolvedNode_efhg> _0 {};
        return (_0 = solveNodes_gDsn(node.items, DeadBreak_Z4ob_DeadBreak_Dont, (*(Type_OiTm*)fu::NIL), (*(Type_OiTm*)fu::NIL), false, StaticEval_IZio{}, false, _current_fn, ss, ctx, _here, module, options, _helpers), SolvedNode_gDsn(Kind_Idfg_pragma, t_void, Flags_Lzg8{}, node.value, static_cast<fu::vec<SolvedNode_efhg>&&>(_0), Target_VZrr{}, Helpers_DyqV{}, _here));
    }
    else
    {
        compilerBreak_gDsn();
        return createEmpty_gDsn(t_void, Target_VZrr{}, ss, ctx, _here, module, options, _helpers);
    };
}

static SolvedNode_efhg createUnwrap_gDsn(const TokenIdx_5581& _here)
{
    return SolvedNode_gDsn(Kind_Idfg_unwrap, t_void, Flags_Lzg8{}, (*(fu::str*)fu::NIL), (*(fu::vec<SolvedNode_efhg>*)fu::NIL), Target_VZrr{}, Helpers_DyqV{}, _here);
}

                                #ifndef DEF_first_q86qNjEs1L7
                                #define DEF_first_q86qNjEs1L7
inline const Node_JjyR& first_q86q(fu::view<Node_JjyR> a)
{
    return a[0];
}
                                #endif

static SolvedNode_efhg solveCallIndirect_gDsn(const Node_JjyR& node, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{
    if (node.items.size())
    {
        fu::vec<Target_VZrr> targets {};
        SolvedNode_efhg head = solveCall_gDsn(first_q86q(node.items), fu::view<Target_VZrr>{}, _current_fn, ss, ctx, _here, module, options, _helpers);
        if (isAddrOfFn_9CJm(head.type))
            unpackAddrOfFn_L5tm(head.type.vtype.canon, targets);
        else if (is_Typename_9CJm(head.type))
        {
            const Struct_LDkB& s = tryLookupUserType_1qjp(head.type.vtype, ctx, _here, module);
            if (s.target)
                targets += Target_VZrr(s.target);

        };
        if (!targets)
        {
            fail_gDsn(("Indirect call: expression does not evaluate to an overload set: "_view + explainType_gDsn(head.type, false, false, false, false, false, (*(Type_OiTm*)fu::NIL), ss, ctx, _here, module, options)), fu::view<char>{}, TokenIdx_5581(first_q86q(node.items).token), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
        }
        else
        {
            /*MOV*/ fu::vec<SolvedNode_efhg> args = solveNodes_gDsn(fu::get_view(node.items, 1), DeadBreak_Z4ob_DeadBreak_Only_WhileSolvingRecursion, (*(Type_OiTm*)fu::NIL), (*(Type_OiTm*)fu::NIL), false, StaticEval_IZio{}, false, _current_fn, ss, ctx, _here, module, options, _helpers);
            if (is_AssumeNever_WhileSolvingRecursion_9CJm(if_last_Xdw0(args).type.vtype))
                return SolvedNode_efhg(last_c4M9(args));
            else
            {
                return solveCall_FDl5(fu::str("__indirect"_fu), static_cast<fu::vec<SolvedNode_efhg>&&>(args), Flags_Lzg8{}, targets, _current_fn, ss, ctx, _here, module, options, _helpers);
            };
        };
    }
    else
        BUG_gDsn("solveCallIndirect: No head node, nothing to call."_view, ss, ctx, _here, module, options, _helpers);

}

static SolvedNode_efhg solveNode_gDsn(const Node_JjyR& node, const Type_OiTm& type, CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, Module_wo7O& module, const Options_TBgD& options, fu::vec<Helpers_DyqV>& _helpers)
{

    {
        const TokenIdx_5581& node_1 = node.token;
        if (node_1)
            _here = node_1;

    };
    const Kind_Idfg k = node.kind;
    if (k == Kind_Idfg_root)
        return solveRoot_gDsn(node, _current_fn, ss, ctx, _here, module, options, _helpers);
    else if (k == Kind_Idfg_block)
        return solveBlock_gDsn(node, type, 0, HelpersMask_w1sv_HM_CanBreak, (*(fu::str*)fu::NIL), 0, _current_fn, ss, ctx, _here, module, options, _helpers);
    else if (k == Kind_Idfg_argid)
        return solveArgID_gDsn(node, type, _current_fn, ss, ctx, _here, module, options, _helpers);
    else if (k == Kind_Idfg_let)
        return solveLet_gDsn(node, false, (*(Type_OiTm*)fu::NIL), _current_fn, ss, ctx, _here, module, options, _helpers);
    else if (k == Kind_Idfg_call)
    {
        return solveCall_gDsn(node, fu::view<Target_VZrr>{}, _current_fn, ss, ctx, _here, module, options, _helpers);
    }
    else if (k == Kind_Idfg_arrlit)
        return solveArrlit_gDsn(node, type, _current_fn, ss, ctx, _here, module, options, _helpers);
    else if (k == Kind_Idfg_not)
        return solveNot_gDsn(node, _current_fn, ss, ctx, _here, module, options, _helpers);
    else if (k == Kind_Idfg_if)
        return solveIf_gDsn(node, type, _current_fn, ss, ctx, _here, module, options, _helpers);
    else if (k == Kind_Idfg_or)
        return solveOr_gDsn(node, type, _current_fn, ss, ctx, _here, module, options, _helpers);
    else if (k == Kind_Idfg_and)
        return solveAnd_gDsn(node, type, _current_fn, ss, ctx, _here, module, options, _helpers);
    else if (k == Kind_Idfg_loop)
        return solveLoop_gDsn(node, _current_fn, ss, ctx, _here, module, options, _helpers);
    else if (k == Kind_Idfg_break)
        return solveJump_gDsn(node, _current_fn, ss, ctx, _here, module, options, _helpers);
    else if (k == Kind_Idfg_return)
        return solveJump_gDsn(node, _current_fn, ss, ctx, _here, module, options, _helpers);
    else if (k == Kind_Idfg_continue)
        return solveJump_gDsn(node, _current_fn, ss, ctx, _here, module, options, _helpers);
    else if (k == Kind_Idfg_int)
        return solveInt_FDl5(node, type, ss, ctx, _here, module, options, _helpers);
    else if (k == Kind_Idfg_real)
        return solveReal_FDl5(node, type, _here);
    else if (k == Kind_Idfg_str)
        return solveString_FDl5(node, type, ss, ctx, _here, module, options, _helpers);
    else if (k == Kind_Idfg_char)
        return solveChar_gDsn(node, _here, options);
    else if (k == Kind_Idfg_bool)
        return solveBool_gDsn(node.value, ss, ctx, _here, module, options, _helpers);
    else if (k == Kind_Idfg_definit)
        return solveDefinit_gDsn(type, ctx, _here);
    else if (k == Kind_Idfg_import)
        return solveImport_gDsn(node, _current_fn, ss, ctx, _here, module, options, _helpers);
    else if (k == Kind_Idfg_defer)
        return solveDefer_gDsn(node, _current_fn, ss, ctx, _here, module, options, _helpers);
    else if (k == Kind_Idfg_try)
        return solveTryCatch_gDsn(node, _current_fn, ss, ctx, _here, module, options, _helpers);
    else if (k == Kind_Idfg_typecast)
        return solveTypeCast_gDsn(node, _current_fn, ss, ctx, _here, module, options, _helpers);
    else if (k == Kind_Idfg_typeassert)
        return solveTypeAssert_gDsn(node, _current_fn, ss, ctx, _here, module, options, _helpers);
    else if (k == Kind_Idfg_typeparam)
        return solveTypeParam_gDsn(node, _current_fn, ss, ctx, _here, module, options, _helpers);
    else if (k == Kind_Idfg_addroffn)
        return solveAddrOfFn_gDsn(node, ss, ctx, _here, module, options, _helpers);
    else if (k == Kind_Idfg_forfieldsof)
        return solveForFieldsOf_gDsn(node, _current_fn, ss, ctx, _here, module, options, _helpers);
    else if (k == Kind_Idfg_pragma)
        return executeCompilerPragma_gDsn(node, _current_fn, ss, ctx, _here, module, options, _helpers);
    else if (k == Kind_Idfg_empty)
    {
        return createEmpty_gDsn(t_void, Target_VZrr{}, ss, ctx, _here, module, options, _helpers);
    }
    else if (k == Kind_Idfg_unwrap)
        return createUnwrap_gDsn(_here);
    else if (k == Kind_Idfg_call_indir)
        return solveCallIndirect_gDsn(node, _current_fn, ss, ctx, _here, module, options, _helpers);
    else if (unorderedClassify_gDsn(k))
        return solveDeclExpr_gDsn(node, false, _current_fn, ss, ctx, _here, module, options, _helpers);
    else
        BUG_gDsn(x7E_rA00("solve: Unexpected "_view, str_eN8k(k)), ss, ctx, _here, module, options, _helpers);

}

static void hash_gDsn(TEA_0Daz& hash, const Type_OiTm& type, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module)
{
    hash_lweH(hash, TEA_0Daz { unsigned((type.vtype.quals & q_TAGS)), (type.lifetime.uni0n.size() ? unsigned(1) : 0u) });
    hash_qRo1(hash, getShape_1qjp(type.vtype, ctx, _here, module).hash);
}

                                #ifndef DEF_typeof_q58Ijg0lJp3
                                #define DEF_typeof_q58Ijg0lJp3
inline fu::vec<SolvedNode_efhg> typeof_q58I()
{
    return fu::vec<SolvedNode_efhg>{};
}
                                #endif

                                #ifndef DEF_x5Bx5D_GIgAOhUWgub
                                #define DEF_x5Bx5D_GIgAOhUWgub
inline fu::vec<SolvedNode_efhg> x5Bx5D_GIgA()
{
    return typeof_q58I();
}
                                #endif

static void sighashNode_gDsn(const SolvedNode_efhg& n, const Target_VZrr& fn_target, TEA_0Daz& hash, Map_ZxRu& name_counts, fu::vec<Target_VZrr>& already_hashing, Set_R8IU& cycle_participants, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, const fu::vec<Helpers_DyqV>& _helpers)
{
    if (isImmediatelyDiscardable_UVY6(n.kind))
    {
        if (n.value)
            hash_l6RU(hash, n.value);

    }
    else
    {
        hash_lweH(hash, TEA_0Daz { unsigned(n.kind), unsigned(n.items.size()) });
        for (int i = 0; i < n.items.size(); i++)
            sighashNode_gDsn(n.items[i], fn_target, hash, name_counts, already_hashing, cycle_participants, _current_fn, ss, ctx, _here, module, options, _helpers);

        if (n.kind == Kind_Idfg_letdef)
            sighashNode_gDsn(GET_gDsn(n.target, ss, ctx, _here, module).solved, fn_target, hash, name_counts, already_hashing, cycle_participants, _current_fn, ss, ctx, _here, module, options, _helpers);
        else if (n.kind == Kind_Idfg_let)
        {
            const Target_VZrr* t;
            unsigned v;
            hash_qRo1(hash, uint64_t(unsigned((t = &(n.target), v = unsigned(((*t)._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))))));
            hash_gDsn(hash, n.type, ctx, _here, module);
        }
        else if (n.kind == Kind_Idfg_call)
        {
            const Target_VZrr& target = n.target;
            unsigned v;
            const int locid = (v = unsigned((target._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
            if (locid)
                hash_qRo1(hash, uint64_t(unsigned(locid)));
            else
            {
                const Overload_aO3i& o = GET_gDsn(target, ss, ctx, _here, module);
                const Kind_Idfg k = o.kind;
                if (k == Kind_Idfg_fn)
                {
                    TEA_0Daz sighash = EXT_gDsn(target, ss, ctx, module).sighash;
                    if (!sighash)
                    {
                        const int idx = find_rD4C(already_hashing, target);
                        if ((idx >= 0))
                        {
                            add_sjqY(cycle_participants, fn_target);
                            sighash = TEA_0Daz { 0xffffffffu, unsigned(idx) };
                        }
                        else if (int(unsigned(((target._packed >> 40ull) & 0xfffffull))) == module.modid)
                            sighash = computeFnSighash_gDsn(target, name_counts, already_hashing, cycle_participants, _current_fn, ss, ctx, _here, module, options, _helpers);
                        else
                        {
                            BUG_gDsn(("Off-module fn with no sighash: "_view + explainWhichFn_gDsn(Target_VZrr(target), fu::view<fu::vec<Target_VZrr>>{}, fu::view<char>{}, CodeFmt_snPx_NoContext, _current_fn, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);
                        };
                    };
                    hash_lweH(hash, sighash);
                }
                else if ((k == Kind_Idfg___native) || (k == Kind_Idfg_enumv))
                    hash_l6RU(hash, o.name);
                else if (k == Kind_Idfg_field)
                {
                    const int offset = field_unpackOffset_gDsn(o, ctx, _here).memberFlatOffset;
                    hash_qRo1(hash, uint64_t(unsigned(offset)));
                }
                else if (k == Kind_Idfg_var)
                    sighashNode_gDsn(o.solved, fn_target, hash, name_counts, already_hashing, cycle_participants, _current_fn, ss, ctx, _here, module, options, _helpers);
                else if ((k != Kind_Idfg_type) && (k != Kind_Idfg_definit))
                    BUG_gDsn(x7E_rA00("computeFnSighash: no support for kind="_view, str_eN8k(k)), ss, ctx, _here, module, options, _helpers);

            };
        };
    };
}

                                #ifndef DEF___a8UwUQsj7Bl
                                #define DEF___a8UwUQsj7Bl
inline static void _a8Uw(const SolvedNode_efhg& _, const Target_VZrr& fn_target, TEA_0Daz& hash, Map_ZxRu& name_counts, fu::vec<Target_VZrr>& already_hashing, Set_R8IU& cycle_participants, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, const fu::vec<Helpers_DyqV>& _helpers)
{
    sighashNode_gDsn(_, fn_target, hash, name_counts, already_hashing, cycle_participants, _current_fn, ss, ctx, _here, module, options, _helpers);
}
                                #endif

                                #ifndef DEF_each_adlbU3qJaUc
                                #define DEF_each_adlbU3qJaUc
inline void each_adlb(fu::view<SolvedNode_efhg> a, const Target_VZrr& fn_target, TEA_0Daz& hash, Map_ZxRu& name_counts, fu::vec<Target_VZrr>& already_hashing, Set_R8IU& cycle_participants, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, const fu::vec<Helpers_DyqV>& _helpers)
{
    for (int i = 0; i < a.size(); i++)
        _a8Uw(a[i], fn_target, hash, name_counts, already_hashing, cycle_participants, _current_fn, ss, ctx, _here, module, options, _helpers);

}
                                #endif

                                #ifndef DEF_bfind_J7Oehye4ZD5
                                #define DEF_bfind_J7Oehye4ZD5
inline static int bfind_J7Oe(fu::view<fu::str> keys_asc, fu::view<char> key, Set_XshD& _, fu::vec_range<char> key_1, fu::vec_range_mut<unsigned> values)
{
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_j5CR(keys_asc[i], key);
        if (cmp == 0)
            return i;
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    const int i = lo;
    values.insert(i, 0u);
    _.keys_asc.insert(i, fu::str(key_1));
    return i;
}
                                #endif

                                #ifndef DEF_ref_iAWo7XNfMEj
                                #define DEF_ref_iAWo7XNfMEj
inline unsigned& ref_iAWo(Set_XshD& _, fu::vec_range<char> key, fu::vec_range_mut<unsigned> values)
{
    const int idx = bfind_J7Oe(_.keys_asc, key, _, key, values);
    return values.mutref(idx);
}
                                #endif

                                #ifndef DEF_ref_Htt0ULCuYF5
                                #define DEF_ref_Htt0ULCuYF5
inline unsigned& ref_Htt0(Map_ZxRu& _, fu::vec_range<char> key)
{
    return ref_iAWo(_.keys, key, _.vals);
}
                                #endif

static const TEA_0Daz& computeFnSighash_gDsn(const Target_VZrr& fn_target, Map_ZxRu& name_counts, fu::vec<Target_VZrr>& already_hashing, Set_R8IU& cycle_participants, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, const fu::vec<Helpers_DyqV>& _helpers)
{
    TEA_0Daz hash {};
    const Overload_aO3i& o = GET_gDsn(fn_target, ss, ctx, _here, module);
    if (o.kind == Kind_Idfg_fn)
    {
        if (o.flags & Flags_Lzg8_F_TEMPLATE)
        {
            hash_gDsn(hash, o.type, ctx, _here, module);
            fu::vec<SolvedNode_efhg> TODO_FIX = (o.solved.items + x5Bx5D_GIgA());
            already_hashing += Target_VZrr(fn_target);
            each_adlb(TODO_FIX, fn_target, hash, name_counts, already_hashing, cycle_participants, _current_fn, ss, ctx, _here, module, options, _helpers);
            already_hashing.pop();
        }
        else
        {
            hash_l6RU(hash, ss.shortModuleName);
            hash_qw8S(hash, ref_Htt0(name_counts, GET_gDsn(fn_target, ss, ctx, _here, module).name)++);
        };
        TEA_0Daz* _0;
        const TEA_0Daz& sighash = ((!*(_0 = &(EXT_mut_gDsn(fn_target, ss, module).sighash)) ? *_0 : BUG_gDsn("sighash already set"_view, ss, ctx, _here, module, options, _helpers)) = TEA_0Daz(non_zero_lweH(hash)));
        return sighash;
    }
    else
        BUG_gDsn(x7E_rA00("computeFnSighash: Not a fn: "_view, str_FDl5(fn_target, false, ss, ctx, _here, module, options)), ss, ctx, _here, module, options, _helpers);

}

                                #ifndef DEF___C02Ioqt03wc
                                #define DEF___C02Ioqt03wc
inline static void _C02I(const Target_VZrr& target, const TEA_0Daz& cycle_root_hash, SolverState_aGlN& ss, const Module_wo7O& module)
{
    hash_lweH(EXT_mut_gDsn(target, ss, module).sighash, cycle_root_hash);
}
                                #endif

                                #ifndef DEF_each_EbV6KnVwJZi
                                #define DEF_each_EbV6KnVwJZi
inline void each_EbV6(fu::view<Target_VZrr> a, const TEA_0Daz& cycle_root_hash, SolverState_aGlN& ss, const Module_wo7O& module)
{
    for (int i = 0; i < a.size(); i++)
        _C02I(a[i], cycle_root_hash, ss, module);

}
                                #endif

static void computeFnSighash_asIfCycleRoot_gDsn(const Target_VZrr& fn_target, Map_ZxRu& name_counts, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, const fu::vec<Helpers_DyqV>& _helpers)
{
    fu::vec<Target_VZrr> already_hashing {};
    Set_R8IU cycle_participants {};
    const TEA_0Daz cycle_root_hash = computeFnSighash_gDsn(fn_target, name_counts, already_hashing, cycle_participants, _current_fn, ss, ctx, _here, module, options, _helpers);
    const Set_R8IU& _ = cycle_participants;
    each_EbV6(_.keys_asc, cycle_root_hash, ss, module);
}

                                #ifndef DEF_ensure_NpveYcY0ikd
                                #define DEF_ensure_NpveYcY0ikd
inline BitSet_mmp7& ensure_Npve(fu::vec_range_mut<BitSet_mmp7> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

                                #ifndef DEF___b6AtBKICFAb
                                #define DEF___b6AtBKICFAb
inline static void _b6At(const Argument_bbKc& host_arg, const int i, fu::vec<BitSet_mmp7>& _may_alias, fu::vec<int>& _argPos_1b, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, const fu::vec<Helpers_DyqV>& _helpers)
{
    if (!(!is_ref_9CJm(host_arg.type)))
    {
        const Target_VZrr* t;
        unsigned v;
        ensure_2Giz(_argPos_1b, (-1 - (t = &(host_arg.target), v = unsigned(((*t)._packed & 0xfffffull)), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)))))) = (i + 1);
        const BitSet_mmp7& may_alias = (host_arg.written_to ? host_arg.may_alias : (*(BitSet_mmp7*)fu::NIL));
        if (may_alias)
        {
            if (!is_mutref_9CJm(host_arg.type, ctx, _here))
                BUG_gDsn("ensureArgSequencing: F_WRITTEN_TO but !is_mutref"_view, ss, ctx, _here, module, options, _helpers);
            else if (!has_ZwXY(may_alias, i))
                BUG_gDsn("ensureArgSequencing: may_alias does not list self [1]"_view, ss, ctx, _here, module, options, _helpers);

            ensure_Npve(_may_alias, i) = BitSet_mmp7(may_alias);
        };
    };
}
                                #endif

                                #ifndef DEF_each_uRsPLjTqaIk
                                #define DEF_each_uRsPLjTqaIk
inline void each_uRsP(fu::vec_range<Argument_bbKc> a, fu::vec<BitSet_mmp7>& _may_alias, fu::vec<int>& _argPos_1b, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, const fu::vec<Helpers_DyqV>& _helpers)
{
    for (int i = 0; i < a.size(); i++)
        _b6At(a[i], i, _may_alias, _argPos_1b, ss, ctx, _here, module, options, _helpers);

}
                                #endif

                                #ifndef DEF_iF_vXCwb2DgOz2
                                #define DEF_iF_vXCwb2DgOz2
inline const BitSet_mmp7& iF_vXCw(fu::view<BitSet_mmp7> a, const int i)
{
    if (uNsigned_40Hl(i) < uNsigned_40Hl(a.size()))
        return a[i];
    else
        return (*(BitSet_mmp7*)fu::NIL);

}
                                #endif

                                #ifndef DEF___aG3c9WRTMk6
                                #define DEF___aG3c9WRTMk6
inline static void _aG3c(const int locid, Regions_9N5a& regions, const bool dontUse_may_alias, fu::view<BitSet_mmp7> _may_alias, fu::view<int> _argPos_1b, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (locid && add_gDsn(regions.locids, locid, _current_fn))
    {
        const int argPos_1b = iF_KelP(_argPos_1b, (-1 - locid));
        if (argPos_1b)
        {
            const int i = (argPos_1b - 1);
            const BitSet_mmp7& may_alias = (!dontUse_may_alias ? iF_vXCw(_may_alias, i) : (*(BitSet_mmp7*)fu::NIL));
            if (may_alias)
            {
                if (!has_ZwXY(may_alias, i))
                    BUG_gDsn("ensureArgSequencing: may_alias does not list self [2]"_view, ss, ctx, _here, module, options, _helpers);
                else
                    regions.arguments |= may_alias;

            }
            else
                add_ZwXY(regions.arguments, i);

        };
        flag_gDsn(regions, Lifetime_climbType_gDsn(nested_FDl5(locid, ss, ctx, _here), ss, ctx, _here, module, options, _helpers).lifetime, dontUse_may_alias, _may_alias, _argPos_1b, _current_fn, ss, ctx, _here, module, options, _helpers);
    };
}
                                #endif

                                #ifndef DEF_Lifetime_each_qVuwUpVQzY9
                                #define DEF_Lifetime_each_qVuwUpVQzY9
inline void Lifetime_each_qVuw(const Lifetime_llCF& lifetime, Regions_9N5a& regions, const bool dontUse_may_alias, fu::view<BitSet_mmp7> _may_alias, fu::view<int> _argPos_1b, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit_7Yz9(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit_7Yz9(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit_7Yz9(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        unsigned v;
        _aG3c(((r & 1u) ? 0 : (v = (r >> 1u), int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))))), regions, dontUse_may_alias, _may_alias, _argPos_1b, _current_fn, ss, ctx, _here, module, options, _helpers);
    };
}
                                #endif

static void flag_gDsn(Regions_9N5a& regions, const Lifetime_llCF& lifetime, const bool dontUse_may_alias, fu::view<BitSet_mmp7> _may_alias, fu::view<int> _argPos_1b, const CurrentFn_QbLp& _current_fn, const SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    Lifetime_each_qVuw(lifetime, regions, dontUse_may_alias, _may_alias, _argPos_1b, _current_fn, ss, ctx, _here, module, options, _helpers);
}

                                #ifndef DEF_steal_ePawkDTbMBb
                                #define DEF_steal_ePawkDTbMBb
inline Unsequenced_MqaY steal_ePaw(Unsequenced_MqaY& v)
{
    /*MOV*/ Unsequenced_MqaY ret {};
    std::swap(v, ret);
    return /*NRVO*/ ret;
}
                                #endif

static void operator|=(Regions_9N5a& a, const Regions_9N5a& b)
{

    {
        const LocidSet_iAWt& other = b.locids;
        LocidSet_iAWt& set = a.locids;
        set._bitset |= other._bitset;
    };
    a.arguments |= b.arguments;
}

static void operator|=(Unsequenced_MqaY& events, const Unsequenced_MqaY& other)
{
    events.writes |= other.writes;
    events.moves |= other.moves;
    events.reads |= other.reads;
}

static void clear_q5Q6(Regions_9N5a& regions)
{

    {
        LocidSet_iAWt& set = regions.locids;
        clear_ZwXY(set._bitset);
    };
    clear_ZwXY(regions.arguments);
}

static void clear_835q(Unsequenced_MqaY& events)
{
    clear_q5Q6(events.writes);
    clear_q5Q6(events.moves);
    clear_q5Q6(events.reads);
}

static bool has_inter_gDsn(const Regions_9N5a& a, const Regions_9N5a& b)
{
    const LocidSet_iAWt* a_1;
    const LocidSet_iAWt* b_1;
    return (a_1 = &(a.locids), b_1 = &(b.locids), has_inter_ZwXY((*a_1)._bitset, (*b_1)._bitset)) || has_inter_ZwXY(a.arguments, b.arguments);
}

                                #ifndef DEF___mfqUpUCHzV5
                                #define DEF___mfqUpUCHzV5
inline static void _mfqU(const int i, const Argument_bbKc& host_arg, const int revSeqIdx, const bool unsequencedOutside, const bool unsequencedHere, Unsequenced_MqaY& outer, Unsequenced_MqaY& parallel, int& MUSTSEQ_mask, fu::view_mut<SolvedNode_efhg> args, fu::view<BitSet_mmp7> _may_alias, fu::view<int> _argPos_1b, int& _unseqDepth, Unsequenced_MqaY& _inner, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    if (unsequencedHere)
    {
        if (revSeqIdx == 1)
            parallel = steal_ePaw(_inner);
        else if (revSeqIdx > 1)
        {
            parallel |= _inner;
            clear_835q(_inner);
        };
    };
    SolvedNode_efhg& arg = args.mutref(i);
    SolvedNode_efhg* expr;
    SolvedNode_efhg& arg_1 = ((arg.kind != Kind_Idfg_move) ? arg : (expr = &(only_krrB(arg.items)), (unsequencedOutside && (flag_gDsn(outer.moves, (*expr).type.lifetime, false, _may_alias, _argPos_1b, _current_fn, ss, ctx, _here, module, options, _helpers), 0)), (*expr)));
    visit_FDl5(arg_1, _may_alias, _argPos_1b, _unseqDepth, _inner, _current_fn, ss, ctx, _here, module, options, _helpers);
    if (unsequencedOutside)
    {
        if (host_arg.written_to)
        {
            flag_gDsn(outer.writes, arg_1.type.lifetime, false, _may_alias, _argPos_1b, _current_fn, ss, ctx, _here, module, options, _helpers);
        };
    };
    if (unsequencedHere)
    {
        const LocidSet_iAWt* a;
        const LocidSet_iAWt* b;
        const LocidSet_iAWt* a_1;
        const LocidSet_iAWt* b_1;
        const SolverNotes_LSla note = ((has_inter_gDsn(_inner.moves, parallel.reads) || has_inter_gDsn(parallel.moves, _inner.reads)) ? SolverNotes_LSla_N_MoveMustSeq : (((a = &(_inner.writes.locids), b = &(parallel.reads.locids), has_inter_ZwXY((*a)._bitset, (*b)._bitset)) || (a_1 = &(parallel.writes.locids), b_1 = &(_inner.reads.locids), has_inter_ZwXY((*a_1)._bitset, (*b_1)._bitset))) ? SolverNotes_LSla_N_BckMustSeq : ((has_inter_ZwXY(_inner.writes.arguments, parallel.reads.arguments) || has_inter_ZwXY(parallel.writes.arguments, _inner.reads.arguments)) ? SolverNotes_LSla_N_AARMustSeq : (__extension__ (
        {
            return;
            (void)0;
        }), fu::unreachable))));
        if (note & options.break_notes)
        {
            fu::view<char> reason = fu::view<char>{};
            fail_gDsn((("`break_notes`: Unwanted event: "_view + qBAD_e44U(str_kJvr(note))) + (reason ? ("\n\t\t"_view + reason) : fu::str("."_fu))), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
        }
        else
            ss._notes |= note;

        MUSTSEQ_mask |= (1 << (i & 31));
    };
}
                                #endif

                                #ifndef DEF_argsReverse_G5UA041bZui
                                #define DEF_argsReverse_G5UA041bZui
inline void argsReverse_G5UA(const bool RTL, fu::view<Argument_bbKc> host_args, const bool unsequencedOutside, const bool unsequencedHere, Unsequenced_MqaY& outer, Unsequenced_MqaY& parallel, int& MUSTSEQ_mask, fu::view_mut<SolvedNode_efhg> args, fu::view<BitSet_mmp7> _may_alias, fu::view<int> _argPos_1b, int& _unseqDepth, Unsequenced_MqaY& _inner, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    int revSeqIdx = 0;
    int lastPass = 1;
    bool ooe_isLast = true;
    for (int pass = 2; pass-- > lastPass; )
    {
        for (int i = host_args.size(); i-- > 0; )
        {
            const Argument_bbKc& host_arg = host_args[i];
            if (!!pass != (RTL ? !i : !!((host_arg.flags & Flags_Lzg8_F_IMPLICIT) || is_mutref_9CJm(host_arg.type, ctx, _here))))
                lastPass = 0;
            else
            {
                _mfqU(i, host_arg, revSeqIdx, unsequencedOutside, unsequencedHere, outer, parallel, MUSTSEQ_mask, args, _may_alias, _argPos_1b, _unseqDepth, _inner, _current_fn, ss, ctx, _here, module, options, _helpers);
                ooe_isLast = false;
                revSeqIdx++;
            };
        };
    };
}
                                #endif

[[noreturn]] static fu::never BUG_FDl5(const TokenIdx_5581& token, fu::view<char> reason, const SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    _here = token;
    BUG_gDsn(reason, ss, ctx, _here, module, options, _helpers);
}

static void visit_FDl5(SolvedNode_efhg& node, fu::view<BitSet_mmp7> _may_alias, fu::view<int> _argPos_1b, int& _unseqDepth, Unsequenced_MqaY& _inner, const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    const bool unsequencedOutside = !!_unseqDepth;
    if (node.kind == Kind_Idfg_call)
    {
        const Overload_aO3i& o = GET_gDsn(node.target, ss, ctx, _here, module);
        if (!node.items)
        {
            if ((o.kind == Kind_Idfg_var) && _unseqDepth)
            {
                flag_gDsn(_inner.reads, o.type.lifetime, true, _may_alias, _argPos_1b, _current_fn, ss, ctx, _here, module, options, _helpers);
            };
        }
        else
        {
            const bool RTL = isRTL_xQNS(o);
            const bool unsequencedHere = (!RTL ? (node.items.size() > 1) : false);
            if (unsequencedHere)
                _unseqDepth++;

            Unsequenced_MqaY outer = steal_ePaw(_inner);
            Unsequenced_MqaY parallel {};
            int MUSTSEQ_mask = 0;
            fu::vec<Argument_bbKc> host_args = fu::vec<Argument_bbKc>(EXT_gDsn(node.target, ss, ctx, module).args);
            fu::view_mut<SolvedNode_efhg> args = node.items;
            if (host_args.size() == args.size())
            {
                argsReverse_G5UA(RTL, host_args, unsequencedOutside, unsequencedHere, outer, parallel, MUSTSEQ_mask, args, _may_alias, _argPos_1b, _unseqDepth, _inner, _current_fn, ss, ctx, _here, module, options, _helpers);
                if (unsequencedHere)
                    _unseqDepth--;

                node.helpers.index |= MUSTSEQ_mask;
                if (unsequencedOutside)
                {
                    outer |= _inner;
                    outer |= parallel;
                    std::swap(_inner, outer);
                }
                else if (outer)
                    BUG_gDsn("!unsequencedOutside but outer events non-empty."_view, ss, ctx, _here, module, options, _helpers);
                else
                    clear_835q(_inner);

            }
            else
            {
                const Target_VZrr* t;
                const Target_VZrr* t_1;
                BUG_FDl5(node.token, (x7E_rA00((x7E_rA00((x7E_rA00((x7E_rA00((x7E_rA00((x7E_rA00("ensureArgSequencing: target("_view, fu::i64dec((t = &(node.target), int(unsigned((((*t)._packed >> 20ull) & 0xfffffull)))))) + " "_view), str_FDl5(node.target, false, ss, ctx, _here, module, options)) + ") host_args.len("_view), fu::i64dec(host_args.size())) + ") != args.len("_view), fu::i64dec(args.size())) + "), nestingFnort("_view), fu::i64dec((t_1 = &(ss._nestingFnort), int(unsigned((((*t_1)._packed >> 20ull) & 0xfffffull)))))) + " "_view), str_FDl5(ss._nestingFnort, false, ss, ctx, _here, module, options)) + ")"_view), ss, ctx, _here, module, options, _helpers);
            };
        };
    }
    else if (node.kind == Kind_Idfg_letdef)
    {
        SolvedNode_efhg root = steal_bX67(GET_mut_gDsn(node.target, ss, module).solved);
        visit_FDl5(root, _may_alias, _argPos_1b, _unseqDepth, _inner, _current_fn, ss, ctx, _here, module, options, _helpers);
        std::swap(root, GET_mut_gDsn(node.target, ss, module).solved);
        if (!isIrrelevant_9CJm(node.type) && unsequencedOutside)
        {
            flag_gDsn(_inner.writes, node.type.lifetime, false, _may_alias, _argPos_1b, _current_fn, ss, ctx, _here, module, options, _helpers);
        };
    }
    else
    {
        if (node.kind == Kind_Idfg_move)
        {
            if (_unseqDepth && (node.kind == Kind_Idfg_move))
            {
                flag_gDsn(_inner.moves, only_S4ER(node.items).type.lifetime, false, _may_alias, _argPos_1b, _current_fn, ss, ctx, _here, module, options, _helpers);
            };
        };
        for (int i = 0; i < node.items.size(); i++)
        {
            SolvedNode_efhg* _0;
            (_0 = &(node.items.mutref(i)), visit_FDl5(*_0, _may_alias, _argPos_1b, _unseqDepth, _inner, _current_fn, ss, ctx, _here, module, options, _helpers));
        };
    };
}

static void nestingFnort_ensureArgSequencing_gDsn(const CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, const fu::vec<Helpers_DyqV>& _helpers)
{
    fu::vec<BitSet_mmp7> _may_alias {};
    fu::vec<int> _argPos_1b {};
    each_uRsP(EXT_gDsn(ss._nestingFnort, ss, ctx, module).args, _may_alias, _argPos_1b, ss, ctx, _here, module, options, _helpers);
    int _unseqDepth = 0;
    Unsequenced_MqaY _inner {};
    SolvedNode_efhg root = steal_bX67(last_xZUS(GET_mut_gDsn(ss._nestingFnort, ss, module).solved.items));
    visit_FDl5(root, _may_alias, _argPos_1b, _unseqDepth, _inner, _current_fn, ss, ctx, _here, module, options, _helpers);
    std::swap(root, last_xZUS(GET_mut_gDsn(ss._nestingFnort, ss, module).solved.items));
}

static void PASS_runAllVerifiers_gDsn(CurrentFn_QbLp& _current_fn, SolverState_aGlN& ss, const Context_noPA& ctx, TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, const fu::vec<Helpers_DyqV>& _helpers)
{

    {
        Map_ZxRu name_counts {};
        for (int i = 0; i < ss._scope.overloads.size(); i++)
        {
            const Overload_aO3i& o = ss._scope.overloads[i];
            if (o.kind == Kind_Idfg_fn)
            {
                const Target_VZrr target = Target_xQNS(module.modid, (i + 1), 0);
                const SolverStatus_h9em status = o.status;
                if (SolverStatus_h9em(~status) & SolverStatus_h9em_SS_FINALIZED)
                {
                    destroyOverload_gDsn(target, ss, module);
                    continue;
                }
                else if (!EXT_gDsn(target, ss, ctx, module).sighash)
                    computeFnSighash_asIfCycleRoot_gDsn(target, name_counts, _current_fn, ss, ctx, _here, module, options, _helpers);

            };
        };
    };
    if (ss._nestingFnort)
    {
        BUG_gDsn("PASS_runAllVerifiers: non-empty _nestingFnort"_view, ss, ctx, _here, module, options, _helpers);
    }
    else if (_current_fn.args_neg)
    {
        BUG_gDsn("PASS_runAllVerifiers: non-empty _current_fn.args_neg"_view, ss, ctx, _here, module, options, _helpers);
    }
    else
    {
        for (int i = 0; i < ss._scope.overloads.size(); i++)
        {
            const Overload_aO3i& o = ss._scope.overloads[i];
            if (o.kind == Kind_Idfg_fn)
            {
                ss._nestingFnort = Target_xQNS(module.modid, (i + 1), 0);
                _current_fn.args_neg = EXT_gDsn(ss._nestingFnort, ss, ctx, module).args_neg;
                nestingFnort_ensureArgSequencing_gDsn(_current_fn, ss, ctx, _here, module, options, _helpers);
            };
        };
    };
    ss._nestingFnort = Target_VZrr{};
    _current_fn.args_neg = 0;
}

static void Scope_observeDefects_gDsn(SolverState_aGlN& ss, const Context_noPA& ctx, const TokenIdx_5581& _here, const Module_wo7O& module, const Options_TBgD& options, fu::view<Helpers_DyqV> _helpers)
{
    bool hasLets = false;
    bool hasPubTemplates = false;
    fu::vec<Target_VZrr> privates {};
    for (int i = 0; i < ss._scope.items.size(); i++)
    {
        const Target_VZrr t = target_z0Qq(ss._scope.items[i]);
        if (!(int(unsigned(((t._packed >> 40ull) & 0xfffffull))) != module.modid))
        {
            Overload_aO3i& o = GET_mut_gDsn(t, ss, module);
            if ((o.kind == Kind_Idfg_var) || (o.kind == Kind_Idfg_fn))
            {
                if (o.kind == Kind_Idfg_var)
                    hasLets = true;

                if (!(o.flags & Flags_Lzg8_F_PUB))
                    privates += Target_VZrr(t);
                else
                    o.status |= SolverStatus_h9em_SS_EXTERNAL_LINKAGE;

            }
            else if (o.kind == Kind_Idfg_template)
            {
                if (o.flags & Flags_Lzg8_F_PUB)
                    hasPubTemplates = true;

            };
        };
    };
    if (hasLets)
    {
        const SolverNotes_LSla note = SolverNotes_LSla_N_SD_HasStaticInit;
        if (note & options.break_notes)
        {
            fu::view<char> reason = fu::view<char>{};
            fail_gDsn((("`break_notes`: Unwanted event: "_view + qBAD_e44U(str_kJvr(note))) + (reason ? ("\n\t\t"_view + reason) : fu::str("."_fu))), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
        }
        else
            ss._notes |= note;

    };
    if (privates && hasPubTemplates)
    {

        {
            const SolverNotes_LSla note = SolverNotes_LSla_N_SD_ExternPrivates;
            if (note & options.break_notes)
            {
                fu::view<char> reason = fu::view<char>{};
                fail_gDsn((("`break_notes`: Unwanted event: "_view + qBAD_e44U(str_kJvr(note))) + (reason ? ("\n\t\t"_view + reason) : fu::str("."_fu))), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
            }
            else
                ss._notes |= note;

        };
        for (int i_1 = 0; i_1 < privates.size(); i_1++)
        {
            Overload_aO3i& o = GET_mut_gDsn(privates[i_1], ss, module);
            o.status |= SolverStatus_h9em_SS_EXTERNAL_LINKAGE;
        };
    };
}

SolverOutput_hA3T solve_gDsn(const Context_noPA& ctx, Module_wo7O& module, const Options_TBgD& options)
{
    TokenIdx_5581 _here {};
    CurrentFn_QbLp _current_fn {};
    SolverState_aGlN ss {};
    fu::vec<Helpers_DyqV> _helpers {};
    ss.shortModuleName = (module.modid ? getShortModuleName_1qjp(module.fname, ctx, _here) : (*(fu::str*)fu::NIL));
    ss.TODO_FIX_convert_args = fu::vec<SolvedNode_efhg> {{ SolvedNode_efhg{} }};
    ss.TODO_FIX_convert_args.mutref(0).kind = Kind_Idfg___convert;
    ss._scope.extended += Extended_z0HS{};
    push_gDsn(HelpersData_uG6I{}, ss, _helpers);
    if (module.modid)
    {
        ss._scope.imports += module.modid;
        _Scope_import__forceCopy_gDsn(0, false, ss, ctx);
    }
    else
    {
        createRawTypedef_gDsn(str_Q1K0BNOSjWk, Type_OiTm(t_i8), Flags_Lzg8_F_PUB, (*(fu::str*)fu::NIL), SolverStatus_h9em{}, ss, module);
        createRawTypedef_gDsn(str_9e92J9C60Ob, Type_OiTm(t_i16), Flags_Lzg8_F_PUB, (*(fu::str*)fu::NIL), SolverStatus_h9em{}, ss, module);
        createRawTypedef_gDsn(str_K8KxoYxA7Xl, Type_OiTm(t_i32), Flags_Lzg8_F_PUB, (*(fu::str*)fu::NIL), SolverStatus_h9em{}, ss, module);
        createRawTypedef_gDsn(str_nXBW7I7egP9, Type_OiTm(t_i64), Flags_Lzg8_F_PUB, (*(fu::str*)fu::NIL), SolverStatus_h9em{}, ss, module);
        createRawTypedef_gDsn(str_T4nNVV0oHGc, Type_OiTm(t_i128), Flags_Lzg8_F_PUB, (*(fu::str*)fu::NIL), SolverStatus_h9em{}, ss, module);
        createRawTypedef_gDsn(str_YhTgzC21Rp2, Type_OiTm(t_u8), Flags_Lzg8_F_PUB, (*(fu::str*)fu::NIL), SolverStatus_h9em{}, ss, module);
        createRawTypedef_gDsn(str_2fAchhueS6b, Type_OiTm(t_u16), Flags_Lzg8_F_PUB, (*(fu::str*)fu::NIL), SolverStatus_h9em{}, ss, module);
        createRawTypedef_gDsn(str_AXDdcKHr29k, Type_OiTm(t_u32), Flags_Lzg8_F_PUB, (*(fu::str*)fu::NIL), SolverStatus_h9em{}, ss, module);
        createRawTypedef_gDsn(str_bDPbEUy6W2b, Type_OiTm(t_u64), Flags_Lzg8_F_PUB, (*(fu::str*)fu::NIL), SolverStatus_h9em{}, ss, module);
        createRawTypedef_gDsn(str_BWBehL8bqk0, Type_OiTm(t_u128), Flags_Lzg8_F_PUB, (*(fu::str*)fu::NIL), SolverStatus_h9em{}, ss, module);
        createRawTypedef_gDsn(str_1QwvpsHdfu3, Type_OiTm(t_f32), Flags_Lzg8_F_PUB, (*(fu::str*)fu::NIL), SolverStatus_h9em{}, ss, module);
        createRawTypedef_gDsn(str_gz4KnAfW2Ug, Type_OiTm(t_f64), Flags_Lzg8_F_PUB, (*(fu::str*)fu::NIL), SolverStatus_h9em{}, ss, module);
        createRawTypedef_gDsn(str_1cD5td1eMvl, Type_OiTm(t_bool), Flags_Lzg8_F_PUB, (*(fu::str*)fu::NIL), SolverStatus_h9em{}, ss, module);
        createRawTypedef_gDsn(str_gj1KpRoPVn2, Type_OiTm(t_byte), Flags_Lzg8_F_PUB, (*(fu::str*)fu::NIL), SolverStatus_h9em{}, ss, module);
        createRawTypedef_gDsn(str_KiGuEGIuqEg, Type_OiTm(t_void), Flags_Lzg8_F_PUB, (*(fu::str*)fu::NIL), SolverStatus_h9em{}, ss, module);
        createRawTypedef_gDsn(str_scsjXZQ1yH3, Type_OiTm(t_never), Flags_Lzg8_F_PUB, (*(fu::str*)fu::NIL), SolverStatus_h9em{}, ss, module);
    };
    Node_JjyR _0 {};
    /*MOV*/ SolvedNode_efhg root = (_0 = steal_9ubk(module.in.parse.root), solveNode_gDsn(static_cast<Node_JjyR&&>(_0), (*(Type_OiTm*)fu::NIL), _current_fn, ss, ctx, _here, module, options, _helpers));
    if (_current_fn)
        BUG_gDsn("non-empty _current_fn."_view, ss, ctx, _here, module, options, _helpers);
    else
    {
        PASS_runAllVerifiers_gDsn(_current_fn, ss, ctx, _here, module, options, _helpers);
        if (ss._helpers_data[0])
            BUG_gDsn("non-empty _helpers_data[0]."_view, ss, ctx, _here, module, options, _helpers);
        else
        {
            Scope_observeDefects_gDsn(ss, ctx, _here, module, options, _helpers);
            for (int i = 0; i < ss._warnings.size(); i++)
            {
                const Warning_9p8u& w = ss._warnings[i];
                if (w.locid)
                {
                    const Target_VZrr target = Target_xQNS(module.modid, i, ((w.locid < 0x11110000) ? w.locid : 0));
                    _here = GET_gDsn(target, ss, ctx, _here, module).solved.token;
                    fail_gDsn(((w.locid == 0x11110000) ? (x7E_rA00(str_FDl5(target, false, ss, ctx, _here, module, options), " does nothing: returns void and has no effects."_view) + makeItLaxIfIntentional_gDsn()) : ((x7E_rA00("Unused variable: "_view, str_FDl5(target, false, ss, ctx, _here, module, options)) + "."_view) + makeItLaxIfIntentional_gDsn())), fu::view<char>{}, TokenIdx_5581(_here), fu::view<TokenIdx_5581>{}, ss, ctx, _here, module, options, _helpers);
                };
            };
            return SolverOutput_hA3T { static_cast<SolvedNode_efhg&&>(root), Scope_exports_z0Qq(ss._scope, module.modid, ss._pub_imports.keys_asc), ss._notes };
        };
    };
}

#endif
