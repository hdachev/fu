#include <cstdint>
#include <fu/int.h>
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/defer.h>
#include <fu/never.h>
#include <fu/decstr.h>
#include <fu/default.h>
#include <fu/vec_range.h>
#include <par/parfor.hpp>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>

struct TestDiffs_EVlo;
typedef int Errno_88RA;
struct TestResult_Ws87;
struct Options_TBgD;
struct Lint_Q9R1;
typedef int SolverNotes_LSla;
typedef fu::u8 CGDefects_2L18;
typedef fu::u8 DevOptions_QEya;
struct Context_noPA;
struct Module_wo7O;
struct ModuleInputs_iQIg;
struct LexerOutput_DN4p;
struct Token_6M7a;
enum Kind_Idfg: fu::u8;
struct LineColChars_6JiM;
struct ParserOutput_d14k;
struct Node_JjyR;
typedef uint16_t DeclAsserts_taUG;
typedef fu::u8 ParseSyntax_Lay2;
typedef unsigned Flags_Lzg8;
struct TokenIdx_5581;
struct Import_7CIJ;
struct ModuleOrder_HMNg;
struct ModuleOutputs_WMGM;
struct Struct_LDkB;
struct Target_VZrr;
struct ScopeItem_xiLD;
struct Set_qOJY;
struct Shape_fvCX;
struct SolverOutput_hA3T;
struct SolvedNode_efhg;
struct Helpers_DyqV;
struct Type_OiTm;
struct ValueType_JtNg;
typedef fu::u8 VFacts_xhRf;
struct Lifetime_llCF;
struct Scope_blWT;
struct Overload_aO3i;
typedef uint16_t SolverStatus_h9em;
struct Extended_z0HS;
struct Argument_bbKc;
struct BitSet_mmp7;
struct COWInside_qvly;
typedef unsigned MayEscapeVia_5nki;
typedef fu::u8 ExitPaths_UXHs;
struct Template_SsLx;
struct TEA_0Daz;
typedef uint16_t FxMask_2dRz;
struct CodegenOutput_qIMB;
struct Set_XshD;
struct BuildHacks_sqc0;
struct ModuleStats_ANTR;
struct ModuleStat_sTmh;
struct Profile_4UPJ;
struct Sample_Time_cblj;
struct NukeOnRebuild_TLE7;
struct Map_Umhk;
fu::str serialize_pXri(const TestDiffs_EVlo&);

                                #ifndef DEF_RW_RW_RW
                                #define DEF_RW_RW_RW
inline constexpr unsigned RW_RW_RW = (((0x6u << 6u) | (0x6u << 3u)) | (0x6u << 0u));
                                #endif
Errno_88RA write_VWJw(fu::str&&, fu::view<char>, unsigned);
Context_noPA ZERO_3QGL(fu::vec<fu::str>&&, Options_TBgD&&, fu::vec_range<char>, int, TestDiffs_EVlo&);
void append_pXri(TestDiffs_EVlo&, const TestDiffs_EVlo&);
void TODO_5TaN(fu::vec_range<char>, fu::vec_range<char>, TestDiffs_EVlo&);
void TODO_3QGL(fu::vec_range<fu::str>, fu::vec_range<char>, TestDiffs_EVlo&);
void ZERO_SAME_5TaN(fu::view<fu::str>, TestDiffs_EVlo&);

                                #ifndef DEF_TestDiffs_EVloQngEKM1
                                #define DEF_TestDiffs_EVloQngEKM1
struct TestDiffs_EVlo
{
    fu::vec<fu::str> data;
    explicit operator bool() const noexcept
    {
        return false
            || data
        ;
    }
};
                                #endif

                                #ifndef DEF_Errno_88RA
                                #define DEF_Errno_88RA
                                #endif

                                #ifndef DEF_TestResult_Ws8767C40A0
                                #define DEF_TestResult_Ws8767C40A0
struct TestResult_Ws87
{
    fu::str error;
    TestDiffs_EVlo testdiffs;
    explicit operator bool() const noexcept
    {
        return false
            || error
            || testdiffs
        ;
    }
};
                                #endif

                                #ifndef DEF_SolverNotes_LSla
                                #define DEF_SolverNotes_LSla
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_FnRecursion = 1;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_FnResolve = 2;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_FnReopen = 4;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_TypeRecursion = 8;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_TypeResolve = 16;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_TypeReopen = 32;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_DeadCode = 64;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_DeadCall = 128;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_DeadLet = 256;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_DeadArrlit = 512;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_DeadLoopInit = 1024;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_DeadConv = 2048;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_NonTrivAutoCopy = 4096;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_RelaxRespec = 8192;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_UnusedImplicit = 16384;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_UnusedCall = 32768;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_UnusedDefer = 65536;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_UnusedTry = 131072;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_UnusedAndOr = 262144;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_UnusedIfElse = 524288;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_UnusedArrlit = 1048576;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_UnusedLet = 2097152;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_BckMustSeq = 4194304;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_AARMustSeq = 8388608;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_AARSoftRisk = 16777216;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_MoveMustSeq = 33554432;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_McomUnwrapsLetdef = 67108864;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_SD_HasStaticInit = 134217728;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_SD_ExternPrivates = 268435456;
inline constexpr SolverNotes_LSla SolverNotes_LSla_N_COWRestrict = 536870912;

inline constexpr SolverNotes_LSla MASK_SolverNotes_LSla
    = SolverNotes_LSla_N_FnRecursion
    | SolverNotes_LSla_N_FnResolve
    | SolverNotes_LSla_N_FnReopen
    | SolverNotes_LSla_N_TypeRecursion
    | SolverNotes_LSla_N_TypeResolve
    | SolverNotes_LSla_N_TypeReopen
    | SolverNotes_LSla_N_DeadCode
    | SolverNotes_LSla_N_DeadCall
    | SolverNotes_LSla_N_DeadLet
    | SolverNotes_LSla_N_DeadArrlit
    | SolverNotes_LSla_N_DeadLoopInit
    | SolverNotes_LSla_N_DeadConv
    | SolverNotes_LSla_N_NonTrivAutoCopy
    | SolverNotes_LSla_N_RelaxRespec
    | SolverNotes_LSla_N_UnusedImplicit
    | SolverNotes_LSla_N_UnusedCall
    | SolverNotes_LSla_N_UnusedDefer
    | SolverNotes_LSla_N_UnusedTry
    | SolverNotes_LSla_N_UnusedAndOr
    | SolverNotes_LSla_N_UnusedIfElse
    | SolverNotes_LSla_N_UnusedArrlit
    | SolverNotes_LSla_N_UnusedLet
    | SolverNotes_LSla_N_BckMustSeq
    | SolverNotes_LSla_N_AARMustSeq
    | SolverNotes_LSla_N_AARSoftRisk
    | SolverNotes_LSla_N_MoveMustSeq
    | SolverNotes_LSla_N_McomUnwrapsLetdef
    | SolverNotes_LSla_N_SD_HasStaticInit
    | SolverNotes_LSla_N_SD_ExternPrivates
    | SolverNotes_LSla_N_COWRestrict;
                                #endif

                                #ifndef DEF_CGDefects_2L18
                                #define DEF_CGDefects_2L18
inline constexpr CGDefects_2L18 CGDefects_2L18_GNUStmtExpr = CGDefects_2L18(1u);
inline constexpr CGDefects_2L18 CGDefects_2L18_Goto = CGDefects_2L18(2u);
inline constexpr CGDefects_2L18 CGDefects_2L18_PointlessMustSeq = CGDefects_2L18(4u);
inline constexpr CGDefects_2L18 CGDefects_2L18_LocalConstBool = CGDefects_2L18(8u);
inline constexpr CGDefects_2L18 CGDefects_2L18_ConstCast = CGDefects_2L18(16u);
inline constexpr CGDefects_2L18 CGDefects_2L18_PointlessLocal = CGDefects_2L18(32u);
inline constexpr CGDefects_2L18 CGDefects_2L18_IrrelevantLiteral = CGDefects_2L18(64u);
inline constexpr CGDefects_2L18 CGDefects_2L18_DuplicateFunctions = CGDefects_2L18(128u);

inline constexpr CGDefects_2L18 MASK_CGDefects_2L18
    = CGDefects_2L18_GNUStmtExpr
    | CGDefects_2L18_Goto
    | CGDefects_2L18_PointlessMustSeq
    | CGDefects_2L18_LocalConstBool
    | CGDefects_2L18_ConstCast
    | CGDefects_2L18_PointlessLocal
    | CGDefects_2L18_IrrelevantLiteral
    | CGDefects_2L18_DuplicateFunctions;
                                #endif

                                #ifndef DEF_DevOptions_QEya
                                #define DEF_DevOptions_QEya
inline constexpr DevOptions_QEya DevOptions_QEya_DEV_Print = DevOptions_QEya(1u);
inline constexpr DevOptions_QEya DevOptions_QEya_DEV_Parallel = DevOptions_QEya(2u);
inline constexpr DevOptions_QEya DevOptions_QEya_DEV_ExpectFail = DevOptions_QEya(4u);
inline constexpr DevOptions_QEya DevOptions_QEya_DEV_HappyPathOnly = DevOptions_QEya(8u);
inline constexpr DevOptions_QEya DevOptions_QEya_DEV_DontFoldLiterals = DevOptions_QEya(16u);
inline constexpr DevOptions_QEya DevOptions_QEya_DEV_IgnoreDefects = DevOptions_QEya(32u);
inline constexpr DevOptions_QEya DevOptions_QEya_DEV_CG_LifetimeAnnots = DevOptions_QEya(64u);

inline constexpr DevOptions_QEya MASK_DevOptions_QEya
    = DevOptions_QEya_DEV_Print
    | DevOptions_QEya_DEV_Parallel
    | DevOptions_QEya_DEV_ExpectFail
    | DevOptions_QEya_DEV_HappyPathOnly
    | DevOptions_QEya_DEV_DontFoldLiterals
    | DevOptions_QEya_DEV_IgnoreDefects
    | DevOptions_QEya_DEV_CG_LifetimeAnnots;
                                #endif

                                #ifndef DEF_Lint_Q9R1a2Yzb4c
                                #define DEF_Lint_Q9R1a2Yzb4c
struct Lint_Q9R1
{
    int maxwarn;
    explicit operator bool() const noexcept
    {
        return false
            || maxwarn
        ;
    }
};
                                #endif

                                #ifndef DEF_Options_TBgDoLC1XOk
                                #define DEF_Options_TBgDoLC1XOk
struct Options_TBgD
{
    Lint_Q9R1 lint;
    SolverNotes_LSla break_notes;
    CGDefects_2L18 break_defects;
    DevOptions_QEya dev;
    unsigned shuffle;
    explicit operator bool() const noexcept
    {
        return false
            || lint
            || break_notes
            || break_defects
            || dev
            || shuffle
        ;
    }
};
                                #endif

                                #ifndef DEF_Kind_Idfg
                                #define DEF_Kind_Idfg
enum Kind_Idfg: fu::u8
{
    Kind_Idfg_sof = 1u,
    Kind_Idfg_err = 2u,
    Kind_Idfg_eof = 3u,
    Kind_Idfg_id = 4u,
    Kind_Idfg_op = 5u,
    Kind_Idfg_int = 6u,
    Kind_Idfg_real = 7u,
    Kind_Idfg_char = 8u,
    Kind_Idfg_str = 9u,
    Kind_Idfg_bool = 10u,
    Kind_Idfg_definit = 11u,
    Kind_Idfg_empty = 12u,
    Kind_Idfg_struct = 13u,
    Kind_Idfg_union = 14u,
    Kind_Idfg_primitive = 15u,
    Kind_Idfg_flags = 16u,
    Kind_Idfg_enum = 17u,
    Kind_Idfg_fn = 18u,
    Kind_Idfg_copy = 19u,
    Kind_Idfg_move = 20u,
    Kind_Idfg_arrlit = 21u,
    Kind_Idfg_not = 22u,
    Kind_Idfg_call = 23u,
    Kind_Idfg_call_indir = 24u,
    Kind_Idfg_argid = 25u,
    Kind_Idfg_root = 26u,
    Kind_Idfg_block = 27u,
    Kind_Idfg_if = 28u,
    Kind_Idfg_or = 29u,
    Kind_Idfg_and = 30u,
    Kind_Idfg_loop = 31u,
    Kind_Idfg_jump = 32u,
    Kind_Idfg___far_jump = 33u,
    Kind_Idfg_defer = 34u,
    Kind_Idfg_try = 35u,
    Kind_Idfg_let = 36u,
    Kind_Idfg_letdef = 37u,
    Kind_Idfg_typecast = 38u,
    Kind_Idfg_typeassert = 39u,
    Kind_Idfg_typeparam = 40u,
    Kind_Idfg_unwrap = 41u,
    Kind_Idfg_pragma = 42u,
    Kind_Idfg_break = 43u,
    Kind_Idfg_return = 44u,
    Kind_Idfg_continue = 45u,
    Kind_Idfg_import = 46u,
    Kind_Idfg_addroffn = 47u,
    Kind_Idfg_forfieldsof = 48u,
    Kind_Idfg_members = 49u,
    Kind_Idfg_fnbranch = 50u,
    Kind_Idfg_pattern = 51u,
    Kind_Idfg_typeunion = 52u,
    Kind_Idfg_typetag = 53u,
    Kind_Idfg___relaxed = 54u,
    Kind_Idfg___convert = 55u,
    Kind_Idfg___preceding_ref_arg = 56u,
    Kind_Idfg___serialized_type = 57u,
    Kind_Idfg___serialized_addrof_type_fn = 58u,
    Kind_Idfg___litfix_bound = 59u,
    Kind_Idfg___no_kind_yet = 60u,
    Kind_Idfg___tombstone = 61u,
    Kind_Idfg_type = 62u,
    Kind_Idfg_var = 63u,
    Kind_Idfg_field = 64u,
    Kind_Idfg_enumv = 65u,
    Kind_Idfg_template = 66u,
    Kind_Idfg___native = 67u,
    Kind_Idfg_inline = 68u,
};
                                #endif

                                #ifndef DEF_DeclAsserts_taUG
                                #define DEF_DeclAsserts_taUG
inline constexpr DeclAsserts_taUG DeclAsserts_taUG_A_NOCOPY = DeclAsserts_taUG(1u);
inline constexpr DeclAsserts_taUG DeclAsserts_taUG_A_NOVEC = DeclAsserts_taUG(2u);
inline constexpr DeclAsserts_taUG DeclAsserts_taUG_A_TRIVIAL = DeclAsserts_taUG(4u);
inline constexpr DeclAsserts_taUG DeclAsserts_taUG_A_NODISCARD = DeclAsserts_taUG(8u);
inline constexpr DeclAsserts_taUG DeclAsserts_taUG_A_PURE = DeclAsserts_taUG(16u);
inline constexpr DeclAsserts_taUG DeclAsserts_taUG_A_PURE_CTX = DeclAsserts_taUG(32u);
inline constexpr DeclAsserts_taUG DeclAsserts_taUG_A_PURE_FX = DeclAsserts_taUG(64u);
inline constexpr DeclAsserts_taUG DeclAsserts_taUG_A_NOFLOW = DeclAsserts_taUG(128u);
inline constexpr DeclAsserts_taUG DeclAsserts_taUG_A_NOTHROW = DeclAsserts_taUG(256u);
inline constexpr DeclAsserts_taUG DeclAsserts_taUG_A_NOCRASH = DeclAsserts_taUG(512u);
inline constexpr DeclAsserts_taUG DeclAsserts_taUG_A_NOIO = DeclAsserts_taUG(1024u);
inline constexpr DeclAsserts_taUG DeclAsserts_taUG_A_FAST = DeclAsserts_taUG(2048u);
inline constexpr DeclAsserts_taUG DeclAsserts_taUG_A_NOINLINE = DeclAsserts_taUG(4096u);

inline constexpr DeclAsserts_taUG MASK_DeclAsserts_taUG
    = DeclAsserts_taUG_A_NOCOPY
    | DeclAsserts_taUG_A_NOVEC
    | DeclAsserts_taUG_A_TRIVIAL
    | DeclAsserts_taUG_A_NODISCARD
    | DeclAsserts_taUG_A_PURE
    | DeclAsserts_taUG_A_PURE_CTX
    | DeclAsserts_taUG_A_PURE_FX
    | DeclAsserts_taUG_A_NOFLOW
    | DeclAsserts_taUG_A_NOTHROW
    | DeclAsserts_taUG_A_NOCRASH
    | DeclAsserts_taUG_A_NOIO
    | DeclAsserts_taUG_A_FAST
    | DeclAsserts_taUG_A_NOINLINE;
                                #endif

                                #ifndef DEF_ParseSyntax_Lay2
                                #define DEF_ParseSyntax_Lay2
inline constexpr ParseSyntax_Lay2 ParseSyntax_Lay2_PS_PARENS = ParseSyntax_Lay2(1u);
inline constexpr ParseSyntax_Lay2 ParseSyntax_Lay2_PS_DISCARD_IF_BLOCK_TAIL = ParseSyntax_Lay2(2u);
inline constexpr ParseSyntax_Lay2 ParseSyntax_Lay2_PS_ALWAYS_DISCARD = ParseSyntax_Lay2(4u);
inline constexpr ParseSyntax_Lay2 ParseSyntax_Lay2_PS_NOT_AN_EXPRESSION = ParseSyntax_Lay2(8u);
inline constexpr ParseSyntax_Lay2 ParseSyntax_Lay2_PS_USING_EXPRESSION = ParseSyntax_Lay2(16u);

inline constexpr ParseSyntax_Lay2 MASK_ParseSyntax_Lay2
    = ParseSyntax_Lay2_PS_PARENS
    | ParseSyntax_Lay2_PS_DISCARD_IF_BLOCK_TAIL
    | ParseSyntax_Lay2_PS_ALWAYS_DISCARD
    | ParseSyntax_Lay2_PS_NOT_AN_EXPRESSION
    | ParseSyntax_Lay2_PS_USING_EXPRESSION;
                                #endif

                                #ifndef DEF_Flags_Lzg8
                                #define DEF_Flags_Lzg8
inline constexpr Flags_Lzg8 Flags_Lzg8_F_CALL_HAS_DOT = 1u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_CALL_HAS_ARGPARENS = 2u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_CALL_HAS_NAMED_ARGS = 4u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_OPERATOR = 8u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_TYPENAME = 16u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_COMPOUND_ID = 32u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_ARGID_IS_OPTIONAL = 64u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_LAX = 128u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_SHADOW = 256u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_MUSTNAME = 512u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_MUT = 1024u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_CONST = 2048u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_VAL = 4096u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_REF = 8192u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_IMPLICIT = 16384u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_USING = 32768u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_CONVERSION = 65536u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_TEST_painted = 131072u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_PUB = 262144u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_EXTERN = 524288u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_HOTSWAP = 1048576u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_PREDICATE = 2097152u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_LT_RETURNED = 4194304u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_REST_ARG = 8388608u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_INJECTED = 16777216u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_TEMPLATE = 33554432u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_INLINE = 67108864u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_LAMBDA = 134217728u;
inline constexpr Flags_Lzg8 Flags_Lzg8_F_COW_INSIDE = 268435456u;

inline constexpr Flags_Lzg8 MASK_Flags_Lzg8
    = Flags_Lzg8_F_CALL_HAS_DOT
    | Flags_Lzg8_F_CALL_HAS_ARGPARENS
    | Flags_Lzg8_F_CALL_HAS_NAMED_ARGS
    | Flags_Lzg8_F_OPERATOR
    | Flags_Lzg8_F_TYPENAME
    | Flags_Lzg8_F_COMPOUND_ID
    | Flags_Lzg8_F_ARGID_IS_OPTIONAL
    | Flags_Lzg8_F_LAX
    | Flags_Lzg8_F_SHADOW
    | Flags_Lzg8_F_MUSTNAME
    | Flags_Lzg8_F_MUT
    | Flags_Lzg8_F_CONST
    | Flags_Lzg8_F_VAL
    | Flags_Lzg8_F_REF
    | Flags_Lzg8_F_IMPLICIT
    | Flags_Lzg8_F_USING
    | Flags_Lzg8_F_CONVERSION
    | Flags_Lzg8_F_TEST_painted
    | Flags_Lzg8_F_PUB
    | Flags_Lzg8_F_EXTERN
    | Flags_Lzg8_F_HOTSWAP
    | Flags_Lzg8_F_PREDICATE
    | Flags_Lzg8_F_LT_RETURNED
    | Flags_Lzg8_F_REST_ARG
    | Flags_Lzg8_F_INJECTED
    | Flags_Lzg8_F_TEMPLATE
    | Flags_Lzg8_F_INLINE
    | Flags_Lzg8_F_LAMBDA
    | Flags_Lzg8_F_COW_INSIDE;
                                #endif

                                #ifndef DEF_VFacts_xhRf
                                #define DEF_VFacts_xhRf
inline constexpr VFacts_xhRf VFacts_xhRf_AlwaysTrue = VFacts_xhRf(1u);
inline constexpr VFacts_xhRf VFacts_xhRf_AlwaysFalse = VFacts_xhRf(2u);
inline constexpr VFacts_xhRf VFacts_xhRf_Typename = VFacts_xhRf(4u);
inline constexpr VFacts_xhRf VFacts_xhRf_LeftAligned = VFacts_xhRf(8u);
inline constexpr VFacts_xhRf VFacts_xhRf_RightAligned = VFacts_xhRf(16u);

inline constexpr VFacts_xhRf MASK_VFacts_xhRf
    = VFacts_xhRf_AlwaysTrue
    | VFacts_xhRf_AlwaysFalse
    | VFacts_xhRf_Typename
    | VFacts_xhRf_LeftAligned
    | VFacts_xhRf_RightAligned;
                                #endif

                                #ifndef DEF_SolverStatus_h9em
                                #define DEF_SolverStatus_h9em
inline constexpr SolverStatus_h9em SolverStatus_h9em_SS_LAZY = SolverStatus_h9em(1u);
inline constexpr SolverStatus_h9em SolverStatus_h9em_SS_DID_START = SolverStatus_h9em(2u);
inline constexpr SolverStatus_h9em SolverStatus_h9em_SS_DIRTY = SolverStatus_h9em(4u);
inline constexpr SolverStatus_h9em SolverStatus_h9em_SS_FINALIZED = SolverStatus_h9em(8u);
inline constexpr SolverStatus_h9em SolverStatus_h9em_SS_UPDATED = SolverStatus_h9em(16u);
inline constexpr SolverStatus_h9em SolverStatus_h9em_SS_TYPE_RECUR = SolverStatus_h9em(32u);
inline constexpr SolverStatus_h9em SolverStatus_h9em_SS_FN_RECUR = SolverStatus_h9em(64u);
inline constexpr SolverStatus_h9em SolverStatus_h9em_SS_FN_OOE_RTL = SolverStatus_h9em(128u);
inline constexpr SolverStatus_h9em SolverStatus_h9em_SS_NAME_UNUSED = SolverStatus_h9em(256u);
inline constexpr SolverStatus_h9em SolverStatus_h9em_SS_UNUSED = SolverStatus_h9em(512u);
inline constexpr SolverStatus_h9em SolverStatus_h9em_SS_MATCHED = SolverStatus_h9em(1024u);
inline constexpr SolverStatus_h9em SolverStatus_h9em_SS_MOVED_FROM = SolverStatus_h9em(2048u);
inline constexpr SolverStatus_h9em SolverStatus_h9em_SS_EXTERNAL_LINKAGE = SolverStatus_h9em(4096u);
inline constexpr SolverStatus_h9em SolverStatus_h9em_SS_OBSERVED_BY_CONV_CACHE = SolverStatus_h9em(8192u);
inline constexpr SolverStatus_h9em SolverStatus_h9em_SS_TODO_FIX_was_rx_resize = SolverStatus_h9em(16384u);
inline constexpr SolverStatus_h9em SolverStatus_h9em_SS_Debug_AllPassesComplete = SolverStatus_h9em(32768u);

inline constexpr SolverStatus_h9em MASK_SolverStatus_h9em
    = SolverStatus_h9em_SS_LAZY
    | SolverStatus_h9em_SS_DID_START
    | SolverStatus_h9em_SS_DIRTY
    | SolverStatus_h9em_SS_FINALIZED
    | SolverStatus_h9em_SS_UPDATED
    | SolverStatus_h9em_SS_TYPE_RECUR
    | SolverStatus_h9em_SS_FN_RECUR
    | SolverStatus_h9em_SS_FN_OOE_RTL
    | SolverStatus_h9em_SS_NAME_UNUSED
    | SolverStatus_h9em_SS_UNUSED
    | SolverStatus_h9em_SS_MATCHED
    | SolverStatus_h9em_SS_MOVED_FROM
    | SolverStatus_h9em_SS_EXTERNAL_LINKAGE
    | SolverStatus_h9em_SS_OBSERVED_BY_CONV_CACHE
    | SolverStatus_h9em_SS_TODO_FIX_was_rx_resize
    | SolverStatus_h9em_SS_Debug_AllPassesComplete;
                                #endif

                                #ifndef DEF_MayEscapeVia_5nki
                                #define DEF_MayEscapeVia_5nki
                                #endif

                                #ifndef DEF_ExitPaths_UXHs
                                #define DEF_ExitPaths_UXHs
inline constexpr ExitPaths_UXHs ExitPaths_UXHs_XP_NonEmptyReturn = ExitPaths_UXHs(1u);
inline constexpr ExitPaths_UXHs ExitPaths_UXHs_XP_EmptyReturn = ExitPaths_UXHs(2u);
inline constexpr ExitPaths_UXHs ExitPaths_UXHs_XP_NoReturn = ExitPaths_UXHs(4u);

inline constexpr ExitPaths_UXHs MASK_ExitPaths_UXHs
    = ExitPaths_UXHs_XP_NonEmptyReturn
    | ExitPaths_UXHs_XP_EmptyReturn
    | ExitPaths_UXHs_XP_NoReturn;
                                #endif

                                #ifndef DEF_FxMask_2dRz
                                #define DEF_FxMask_2dRz
inline constexpr FxMask_2dRz FxMask_2dRz_Fx_NotDeadCode = FxMask_2dRz(1u);
inline constexpr FxMask_2dRz FxMask_2dRz_Fx_NonDeterministic = FxMask_2dRz(2u);
inline constexpr FxMask_2dRz FxMask_2dRz_Fx_DontMoveUp = FxMask_2dRz(4u);
inline constexpr FxMask_2dRz FxMask_2dRz_Fx_DontMoveDown = FxMask_2dRz(8u);
inline constexpr FxMask_2dRz FxMask_2dRz_Fx_Input = FxMask_2dRz(16u);
inline constexpr FxMask_2dRz FxMask_2dRz_Fx_Output = FxMask_2dRz(32u);
inline constexpr FxMask_2dRz FxMask_2dRz_Fx_Throws = FxMask_2dRz(64u);
inline constexpr FxMask_2dRz FxMask_2dRz_Fx_Crashes = FxMask_2dRz(128u);
inline constexpr FxMask_2dRz FxMask_2dRz_Fx_Crashes_Div0 = FxMask_2dRz(256u);
inline constexpr FxMask_2dRz FxMask_2dRz_Fx_Crashes_OOB = FxMask_2dRz(512u);
inline constexpr FxMask_2dRz FxMask_2dRz_Fx_Crashes_Assert = FxMask_2dRz(1024u);
inline constexpr FxMask_2dRz FxMask_2dRz_Fx_Crashes_Exit = FxMask_2dRz(2048u);
inline constexpr FxMask_2dRz FxMask_2dRz_Fx_Syscall = FxMask_2dRz(4096u);
inline constexpr FxMask_2dRz FxMask_2dRz_Fx_Blocks = FxMask_2dRz(8192u);
inline constexpr FxMask_2dRz FxMask_2dRz_Fx_Blocks_Alloc = FxMask_2dRz(16384u);
inline constexpr FxMask_2dRz FxMask_2dRz_Fx_Blocks_Await = FxMask_2dRz(32768u);

inline constexpr FxMask_2dRz MASK_FxMask_2dRz
    = FxMask_2dRz_Fx_NotDeadCode
    | FxMask_2dRz_Fx_NonDeterministic
    | FxMask_2dRz_Fx_DontMoveUp
    | FxMask_2dRz_Fx_DontMoveDown
    | FxMask_2dRz_Fx_Input
    | FxMask_2dRz_Fx_Output
    | FxMask_2dRz_Fx_Throws
    | FxMask_2dRz_Fx_Crashes
    | FxMask_2dRz_Fx_Crashes_Div0
    | FxMask_2dRz_Fx_Crashes_OOB
    | FxMask_2dRz_Fx_Crashes_Assert
    | FxMask_2dRz_Fx_Crashes_Exit
    | FxMask_2dRz_Fx_Syscall
    | FxMask_2dRz_Fx_Blocks
    | FxMask_2dRz_Fx_Blocks_Alloc
    | FxMask_2dRz_Fx_Blocks_Await;
                                #endif

                                #ifndef DEF_Helpers_DyqVC1yXPkj
                                #define DEF_Helpers_DyqVC1yXPkj
struct Helpers_DyqV
{
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_Set_qOJYtbQKZe4
                                #define DEF_Set_qOJYtbQKZe4
struct Set_qOJY
{
    fu::vec<int> keys_asc;
    explicit operator bool() const noexcept
    {
        return false
            || keys_asc
        ;
    }
};
                                #endif

                                #ifndef DEF_Target_VZrrYUw5Awd
                                #define DEF_Target_VZrrYUw5Awd
struct Target_VZrr
{
    uint64_t _packed;
    explicit operator bool() const noexcept
    {
        return false
            || _packed
        ;
    }
};
                                #endif

                                #ifndef DEF_Lifetime_llCFAn7rdDl
                                #define DEF_Lifetime_llCFAn7rdDl
struct Lifetime_llCF
{
    fu::str uni0n;
    explicit operator bool() const noexcept
    {
        return false
            || uni0n
        ;
    }
};
                                #endif

                                #ifndef DEF_Set_XshDfC0Mim3
                                #define DEF_Set_XshDfC0Mim3
struct Set_XshD
{
    fu::vec<fu::str> keys_asc;
    explicit operator bool() const noexcept
    {
        return false
            || keys_asc
        ;
    }
};
                                #endif

                                #ifndef DEF_BitSet_mmp7xBZ4kaf
                                #define DEF_BitSet_mmp7xBZ4kaf
struct BitSet_mmp7
{
    fu::vec<fu::u8> _data;
    explicit operator bool() const noexcept
    {
        return false
            || _data
        ;
    }
};
                                #endif

                                #ifndef DEF_Sample_Time_cblj5KsY6d7
                                #define DEF_Sample_Time_cblj5KsY6d7
struct Sample_Time_cblj
{
    double time;
    explicit operator bool() const noexcept
    {
        return false
            || time
        ;
    }
};
                                #endif

                                #ifndef DEF_ModuleOrder_HMNgkDis85k
                                #define DEF_ModuleOrder_HMNgkDis85k
struct ModuleOrder_HMNg
{
    int dep_depth;
    explicit operator bool() const noexcept
    {
        return false
            || dep_depth
        ;
    }
};
                                #endif

                                #ifndef DEF_TEA_0DazMLEH01f
                                #define DEF_TEA_0DazMLEH01f
struct TEA_0Daz
{
    unsigned v0;
    unsigned v1;
    explicit operator bool() const noexcept
    {
        return false
            || v0
            || v1
        ;
    }
};
                                #endif

                                #ifndef DEF_ScopeItem_xiLD4Gix9jd
                                #define DEF_ScopeItem_xiLD4Gix9jd
struct ScopeItem_xiLD
{
    fu::str id;
    uint64_t _packed;
    explicit operator bool() const noexcept
    {
        return false
            || id
        ;
    }
};
                                #endif

                                #ifndef DEF_LexerOutput_DN4p6bz8JN7
                                #define DEF_LexerOutput_DN4p6bz8JN7
struct LexerOutput_DN4p
{
    fu::vec<Token_6M7a> tokens;
    explicit operator bool() const noexcept
    {
        return false
            || tokens
        ;
    }
};
                                #endif

                                #ifndef DEF_TokenIdx_5581Mdn3MDd
                                #define DEF_TokenIdx_5581Mdn3MDd
struct TokenIdx_5581
{
    int modid;
    int tokidx;
    explicit operator bool() const noexcept
    {
        return false
            || modid
            || tokidx
        ;
    }
};
                                #endif

                                #ifndef DEF_LineColChars_6JiMQvLXJS2
                                #define DEF_LineColChars_6JiMQvLXJS2
struct LineColChars_6JiM
{
    int line;
    int col;
    int chars;
    explicit operator bool() const noexcept
    {
        return false
            || line
            || col
            || chars
        ;
    }
};
                                #endif

                                #ifndef DEF_ValueType_JtNg3Yu4fH2
                                #define DEF_ValueType_JtNg3Yu4fH2
struct ValueType_JtNg
{
    unsigned quals;
    VFacts_xhRf vfacts;
    fu::str canon;
    explicit operator bool() const noexcept
    {
        return false
            || quals
            || vfacts
            || canon
        ;
    }
};
                                #endif

                                #ifndef DEF_ModuleStat_sTmhPzQmjMb
                                #define DEF_ModuleStat_sTmhPzQmjMb
struct ModuleStat_sTmh
{
    double time;
    int alloc_count;
    int alloc_bytes;
    explicit operator bool() const noexcept
    {
        return false
            || time
            || alloc_count
            || alloc_bytes
        ;
    }
};
                                #endif

                                #ifndef DEF_Shape_fvCXSyBvLeh
                                #define DEF_Shape_fvCXSyBvLeh
struct Shape_fvCX
{
    fu::str basePrim;
    uint64_t non_triv_mask;
    uint64_t hash;
    int flatCount;
    int declDepth;
    explicit operator bool() const noexcept
    {
        return false
            || basePrim
            || non_triv_mask
            || hash
            || flatCount
            || declDepth
        ;
    }
};
                                #endif

                                #ifndef DEF_Scope_blWT6MMEi3a
                                #define DEF_Scope_blWT6MMEi3a
struct Scope_blWT
{
    fu::vec<Overload_aO3i> overloads;
    fu::vec<Extended_z0HS> extended;
    fu::vec<ScopeItem_xiLD> items;
    fu::vec<ScopeItem_xiLD> implicits;
    fu::vec<ScopeItem_xiLD> globals;
    fu::vec<int> imports;
    fu::vec<int> privates;
    fu::vec<Target_VZrr> usings;
    fu::vec<Target_VZrr> converts;
    int pub_items;
    int pub_implicits;
    int pub_globals;
    int pub_converts;
    Scope_blWT(const Scope_blWT&) = delete;
    Scope_blWT(Scope_blWT&&) = default;
    Scope_blWT& operator=(const Scope_blWT&) = delete;
    Scope_blWT& operator=(Scope_blWT&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || overloads
            || extended
            || items
            || implicits
            || globals
            || imports
            || privates
            || usings
            || converts
            || pub_items
            || pub_implicits
            || pub_globals
            || pub_converts
        ;
    }
};
                                #endif

                                #ifndef DEF_Profile_4UPJX2Ekm31
                                #define DEF_Profile_4UPJX2Ekm31
struct Profile_4UPJ
{
    Sample_Time_cblj now;
    explicit operator bool() const noexcept
    {
        return false
            || now
        ;
    }
};
                                #endif

                                #ifndef DEF_Map_Umhkk3Q7ESc
                                #define DEF_Map_Umhkk3Q7ESc
struct Map_Umhk
{
    Set_XshD keys;
    fu::vec<fu::str> vals;
    explicit operator bool() const noexcept
    {
        return false
            || keys
            || vals
        ;
    }
};
                                #endif

                                #ifndef DEF_Token_6M7a5ObuiN2
                                #define DEF_Token_6M7a5ObuiN2
struct Token_6M7a
{
    Kind_Idfg kind;
    LineColChars_6JiM lcc;
    fu::str value;
    explicit operator bool() const noexcept
    {
        return false
            || kind
        ;
    }
};
                                #endif

                                #ifndef DEF_Type_OiTmZNVtrhg
                                #define DEF_Type_OiTmZNVtrhg
struct Type_OiTm
{
    ValueType_JtNg vtype;
    Lifetime_llCF lifetime;
    explicit operator bool() const noexcept
    {
        return false
            || vtype
            || lifetime
        ;
    }
};
                                #endif

                                #ifndef DEF_Import_7CIJGVi8Ybg
                                #define DEF_Import_7CIJGVi8Ybg
struct Import_7CIJ
{
    TokenIdx_5581 token;
    fu::str pattern;
    int modid;
    explicit operator bool() const noexcept
    {
        return false
            || token
            || pattern
            || modid
        ;
    }
};
                                #endif

                                #ifndef DEF_BuildHacks_sqc0iR8AO8j
                                #define DEF_BuildHacks_sqc0iR8AO8j
struct BuildHacks_sqc0
{
    Set_XshD link;
    Set_XshD include_dirs;
    Set_XshD extra_sources;
    explicit operator bool() const noexcept
    {
        return false
            || link
            || include_dirs
            || extra_sources
        ;
    }
};
                                #endif

                                #ifndef DEF_ModuleStats_ANTRP1S5xh9
                                #define DEF_ModuleStats_ANTRP1S5xh9
struct ModuleStats_ANTR
{
    ModuleStat_sTmh lex;
    ModuleStat_sTmh parse;
    ModuleStat_sTmh solve;
    ModuleStat_sTmh codegen;
    explicit operator bool() const noexcept
    {
        return false
            || lex
            || parse
            || solve
            || codegen
        ;
    }
};
                                #endif

                                #ifndef DEF_Struct_LDkBleMfVWj
                                #define DEF_Struct_LDkBleMfVWj
struct Struct_LDkB
{
    Kind_Idfg kind;
    fu::str name;
    Target_VZrr target;
    fu::vec<ScopeItem_xiLD> items;
    fu::vec<ScopeItem_xiLD> implicits;
    Set_qOJY imports;
    fu::vec<Target_VZrr> converts;
    Shape_fvCX shape;
    explicit operator bool() const noexcept
    {
        return false
            || kind
        ;
    }
};
                                #endif

                                #ifndef DEF_COWInside_qvlyaYROKmj
                                #define DEF_COWInside_qvlyaYROKmj
struct COWInside_qvly
{
    ValueType_JtNg vtype;
    TokenIdx_5581 token;
    int argTarget;
    MayEscapeVia_5nki mayEscapeVia;
    ExitPaths_UXHs exitPaths;
    explicit operator bool() const noexcept
    {
        return false
            || vtype
            || token
            || argTarget
            || mayEscapeVia
            || exitPaths
        ;
    }
};
                                #endif

                                #ifndef DEF_Node_JjyRxwEqS5g
                                #define DEF_Node_JjyRxwEqS5g
struct Node_JjyR
{
    Kind_Idfg kind;
    DeclAsserts_taUG asserts;
    ParseSyntax_Lay2 syntax;
    Flags_Lzg8 flags;
    fu::str value;
    fu::vec<Node_JjyR> items;
    TokenIdx_5581 token;
    Node_JjyR(const Node_JjyR&) = default;
    Node_JjyR(Node_JjyR&&) = default;
    Node_JjyR& operator=(Node_JjyR&&) = default;
    Node_JjyR& operator=(const Node_JjyR& selfrec) { return *this = Node_JjyR(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || kind
        ;
    }
};
                                #endif

                                #ifndef DEF_Template_SsLxhvAKrZc
                                #define DEF_Template_SsLxhvAKrZc
struct Template_SsLx
{
    Node_JjyR node;
    fu::vec<int> imports;
    explicit operator bool() const noexcept
    {
        return false
            || node
        ;
    }
};
                                #endif

                                #ifndef DEF_NukeOnRebuild_TLE7j3PsyGg
                                #define DEF_NukeOnRebuild_TLE7j3PsyGg
struct NukeOnRebuild_TLE7
{
    Map_Umhk files;
    Map_Umhk fuzzy;
    explicit operator bool() const noexcept
    {
        return false
            || files
            || fuzzy
        ;
    }
};
                                #endif

                                #ifndef DEF_ParserOutput_d14kSKCxwSg
                                #define DEF_ParserOutput_d14kSKCxwSg
struct ParserOutput_d14k
{
    Node_JjyR root;
    fu::vec<Import_7CIJ> imports;
    fu::vec<fu::str> warnings;
    explicit operator bool() const noexcept
    {
        return false
            || root
            || imports
            || warnings
        ;
    }
};
                                #endif

                                #ifndef DEF_CodegenOutput_qIMBO7608c0
                                #define DEF_CodegenOutput_qIMBO7608c0
struct CodegenOutput_qIMB
{
    fu::str src;
    Set_XshD includes_headers;
    BuildHacks_sqc0 hacks;
    Set_qOJY testsuite_modids;
    CGDefects_2L18 defects;
    explicit operator bool() const noexcept
    {
        return false
            || src
            || includes_headers
            || hacks
            || testsuite_modids
            || defects
        ;
    }
};
                                #endif

                                #ifndef DEF_SolvedNode_efhg6mFAbn1
                                #define DEF_SolvedNode_efhg6mFAbn1
struct SolvedNode_efhg
{
    Kind_Idfg kind;
    Helpers_DyqV helpers;
    Flags_Lzg8 flags;
    int _loop_start;
    fu::str value;
    fu::vec<SolvedNode_efhg> items;
    TokenIdx_5581 token;
    Type_OiTm type;
    Target_VZrr target;
    SolvedNode_efhg(const SolvedNode_efhg&) = default;
    SolvedNode_efhg(SolvedNode_efhg&&) = default;
    SolvedNode_efhg& operator=(SolvedNode_efhg&&) = default;
    SolvedNode_efhg& operator=(const SolvedNode_efhg& selfrec) { return *this = SolvedNode_efhg(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || kind
        ;
    }
};
                                #endif

                                #ifndef DEF_ModuleInputs_iQIgWAk3ys1
                                #define DEF_ModuleInputs_iQIgWAk3ys1
struct ModuleInputs_iQIg
{
    fu::str src;
    LexerOutput_DN4p lex;
    ParserOutput_d14k parse;
    explicit operator bool() const noexcept
    {
        return false
            || src
            || lex
            || parse
        ;
    }
};
                                #endif

                                #ifndef DEF_Overload_aO3iBmOu2tl
                                #define DEF_Overload_aO3iBmOu2tl
struct Overload_aO3i
{
    Kind_Idfg kind;
    Flags_Lzg8 flags;
    SolverStatus_h9em status;
    DeclAsserts_taUG asserts;
    fu::str name;
    Type_OiTm type;
    SolvedNode_efhg solved;
    explicit operator bool() const noexcept
    {
        return false
            || kind
        ;
    }
};
                                #endif

                                #ifndef DEF_Extended_z0HSOEPqb07
                                #define DEF_Extended_z0HSOEPqb07
struct Extended_z0HS
{
    int min;
    int max;
    fu::vec<Argument_bbKc> args;
    fu::vec<COWInside_qvly> cows_inside;
    Target_VZrr spec_of;
    Template_SsLx tEmplate;
    fu::vec<Overload_aO3i> args_n_locals;
    TEA_0Daz sighash;
    FxMask_2dRz fx_mask;
    int args_neg;
    explicit operator bool() const noexcept
    {
        return false
            || tEmplate
        ;
    }
};
                                #endif

                                #ifndef DEF_SolverOutput_hA3TAuh8W27
                                #define DEF_SolverOutput_hA3TAuh8W27
struct SolverOutput_hA3T
{
    SolvedNode_efhg root;
    Scope_blWT scope;
    SolverNotes_LSla notes;
    SolverOutput_hA3T(const SolverOutput_hA3T&) = delete;
    SolverOutput_hA3T(SolverOutput_hA3T&&) = default;
    SolverOutput_hA3T& operator=(const SolverOutput_hA3T&) = delete;
    SolverOutput_hA3T& operator=(SolverOutput_hA3T&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || root
            || scope
            || notes
        ;
    }
};
                                #endif

                                #ifndef DEF_Argument_bbKcjdTxEug
                                #define DEF_Argument_bbKcjdTxEug
struct Argument_bbKc
{
    fu::str name;
    fu::str autocall;
    Type_OiTm type;
    SolvedNode_efhg dEfault;
    Target_VZrr target;
    Flags_Lzg8 flags;
    unsigned written_to;
    BitSet_mmp7 may_invalidate;
    BitSet_mmp7 may_alias;
    explicit operator bool() const noexcept
    {
        return false
            || name
            || autocall
            || type
            || dEfault
            || target
            || flags
            || written_to
            || may_invalidate
            || may_alias
        ;
    }
};
                                #endif

                                #ifndef DEF_Context_noPAKWUf0xa
                                #define DEF_Context_noPAKWUf0xa
struct Context_noPA
{
    fu::str fudir;
    fu::str base_dir;
    fu::vec<Module_wo7O> modules;
    fu::vec<int> dep_order;
    NukeOnRebuild_TLE7 nuke;
    Context_noPA(const Context_noPA&) = delete;
    Context_noPA(Context_noPA&&) = default;
    Context_noPA& operator=(const Context_noPA&) = delete;
    Context_noPA& operator=(Context_noPA&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || fudir
            || base_dir
            || modules
            || dep_order
            || nuke
        ;
    }
};
                                #endif

                                #ifndef DEF_ModuleOutputs_WMGMpooiIO2
                                #define DEF_ModuleOutputs_WMGMpooiIO2
struct ModuleOutputs_WMGM
{
    fu::vec<Struct_LDkB> types;
    SolverOutput_hA3T solve;
    CodegenOutput_qIMB cpp;
    ModuleOutputs_WMGM(const ModuleOutputs_WMGM&) = delete;
    ModuleOutputs_WMGM(ModuleOutputs_WMGM&&) = default;
    ModuleOutputs_WMGM& operator=(const ModuleOutputs_WMGM&) = delete;
    ModuleOutputs_WMGM& operator=(ModuleOutputs_WMGM&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || types
            || solve
            || cpp
        ;
    }
};
                                #endif

                                #ifndef DEF_Module_wo7O6EZDQyh
                                #define DEF_Module_wo7O6EZDQyh
struct Module_wo7O
{
    int modid;
    fu::str fname;
    ModuleInputs_iQIg in;
    ModuleOrder_HMNg order;
    ModuleOutputs_WMGM out;
    ModuleStats_ANTR stats;
    Profile_4UPJ profile;
    Module_wo7O(const Module_wo7O&) = delete;
    Module_wo7O(Module_wo7O&&) = default;
    Module_wo7O& operator=(const Module_wo7O&) = delete;
    Module_wo7O& operator=(Module_wo7O&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || modid
            || fname
            || in
            || order
            || out
            || stats
            || profile
        ;
    }
};
                                #endif

                                #ifndef STR_VipjxbFj0Wb
                                #define STR_VipjxbFj0Wb
static const fu::str str_VipjxbFj0Wb fu_INIT_PRIORITY(1015) { "\n        <fail main return type does not match annot i32 3:12+4>\n        fn main(): i32 {}               <pass/>\n        fn main(): i32 { return 0; }    </fail>\n    "_fu };
                                #endif

                                #ifndef STR_DFOuAasAaAb
                                #define STR_DFOuAasAaAb
static const fu::str str_DFOuAasAaAb fu_INIT_PRIORITY(1015) { "\n        <fail test return type does not match annot i32 3:12+4>\n        fn test(): i32 {}               <pass/>\n        fn test(): i32 { return 0; }    </fail>\n        fn main() test();\n    "_fu };
                                #endif

                                #ifndef STR_3sE2yOAoS6b
                                #define STR_3sE2yOAoS6b
static const fu::str str_3sE2yOAoS6b fu_INIT_PRIORITY(1015) { "\n        return 1 - 1;\n    "_fu };
                                #endif

                                #ifndef STR_zz5dICl64U1
                                #define STR_zz5dICl64U1
static const fu::str str_zz5dICl64U1 fu_INIT_PRIORITY(1015) { "\n        return <fail COMPILER BUG or INCORRECT TESTCASE exit code 3>\n                        3 <pass/>\n                        0 </fail>\n    "_fu };
                                #endif

                                #ifndef STR_Y1AchFVVAe3
                                #define STR_Y1AchFVVAe3
static const fu::str str_Y1AchFVVAe3 fu_INIT_PRIORITY(1015) { "\n        return 0\n        <fail COMPILER BUG or INCORRECT TESTCASE exit code>\n            || throw(\"TESTERR\")\n                 <pass/></fail>\n    "_fu };
                                #endif

                                #ifndef STR_VXdeCe0KFU3
                                #define STR_VXdeCe0KFU3
static const fu::str str_VXdeCe0KFU3 fu_INIT_PRIORITY(1015) { "\n        fn sum(a: i32, b: i32): i32\n            a + b;\n\n        return sum(1, -1);\n    "_fu };
                                #endif

                                #ifndef STR_V9m6LFrfrSh
                                #define STR_V9m6LFrfrSh
static const fu::str str_V9m6LFrfrSh fu_INIT_PRIORITY(1015) { "\n        fn sum(a: i32, b: i32)\n            a + b;\n\n        return sum(1, -1);\n    "_fu };
                                #endif

                                #ifndef STR_3mf1WaH6287
                                #define STR_3mf1WaH6287
static const fu::str str_3mf1WaH6287 fu_INIT_PRIORITY(1015) { "\n        fn sign(a: i32)\n            a > 0 ? 1 : a < 0 ? -1 : 0;\n\n        return sign(7) + sign(-3) + sign(0);\n    "_fu };
                                #endif

                                #ifndef STR_qySmxBISqli
                                #define STR_qySmxBISqli
static const fu::str str_qySmxBISqli fu_INIT_PRIORITY(1015) { "\n        fn sign(a: i32) {\n            if (a > 0)\n                return 1;\n\n            return -2;\n        }\n\n        return sign(10) * 2 + sign(-5);\n    "_fu };
                                #endif

                                #ifndef STR_PH4axN3ofZ2
                                #define STR_PH4axN3ofZ2
static const fu::str str_PH4axN3ofZ2 fu_INIT_PRIORITY(1015) { "\n        fn sign(a: i32) {\n            if (a > 0)\n                return 1;\n            else\n                return -2;\n        }\n\n        return sign(10) * 2 + sign(-5);\n    "_fu };
                                #endif

                                #ifndef STR_ptOK4lUjXWb
                                #define STR_ptOK4lUjXWb
static const fu::str str_ptOK4lUjXWb fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            let  i = -1;\n            let sb = i.i8;\n            let  b = i.u8;\n\n            return sb == -1 && b == 255 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_iuYgSXycQvb
                                #define STR_iuYgSXycQvb
static const fu::str str_iuYgSXycQvb fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            let sb = (-1).i8;\n            let  i =  sb.i32;\n            let  u =  sb.u32;\n\n            return i == -1 && u.i32 == 255 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_JKF8d7BdQ41
                                #define STR_JKF8d7BdQ41
static const fu::str str_JKF8d7BdQ41 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            let b = byte(200);\n            let i = b.i32;\n            return i == 200 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_WYhljbj6Ut1
                                #define STR_WYhljbj6Ut1
static const fu::str str_WYhljbj6Ut1 fu_INIT_PRIORITY(1015) { "\n        mut arr = [ 0 ];\n        return arr[0];\n    "_fu };
                                #endif

                                #ifndef STR_85vrrNH3mR7
                                #define STR_85vrrNH3mR7
static const fu::str str_85vrrNH3mR7 fu_INIT_PRIORITY(1015) { "\n        let a = 3;\n        mut b = a;\n        b++;\n        return b - (a + 1);\n    "_fu };
                                #endif

                                #ifndef STR_eIA2tHcNZt9
                                #define STR_eIA2tHcNZt9
static const fu::str str_eIA2tHcNZt9 fu_INIT_PRIORITY(1015) { "\n        mut sum = 0;\n        for (mut i = 0; i < 10; i++)\n            sum++;\n\n        return sum * 2 - 20;\n    "_fu };
                                #endif

                                #ifndef STR_FVcxBzdMF99
                                #define STR_FVcxBzdMF99
static const fu::str str_FVcxBzdMF99 fu_INIT_PRIORITY(1015) { "\n        mut sum = 0;\n        for (mut i = 10; i --> 0; )\n            sum--;\n\n        return sum * 2 + 20;\n    "_fu };
                                #endif

                                #ifndef STR_4wF8hgGOC3l
                                #define STR_4wF8hgGOC3l
static const fu::str str_4wF8hgGOC3l fu_INIT_PRIORITY(1015) { "\n        fn decr(ref num: i32)\n            num--;\n\n        mut res = 0;\n        decr(res);\n        return res + 1;\n    "_fu };
                                #endif

                                #ifndef STR_baOp0SqqxZa
                                #define STR_baOp0SqqxZa
static const fu::str str_baOp0SqqxZa fu_INIT_PRIORITY(1015) { "\n        mut res = 0;\n        fn decr()\n            res--;\n\n        decr();\n        return res + 1;\n    "_fu };
                                #endif

                                #ifndef STR_yEn7bIzFO17
                                #define STR_yEn7bIzFO17
static const fu::str str_yEn7bIzFO17 fu_INIT_PRIORITY(1015) { "\n        mut res = 0;\n        fn decr(ref num: i32) { num--; } // ret void\n\n        decr(res);\n        return res + 1;\n    "_fu };
                                #endif

                                #ifndef STR_jRbiwb9QoO4
                                #define STR_jRbiwb9QoO4
static const fu::str str_jRbiwb9QoO4 fu_INIT_PRIORITY(1015) { "\n        mut sum = 0;\n        while (sum < 15)\n            sum++;\n\n        return sum - 15;\n    "_fu };
                                #endif

                                #ifndef STR_MnuQLPY1gie
                                #define STR_MnuQLPY1gie
static const fu::str str_MnuQLPY1gie fu_INIT_PRIORITY(1015) { "\n        <fail ++>\n        let sum = 0;        <pass/>\n        mut sum = 0;        </fail>\n        while (sum < 15)\n            sum++;\n\n        return sum - 15;\n    "_fu };
                                #endif

                                #ifndef STR_iqIw1B7fIJ7
                                #define STR_iqIw1B7fIJ7
static const fu::str str_iqIw1B7fIJ7 fu_INIT_PRIORITY(1015) { "\n        mut sum = 0;\n        while (sum < 15)\n            sum += 2;\n\n        return sum - 16;\n    "_fu };
                                #endif

                                #ifndef STR_5j8tXarLnng
                                #define STR_5j8tXarLnng
static const fu::str str_5j8tXarLnng fu_INIT_PRIORITY(1015) { "\n        mut i = 5;\n        mut sum = 0;\n        while (let x = i--) sum += x - i;\n        return sum - 5;\n    "_fu };
                                #endif

                                #ifndef STR_ZxLoGcfp2Of
                                #define STR_ZxLoGcfp2Of
static const fu::str str_ZxLoGcfp2Of fu_INIT_PRIORITY(1015) { "\n        fn named(a: i32, b: i32)\n            a - b * 2;\n\n        return named(b: 3, 6);\n    "_fu };
                                #endif

                                #ifndef STR_4eCz5turkM1
                                #define STR_4eCz5turkM1
static const fu::str str_4eCz5turkM1 fu_INIT_PRIORITY(1015) { "\n        fn named(a: i32, b: i32)\n            a - b * 2;\n\n        fn other(a: i32, b: i32)\n            named(:b, :a);\n\n        return other(b: 3, 6);\n    "_fu };
                                #endif

                                #ifndef STR_BfNe5UI4fe2
                                #define STR_BfNe5UI4fe2
static const fu::str str_BfNe5UI4fe2 fu_INIT_PRIORITY(1015) { "\n        fn ret_only_arg(a) a;\n        <split/>\n        fn main() 0.ret_only_arg;\n    "_fu };
                                #endif

                                #ifndef STR_eD4mWFBbZQ6
                                #define STR_eD4mWFBbZQ6
static const fu::str str_eD4mWFBbZQ6 fu_INIT_PRIORITY(1015) { "\n        struct Range {\n            min: i32;\n            max: i32;\n        }\n\n        fn size(r: Range)\n            r.max - r.min;\n\n        return size(Range(14, 21)) - 7;\n    "_fu };
                                #endif

                                #ifndef STR_AJyfp9wq1Ml
                                #define STR_AJyfp9wq1Ml
static const fu::str str_AJyfp9wq1Ml fu_INIT_PRIORITY(1015) { "\n        struct Range {\n            min: i32;\n            max: i32;\n        }\n\n        mut r = Range(1, 2);\n        r.min++;\n        return r.max - r.min;\n    "_fu };
                                #endif

                                #ifndef STR_rSiYuQgPDUi
                                #define STR_rSiYuQgPDUi
static const fu::str str_rSiYuQgPDUi fu_INIT_PRIORITY(1015) { "\n        struct Range {\n            min: i32;\n            max: i32;\n        }\n\n        <fail ++>\n        let r =             <pass/>\n        mut r =             </fail>\n            Range(1, 2);\n\n        r.min++;\n        return r.max - r.min;\n    "_fu };
                                #endif

                                #ifndef STR_VqaY5S6Ltbg
                                #define STR_VqaY5S6Ltbg
static const fu::str str_VqaY5S6Ltbg fu_INIT_PRIORITY(1015) { "\n        struct Range {\n            r_min: i32;\n            r_max: i32;\n        }\n\n        fn size(using r: Range)\n            r_max - r_min;\n\n        return size(Range(14, 21)) - 7;\n    "_fu };
                                #endif

                                #ifndef STR_yMbq6hEIGxk
                                #define STR_yMbq6hEIGxk
static const fu::str str_yMbq6hEIGxk fu_INIT_PRIORITY(1015) { "\n        struct X {\n            a: i32;\n        }\n\n        fn test(using x: X, b: i32) a + b;\n        fn hey(using x: X) test(-1);\n\n        return X(1).hey;\n    "_fu };
                                #endif

                                #ifndef STR_OokcKR28ew6
                                #define STR_OokcKR28ew6
static const fu::str str_OokcKR28ew6 fu_INIT_PRIORITY(1015) { "\n        struct Pos {\n            x: i32;\n        }\n\n        struct Player {\n            using pos: Pos;\n        }\n\n        fn dist(using p: Player, other: Player)\n            x - other.x;\n\n        let a = Player(Pos(10));\n        let b = Player(Pos( 4));\n\n        return dist(a, b) - 6;\n    "_fu };
                                #endif

                                #ifndef STR_KxmAtvVIW1i
                                #define STR_KxmAtvVIW1i
static const fu::str str_KxmAtvVIW1i fu_INIT_PRIORITY(1015) { "\n        struct A { x: i32; y: i32; };\n        struct B { x: i32; z: i32; };\n        fn test(using left: A, using right: B)\n            <fail ambig x 2:20+1 using left 4:17+5 3:20+1 using right 4:32+5>\n            x + z; <pass/>\n            y + z; </fail>\n\n        fn main() test(A(1, 1), B(-1, -1));\n    "_fu };
                                #endif

                                #ifndef STR_Bc6P7zVUdW6
                                #define STR_Bc6P7zVUdW6
static const fu::str str_Bc6P7zVUdW6 fu_INIT_PRIORITY(1015) { "\n        struct CurrentFn {\n            parent_idx: i32;\n            using RoR?: CurrentFn_ResetOnResolve; // not yet populated\n        };\n\n        struct CurrentFn_ResetOnResolve {\n            ret_count: i32;\n        };\n\n        fn test(f: CurrentFn) f.parent_idx - f.ret_count;\n        fn main() test(CurrentFn(1, CurrentFn_ResetOnResolve(1)));\n    "_fu };
                                #endif

                                #ifndef STR_X0xc4w1TAZ9
                                #define STR_X0xc4w1TAZ9
static const fu::str str_X0xc4w1TAZ9 fu_INIT_PRIORITY(1015) { "\n        struct HasPredicate {\n            true kind   : string;\n            items       : i32;\n        };\n\n        fn main() {\n            let isTrue  = HasPredicate(\"let\", 0);\n            let isFalse = HasPredicate(\"\",    1);\n            return isTrue && !isFalse ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_QEJ7S5ntxrk
                                #define STR_QEJ7S5ntxrk
static const fu::str str_QEJ7S5ntxrk fu_INIT_PRIORITY(1015) { "\n        struct Stuff { name: string };\n\n        fn shadowsStructMember(using stuff: Stuff, other: string) {\n            shadow let name = other || name;\n            return name;\n        }\n\n        fn main() = shadowsStructMember(Stuff(\"a\"), \"bb\").len - 2;\n    "_fu };
                                #endif

                                #ifndef STR_vp5GoKzKuMb
                                #define STR_vp5GoKzKuMb
static const fu::str str_vp5GoKzKuMb fu_INIT_PRIORITY(1015) { "\n        fn call_with_using_and_explicit_arg(x: i32, y: i32) = x + 7*y;\n        fn main () {\n            using let y = 1;\n            return call_with_using_and_explicit_arg(x: 2) - 9;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_z7OFVfq8IMi
                                #define STR_z7OFVfq8IMi
static const fu::str str_z7OFVfq8IMi fu_INIT_PRIORITY(1015) { "\n        fn call_with_using_explicit_and_trailing(x: i32, y: i32, m: i32) = (x + 7*y) * m;\n        fn main () {\n            using let x = 1;\n            return call_with_using_explicit_and_trailing(y: 2, 3) - 45;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_VLMFPCNHoL6
                                #define STR_VLMFPCNHoL6
static const fu::str str_VLMFPCNHoL6 fu_INIT_PRIORITY(1015) { "\n        <fail items not trivial>\n        trivial<pass/></fail>\n        struct Node { items: Node[]; };\n\n        fn main() {\n            mut n: Node;\n            return n.items.len;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_BoqTaGpQg5b
                                #define STR_BoqTaGpQg5b
static const fu::str str_BoqTaGpQg5b fu_INIT_PRIORITY(1015) { "\n        struct Other { using w: Node };\n\n        struct Node {\n            <fail self recursive (Node|Other) (2:30+1|6:13+1)>\n            v: Node;           <fail/>\n            v: Other;          <pass/>\n            v: i32;            </fail>\n        };\n\n        fn main() {\n            mut node: Node;\n            return node.v ? 1 : 0;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_NsxAC7cy3Ga
                                #define STR_NsxAC7cy3Ga
static const fu::str str_NsxAC7cy3Ga fu_INIT_PRIORITY(1015) { "\n        fn sqr(implicit ref b: i32) {\n            return b *= b;\n        }\n        <split/>\n        fn main() {\n            struct Hey {\n                implicit a: i32;\n                implicit b: i32;\n            };\n\n            using mut hey = Hey(10, 20);\n            sqr();\n            return hey.a == 10 && hey.b == 400 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_n6MFqRk4oUg
                                #define STR_n6MFqRk4oUg
static const fu::str str_n6MFqRk4oUg fu_INIT_PRIORITY(1015) { "\n        extern struct hello { v: int }\n        fn what(h: hello) h.v;\n        fn main() {\n            mut s: hello;\n            pragma emit(s, \" = hello { 10 };\");\n            return s.v - 10\n        }\n    "_fu };
                                #endif

                                #ifndef STR_a9aEBbp7Fql
                                #define STR_a9aEBbp7Fql
static const fu::str str_a9aEBbp7Fql fu_INIT_PRIORITY(1015) { "\n        struct vec3 { v: i32 };\n        struct mat34 { mx: vec3; my: vec3; mo: vec3 };\n        fn translate = vec3(0);\n\n        fn mat34(using scale: vec3)\n            mat34(\n                vec3(v),    // Intent of using was just to destructure the vec3 here.\n                vec3(v),\n                // translate, Forgot this, compiles without it, got really confused.\n                            // It's surprising when usings feed into constructors,\n                            //  but i don't like the idea of making them special either.\n                            //   Perhaps require argnames when multiple members have same type?\n            );\n\n        fn main() mat34(vec3(1)).mo.v;\n    "_fu };
                                #endif

                                #ifndef STR_7NNX97mGs5d
                                #define STR_7NNX97mGs5d
static const fu::str str_7NNX97mGs5d fu_INIT_PRIORITY(1015) { "BUG exit code"_fu };
                                #endif

                                #ifndef STR_v4ApVJmczQd
                                #define STR_v4ApVJmczQd
static const fu::str str_v4ApVJmczQd fu_INIT_PRIORITY(1015) { "\n        fn test(x: i32) {\n            <fail annotation not a type 4:20+1>\n            mut y: x;                   <pass/>\n            mut y = x;                  </fail>\n            y += x;\n            return y;\n        }\n\n        fn main() test(2) - 4;\n    "_fu };
                                #endif

                                #ifndef STR_bMAU5po8B79
                                #define STR_bMAU5po8B79
static const fu::str str_bMAU5po8B79 fu_INIT_PRIORITY(1015) { "\n        struct Hey { v: i32 }\n\n        fn test(x: Hey) {\n            <fail annotation not a type 6:20+3>\n            mut y: Hey(1);              <pass/>\n            mut y = Hey(1);             </fail>\n            y.v += x.v;\n            return y;\n        }\n\n        fn main() test(Hey(2)).v - 3;\n    "_fu };
                                #endif

                                #ifndef STR_viBmYapl7lc
                                #define STR_viBmYapl7lc
static const fu::str str_viBmYapl7lc fu_INIT_PRIORITY(1015) { "\n        type A = int;   <fail ambig call A 3:14+1 2:14+1>\n        type A = int;   <pass/></fail>\n\n        fn main() {\n            mut a: A;\n            return a;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_zGAzsw9ebSk
                                #define STR_zGAzsw9ebSk
static const fu::str str_zGAzsw9ebSk fu_INIT_PRIORITY(1015) { "\n        struct Int { i: int };\n\n        type A = Int;   <fail ambig call A 5:14+1 4:14+1 2:9+6>\n        type A = Int;   <pass/></fail>\n\n        fn main() {\n            mut a: A;\n            return a.i;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_JdPiVJQzzy1
                                #define STR_JdPiVJQzzy1
static const fu::str str_JdPiVJQzzy1 fu_INIT_PRIORITY(1015) { "\n        let x = 3;\n        return x / 2 - 1;\n    "_fu };
                                #endif

                                #ifndef STR_KKyn4OMNEy9
                                #define STR_KKyn4OMNEy9
static const fu::str str_KKyn4OMNEy9 fu_INIT_PRIORITY(1015) { "\n        fn hey(a) a * a;\n        fn main = 0.hey;\n    "_fu };
                                #endif

                                #ifndef STR_0dEy3ESolD8
                                #define STR_0dEy3ESolD8
static const fu::str str_0dEy3ESolD8 fu_INIT_PRIORITY(1015) { "\n        fn div3by(a: <T>) 3 / a;\n        return div3by(2) - 1;\n    "_fu };
                                #endif

                                #ifndef STR_EyeMcqi2l3f
                                #define STR_EyeMcqi2l3f
static const fu::str str_EyeMcqi2l3f fu_INIT_PRIORITY(1015) { "\n        fn div3by(a) 3 / a;\n        return div3by(2) - 1;\n    "_fu };
                                #endif

                                #ifndef STR_WREJuc3XFM0
                                #define STR_WREJuc3XFM0
static const fu::str str_WREJuc3XFM0 fu_INIT_PRIORITY(1015) { "\n        fn add3(a: i32, b = 3) a + b;\n        fn main() add3(-3);\n    "_fu };
                                #endif

                                #ifndef STR_Cu5DeJi2TA3
                                #define STR_Cu5DeJi2TA3
static const fu::str str_Cu5DeJi2TA3 fu_INIT_PRIORITY(1015) { "\n        fn add3(a: <T>, b = 3) a + b;\n        struct v1 { x: i32; };\n        fn +(a: v1, b: i32) v1(a.x + b);\n        fn main() add3(2.v1).x - 5;\n    "_fu };
                                #endif

                                #ifndef STR_JCUSm1T3LOk
                                #define STR_JCUSm1T3LOk
static const fu::str str_JCUSm1T3LOk fu_INIT_PRIORITY(1015) { "\n        fn mul_ab_init(a: <T>, b = 0) a*b;\n        fn main() mul_ab_init(1);\n    "_fu };
                                #endif

                                #ifndef STR_UIe7W7zuYS8
                                #define STR_UIe7W7zuYS8
static const fu::str str_UIe7W7zuYS8 fu_INIT_PRIORITY(1015) { "\n        fn mul_ab_annot_init(a: <T>, b: T = 0) a*b;\n        fn main() mul_ab_annot_init(1);\n    "_fu };
                                #endif

                                #ifndef STR_Z8ZQl2yDiSc
                                #define STR_Z8ZQl2yDiSc
static const fu::str str_Z8ZQl2yDiSc fu_INIT_PRIORITY(1015) { "\n        fn mul_ab_opt(a: $T, b?: $T) a*b;\n        fn main() mul_ab_opt(1);\n    "_fu };
                                #endif

                                #ifndef STR_Jw5BfohAh1f
                                #define STR_Jw5BfohAh1f
static const fu::str str_Jw5BfohAh1f fu_INIT_PRIORITY(1015) { "\n        fn ab(a, b) a + b*2;\n        fn main() ab(b: 1, a: -2);\n    "_fu };
                                #endif

                                #ifndef STR_iRADgJPXgtd
                                #define STR_iRADgJPXgtd
static const fu::str str_iRADgJPXgtd fu_INIT_PRIORITY(1015) { "\n        struct yi32 { y: i32; };\n        fn add_s_vy(v, s) s + v.y;\n        fn main() add_s_vy(v: yi32(1), -1);\n    "_fu };
                                #endif

                                #ifndef STR_eG4dLDyp0w1
                                #define STR_eG4dLDyp0w1
static const fu::str str_eG4dLDyp0w1 fu_INIT_PRIORITY(1015) { "\n        struct xi32 { x: i32; };\n        fn add_s_vx(s, v) s + v.x; // <- args reordered\n        fn main() add_s_vx(v: xi32(1), -1);\n    "_fu };
                                #endif

                                #ifndef STR_VutVmAnXV27
                                #define STR_VutVmAnXV27
static const fu::str str_VutVmAnXV27 fu_INIT_PRIORITY(1015) { "\n        fn ab(a, b = 0, c = 0) a + b*2 + c*3;\n        fn main() ab(3, c: -1);\n    "_fu };
                                #endif

                                #ifndef STR_TRDCnpau7D5
                                #define STR_TRDCnpau7D5
static const fu::str str_TRDCnpau7D5 fu_INIT_PRIORITY(1015) { "\n        fn ab(a, b = -1) a + b*2;\n        fn main() ab(3.0, -1.5).i32;\n    "_fu };
                                #endif

                                #ifndef STR_DG4wErg4TSg
                                #define STR_DG4wErg4TSg
static const fu::str str_DG4wErg4TSg fu_INIT_PRIORITY(1015) { "\n        let NEG_ONE_FIVE = -1.5;\n        fn ab(a: $T, b: $T = -1) a + b*2;\n        fn main() ab(3, NEG_ONE_FIVE).i32;\n    "_fu };
                                #endif

                                #ifndef STR_h2hvYOQoBP7
                                #define STR_h2hvYOQoBP7
static const fu::str str_h2hvYOQoBP7 fu_INIT_PRIORITY(1015) { "\n        let TWO = 2.0;\n        fn ab(a: $T, b: $T = -1) a + b*2;\n        fn main() ab(TWO).i32;\n    "_fu };
                                #endif

                                #ifndef STR_s8WPZWSGk8i
                                #define STR_s8WPZWSGk8i
static const fu::str str_s8WPZWSGk8i fu_INIT_PRIORITY(1015) { "\n        fn self_rec_template(x: $T): $T\n            x > 0 ? self_rec_template(x / 2 - 5) : x;\n\n        fn main()\n            self_rec_template(7) + 2;\n    "_fu };
                                #endif

                                #ifndef STR_GRpmnOY7IW1
                                #define STR_GRpmnOY7IW1
static const fu::str str_GRpmnOY7IW1 fu_INIT_PRIORITY(1015) { "\n        fn ab_rec(a: $T): $T = a ? ba_rec(a - 2) : -100;\n        fn ba_rec(a: $T): $T = a ? ab_rec(a - 7) : -200;\n        fn main() ab_rec(11) + 200;\n    "_fu };
                                #endif

                                #ifndef STR_uo6A5uHOT4f
                                #define STR_uo6A5uHOT4f
static const fu::str str_uo6A5uHOT4f fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            let a = 1;\n            fn add1(b) a + b;\n            return 2.add1 - 3;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_W5k6F1MNPia
                                #define STR_W5k6F1MNPia
static const fu::str str_W5k6F1MNPia fu_INIT_PRIORITY(1015) { "\n        pub fn MAP(a: $T[..], fn) {             ;; !N_DeadCode\n            mut res: typeof( fn($T) )[];\n            res.grow_junk(a.len);\n            for (mut i = 0; i < a.len; i++) res[i] = fn(a[i]);\n            return res;\n        }\n\n        pub fn clone(a: $T)\n        case ($T.is::copy) a;\n        case ($T -> $U[..]) a.MAP(fn clone);\n        default {\n            mut res: $T;\n            for (fieldname i: $T) res.i = a.i.clone();\n            return res;\n        }\n\n        pub nocopy struct Scope { x: i32; };\n        pub struct ModuleOutputs { deps: Scope[]; };\n\n        pub fn test(a: ModuleOutputs) {\n            let b = a.clone();\n            return a.deps.len - b.deps.len;\n        }\n\n        pub fn main() test(ModuleOutputs);\n    "_fu };
                                #endif

                                #ifndef STR_VblMKguew61
                                #define STR_VblMKguew61
static const fu::str str_VblMKguew61 fu_INIT_PRIORITY(1015) { "\n        struct X { a: i32; };\n        inline fn add_uxa_b_inline(using x: X, b: i32) a + b;\n        fn hey(using x: X) add_uxa_b_inline(-1);\n        return X(1).hey;\n    "_fu };
                                #endif

                                #ifndef STR_K5xjRbmbU1j
                                #define STR_K5xjRbmbU1j
static const fu::str str_K5xjRbmbU1j fu_INIT_PRIORITY(1015) { "\n        struct X { a: i32; };\n        fn add_uxa_b_template(using x: X, b /* untyped */) a + b;\n        fn hey(using x: X) add_uxa_b_template(-1);\n        return X(1).hey;\n    "_fu };
                                #endif

                                #ifndef STR_VFLffpO9f5f
                                #define STR_VFLffpO9f5f
static const fu::str str_VFLffpO9f5f fu_INIT_PRIORITY(1015) { "\n        fn incr(a) a++;\n        fn main() {\n            mut a = 1;      <fail inrc not defined 5:13+4>\n            inrc: || a;     <pass/>\n            incr: || a;     </fail>\n            return a - 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_hFs0YQbEca8
                                #define STR_hFs0YQbEca8
static const fu::str str_hFs0YQbEca8 fu_INIT_PRIORITY(1015) { "\n        inline fn inl_lies(x: u32)<fail inl_lies: return match annot 2:43+1>: i32<pass/></fail> = x;\n        fn main() 0.inl_lies ? 1 : 0;                           ;; PointlessLocal\n    "_fu };
                                #endif

                                #ifndef STR_lJ0K3HNfcwg
                                #define STR_lJ0K3HNfcwg
static const fu::str str_lJ0K3HNfcwg fu_INIT_PRIORITY(1015) { "\n        fn what(ref x: i32, ref y: i32) {\n            <fail bad call swap>\n            let z = y;   <pass/>\n            ref z = y;   </fail>\n            swap(x, z);  // swap is defined(ref x: $T, ref y: $T),\n        }                //  we ignore the 'ref' part in type patterns,\n                         //   so we only notice later when checking the spec\n        fn main() {\n            mut a = 1; mut b = 0; what(a, b);\n            return a;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_WgKNte3Bvje
                                #define STR_WgKNte3Bvje
static const fu::str str_WgKNte3Bvje fu_INIT_PRIORITY(1015) { "\n        fn any(a, b) a || b;\n        fn main() any(0, []);\n    "_fu };
                                #endif

                                #ifndef STR_8YHEnlGDnZ1
                                #define STR_8YHEnlGDnZ1
static const fu::str str_8YHEnlGDnZ1 fu_INIT_PRIORITY(1015) { "\n        fn both(a, b) a && b;\n        fn main() both(1, []);\n    "_fu };
                                #endif

                                #ifndef STR_gQYmWfpvem3
                                #define STR_gQYmWfpvem3
static const fu::str str_gQYmWfpvem3 fu_INIT_PRIORITY(1015) { "\n        fn either(a, b) a ? a : b;\n        fn main() either(0, []);\n    "_fu };
                                #endif

                                #ifndef STR_YeNgZLRkCGe
                                #define STR_YeNgZLRkCGe
static const fu::str str_YeNgZLRkCGe fu_INIT_PRIORITY(1015) { "\n        fn both_same_type(_<fail $T is not defined><pass/>: $T</fail>, y) =\n            typeof(y) -> $T;\n\n        fn main()   = both_same_type(1.u32, 1.i32) ? 1\n                    : both_same_type(1.i32, 1.i32) ? 0\n                    : 2;\n    "_fu };
                                #endif

                                #ifndef STR_GijosH1Qr09
                                #define STR_GijosH1Qr09
static const fu::str str_GijosH1Qr09 fu_INIT_PRIORITY(1015) { "\n        fn arrof <T>(lax _: T[], type U)\n            case (T -> U)   true;\n            default         false;\n\n        fn main() {\n            mut a: i32[];\n            return arrof(a, i32) && !arrof(a, u32) ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_XdqjUEnAll8
                                #define STR_XdqjUEnAll8
static const fu::str str_XdqjUEnAll8 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut x: i32 = 0;\n            return (typeof(x) -> &mut i32).i32 - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_wrN6ToXoPq9
                                #define STR_wrN6ToXoPq9
static const fu::str str_wrN6ToXoPq9 fu_INIT_PRIORITY(1015) { "\n        fn work(visit) visit(1, 2);\n        fn main() work: |_, _| return 0;\n    "_fu };
                                #endif

                                #ifndef STR_LVC6Z5orJl6
                                #define STR_LVC6Z5orJl6
static const fu::str str_LVC6Z5orJl6 fu_INIT_PRIORITY(1015) { "\n        fn each(ref moot: u32) moot++;\n\n        fn Lifetime_process(lt: string, each) {\n            for (mut i = 0; i < lt.len; i++) {\n                fn climb(mut parent: string) // .... ///// what happened is this recursively picked up fn each from prelude\n                    Lifetime_process(parent, fn each); ///  on each nested iteration, which grew the addrofn type,\n                                             // ^^^^ /////   resulting in a new mangle on each go.\n                each(climb: fn climb, lt.slice(i, lt.len));\n            }\n        }\n\n        fn main() {\n            mut result = \"\";\n            Lifetime_process(\"abc\", each: |lt, climb| {\n                result ~= \" \" ~ lt;\n                if (let init = lt.slice(0, lt.len - 1))\n                    climb(init);\n            });\n\n            return result == \" abc ab a b bc b c\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_1SBlfyGKY8i
                                #define STR_1SBlfyGKY8i
static const fu::str str_1SBlfyGKY8i fu_INIT_PRIORITY(1015) { "\n        using flags Flags { F_SOME; F_OTHER };\n\n        fn parseInlineDecl(mut flags, flag = F_OTHER) {\n            flags |= flag;\n            return flags;\n        }\n\n        fn parseNoInline(mut flags) {\n            return parseInlineDecl(:flags, flag: []);\n        }\n\n        fn main() = parseInlineDecl(F_SOME).i32\n                  - parseNoInline(F_SOME).i32 * 3;\n    "_fu };
                                #endif

                                #ifndef STR_08eiRZhgpY1
                                #define STR_08eiRZhgpY1
static const fu::str str_08eiRZhgpY1 fu_INIT_PRIORITY(1015) { "\n        struct Range { lo_incl: int; hi_excl: int };\n\n        fn each(using _: Range, each)\n            for (mut i = lo_incl; i < hi_excl; i++)\n                each(i);\n    "_fu };
                                #endif

                                #ifndef STR_JPwg92b5bo1
                                #define STR_JPwg92b5bo1
static const fu::str str_JPwg92b5bo1 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut sum = 0;\n            _0::Range(0, 10).each: |i| sum += i;\n            return sum - 45 ;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_naQ9xOK24jj
                                #define STR_naQ9xOK24jj
static const fu::str str_naQ9xOK24jj fu_INIT_PRIORITY(1015) { "\n        fn hello(mut x: <alt>i32<alt/>$T</alt>[]) {\n            x.each: |ref it| it++;\n            return x;\n        }\n\n        fn main() {\n            mut a = [ 1 ];\n            let b = hello(a);\n            for (mut i = 0; i < min(a.len, b.len); i++)\n                return a[i] + b[i] - 3;\n\n            <fail missing final return 10:13+3> <pass/>\n            return 1;                           </fail>\n        }\n    "_fu };
                                #endif

                                #ifndef STR_wBOXD0ar7Y7
                                #define STR_wBOXD0ar7Y7
static const fu::str str_wBOXD0ar7Y7 fu_INIT_PRIORITY(1015) { "\n        struct Things(type <T>) { ARR: T[] };\n    "_fu };
                                #endif

                                #ifndef STR_KfJftDgDlMk
                                #define STR_KfJftDgDlMk
static const fu::str str_KfJftDgDlMk fu_INIT_PRIORITY(1015) { "\n<alt>\n        fn add !T(ref a: _0::Things(T), b: _0::Things(T))\n            a.ARR ~= b.ARR;\n<alt/>\n        fn add(ref a.ARR, b.ARR)\n            a ~= b;\n</alt>\n        fn main() {\n            type i32s = _0::Things(i32);\n            mut a: i32s;\n            mut b: i32s;\n            a.add(b);\n            return a.ARR.len;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_tsLsXXR9134
                                #define STR_tsLsXXR9134
static const fu::str str_tsLsXXR9134 fu_INIT_PRIORITY(1015) { "\n        struct Things(type T) { ARR: T[] };\n<alt>\n        fn add(ref a: Things($T), b: Things($T))\n            a.ARR ~= b.ARR;\n<alt/>\n        fn add(ref a.ARR, b.ARR)\n            a ~= b;\n</alt>\n    "_fu };
                                #endif

                                #ifndef STR_NUUEHFzwTk4
                                #define STR_NUUEHFzwTk4
static const fu::str str_NUUEHFzwTk4 fu_INIT_PRIORITY(1015) { "\n        struct Events(type A, type B) {\n            a: _0::Things(A);\n            b: _0::Things(B);\n        };\n\n        fn Events_merge(ref e0: Events($A, $B), e1: Events($A, $B))\n        {\n            fn Events_merge(ref a: _0::Things($T), b: _0::Things($T))\n                a.add(b);\n\n            for (fieldname i: Events($A, $B))\n                Events_merge(e0.i, e1.i);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_vptizWpEwy8
                                #define STR_vptizWpEwy8
static const fu::str str_vptizWpEwy8 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut e0: _1::Events(i32, u32);\n            mut e1: _1::Events(i32, u32);\n            for (mut i = 0; i < 3; i++) {\n                e0.a.ARR ~= i;\n                e1.a.ARR ~= 3 + i;\n                if (i & 1) {\n                    e0.b.ARR ~= 0xff;\n                    e1.b.ARR ~= 0xfe;\n                }\n            }\n\n            e0.Events_merge(e1);\n            return e0.a.ARR == [ 0, 1, 2, 3, 4, 5 ]\n                && e0.b.ARR == [ 0xff, 0xfe ] ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_j5aAPhN1dff
                                #define STR_j5aAPhN1dff
static const fu::str str_j5aAPhN1dff fu_INIT_PRIORITY(1015) { "\n        fn reduce(array: <T>[], reducer, mut reduct?: T) {\n            for (mut i = array.len; i --> 0; )\n                reduct = reducer(array[i], reduct);\n\n            return reduct;\n        }\n\n        fn parent_fn(orig: <T>[])\n        {\n            struct Item { value: T };\n\n            let mapped = orig.map(\n                fn child_fn(value: T)\n                    Item(:value));\n\n            mut num_items_added = 0;\n            infix fn +(a: Item, b: Item) {\n                num_items_added++;\n                Item(a.value + b.value)\n            }\n                                                <fail type param T already defined 23:28+1>\n            fn sum(array: <T>[])                <pass/>\n            fn sum(array: <U>[])                </fail>\n                reduce(array, |a, b| a + b);\n\n            let sum_orig    = sum(orig);\n            let sum_mapped  = sum(mapped);\n\n            assert(sum_orig == sum_mapped.value);\n            assert(num_items_added == orig.len);\n            return sum_mapped;\n        }\n\n        fn main() [ 1, 2, -3 ].parent_fn().value;\n    "_fu };
                                #endif

                                #ifndef STR_pzqtoRyuiK9
                                #define STR_pzqtoRyuiK9
static const fu::str str_pzqtoRyuiK9 fu_INIT_PRIORITY(1015) { "\n        struct SocketArrays { v: int };\n        struct Sockets(type X) { x: X; using sa?: SocketArrays }\n\n        fn what(ref s) s.v += s.x;\n        fn socket_accepted(ref sa: SocketArrays, woot) woot(sa.v);\n\n        fn main() {                             <alt>\n            mut sockets = Sockets(int)(3);      <alt/>\n            mut sockets: Sockets(int) = [ 3 ];  </alt>\n            sockets.what();\n            sockets.socket_accepted: |ref v| v *= 7;\n            return sockets.v - 21;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_zKwO2PVV2Kk
                                #define STR_zKwO2PVV2Kk
static const fu::str str_zKwO2PVV2Kk fu_INIT_PRIORITY(1015) { "\n        pub fn identity(dont_leak_me) dont_leak_me;\n    "_fu };
                                #endif

                                #ifndef STR_xiait1K9cc7
                                #define STR_xiait1K9cc7
static const fu::str str_xiait1K9cc7 fu_INIT_PRIORITY(1015) { "\n        let dont_leak_me = 1;\n        fn main() _0::identity(dont_leak_me * 2) - 2;\n    "_fu };
                                #endif

                                #ifndef STR_AyC8Sz3Xvd5
                                #define STR_AyC8Sz3Xvd5
static const fu::str str_AyC8Sz3Xvd5 fu_INIT_PRIORITY(1015) { "\n        pub inline fn inl_id_leak(dont_leak_me) dont_leak_me;\n        let dont_leak_me = 1;\n        fn main() inl_id_leak(dont_leak_me * 2) - 2;            ;; PointlessLocal\n    "_fu };
                                #endif

                                #ifndef STR_0NMc6LDFli1
                                #define STR_0NMc6LDFli1
static const fu::str str_0NMc6LDFli1 fu_INIT_PRIORITY(1015) { "\n        let static = 1;\n        fn template(arg) static + arg;\n        let arg = 7;                        // <- template shouldn't see this\n        let result = template(arg / -4);    // <- when specializing here\n        fn main() result;\n    "_fu };
                                #endif

                                #ifndef STR_8FCe6Cr7bpg
                                #define STR_8FCe6Cr7bpg
static const fu::str str_8FCe6Cr7bpg fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            let static = 1;\n            fn template(arg) static + arg;\n            let arg = 7; // same here, except we're in a fn.\n            return template(arg / -4);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Vshfku53tH3
                                #define STR_Vshfku53tH3
static const fu::str str_Vshfku53tH3 fu_INIT_PRIORITY(1015) { "\n        fn template_add(a, b) a + b;\n    "_fu };
                                #endif

                                #ifndef STR_g6wj0B6vCWb
                                #define STR_g6wj0B6vCWb
static const fu::str str_g6wj0B6vCWb fu_INIT_PRIORITY(1015) { "\n        struct HasInt { i: i32 };\n        <split/>\n        fn +(a: HasInt, b: HasInt) HasInt(a.i + b.i);\n        fn main() _0::template_add(HasInt(1), HasInt(2)).i - 3;\n    "_fu };
                                #endif

                                #ifndef STR_n2ShRbEE8zl
                                #define STR_n2ShRbEE8zl
static const fu::str str_n2ShRbEE8zl fu_INIT_PRIORITY(1015) { "\n        struct HasInt { i: i32 };\n        fn main() {\n            infix fn +(a: HasInt, b: HasInt) HasInt(a.i + b.i); // its hard to defend this -\n            _0::template_add(HasInt(1), HasInt(2)).i - 3;       //  the thing above works but this doesn't.\n        }                                                       //   given the autoshadowing, we might just want to allow everything.\n    "_fu };
                                #endif

                                #ifndef STR_v6Phd4Ckcie
                                #define STR_v6Phd4Ckcie
static const fu::str str_v6Phd4Ckcie fu_INIT_PRIORITY(1015) { "Bad call to + 2:33+1"_fu };
                                #endif

                                #ifndef STR_ydjNEPGqK3i
                                #define STR_ydjNEPGqK3i
static const fu::str str_ydjNEPGqK3i fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            postfix fn [](x: u32, at: u32) x & 1 << (at & 31);\n            return 0x7[3].i32;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Z9onYAdaf8b
                                #define STR_Z9onYAdaf8b
static const fu::str str_Z9onYAdaf8b fu_INIT_PRIORITY(1015) { "\n        fn inner(i: i32): i32\n            i > 0 ? outer(i - 1) : 0;\n\n        fn outer(i: i32): i32\n            2 * inner(i);\n\n        return outer(1);\n    "_fu };
                                #endif

                                #ifndef STR_SDwWRJD8Pmi
                                #define STR_SDwWRJD8Pmi
static const fu::str str_SDwWRJD8Pmi fu_INIT_PRIORITY(1015) { "\n        fn test(one: i32) {\n            let zero = one - 1;\n            let two  = one * 2;\n\n            <alt>\n            inline </alt>\n            fn inner(i: i32): i32\n                i > zero ? outer(i - one) : zero;\n\n            fn outer(i: i32): i32\n                two * inner(i);\n\n            return outer(one) + (two - one) * 17;\n        }\n\n        fn main() test(1) - 17;\n    "_fu };
                                #endif

                                #ifndef STR_7YbJLsKzgz2
                                #define STR_7YbJLsKzgz2
static const fu::str str_7YbJLsKzgz2 fu_INIT_PRIORITY(1015) { "\n        fn inner(i: i32): i32\n            outer(i - 1);\n\n        fn outer(implicit x: i32, i: i32): i32\n            i > 0   ? inner(i)\n                    : x + i;\n\n        let implicit x = 7;\n        return outer(1) - 7;\n    "_fu };
                                #endif

                                #ifndef STR_FkrTCufLaG2
                                #define STR_FkrTCufLaG2
static const fu::str str_FkrTCufLaG2 fu_INIT_PRIORITY(1015) { "\n        fn inner_noret(i: i32)\n            outer_noret(i - 1);\n\n        fn outer_noret(implicit x: i32, i: i32)\n            i > 0   ? inner_noret(i)\n                    : x + i;\n\n        let implicit x = 7;\n        return outer_noret(1) - 7;\n    "_fu };
                                #endif

                                #ifndef STR_lQ4dWcPcTra
                                #define STR_lQ4dWcPcTra
static const fu::str str_lQ4dWcPcTra fu_INIT_PRIORITY(1015) { "\n        inline fn inner_inl(i: i32): i32\n            outer_inl(i - 1);\n\n        fn outer_inl(implicit x: i32, i: i32): i32\n            i > 0   ? inner_inl(i)\n                    : x + i;\n\n        let implicit x = 7;\n        return outer_inl(1) - 7;\n    "_fu };
                                #endif

                                #ifndef STR_bkCPdEoJ9sg
                                #define STR_bkCPdEoJ9sg
static const fu::str str_bkCPdEoJ9sg fu_INIT_PRIORITY(1015) { "\n        fn inner_templ(i): i32\n            outer_templ(i - 1);\n\n        fn outer_templ(implicit x: i32, i): i32\n            i > 0   ? inner_templ(i)\n                    : x + i;\n\n        let implicit x = 7;\n        return outer_templ(1) - 7;\n    "_fu };
                                #endif

                                #ifndef STR_GN5eDjFQws9
                                #define STR_GN5eDjFQws9
static const fu::str str_GN5eDjFQws9 fu_INIT_PRIORITY(1015) { "\n        fn inner_templ_noret(i)\n            outer_templ_noret(i - 1);\n\n        fn outer_templ_noret(implicit x: i32, i)\n            i > 0   ? inner_templ_noret(i)\n                    : x + i;\n\n        let implicit x = 7;\n        return outer_templ_noret(1) - 7;\n    "_fu };
                                #endif

                                #ifndef STR_KtvqHt4uayd
                                #define STR_KtvqHt4uayd
static const fu::str str_KtvqHt4uayd fu_INIT_PRIORITY(1015) { "\n        fn outer(i: i32): i32\n            i > 0   ? inner(i)\n                    : 2 * i;\n\n        fn inner(implicit x: i32, i: i32): i32\n            outer(i - 2 * x);\n\n        let implicit x = 3;\n        return outer(6);\n    "_fu };
                                #endif

                                #ifndef STR_3A2ZevlxLZ0
                                #define STR_3A2ZevlxLZ0
static const fu::str str_3A2ZevlxLZ0 fu_INIT_PRIORITY(1015) { "\n        fn has_implicit(implicit i: i32, add: i32): i32\n            i + add;\n\n        inline fn injects_implicit_while_inlined(): i32\n            has_implicit(1); // broken by no ss.declash\n\n        fn main() {\n            let implicit i = 2;\n            return injects_implicit_while_inlined() - 3;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_wlaj4IuxHW7
                                #define STR_wlaj4IuxHW7
static const fu::str str_wlaj4IuxHW7 fu_INIT_PRIORITY(1015) { "\n        inline fn outer_inl(i: i32): i32\n            i > 0   ? inner_inl(i)\n                    : 2 * i;\n\n        fn inner_inl(implicit x: i32, i: i32): i32\n            outer_inl(i - 2 * x); // broken by no ss.declash\n\n        let implicit x = 3;\n        return outer_inl(6);\n    "_fu };
                                #endif

                                #ifndef STR_S8mgDIez1q8
                                #define STR_S8mgDIez1q8
static const fu::str str_S8mgDIez1q8 fu_INIT_PRIORITY(1015) { "\n        fn outer_templ(i): i32\n            i > 0   ? inner_templ(i)\n                    : 2 * i;\n\n        fn inner_templ(implicit x: i32, i): i32\n            outer_templ(i - 2 * x);\n\n        let implicit x = 3;\n        return outer_templ(6);\n    "_fu };
                                #endif

                                #ifndef STR_0qc14Icppyb
                                #define STR_0qc14Icppyb
static const fu::str str_0qc14Icppyb fu_INIT_PRIORITY(1015) { "\n        fn outer(implicit x: i32, i: i32): i32\n            i > 0   ? inner(i)\n                    : x + i;\n\n        fn inner(i: i32): i32\n            outer(i - 1);\n\n        let implicit x = 7;\n        return outer(1) - 7;\n    "_fu };
                                #endif

                                #ifndef STR_2Hs0suA9w99
                                #define STR_2Hs0suA9w99
static const fu::str str_2Hs0suA9w99 fu_INIT_PRIORITY(1015) { "\n        fn outer(implicit x: i32, i: i32)\n            i > 0   ? inner(i)\n                    : x + i;\n\n        fn noret(i: i32) = outer(i);\n\n        fn template(i) = i & 1 ? outer(i) : noret(i);\n\n        fn inner(i: i32): i32\n            template(i - 1);\n\n        fn main() {\n            let implicit x = 7;\n            return outer(1) - 7;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Oxl2YB7CEd0
                                #define STR_Oxl2YB7CEd0
static const fu::str str_Oxl2YB7CEd0 fu_INIT_PRIORITY(1015) { "\n        fn returns_x(implicit x: i32): i32\n            = x;\n\n        fn calls_self_1(call_self = false): i32\n            = !call_self ? returns_x : calls_self_1 * 2;\n\n        let implicit x = 7;\n        return calls_self_1(true) - 14;\n    "_fu };
                                #endif

                                #ifndef STR_pLLQDlSu3wg
                                #define STR_pLLQDlSu3wg
static const fu::str str_pLLQDlSu3wg fu_INIT_PRIORITY(1015) { "\n        fn returns_x(implicit x: i32): i32\n            = x;\n\n        fn calls_self_2(call_self = false): i32\n            = call_self ? calls_self_2 * 3 : returns_x;\n\n        let implicit x = 7;\n        return calls_self_2(true) - 21;\n    "_fu };
                                #endif

                                #ifndef STR_XenVcGtTEs8
                                #define STR_XenVcGtTEs8
static const fu::str str_XenVcGtTEs8 fu_INIT_PRIORITY(1015) { "\n        fn returns_x(implicit x: i32): i32\n            = x;\n\n        fn calls_self_3(call_self = false): i32\n        {\n            let add = 1; // <- this wasnt visible\n            fn do_call_self(mul: i32 = 0)\n                = calls_self_3 * mul + add;\n\n            return call_self ? do_call_self(4) : returns_x;\n        }\n\n        let implicit x = 7;\n        return calls_self_3(true) - 29;\n    "_fu };
                                #endif

                                #ifndef STR_OyGPB0V2Uce
                                #define STR_OyGPB0V2Uce
static const fu::str str_OyGPB0V2Uce fu_INIT_PRIORITY(1015) { "\n        fn noret_x(implicit x: i32) x;\n\n        fn templ_calls_self_2(call_self): i32\n            = call_self ? templ_calls_self_2(false) * 3 : noret_x;\n\n        fn main() {\n            let implicit x = 7;\n            return templ_calls_self_2(true) - 21;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Ono5iR8ywPc
                                #define STR_Ono5iR8ywPc
static const fu::str str_Ono5iR8ywPc fu_INIT_PRIORITY(1015) { "\n        struct Range {\n            min: i32;\n            max: i32;\n        }\n\n        fn size(using implicit r: Range)\n            max - min;\n\n        fn test()\n            size();\n\n        let implicit r = Range(14, 21);\n\n        return test  - 7;\n    "_fu };
                                #endif

                                #ifndef STR_zbfjbPhgYa3
                                #define STR_zbfjbPhgYa3
static const fu::str str_zbfjbPhgYa3 fu_INIT_PRIORITY(1015) { "\n        struct Range {\n            min: i32;\n            max: i32;\n        }\n\n        fn size(using implicit r: Range)\n            max - min;\n\n        fn inner()\n            size();\n\n        fn outer()\n            inner();\n\n        let implicit r = Range(14, 21);\n\n        return outer() - 7;\n    "_fu };
                                #endif

                                #ifndef STR_R6We47NDRU6
                                #define STR_R6We47NDRU6
static const fu::str str_R6We47NDRU6 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            let a = 1;\n            let b = 2;\n            let c = 3;\n\n            fn depth1(x: i32) {\n                fn depth2(y: i32) {\n                    return sibling1(x + y + b);\n                }\n\n                return depth2(x + a);\n            }\n\n            fn sibling1(z: i32): i32 {\n                return z + c;\n            }\n\n            return depth1(0) - 6;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_8hBDrtZxABi
                                #define STR_8hBDrtZxABi
static const fu::str str_8hBDrtZxABi fu_INIT_PRIORITY(1015) { "\n        fn goto0(x): i32 = x ? goto0(x / 2) : 0;\n        fn main() goto0(1);\n    "_fu };
                                #endif

                                #ifndef STR_9cTaL8Bn22d
                                #define STR_9cTaL8Bn22d
static const fu::str str_9cTaL8Bn22d fu_INIT_PRIORITY(1015) { "\n        fn goto0(x) x ? goto0(x / 2) : 0;\n        fn main() goto0(1);\n    "_fu };
                                #endif

                                #ifndef STR_2fxgtZzyikg
                                #define STR_2fxgtZzyikg
static const fu::str str_2fxgtZzyikg fu_INIT_PRIORITY(1015) { "\n        fn goto0(x) x ? goto0(x / 2) : x; // ideally same as above\n        fn main() goto0(1);\n    "_fu };
                                #endif

                                #ifndef STR_o6FtGkqSxt9
                                #define STR_o6FtGkqSxt9
static const fu::str str_o6FtGkqSxt9 fu_INIT_PRIORITY(1015) { "\n        fn goto0(x) x && goto0(x / 2); // ideally same as above [again]\n        fn main() goto0(1);\n    "_fu };
                                #endif

                                #ifndef STR_GOqIycjLRk2
                                #define STR_GOqIycjLRk2
static const fu::str str_GOqIycjLRk2 fu_INIT_PRIORITY(1015) { "\n        fn ref_a(ref a: i32) a;\n\n        fn main() {\n            mut a: i32;\n            ref r = ref_a(a);\n            r++;\n            return a - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_oDld2SGUSug
                                #define STR_oDld2SGUSug
static const fu::str str_oDld2SGUSug fu_INIT_PRIORITY(1015) { "\n        fn ref_a_or_ref_b(ref a: i32, ref b: i32)\n            a || b;\n\n        fn main() {\n            mut a: i32;\n            mut b: i32;\n            ref a_or_b = ref_a_or_ref_b(a, b);\n            a_or_b++;\n            return b - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_n1ljknw4L2e
                                #define STR_n1ljknw4L2e
static const fu::str str_n1ljknw4L2e fu_INIT_PRIORITY(1015) { "\n        fn impl(implicit ref _impl: i32) _impl;\n        fn arg_or_impl(ref arg: i32) arg || impl;\n        fn main() {\n            implicit mut _impl: i32;\n            mut arg: i32;\n            ref ref = arg_or_impl(arg);\n            return arg - ref;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_rqwmqJz6OGc
                                #define STR_rqwmqJz6OGc
static const fu::str str_rqwmqJz6OGc fu_INIT_PRIORITY(1015) { "\n        fn hello(ref a: i32[], ref b: i32[], x: i32): &mut i32[] {\n            if (x == 0) return a;\n            if (x == 1) return b;\n            return hello(b, a, x / 17);\n        }\n\n        fn main() {\n            mut a = [1, 2, 3];\n            mut b = [4, 5, 6];\n            hello(a, b, 397)[1] *= 5;\n            return b[1] - 25;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Wwczx5EojCk
                                #define STR_Wwczx5EojCk
static const fu::str str_Wwczx5EojCk fu_INIT_PRIORITY(1015) { "\n        pub fn ZERO(implicit ref sum: i32, mut x: i32) {\n            while (x) {\n                ZERO( --x ); // Same as below but without the unused 'y' thing,\n                sum += x;    //  everything works because the call to ZERO isnt really unconditional,\n            }                //   and if it were, then the never return would actually be correct.\n        }\n\n        fn main() {\n            implicit mut sum = 0;\n            ZERO(4);\n            return sum - 11;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_jrgwtv5LVpb
                                #define STR_jrgwtv5LVpb
static const fu::str str_jrgwtv5LVpb fu_INIT_PRIORITY(1015) { "\n        pub fn ZERO(implicit ref sum: i32, mut x: i32) {\n            while (x) {\n                let y = x / 2;\n                ZERO( --x ); // Unconditional self recursion, initially hinted as t_never,\n                ZERO(   y ); //  meaning y remains unused here on first solve.\n                sum += x;\n            }\n        }\n\n        fn main() {\n            implicit mut sum = 0;\n            ZERO(4);\n            return sum - 12;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_PPEedE913Ld
                                #define STR_PPEedE913Ld
static const fu::str str_PPEedE913Ld fu_INIT_PRIORITY(1015) { "\n        struct Node {\n            items: Node[];\n        }\n\n        fn solve(root: Node)\n        {\n            fn solveBlock(node: Node) {\n                let items = solveNodes(node.items);\n                return solveBlock(items);                       ;; ConstCast\n            }\n\n            fn solveBlock(items: i32[]) {\n                if (!Lifetime_allowsMutrefReturn(items))\n                    throw(\"Nope!\");\n\n                return items;\n            }\n\n            fn solveNode(node: Node, implicit ref next: i32) {\n                if (!node.items)\n                    return [ next++ ];\n\n                let implicit CTX = node.items.len; // <- this shows up as an closure-arg with an outdated revision\n                return solveBlock(node);\n            }\n\n            fn Lifetime_each(items, visit)\n                for (mut i = items.len; i --> 0; )\n                    visit(items[i]);\n\n            fn Lifetime_allowsMutrefReturn(items: i32[]) {\n                Lifetime_each(:items, visit: |item, implicit CTX: i32| {\n                    if (item == CTX)\n                        return false;\n                });\n\n                return true;\n            }\n\n            fn solveNodes(nodes: Node[]) {\n                mut result: i32[];\n                for (mut i = 0; i < nodes.len; i++)\n                    result ~= solveNode(nodes[i]);\n\n                return result;\n            }\n\n            return solveNode(root);\n        }\n\n        fn main() {\n            implicit mut next = 0;\n\n            let solve = solve(Node([\n                Node([ Node ]),\n                Node(),\n            ]));\n\n            return solve.len - 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_5fT0Cc1YF4f
                                #define STR_5fT0Cc1YF4f
static const fu::str str_5fT0Cc1YF4f fu_INIT_PRIORITY(1015) { "\n        fn woot(implicit x: i32) = x;\n\n        fn main() {\n            <fail no implicit x>\n            <pass/>\n            let implicit x = 2;\n            </fail>\n            return woot() - 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_8ppmBpyFhf3
                                #define STR_8ppmBpyFhf3
static const fu::str str_8ppmBpyFhf3 fu_INIT_PRIORITY(1015) { "\n        <fail no implicit y>\n        fn woot(implicit y: i32) = y;\n        <pass/>\n        fn woot(implicit x: i32) = x;\n        </fail>\n\n        fn hey() {\n            let implicit x = 2;\n            return woot() - 2;\n        }\n\n        let here = hey();\n        fn main() = here;\n    "_fu };
                                #endif

                                #ifndef STR_E30xh9U7DFk
                                #define STR_E30xh9U7DFk
static const fu::str str_E30xh9U7DFk fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut x = +1;\n            mut y: typeof(x) = -x;\n            return x + y;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_N49RPGMMSV4
                                #define STR_N49RPGMMSV4
static const fu::str str_N49RPGMMSV4 fu_INIT_PRIORITY(1015) { "\n        ;; N_UnusedImplicit\n        fn dont_inject_my_implicit_args(implicit unused_implicit_arg: i32) {\n            return unused_implicit_arg;\n        }\n\n        fn not_extern() {\n            mut x: typeof(dont_inject_my_implicit_args) = 2;\n            return x;\n        }\n\n        fn not_extern(mut x: typeof(dont_inject_my_implicit_args)) {\n            return x;\n        }\n\n        fn main() {\n            return not_extern() + not_extern(-2);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_UPfr3r6MbQ7
                                #define STR_UPfr3r6MbQ7
static const fu::str str_UPfr3r6MbQ7 fu_INIT_PRIORITY(1015) { "\n        fn mustwarn_unused_implicit(implicit forgot_to_use: i32, ref x: i32) {\n            <fail unused forgot_to_use>\n            x *= 3;             <pass/>\n            x *= forgot_to_use; </fail>\n        }\n\n        fn main() {\n            mut x = 7;\n            implicit forgot_to_use = 3;\n            mustwarn_unused_implicit(x);\n            return x == forgot_to_use * 7 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_cJ4h8q2IXGj
                                #define STR_cJ4h8q2IXGj
static const fu::str str_cJ4h8q2IXGj fu_INIT_PRIORITY(1015) { "\n        fn log_append(implicit ref log_out: string, str: string)\n            log_out ~= str;\n\n        let VERBOSE = false;                                    ;; !DEV_DontFoldLiterals\n\n        fn verbose(implicit ref log_events: i32, inline stuff: string)\n        {\n            if (VERBOSE) log_append(stuff);\n            log_events++;\n        }\n\n        fn main() {\n            <fail unused log_out 15:30+7>\n            implicit     mut log_out: string; <pass/>\n            implicit lax mut log_out: string; </fail>\n\n            implicit mut log_events: i32;\n            verbose(\"Hello!\");\n            verbose(\"World!\");\n\n            return log_events == 2 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_fmGBJChDlxk
                                #define STR_fmGBJChDlxk
static const fu::str str_fmGBJChDlxk fu_INIT_PRIORITY(1015) { "\n\n        // TODO remove this, currently gets repeatedly\n        //  rebuilt & rejected because of -Werror\n        pragma emit(`#pragma GCC diagnostic ignored \"-Wpragmas\"`);\n        pragma emit(`#pragma GCC diagnostic ignored \"-Winfinite-recursion\"`);\n\n        fn infRec(x: i32) {\n            if (x > 1)\n                return infRec(x - 1);\n            else                        <fail infinite recur X:X>\n                return infRec(x + 1);   <pass/>\n                return x;               </fail>\n        }\n\n        fn main() infRec(1);\n    "_fu };
                                #endif

                                #ifndef STR_vEzE0zRYlI8
                                #define STR_vEzE0zRYlI8
static const fu::str str_vEzE0zRYlI8 fu_INIT_PRIORITY(1015) { "\n        struct NeverImported { x: i32 };\n        fn wrap(x: i32) NeverImported(x * 10);\n    "_fu };
                                #endif

                                #ifndef STR_d815FcSpjIc
                                #define STR_d815FcSpjIc
static const fu::str str_d815FcSpjIc fu_INIT_PRIORITY(1015) { "\n        fn rec(y: i32)\n            if (y < 0)  return _0::wrap(rec(y + 7).x);\n            else        return _0::wrap(y);\n\n        fn main() rec(-2).x - 500;\n    "_fu };
                                #endif

                                #ifndef STR_ssNyToqAB68
                                #define STR_ssNyToqAB68
static const fu::str str_ssNyToqAB68 fu_INIT_PRIORITY(1015) { "\n        fn wantsImplicit(implicit ref x: i32) = x++;\n    "_fu };
                                #endif

                                #ifndef STR_syjmioCu5Yd
                                #define STR_syjmioCu5Yd
static const fu::str str_syjmioCu5Yd fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            <fail no implicit x 4:24+13 2:39+1>  <pass/>\n            implicit mut x: i32 = 0;            </fail>\n            return _0::wantsImplicit();\n        }\n    "_fu };
                                #endif

                                #ifndef STR_wIqfwOKjNIl
                                #define STR_wIqfwOKjNIl
static const fu::str str_wIqfwOKjNIl fu_INIT_PRIORITY(1015) { "\n        struct TokenIdx { id: i32 };\n    "_fu };
                                #endif

                                #ifndef STR_7rkmFWY8wZ2
                                #define STR_7rkmFWY8wZ2
static const fu::str str_7rkmFWY8wZ2 fu_INIT_PRIORITY(1015) { "\n        import _0;\n        fn fail(implicit a: TokenIdx, b: i32) =\n            a.id + b;\n    "_fu };
                                #endif

                                #ifndef STR_M0e9i3cottg
                                #define STR_M0e9i3cottg
static const fu::str str_M0e9i3cottg fu_INIT_PRIORITY(1015) { "\n        import _1;\n        fn cleanID(c: i32) =\n            fail(c) + 3;\n    "_fu };
                                #endif

                                #ifndef STR_TrEVbJrguI2
                                #define STR_TrEVbJrguI2
static const fu::str str_TrEVbJrguI2 fu_INIT_PRIORITY(1015) { "\n        import _0;\n        import _2;\n        fn solvePrelude(d: i32) {\n            <fail no implicit in scope 10:13+12 6:20+7 4:13+4 3:26+1><pass/>\n            let implicit a: TokenIdx = TokenIdx(2);                 </fail>\n            return cleanID(d) + 5;\n        }\n\n        let CTX_PRELUDE =\n            solvePrelude(7);\n\n        fn main() =\n            CTX_PRELUDE - 17;\n    "_fu };
                                #endif

                                #ifndef STR_pGLPMH8el78
                                #define STR_pGLPMH8el78
static const fu::str str_pGLPMH8el78 fu_INIT_PRIORITY(1015) { "\n        fn Lifetime_process(lt: string, each) {\n            fn visit(chars) {\n                for (mut i = 0; i < chars.len; i++) {                   <alt>\n                    inline fn climb(mut parent)           visit(parent);<alt/>\n                    noinline fn climb(mut parent)         visit(parent);<alt/>\n                    inline fn climb(mut parent: string)   visit(parent);<alt/>\n                    noinline fn climb(mut parent: string) visit(parent);<alt/>\n                    let climb = fn visit;                               </alt>\n\n                    each(climb?: fn climb, chars.slice(i, chars.len))\n                }\n            }\n\n            visit(lt);\n        }\n\n        fn main() {\n            mut result = \"\";\n            Lifetime_process(\"abc\", each: |lt, climb| {\n                result ~= lt;\n                if (let init = lt && lt.slice(0, lt.len - 1))\n                    climb(init);\n            });\n\n            return result == \"abcababbcbc\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_UJazhkxbL75
                                #define STR_UJazhkxbL75
static const fu::str str_UJazhkxbL75 fu_INIT_PRIORITY(1015) { "\n        struct Helper { id: i32; type: string };\n\n        fn main() {\n            mut helpers = [\n                Helper(13, \"This is a long string, shouldn't fit in small string opti.\"),\n            ];\n\n            fn solveNode(\n                <fail solveNode 23:23+9 helpers type both alias 5:17+7>\n                ref <pass/>\n                mut </fail>\n                type: string) {\n                helpers && helpers.pop();\n                return type;\n            }\n\n            mut fallback: string;\n            fn lookup(id: i32) {\n                helpers.each: |ref h| if (h.id == id) return h.type;\n                return fallback;\n            }\n\n            mut str = solveNode(lookup(13));\n            str ~= str;\n            return helpers.len * 1000 + str.len - 116;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_XLxi39Y9lFe
                                #define STR_XLxi39Y9lFe
static const fu::str str_XLxi39Y9lFe fu_INIT_PRIORITY(1015) { "\n        enum Kind       { return; expr }\n        struct Type     { canon: string }\n        struct Helpers  { id: string; ret_actual: Type }\n        struct Node     { kind: Kind; value: string; items?: Node[] }\n\n        fn Scope_pop(implicit ref _helpers: Helpers[])\n            _helpers && _helpers.pop();\n\n        fn test(implicit mut _helpers: Helpers[], root: Node)\n        {\n            fn solveNode(node: Node,\n\n                // TODO fix this is stupid, just documenting the reasoning here\n                <fail arg solveNode:type is ref-returned from fn solveNode 28:24+9><pass/>\n                mut\n                </fail>\n                val type?: Type\n            ) {\n                if (node.kind == Kind.return)\n                    return solveJump(node);\n\n                Scope_pop();\n                return type;\n            }\n\n            fn solveJump(node: Node) {\n                let h       = Scope_lookupLabel(node.value);\n                let n_expr  = node.items && node.items[0];\n                return solveNode(n_expr, type: h.ret_actual);\n            }\n\n            fn Scope_lookupLabel(id: string) {\n                _helpers.each: |item| item.id == id && { return item };\n                throw(\"No label '\" ~ id ~ \"' in scope.\");\n            }\n\n            return solveNode(root);\n        }\n\n        fn main() {\n            implicit mut _helpers = [\n                Helpers(\"hello\", Type(\"Hello\")),\n                Helpers(\"world\", Type(\"World\")),\n            ];\n\n            let res = test(\n                Node(Kind.return, \"world\", [\n                    Node(Kind.expr, \"hello\")\n                ]));\n\n            return res.canon == \"World\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_B315WHl5jX1
                                #define STR_B315WHl5jX1
static const fu::str str_B315WHl5jX1 fu_INIT_PRIORITY(1015) { "\n        struct Node { target: int; items?: Node[] }\n\n        noinline fn revSpecFewerArgs(overloads: Node[], args: int[][], root: Node)\n        {\n            fn cgNode(n: Node) {\n                mut src = \"\";\n                for (mut i = 0; i < n.items.len; i++)\n                    src ~= cgFn(n.items[i].target);\n\n                return src;\n            }\n\n            fn cgFn(target: int) {\n                mut src = cgNode(overloads[target]);\n\n                fn foreach(arg: int)\n                    src ~= cgNode(overloads[arg]);\n\n                shadow let args = args[target];\n                for (mut i = 0; i < args.len; i++)\n                    foreach(args[i]);\n\n                return src;\n            }\n\n            return cgNode(root);\n        }\n\n        fn main() {\n            return revSpecFewerArgs(\n                [ Node() ], [ [] => int[] ], Node()).len;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_IhlKCAiBPsk
                                #define STR_IhlKCAiBPsk
static const fu::str str_IhlKCAiBPsk fu_INIT_PRIORITY(1015) { "\n        struct Target { globid: i32 };\n        struct SolvedNode { target: Target; items?: SolvedNode[] }\n        struct Argument { target: Target };\n        struct Overload { solved: SolvedNode };\n        struct Extended { args: Argument[] };\n\n        noinline fn lazySolveStartDetectRecursionBug(overloads: Overload[], extended: Extended[], root: SolvedNode)\n        {\n            using fn GET(target: Target)\n                overloads[target.globid];\n\n            using fn EXT(target: Target)\n                extended[target.globid];\n\n            fn cgNode(n: SolvedNode) {\n                mut src = \"\";\n        <alt>\n                n.items.each: |member|\n                    src ~= cgFn(member.target);\n        <alt/>\n                for (mut i = 0; i < n.items.len; i++)\n                    src ~= cgFn(n.items[i].target);\n        </alt>\n                return src;\n            }\n\n            fn cgFn(target: Target) {\n                mut src = cgNode(target.solved);\n        <alt>\n                target.args.each: |host_arg|\n                    src ~= binding(host_arg);\n        <alt/>\n                let args = target.args;\n                for (mut i = 0; i < args.len; i++)\n                    src ~= binding(args[i]);\n        </alt>\n                return src;\n            }\n\n            fn binding(target: Target)      cgNode(target.solved);\n            fn binding(arg: Argument)       binding(arg.target);\n\n            return cgNode(root);\n        }\n\n        fn main() {\n            return lazySolveStartDetectRecursionBug(\n                [ Overload() ], [ Extended() ], SolvedNode()).len;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_14bQcicZnI0
                                #define STR_14bQcicZnI0
static const fu::str str_14bQcicZnI0 fu_INIT_PRIORITY(1015) { "\n        struct Hello { x: i32 };\n        implicit ref hello: Hello;\n        fn woot() = hello.x++;\n\n        <split/>\n        fn main() {\n            shadow implicit mut hello = Hello(1);\n            return woot() * 10 + hello.x - 12;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_oBXMDJiMYB0
                                #define STR_oBXMDJiMYB0
static const fu::str str_oBXMDJiMYB0 fu_INIT_PRIORITY(1015) { "\n        struct World { x: i32 };\n        struct Hello {  <fail no implicit world :20+4 because of 6:30+5><pass/>\n            implicit    </fail> world: World;\n        };\n\n        fn woot(implicit ref world: World) = world.x++;\n\n        <split/>\n        fn main() {\n            using mut hello = Hello(World(1));\n            return woot() * 10 + hello.world.x - 12;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_vq49F8eE801
                                #define STR_vq49F8eE801
static const fu::str str_vq49F8eE801 fu_INIT_PRIORITY(1015) { "\n        nocopy struct EventLoop { loop_fd: int };\n        pub fn ipv4_listen(implicit ref event_loop: EventLoop)\n            event_loop.loop_fd++;\n\n        pub fn EventLoop(loop_start!) {\n            <fail implicit event_loop 3:41+10 expects mutref 13:13+10 not mutable 8:27+10 loop_start>\n            let implicit <pass/>\n            implicit mut </fail> event_loop = {\n                mut loop_fd: int;\n                EventLoop(loop_fd)\n            };\n\n            loop_start();\n            return event_loop;\n        }\n\n        fn main() {\n            let event_loop = EventLoop(loop_start: || { ipv4_listen() });\n            return event_loop.loop_fd - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_p3yFAfmfOBi
                                #define STR_p3yFAfmfOBi
static const fu::str str_p3yFAfmfOBi fu_INIT_PRIORITY(1015) { "\n        fn privateTypeWithinRecursion(lt: int[]) {\n            fn propagateType(shadow lt: int[]) {\n                struct UsedAgain { i: int };\n\n                fn trackUsedAgain_descend(shadow lt: int[]): UsedAgain {\n                    fn trackUsedAgain_descend(t: int): UsedAgain {\n                        return trackUsedAgain_descend(Lifetime_climbType(t));\n                    }\n\n                    for (mut i = 0; i < lt.len; i++) {\n                        let u = trackUsedAgain_descend(lt[i]);\n                        if (u) return u;\n                    }\n\n                    return UsedAgain(lt.len);\n                }\n\n                let v = trackUsedAgain_descend(lt);\n                return v && propagateType([ v.i ]);\n            }\n\n            fn Lifetime_climbType(i: int): i32[] {\n                return i > 1 ? [ i / 2 ] : [];\n            }\n\n            return propagateType(lt);\n        }\n\n        fn main() {\n            return privateTypeWithinRecursion([ 1, 2, 3 ]);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_8RiKcCfOlBd
                                #define STR_8RiKcCfOlBd
static const fu::str str_8RiKcCfOlBd fu_INIT_PRIORITY(1015) { "expects struct UsedAgain, got struct UsedAgain 8:25+6"_fu };
                                #endif

                                #ifndef STR_8Vn2BAJ6hq0
                                #define STR_8Vn2BAJ6hq0
static const fu::str str_8Vn2BAJ6hq0 fu_INIT_PRIORITY(1015) { "\n        struct Node  { items: Node[] }\n        struct Document { root: Node }\n\n        fn render(doc: Document) {\n            mut count = 0;\n\n            fn visit(n: Node) {\n                count++;\n                n.items.each: |item| visit(item);\n            }\n\n            doc.root.items.each: |item| visit(item);\n            return count;\n        }\n\n        fn main() Document(root: Node(items: [ Node(items: [ Node(), Node() ]), Node() ])).render - 5;\n    "_fu };
                                #endif

                                #ifndef STR_N7ugWleN8je
                                #define STR_N7ugWleN8je
static const fu::str str_N7ugWleN8je fu_INIT_PRIORITY(1015) { "BUG recursive function without SS_FN_RECUR 10:25+4"_fu };
                                #endif

                                #ifndef STR_4ZyGU93Ppna
                                #define STR_4ZyGU93Ppna
static const fu::str str_4ZyGU93Ppna fu_INIT_PRIORITY(1015) { "\n        struct Node { items?: Node[] }\n\n        nothrow fn count(tree: Node) {\n            mut count = 0;\n            fn visit(node: Node) {\n                count++;                                <fail not nothrow 4:9+7 throws here 8:32+5 via visit 13:13+5>\n                if (count > 1) throw(\"What! Throws.\");  <pass/></fail>\n\n                node.items.each(fn visit);\n            }\n\n            visit(tree);\n            return count;\n        }\n\n        fn main() Node(items: [ Node(), Node() ]).count - 3;\n    "_fu };
                                #endif

                                #ifndef STR_kxIjny6th6f
                                #define STR_kxIjny6th6f
static const fu::str str_kxIjny6th6f fu_INIT_PRIORITY(1015) { "\n        let x = 1;\n\n        fn test(): &i32\n            x;\n\n        return test - 1;\n    "_fu };
                                #endif

                                #ifndef STR_cD3iyVgVhV8
                                #define STR_cD3iyVgVhV8
static const fu::str str_cD3iyVgVhV8 fu_INIT_PRIORITY(1015) { "\n        let a = 1;\n        let x: &i32 = a;\n\n        return a - x;\n    "_fu };
                                #endif

                                #ifndef STR_IJ7RE102xMc
                                #define STR_IJ7RE102xMc
static const fu::str str_IJ7RE102xMc fu_INIT_PRIORITY(1015) { "\n        struct Test {\n            x: &i32;\n        }\n\n        let a = 1;\n        let test = Test(a);\n\n        return test.x - 1;\n    "_fu };
                                #endif

                                #ifndef STR_5jbiuj6pri9
                                #define STR_5jbiuj6pri9
static const fu::str str_5jbiuj6pri9 fu_INIT_PRIORITY(1015) { "\n        mut a = 0;\n        mut b = a;\n        b++;\n        let c = a = b;\n\n        return a - c;\n    "_fu };
                                #endif

                                #ifndef STR_0qJ8q13JQ1l
                                #define STR_0qJ8q13JQ1l
static const fu::str str_0qJ8q13JQ1l fu_INIT_PRIORITY(1015) { "\n        mut arr = [0, 1, 2, 3, 4];\n        arr.push(5);\n\n        fn test(view: &i32[]): i32 {\n            mut sum = 0;\n            for (mut i = 0; i < view.len; i++)\n                sum += view[i];\n\n            return sum - 15;\n        }\n\n        return test(arr);\n    "_fu };
                                #endif

                                #ifndef STR_2AFi0dCest4
                                #define STR_2AFi0dCest4
static const fu::str str_2AFi0dCest4 fu_INIT_PRIORITY(1015) { "\n        mut arr: i32[] = [1, 2, 3, 4];\n        arr.push(5);\n\n        fn test(view: &i32[]): i32 {\n            mut sum = 0;\n            for (mut i = 0; i < view.len; i++)\n                sum += view[i];\n\n            return sum - 15;\n        }\n\n        return test(arr);\n    "_fu };
                                #endif

                                #ifndef STR_lOODLuOF1qc
                                #define STR_lOODLuOF1qc
static const fu::str str_lOODLuOF1qc fu_INIT_PRIORITY(1015) { "\n        let x = 5;\n        mut arr = [ -5 ];\n        arr.push(x);\n        return arr[0] + arr[1];\n    "_fu };
                                #endif

                                #ifndef STR_G1JOw8Cr9X9
                                #define STR_G1JOw8Cr9X9
static const fu::str str_G1JOw8Cr9X9 fu_INIT_PRIORITY(1015) { "\n        <fail name>\n        let x = [ named: 0 ]; <pass/>\n        let x = [        0 ]; </fail>\n        return x[0];\n    "_fu };
                                #endif

                                #ifndef STR_turhjXtbP8k
                                #define STR_turhjXtbP8k
static const fu::str str_turhjXtbP8k fu_INIT_PRIORITY(1015) { "\n        mut other: i32[][];\n        mut arr:   i32[][];\n        for (mut i = 4; i --> 0; )\n        {\n            arr.resize(i);\n\n            // fill up with non small vecs so we can check alloc counts\n            for (shadow mut i = 0; i < arr.len; i++)\n                arr[i] ||= [ i, i, i, i, i, i, i, i ]; // defeat small vec\n\n            // now this convers the \"Last chance to do nothing\" opti -\n            //  noop resize a shared vec.\n            other = arr;\n            arr.resize(other.len || i);\n        }\n        return other.len;\n    "_fu };
                                #endif

                                #ifndef STR_poSi2gSU3B1
                                #define STR_poSi2gSU3B1
static const fu::str str_poSi2gSU3B1 fu_INIT_PRIORITY(1015) { "\n        fn grow_if_oob(ref a: $T[], i: int) {\n            if (a.len <= i) a.grow(i + 1);\n            return a[i];\n        }\n\n        <split/>\n        struct Token { str: string };\n        fn add_at(ref tok2d: Token[][], i: int, str: string)\n            tok2d.grow_if_oob(i) ~= Token(str);\n\n        <split/>\n        fn main() {\n            mut tok2d: Token[][];\n            tok2d.add_at(1, \", \");\n            tok2d.add_at(3, \"Worl\");\n            tok2d.add_at(0, \"Hello\");\n            tok2d.add_at(3, \"!\");\n            let res = tok2d.map(.map(.str).join(\"d\")).join();\n            return res == \"Hello, World!\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_27H1lbWorm2
                                #define STR_27H1lbWorm2
static const fu::str str_27H1lbWorm2 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut a = [ 4, 5, 6, 7, 8, 9, 10 ];\n            mut b = [ 1, 2, 3 ];\n            swap(a, b);\n            return a.len + b.len * 10 - 73;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Ehh6dlsKgSb
                                #define STR_Ehh6dlsKgSb
static const fu::str str_Ehh6dlsKgSb fu_INIT_PRIORITY(1015) { "\n        noinline fn swap_indirect(          <fail bad call swap 4:17+4>\n            ref a: i32[..], ref b: i32[..]) <pass/>\n            ref a: i32[],   ref b: i32[])   </fail>\n                swap(a, b);\n\n        fn main() {\n            mut a = [ 4, 5, 6, 7, 8, 9, 10 ];\n            mut b = [ 1, 2, 3 ];\n            swap_indirect(a, b);\n            return a.len + b.len * 10 - 73;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_3Ehc80pm5W5
                                #define STR_3Ehc80pm5W5
static const fu::str str_3Ehc80pm5W5 fu_INIT_PRIORITY(1015) { "\n        noinline fn swap_indirect(          <fail bad call swap 6:13+4>\n            ref a: i32[..])                 <pass/>\n            ref a: i32[])                   </fail>\n        {\n            mut b = [ 1, 2, 3 ];            <alt>\n            swap(a, b);                     <alt/>\n            swap(b, a);                     </alt>\n            return b;\n        }\n\n        fn main() {\n            mut a = [ 4, 5, 6, 7, 8, 9, 10 ];\n            let b = swap_indirect(a);\n            return a.len + b.len * 10 - 73;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_n3IjUB06OJ9
                                #define STR_n3IjUB06OJ9
static const fu::str str_n3IjUB06OJ9 fu_INIT_PRIORITY(1015) { "\n        nocopy struct NC { items: NC[] };\n\n        fn main() {\n            mut whats = [ NC([ NC(), NC(), NC(), NC() ]), NC([ NC(), NC() ]), NC([ NC() ]), NC([ NC(), NC(), NC() ]) ];\n            whats.sort(|a, b| a.items.len - b.items.len < 0);\n            mut res = 0;\n            for (mut i = 0; i < whats.len; i++) res = res * 10 + whats[i].items.len;\n            return res == 1234 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_VaZ89M0Uxs1
                                #define STR_VaZ89M0Uxs1
static const fu::str str_VaZ89M0Uxs1 fu_INIT_PRIORITY(1015) { "\n        <alt>           ;; ALLOCS 4/512\n        nocopy\n        <alt/>          ;; ALLOCS 3/336\n        </alt>\n        struct NC { items: NC[] }\n<alt>\n        fn takesInlineArg(inline a: NC[], inline b: NC[]) a ~ b;\n<alt/>\n        fn takesInlineArg(mut a: NC[], inline b: NC[]) a ~= b;\n<alt/>\n        fn takesInlineArg(mut a: NC[], inline b: NC[]) {\n            a.splice(a.len / 2, 0, b);\n            return a;\n        }\n</alt>\n        fn count(items: NC[]) {\n            mut count = items.len;\n            items.each: |x| count += x.items.count;\n            return count;\n        }\n\n        fn main() {\n            let woot = takesInlineArg([ NC([ NC() ]), NC() ], [ NC(), NC([ NC() ]) ]);\n            let count = woot.count;\n            return count - 6;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_sEAbqorG5q6
                                #define STR_sEAbqorG5q6
static const fu::str str_sEAbqorG5q6 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut arr = [ 1, 2, 3 ];\n            let cpy = arr.map(|ref v| v++);\n            mut sum_arr = 0; arr.each: |v| sum_arr += v;\n            mut sum_cpy = 0; cpy.each: |v| sum_cpy += v;        ;; DuplicateFunctions\n            return sum_arr == 9 && sum_cpy == 6 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_99DHs63HK10
                                #define STR_99DHs63HK10
static const fu::str str_99DHs63HK10 fu_INIT_PRIORITY(1015) { "\n        nocopy struct NC { v: int };\n\n        fn main() {\n            mut v: NC[];    assert(v.len == 0);\n            v ~= NC(0);     assert(v.len == 1);\n            v ~= NC(1);     assert(v.len == 2);\n            v ~= NC(2);     assert(v.len == 3);\n            v ~= NC(3);     assert(v.len == 4);\n            v ~= NC(4);     assert(v.len == 5);\n            v ~= NC(5);     assert(v.len == 6);\n            v ~= NC(6);     assert(v.len == 7);\n            v ~= NC(7);     assert(v.len == 8);\n            v ~= NC(8);     assert(v.len == 9);\n            v ~= NC(9);     assert(v.len == 10);\n            mut sum = 0;\n            for (mut i = 0; i < v.len; i++) sum += v[i].v;\n            return sum - 45 + v.len * 101 - 1010;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_lGxsig7rGx9
                                #define STR_lGxsig7rGx9
static const fu::str str_lGxsig7rGx9 fu_INIT_PRIORITY(1015) { "\n        nocopy struct NC { v: int };\n\n        fn generate(n: int) {\n            mut v: NC[];\n            for (mut i = 0; i < n; i++) v ~= NC(i);\n            return v;\n        }\n\n        fn test(n: int) {\n    <alt>\n            let a = generate(n);\n            let b = a;\n    <alt/>\n            mut a = generate(n);\n            let b = a;\n    <alt/>\n            mut a = generate(n);\n            mut b = a;\n            b.reverse();\n    </alt>\n            return b;\n        }\n\n        fn main() 7.test.len - 7;\n    "_fu };
                                #endif

                                #ifndef STR_jB0pWti6mZ3
                                #define STR_jB0pWti6mZ3
static const fu::str str_jB0pWti6mZ3 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut nums: i32[];\n            for (mut i = 0; i < 100; i++) nums ~= 1;\n\n            <fail COW will break (8:27+4|8:41+4) 7:17+4>\n            ref zero    = nums[nums.len / 2];\n            let allOnes = <alt>nums<alt/>indirect_copy(nums)</alt>;\n            <pass/>\n            let allOnes = <alt>nums<alt/>indirect_copy(nums)</alt>;\n            ref zero    = nums[nums.len / 2];\n            </fail>\n\n            zero = 0;\n\n            mut o = 0;\n            for (mut i = 0; i < allOnes.len; i++)\n                if (allOnes[i] == 1)\n                    o++;\n\n            return zero == 0 && o == 100 ? 0 : 1;\n        }\n\n        noinline fn indirect_copy(arr: i32[])\n            arr.len & 1\n                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]\n                : arr; // <- we take this branch\n    "_fu };
                                #endif

                                #ifndef STR_uGz5YpwRa95
                                #define STR_uGz5YpwRa95
static const fu::str str_uGz5YpwRa95 fu_INIT_PRIORITY(1015) { "\n        let immovable: i32[] = [ 1, 2, 3 ];\n\n        fn main() {\n            mut nums: i32[];\n            for (mut i = 0; i < 100; i++) nums ~= 1;\n\n            let OPAQUE  = nums.len == 100 * nums[nums.len / 2];\n\n            <fail COW will break (15:34+1|15:48+2) 11:17+4>\n            ref zero    = nums[nums.len / 2];\n            let woot    = OPAQUE && nums;\n            <pass/>\n            let woot    = OPAQUE && nums;\n            ref zero    = nums[nums.len / 2];\n            </fail>\n\n            let allOnes = <alt>OPAQUE ? woot : immovable<alt/>indirect_copy(OPAQUE && woot)</alt>;\n\n            zero = 0;\n\n            mut o = 0;\n            for (mut i = 0; i < allOnes.len; i++)\n                if (allOnes[i] == 1)\n                    o++;\n\n            return zero == 0 && o == 100 ? 0 : 1;\n        }\n\n        noinline fn indirect_copy(arr: i32[])\n            arr.len & 1\n                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]\n                : arr; // <- we take this branch\n    "_fu };
                                #endif

                                #ifndef STR_dPYLI6XGCAf
                                #define STR_dPYLI6XGCAf
static const fu::str str_dPYLI6XGCAf fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut nums: i32[];\n            for (mut i = 0; i < 100; i++) nums ~= 1;\n\n            let OPAQUE  = nums.len == 100 * nums[nums.len / 2];\n            mut other   = 0;\n\n            <fail COW will break (12:27+4|12:41+4|11:27+4|11:41+4)>\n            ref woot    = nums[nums.len / 2];\n            ref zero    = OPAQUE ? woot : other;\n            let allOnes = <alt>nums<alt/>indirect_copy(nums)</alt>;\n            <fail/>\n            ref woot    = nums[nums.len / 2];\n            let allOnes = <alt>nums<alt/>indirect_copy(nums)</alt>;\n            ref zero    = OPAQUE ? woot : other;\n            <pass/>\n            let allOnes = <alt>nums<alt/>indirect_copy(nums)</alt>;\n            ref woot    = nums[nums.len / 2];\n            ref zero    = OPAQUE ? woot : other;\n            </fail>\n\n            zero = 0;\n\n            mut o = 0;\n            for (mut i = 0; i < allOnes.len; i++)\n                if (allOnes[i] == 1)\n                    o++;\n\n            return zero == 0 && o == 100 ? 0 : 1;\n        }\n\n        noinline fn indirect_copy(arr: i32[])\n            arr.len & 1\n                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]\n                : arr; // <- we take this branch\n    "_fu };
                                #endif

                                #ifndef STR_MJ4fG4x3eqc
                                #define STR_MJ4fG4x3eqc
static const fu::str str_MJ4fG4x3eqc fu_INIT_PRIORITY(1015) { "\n        <alt>\n        noinline fn cow_after_ref_indirect(ref zero: i32, allOnes: i32[]) cow_after_ref(:zero, :allOnes);\n        noinline fn cow_after_ref(ref zero: i32, allOnes: i32[])\n        <alt/>\n        noinline fn cow_after_ref_indirect(allOnes: i32[], ref zero: i32) cow_after_ref(:allOnes, :zero);\n        noinline fn cow_after_ref(allOnes: i32[], ref zero: i32)\n        </alt>\n        {\n            zero = 0;\n\n            mut o = 0;\n            for (mut i = 0; i < allOnes.len; i++)\n                if (allOnes[i] == 1)\n                    o++;\n\n            return zero == 0 && o == 100 ? 0 : 1;\n        }\n\n        fn main() {\n            mut nums: i32[];\n            for (mut i = 0; i < 100; i++)\n                nums ~= 1;\n\n            <alt>\n            return cow_after_ref(           <alt/>\n            return cow_after_ref_indirect(  </alt>\n                zero: nums[nums.len / 2], allOnes: <alt>nums<alt/>indirect_copy(nums)</alt>);\n        }\n\n        noinline fn indirect_copy(arr: i32[])\n            arr.len & 1\n                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]\n                : arr; // <- we take this branch\n    "_fu };
                                #endif

                                #ifndef STR_a1q3gbMUjC7
                                #define STR_a1q3gbMUjC7
static const fu::str str_a1q3gbMUjC7 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut nums: i32[];\n            for (mut i = 0; i < 100; i++) nums ~= 1;\n\n            <fail COW will break (8:27+4|8:41+4) (8:27+4|30:19+3) 7:17+6>\n            ref zeroes  = nums[10..20];\n            let allOnes = <alt>nums<alt/>indirect_copy(nums)</alt>;\n            <pass/>\n            let allOnes = <alt>nums<alt/>indirect_copy(nums)</alt>;\n            ref zeroes  = nums[10..20];\n            </fail>\n\n            for (mut i = 0; i < zeroes.len; i++)\n                zeroes[i] = 0;\n\n            mut o = 0;\n            for (mut i = 0; i < allOnes.len; i++)\n                if (allOnes[i] == 1)\n                    o++;\n\n            mut z = 0;\n            for (mut i = 0; i < zeroes.len; i++)\n                if (!zeroes[i])\n                    z++;\n\n            return z == 10 && o == 100 ? 0 : 1;\n        }\n\n        noinline fn indirect_copy(arr: i32[])\n            arr.len & 1\n                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]\n                : arr; // <- we take this branch\n    "_fu };
                                #endif

                                #ifndef STR_YlebwiTEBmj
                                #define STR_YlebwiTEBmj
static const fu::str str_YlebwiTEBmj fu_INIT_PRIORITY(1015) { "\n        <alt>\n        noinline fn cow_after_ref_indirect(ref zeroes: i32[..], allOnes: i32[]) cow_after_ref(:zeroes, :allOnes);\n        noinline fn cow_after_ref(ref zeroes: i32[..], allOnes: i32[])\n        <alt/>\n        noinline fn cow_after_ref_indirect(allOnes: i32[], ref zeroes: i32[..]) cow_after_ref(:allOnes, :zeroes);\n        noinline fn cow_after_ref(allOnes: i32[], ref zeroes: i32[..])\n        </alt>\n        {\n            for (mut i = 0; i < zeroes.len; i++)\n                zeroes[i] = 0;\n\n            mut o = 0;\n            for (mut i = 0; i < allOnes.len; i++)\n                if (allOnes[i] == 1)\n                    o++;\n\n            mut z = 0;\n            for (mut i = 0; i < zeroes.len; i++)\n                if (!zeroes[i])\n                    z++;\n\n            return z == 10 && o == 100 ? 0 : 1;\n        }\n\n        fn main() {\n            mut nums: i32[];\n            for (mut i = 0; i < 100; i++)\n                nums ~= 1;\n\n            <alt>\n            return cow_after_ref(           <alt/>\n            return cow_after_ref_indirect(  </alt>\n                zeroes: nums[10..20], allOnes: <alt>nums<alt/>indirect_copy(nums)</alt>);\n        }\n\n        noinline fn indirect_copy(arr: i32[])\n            arr.len & 1\n                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]\n                : arr; // <- we take this branch\n    "_fu };
                                #endif

                                #ifndef STR_SVqKWc5Cn30
                                #define STR_SVqKWc5Cn30
static const fu::str str_SVqKWc5Cn30 fu_INIT_PRIORITY(1015) { "\n        fn test(ref nums: i32[][])\n        {\n            <fail COW will break (6:31+1|6:45+1) (6:31+1|36:19+3) 5:17+6>\n            ref zeroes  = nums[nums.len / 2];\n            mut allOnes = <alt>nums[nums.len / 2]<alt/>indirect_copy(nums[nums.len / 2])</alt>;\n            <pass/>\n            mut allOnes = <alt>nums[nums.len / 2]<alt/>indirect_copy(nums[nums.len / 2])</alt>;\n            ref zeroes  = nums[nums.len / 2];\n            </fail>\n\n            for (mut i = 0; i < zeroes.len; i++)\n                zeroes[i] = 0;\n\n            mut o = 0;\n            for (mut i = 0; i < allOnes.len; i++)\n                if (allOnes[i] == 1)\n                    o++;\n\n            mut z = 0;\n            for (mut i = 0; i < zeroes.len; i++)\n                if (!zeroes[i])\n                    z++;\n\n            return o == 10 && z == 10 ? 0 : 10;\n        }\n\n        fn main() {\n            mut nums: i32[][];\n            for (mut i = 0; i < 4; i++)\n                nums ~= [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ];\n\n            return test(nums);\n        }\n\n        noinline fn indirect_copy(arr: i32[])\n            arr.len & 1\n                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]\n                : arr; // <- we take this branch\n    "_fu };
                                #endif

                                #ifndef STR_f0clcpmxQ0c
                                #define STR_f0clcpmxQ0c
static const fu::str str_f0clcpmxQ0c fu_INIT_PRIORITY(1015) { "\n        struct TwoVecs {\n            ones: i32[]; twos: i32[];\n        };\n\n        fn main() {\n            mut orig: TwoVecs;\n            for (mut i = 0; i < 100; i++) {\n                orig.ones ~= 1;\n                orig.twos ~= 2;\n            }\n\n            <fail COW will break (15:27+4|15:41+4) (15:27+4|34:27+13) (15:27+4|40:19+3)>\n            ref zero    = orig.ones[orig.ones.len / 2];\n            let all     = <alt>orig<alt/>indirect_copy(orig)</alt>;\n            <pass/>\n            let all     = <alt>orig<alt/>indirect_copy(orig)</alt>;\n            ref zero    = orig.ones[orig.ones.len / 2];\n            </fail>\n\n            zero = 0;\n\n            mut o = 0;\n            for (mut i = 0; i < all.ones.len; i++)\n                if (all.ones[i] == 1)\n                    o++;\n\n            mut t = 0;\n            for (mut i = 0; i < all.twos.len; i++)\n                if (all.twos[i] == 2)\n                    t++;\n\n            return zero == 0 && o == 100 && t == 100 ? 0 : 1;\n        }\n\n        noinline fn indirect_copy(tv: TwoVecs)\n            TwoVecs(ones: indirect_copy(tv.ones),\n                    twos: indirect_copy(tv.twos));\n\n        noinline fn indirect_copy(arr: i32[])\n            arr.len & 1\n                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]\n                : arr; // <- we take this branch\n    "_fu };
                                #endif

                                #ifndef STR_iZQ6l8bpHAe
                                #define STR_iZQ6l8bpHAe
static const fu::str str_iZQ6l8bpHAe fu_INIT_PRIORITY(1015) { "\n        struct TwoVecs {\n            ones: i32[];\n            twos: i32[];\n        };\n\n        <alt>\n        noinline fn cow_after_ref_indirect(ref zero: i32, all: TwoVecs) cow_after_ref(:zero, :all);\n        noinline fn cow_after_ref(ref zero: i32, all: TwoVecs)\n        <alt/>\n        noinline fn cow_after_ref_indirect(all: TwoVecs, ref zero: i32) cow_after_ref(:all, :zero);\n        noinline fn cow_after_ref(all: TwoVecs, ref zero: i32)\n        </alt>\n        {\n            zero = 0;\n\n            mut o = 0;\n            for (mut i = 0; i < all.ones.len; i++)\n                if (all.ones[i] == 1)\n                    o++;\n\n            mut t = 0;\n            for (mut i = 0; i < all.twos.len; i++)\n                if (all.twos[i] == 2)\n                    t++;\n\n            return zero == 0 && o == 100 && t == 100 ? 0 : 1;\n        }\n\n        fn main() {\n            mut orig: TwoVecs;\n            for (mut i = 0; i < 100; i++) {\n                orig.ones ~= 1;\n                orig.twos ~= 2;\n            }\n\n            <alt>\n            return cow_after_ref(           <alt/>\n            return cow_after_ref_indirect(  </alt>\n                zero: orig.ones[orig.ones.len / 2], all: <alt>orig<alt/>indirect_copy(orig)</alt>);\n        }\n\n        noinline fn indirect_copy(tv: TwoVecs)\n            TwoVecs(ones: indirect_copy(tv.ones),\n                    twos: indirect_copy(tv.twos));\n\n        noinline fn indirect_copy(arr: i32[])\n            arr.len & 1\n                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]\n                : arr; // <- we take this branch\n    "_fu };
                                #endif

                                #ifndef STR_UxMJXmZeCm3
                                #define STR_UxMJXmZeCm3
static const fu::str str_UxMJXmZeCm3 fu_INIT_PRIORITY(1015) { "\n        noinline fn test(ref barr: i32[][], ref x: i32[]) {\n            for (mut i = 0; i < x.len; i++)\n                x[i] += 2;\n\n            for (mut i = 0; i < barr.len; i++) {\n                ref b = barr[i];\n                for (mut j = 0; j < b.len; j++)\n                    b[j] += 1;\n            }\n\n            barr ~= [ 0 ];\n        }\n\n        fn main() {\n            mut arr: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];\n\n            <fail COW will break (20:24+3|20:38+3) (20:24+3|31:19+3)>\n            ref x = arr[0];\n            mut barr = <alt>arr<alt/>indirect_copy(arr)</alt>;\n            <pass/>\n            mut barr = <alt>arr<alt/>indirect_copy(arr)</alt>;\n            ref x = arr[0];\n            </fail>\n\n            test(:barr, x);\n\n            return barr == [ [1,2,3,4,5,6,7,8], [9,10,11,12,13,14,15,16], [0] ] ? 0 : 1;\n        }\n\n        noinline fn indirect_copy(arr: i32[][])\n            arr.len & 1\n                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]\n                : arr; // <- we take this branch\n    "_fu };
                                #endif

                                #ifndef STR_Is0SuuA6Mu9
                                #define STR_Is0SuuA6Mu9
static const fu::str str_Is0SuuA6Mu9 fu_INIT_PRIORITY(1015) { "\n        noinline fn test(ref barr: i32[][], ref x: i32[]) {\n            for (mut i = 0; i < x.len; i++)\n                x[i] += 2;\n\n            for (mut i = 0; i < barr.len; i++) {\n                ref b = barr[i];\n                for (mut j = 0; j < b.len; j++)\n                    b[j] += 1;\n            }\n\n            barr ~= [ 0 ];\n        }\n\n        noinline fn outer(ref a: i32[][], ref b: i32[][])\n        {\n            <fail both alias arr (28:17+3|28:31+3|27:17+3|27:31+3) 30:35+3>\n            ref x = a[0];\n            mut barr = <alt>b<alt/>indirect_copy(b)</alt>;\n            <fail/>\n            mut barr = <alt>b<alt/>indirect_copy(b)</alt>;\n            ref x = a[0];\n            <pass/>\n            mut barr = <alt>b<alt/>indirect_copy(b)</alt>;\n            mut x = a[0];\n            </fail>\n\n            test(:barr, x);\n\n            return barr;\n        }\n\n        fn main() {\n            mut arr: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];\n\n            let barr = outer(arr, arr);\n            return barr == [ [1,2,3,4,5,6,7,8], [9,10,11,12,13,14,15,16], [0] ] ? 0 : 1;\n        }\n\n        noinline fn indirect_copy(arr: i32[][])\n            arr.len & 1\n                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]\n                : arr; // <- we take this branch\n    "_fu };
                                #endif

                                #ifndef STR_PYUVsGYkPoj
                                #define STR_PYUVsGYkPoj
static const fu::str str_PYUVsGYkPoj fu_INIT_PRIORITY(1015) { "\n        struct Ephemeral {\n            id:             i32;\n            scope_skip?:    Ephemeral[];\n        };\n\n        struct SolverState {\n            _scope_skip:    Ephemeral[];\n            _ephs:          Ephemeral[];\n        };\n\n        fn snap(i: i32, ref s: SolverState) {\n            ref eph        = s._ephs[i]; // cannotCOW false positive, copy(s._scope_skip) <- ref eph, but they're disjoint\n            eph.scope_skip = <alt>s._scope_skip<alt/>indirect_copy(s._scope_skip)</alt>;\n            return eph;\n        }\n\n        fn main() {\n            mut s = SolverState(\n                _scope_skip: [ Ephemeral(1), Ephemeral(2), Ephemeral(3) ],\n                _ephs:       [ Ephemeral(4) ],\n            );\n\n            return snap(:s, 0).scope_skip.len - 3;\n        }\n\n        noinline fn indirect_copy!<T>(arr: T[])\n            arr.len & 1\n                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]\n                : arr; // <- we take this branch\n    "_fu };
                                #endif

                                #ifndef STR_NeFV0bpxV0h
                                #define STR_NeFV0bpxV0h
static const fu::str str_NeFV0bpxV0h fu_INIT_PRIORITY(1015) { "\n        // This one unrelated to COW but variation of test above.\n        <flip>\n        struct Ephemeral { // When first, we cg declarations in the wrong order\n            id:             i32;\n            scope_skip?:    ScopeSkip;\n        };\n        <flip/>\n        struct ScopeSkip { // When first, we complain about recursive types\n            left:           Ephemeral[];\n            right:          Ephemeral[];\n        };\n        </flip>\n\n        struct SolverState {\n            _scope_skip:    ScopeSkip;\n            _ephs:          Ephemeral[];\n        };\n\n        fn snap(i: i32, ref s: SolverState) {\n            mut scope_skip  = s._scope_skip;\n            ref eph         = s._ephs[i];\n            eph.scope_skip  = scope_skip;\n            return eph;\n        }\n\n        fn main() {\n            mut s = SolverState(\n                _scope_skip: ScopeSkip(\n                    [ Ephemeral(1), Ephemeral(2), Ephemeral(3) ],\n                    [ Ephemeral(4), Ephemeral(5) ]\n                ),\n                _ephs:       [ Ephemeral(4) ],\n            );\n\n            return snap(:s, 0).scope_skip.left.len - 3;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_0LlLhdYgbZj
                                #define STR_0LlLhdYgbZj
static const fu::str str_0LlLhdYgbZj fu_INIT_PRIORITY(1015) { "\n        struct Node { items: Node[] };\n\n        fn unwrap_all(ref nodes: Node[]) {\n            for (mut i = 0; i < nodes.len; i++) {\n                ref n = nodes[i];\n                if (n.items)        // cannotCOW false pos\n                    n = n.items[0]; //  copy(n.items[0]) <- ref n\n            }                       //   via parent nodes\n        }\n\n        fn count(nodes: Node[]) {\n            mut N = nodes.len;\n            for (mut i = 0; i < nodes.len; i++)\n                N += nodes[i].items.count;\n            return N;\n        }\n\n        fn main() {\n            mut nodes = [ Node([ Node() ]) ];\n            nodes.unwrap_all();\n            return nodes.count - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_4vg60020IRc
                                #define STR_4vg60020IRc
static const fu::str str_4vg60020IRc fu_INIT_PRIORITY(1015) { "\n        noinline fn conditionalCopyOrWrite(ref a: i32[][], ref b: i32[][]) {\n            ref either = (a || b)[0];\n            <alt>\n            if (either.len & 1)\n                b = a;              // <- no issue here\n            else                    //  either only written to\n                either ~= 1;        //   if copy never created.\n            <alt/>\n            if (either.len & 1 == 0)\n                either ~= 1;\n            else\n                b = a;\n            </alt>\n        }\n\n        fn arr(n: i32) {\n            mut arr: i32[];\n            for (mut i = 1; i <= n; i++) arr ~= i;\n            return arr;\n        }\n\n        fn check(arr: i32[]) {\n            mut sum = 0;\n            for (mut i = 0; i < arr.len; i++) sum += arr[i];\n            return sum;\n        }\n\n        fn check(arr: i32[][]) {\n            mut sum = 0;\n            for (mut i = 0; i < arr.len; i++) sum = sum * 100 + check(arr[i]);\n            return sum;\n        }\n\n        fn main() {\n            mut a = [ arr( 8), arr( 9) ];\n            mut b = [ arr(10), arr(11) ];\n\n            conditionalCopyOrWrite(:a, :b);\n\n            return check(a) == 3600 + 45 + 100\n                && check(b) == 5500 + 66\n                    ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_qanPrWRnZwd
                                #define STR_qanPrWRnZwd
static const fu::str str_qanPrWRnZwd fu_INIT_PRIORITY(1015) { "\n        struct SolvedNode {\n            items: SolvedNode[];\n        };\n\n        fn mutateThenCopy(ref callsite: SolvedNode, ref root: SolvedNode) {\n            callsite.items ~= callsite;\n            mut result = root;\n            result.items ~= root;\n            return result;\n        }\n\n        fn main() {\n            fn count(node: SolvedNode) {\n                mut c = 1;\n                node.items.each: |item| c += count(item);\n                return c;\n            }\n\n            mut a: SolvedNode;\n            mut b = mutateThenCopy(a, a);\n            return 1000 * a.count + b.count - 2004;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_dFuNduznSXg
                                #define STR_dFuNduznSXg
static const fu::str str_dFuNduznSXg fu_INIT_PRIORITY(1015) { "\n        struct SolvedNode {\n            items: SolvedNode[];\n        };\n\n        fn mutateThenCopy(ref root: SolvedNode) {\n            fn copyRoot() {\n                mut result = root;\n                result.items ~= root;\n                return result;\n            }\n\n            fn bck_call(ref callsite: SolvedNode) {\n                callsite.items ~= callsite; // mutation\n                return copyRoot();          // copy inside\n            }\n\n            return bck_call(root);\n        }\n\n        fn main() {\n            fn count(node: SolvedNode) {\n                mut c = 1;\n                node.items.each: |item| c += count(item);\n                return c;\n            }\n\n            mut a: SolvedNode;\n            mut b = a.mutateThenCopy();\n            return 1000 * a.count + b.count - 2004;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_j9apFJH3FY5
                                #define STR_j9apFJH3FY5
static const fu::str str_j9apFJH3FY5 fu_INIT_PRIORITY(1015) { "\n        struct SolvedNode {\n            items: SolvedNode[];\n        };\n\n        fn mutateCopyMutate(ref callsite: SolvedNode, ref root: SolvedNode) {\n            callsite.items ~= callsite;\n            mut result = root;\n            root.items ~= root;\n            return result;\n        }\n\n        fn main() {\n            fn count(node: SolvedNode) {\n                mut c = 1;\n                node.items.each: |item| c += count(item);\n                return c;\n            }\n\n            mut a: SolvedNode;\n            mut b = mutateCopyMutate(a, a);\n            return 1000 * a.count + b.count - 4002;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_lzIeca1Suig
                                #define STR_lzIeca1Suig
static const fu::str str_lzIeca1Suig fu_INIT_PRIORITY(1015) { "\n        struct SolvedNode {\n            items: SolvedNode[];\n        };\n\n        fn mutateCopyMutate(ref root: SolvedNode) {\n            fn copyRoot() {\n                mut result = root;\n                root.items ~= root;\n                return result;\n            }\n\n            fn bck_call(ref callsite: SolvedNode) {\n                callsite.items ~= callsite; // mutation\n                return copyRoot();          // copy inside\n            }\n\n            return bck_call(root);\n        }\n\n        fn main() {\n            fn count(node: SolvedNode) {\n                mut c = 1;\n                node.items.each: |item| c += count(item);\n                return c;\n            }\n\n            mut a: SolvedNode;\n            mut b = a.mutateCopyMutate();\n            return 1000 * a.count + b.count - 4002;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_EsiYTpW3Dbh
                                #define STR_EsiYTpW3Dbh
static const fu::str str_EsiYTpW3Dbh fu_INIT_PRIORITY(1015) { "\n        struct SolvedNode {\n            items: SolvedNode[];\n        };\n\n        fn mutateThenCopyAfterRecursion(ref root: SolvedNode) {\n            fn mutateThenCopy(ref callsite: SolvedNode) {\n                callsite.items ~= callsite;\n\n                mut result = root;\n                result.items ~= root;\n                return result;\n            }\n<flip>\n            fn indirectRecursion(ref node: SolvedNode) {\n                ref items = node.items;\n\n                // The root copies made at the end of each bck_node call\n                //  would indeed be invalid if they survived,\n                //   but they get return-discarded here.\n                for (mut i = items.len; i --> 1; )\n                    bck_node(items[i]);                         ;; !N_COWRestrict\n                                                                ;; PointlessMustSeq\n                return items && bck_node(items[0]);\n            }\n<flip/>\n            fn bck_node(ref node: SolvedNode)\n                node.items\n                    ? indirectRecursion(node)\n                    : mutateThenCopy(node);\n</flip>\n            return bck_node(root);\n        }\n\n        fn main() {\n            fn count(node: SolvedNode) {\n                mut c = 1;\n                node.items.each: |item| c += count(item);\n                return c;\n            }\n\n            mut a: SolvedNode;\n            mut b = a.mutateThenCopyAfterRecursion();\n            return 1000 * a.count + b.count - 2004;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_82fLRafJ41d
                                #define STR_82fLRafJ41d
static const fu::str str_82fLRafJ41d fu_INIT_PRIORITY(1015) { "if/else no common supertype SolvedNode[] 17:21+1"_fu };
                                #endif

                                #ifndef STR_3sTHvlOeAW7
                                #define STR_3sTHvlOeAW7
static const fu::str str_3sTHvlOeAW7 fu_INIT_PRIORITY(1015) { "\n        struct Node {\n            items?: Node[];\n        };\n\n        fn obtuseEscapeOnNextLoopIter(ref node: Node, ref root: Node) {\n            mut escape: Node;\n            <fail both alias root 26:17+4>\n            ref <pass/>\n            fn  </fail> items = node.items;\n\n            for (mut i = items.len; i --> 0; ) {\n                <alt>\n                if (i)      escape = root;\n                else        items[i].items ~= escape;\n                <alt/>\n                if (i == 0) items[i].items ~= escape;\n                else        escape = root;\n                </alt>\n            }\n        }\n\n        fn main() {\n            fn count(node: Node) {\n                mut c = 1;\n                node.items.each: |item| c += count(item);\n                return c;\n            }\n\n            mut root = Node([ Node, Node ]);\n            obtuseEscapeOnNextLoopIter(root, root);\n\n            // Now root should be:\n            // Node([ Node([ Node([ Node, Node ]) ]), Node ])\n            //\n            // If COW breaks this can get self-recursive,\n            //  currently blows up with a segfault if 'ref items'.\n            //\n            return root.count - 6;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_X4SsAWJ1a0e
                                #define STR_X4SsAWJ1a0e
static const fu::str str_X4SsAWJ1a0e fu_INIT_PRIORITY(1015) { "\n        struct SolvedNode {\n            items: SolvedNode[];\n        };\n\n        fn cowAfterConditionalWithLoop(ref a: SolvedNode, ref b: SolvedNode) {\n            if (a.items.len & 1) {\n                ref items = a.items;\n                for (mut i = 0; i < items.len; i++)\n                    cowAfterConditionalWithLoop(items[i], b);\n            }\n\n            a.items ~= b;\n        }\n\n        fn main() {\n            mut x = SolvedNode([ SolvedNode ]);\n            <fail both alias x>\n            ref y = x;  <pass/>\n            mut y = x;  </fail>\n            cowAfterConditionalWithLoop(x, y);                  ;; N_COWRestrict\n\n            fn count(node: SolvedNode) {\n                mut c = 1;\n                node.items.each: |item| c += count(item);\n                return c;\n            }\n\n            return x.count == 6 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_qCkAW5kkekd
                                #define STR_qCkAW5kkekd
static const fu::str str_qCkAW5kkekd fu_INIT_PRIORITY(1015) { "\n        struct SolvedNode {\n            items: SolvedNode[];\n        };\n\n        fn copiesRootBeforeThrow(ref root: SolvedNode, ref escape: SolvedNode)\n        {\n            fn fail(reason: string)\n                reason.len & 1 && throw(\"odd: \" ~ reason)\n                               || throw(reason);\n\n            fn bck_node(ref node: SolvedNode) {\n                ref items = node.items;\n                for (mut i = 0; i < items.len; i++) {\n                    ref item = items[i];\n                    bck_node(item);\n\n                    if (item.items.len > 1) {\n                        escape = root;\n                        <fail both alias root 29:13+8>\n                        if (escape.items.len > 3)       <pass/>\n                        if (true)                       </fail> ;; !DEV_DontFoldLiterals\n                            fail(\"#\" ~ escape.items.len);\n                    }\n                }\n\n                node.items ~= node;\n            }\n\n            bck_node(root);\n        }\n\n        fn main() {\n            fn count(node: SolvedNode) {\n                mut c = 1;\n                node.items.each: |item| c += count(item);\n                return c;\n            }\n\n            mut escape: SolvedNode;\n            mut a = SolvedNode([ SolvedNode ]);\n            a.copiesRootBeforeThrow(:escape);\n\n            let C0 = a.count;\n            if (C0 != 6)            return 1;\n\n            try {\n                a.copiesRootBeforeThrow(:escape);\n            }\n            catch (e) {\n                a.items ~= SolvedNode(); // escape !== a\n                let C1 = a.count;\n                let C2 = escape.count;\n                if (C1 != 11)           return 2;\n                if (C2 != 10)           return 3;\n                else if (e != \"#2\")     return 4;\n                else                    return 0;\n            }\n\n            return 5;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_0Wa6BLs9fCd
                                #define STR_0Wa6BLs9fCd
static const fu::str str_0Wa6BLs9fCd fu_INIT_PRIORITY(1015) { "\n        struct A { ints: i32[] };\n\n        fn copyInts_then_mutateBytes(ref bytes: byte[], a: A) {\n        <flip>\n            for (mut i = 0; i < bytes.len; i++)\n                bytes[i] = 0.byte;\n        <flip/>\n            mut ret = a;\n        </flip>\n            ret.ints.pop();\n            return ret;\n        }\n\n        fn main() {\n            mut a = A([ 1, 1, 1, 1, 1, 2, 2, 2, 2, 2 ]);\n\n            <fail mut a 16:17+1 COW will break 21:56+1 due to bytes 19:18+5>\n            ref <pass/>\n            fn  </fail> bytes = a.ints.view(of: byte);\n\n            let b = copyInts_then_mutateBytes(:bytes, :a);\n\n            mut sum = 0;\n            for (mut i = 0; i < b.ints.len; i++)\n                sum += b.ints[i];\n\n            return sum - 13;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_q5M3vCa7Khi
                                #define STR_q5M3vCa7Khi
static const fu::str str_q5M3vCa7Khi fu_INIT_PRIORITY(1015) { "\n        struct Wrapper { str: string };\n\n        fn validateCOW_falsePos_with_typeMayPointInto_disabled(\n            ref _scope: Wrapper[])\n        {\n            fn findFirstSet() {\n                _scope.each: |wrapper|\n                    if (wrapper.str)\n                        return wrapper.str;\n\n                return \"None\";\n            }\n\n            fn wrapper_cannotPointInto_String(h: int) {\n                ref wrapper = _scope[h];\n                wrapper.str = findFirstSet();\n            }\n\n            for (mut i = 0; i < _scope.len; i++)\n                wrapper_cannotPointInto_String(i);\n        }\n\n        fn main() {\n            mut _scope = [ Wrapper() ];\n            validateCOW_falsePos_with_typeMayPointInto_disabled(_scope);\n            return _scope.len == 1 && _scope[0].str.len - 4;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_nPG8HiIx3ec
                                #define STR_nPG8HiIx3ec
static const fu::str str_nPG8HiIx3ec fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut data: int[][] = [ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 ] ];\n\n        <fail cow will break data (10:31+4|11:21+4|11:25+1|9:28+1|9:24+4)>\n            ref <pass/>\n            mut </fail> item = data[0][1];\n\n        <alt>\n            mut copy = data;\n        <alt/>\n            mut copy = data ~ [ 0, 0, 0, 0 ];\n        <alt/>\n            mut copy = data ~ [ [ 0, 0, 0, 0 ] ];\n        <alt/>\n            mut copy = data[.. 1] ~ data[1 ..];\n        <alt/>\n            mut copy: int[][];\n            copy ~= data[.. data.len / 2];\n            copy ~= data[data.len / 2 ..];\n        <alt/>\n            mut copy: int[][];\n            copy ~= [ 0, 0, 0, 0 ];\n            copy ~= data;\n        <alt/>\n            mut copy: int[][];\n            copy.splice(0, 0, data);\n        </alt>\n\n            item += 1000;\n\n            mut sum = 0;\n            copy.each: .each(|x| sum += x);\n            return item == 1001 && sum == 190 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_90ptpPCGvya
                                #define STR_90ptpPCGvya
static const fu::str str_90ptpPCGvya fu_INIT_PRIORITY(1015) { "@[1] + @[4] - @[5]"_fu };
                                #endif

                                #ifndef STR_OFMn1vaNmF3
                                #define STR_OFMn1vaNmF3
static const fu::str str_OFMn1vaNmF3 fu_INIT_PRIORITY(1015) { "@[1] + @[3] - @.len"_fu };
                                #endif

                                #ifndef STR_wXoLNlkfwzj
                                #define STR_wXoLNlkfwzj
static const fu::str str_wXoLNlkfwzj fu_INIT_PRIORITY(1015) { "@[2] + @[5] - @[0]"_fu };
                                #endif

                                #ifndef STR_WH8u7MfeHB0
                                #define STR_WH8u7MfeHB0
static const fu::str str_WH8u7MfeHB0 fu_INIT_PRIORITY(1015) { "@[0] + @[2] - @[3]"_fu };
                                #endif

                                #ifndef STR_gBXOUnICkN0
                                #define STR_gBXOUnICkN0
static const fu::str str_gBXOUnICkN0 fu_INIT_PRIORITY(1015) { "@[2] + @[5] - @[1]"_fu };
                                #endif

                                #ifndef STR_V1KYEmaMpmc
                                #define STR_V1KYEmaMpmc
static const fu::str str_V1KYEmaMpmc fu_INIT_PRIORITY(1015) { "@.len + @[0] + @[1] - 102"_fu };
                                #endif

                                #ifndef STR_tXttLJYNzq7
                                #define STR_tXttLJYNzq7
static const fu::str str_tXttLJYNzq7 fu_INIT_PRIORITY(1015) { "\n        let OPERATORS = [ \"+\", \"-\", \"*\", \"/\" ];\n\n        fn main()\n            OPERATORS[2] == \"*\" ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_PwUQYxB5dVf
                                #define STR_PwUQYxB5dVf
static const fu::str str_PwUQYxB5dVf fu_INIT_PRIORITY(1015) { "\n        struct Y { b: bool; }\n        struct X { y: Y[]; }\n\n        mut x: X[];\n        x.push( X([ Y(true) ]) );\n\n        return x.len + x[0].y.len * 2 - 3;\n    "_fu };
                                #endif

                                #ifndef STR_bT0JEalwgK5
                                #define STR_bT0JEalwgK5
static const fu::str str_bT0JEalwgK5 fu_INIT_PRIORITY(1015) { "\n        struct SelfRec { x: SelfRec[]; };\n        fn main() SelfRec( [ SelfRec() ] ).x.len - 1; // <- solved with a dirty selfrec & defctor\n    "_fu };
                                #endif

                                #ifndef STR_ddAIkpytU2k
                                #define STR_ddAIkpytU2k
static const fu::str str_ddAIkpytU2k fu_INIT_PRIORITY(1015) { "\n        struct ABRec { x: BARec[]; };\n        struct BARec { x: ABRec[]; };\n        fn main() ABRec( [ BARec() ] ).x.len - 1; // <- solved with a dirty selfrec & defctor\n    "_fu };
                                #endif

                                #ifndef STR_hbNpLUmow49
                                #define STR_hbNpLUmow49
static const fu::str str_hbNpLUmow49 fu_INIT_PRIORITY(1015) { "\n        struct ABRec { x: BARec[]; y: ABBARec[]; };\n        struct BARec { x: ABRec[]; y: ABBARec[]; };\n        struct ABBARec { x: ABRec[]; y: BARec[]; };\n        fn main() ABRec( [ BARec() ], [ ABBARec() ] ).x.len - 1; // <- solved with a dirty selfrec & defctor\n    "_fu };
                                #endif

                                #ifndef STR_Qn4oMSeXLS0
                                #define STR_Qn4oMSeXLS0
static const fu::str str_Qn4oMSeXLS0 fu_INIT_PRIORITY(1015) { "\n        mut a = [7, 1, 5, 3, 99, -13]; // [-13, 1, 3, 5, 7, 99]\n        a.sort();\n        return a[0] + a[1] + a[3] + a[4];\n    "_fu };
                                #endif

                                #ifndef STR_ucNSkRs4qDj
                                #define STR_ucNSkRs4qDj
static const fu::str str_ucNSkRs4qDj fu_INIT_PRIORITY(1015) { "\n        let a = [0, 1, 2, 3];\n        let b = a.slice(1, 3);\n        return b.len - b[1];\n    "_fu };
                                #endif

                                #ifndef STR_Y40VRJQdrc1
                                #define STR_Y40VRJQdrc1
static const fu::str str_Y40VRJQdrc1 fu_INIT_PRIORITY(1015) { "\n        let a = [0, 1, 2, 3];\n        let b = a.slice(1);\n        return b.len - b[2];\n    "_fu };
                                #endif

                                #ifndef STR_iFxUHcBAfKd
                                #define STR_iFxUHcBAfKd
static const fu::str str_iFxUHcBAfKd fu_INIT_PRIORITY(1015) { "\n        fn collectDedupes(mut vals<alt>: i32[]</alt>) {\n            vals.sort();\n            return vals[0];\n        }\n\n        fn main() {\n            let vals = [ 1, 0 ];\n            return collectDedupes(vals);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_ojMkbeJEJoe
                                #define STR_ojMkbeJEJoe
static const fu::str str_ojMkbeJEJoe fu_INIT_PRIORITY(1015) { "\n        fn sort01(ref arr: $T[..]) {\n            mut tmp: $T;\n            if (arr[0] > arr[1]) {\n                swap(arr[0], tmp);\n                swap(arr[1], tmp);\n            }\n        }\n\n        fn collectDedupes(mut vals) {\n            vals.sort01();\n            return vals[0];\n        }\n\n        fn main() {\n            let vals = [ 1, 0 ];\n            return collectDedupes(vals);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_vdUI3y5bSHf
                                #define STR_vdUI3y5bSHf
static const fu::str str_vdUI3y5bSHf fu_INIT_PRIORITY(1015) { "\n        mut str = \"hello \";\n        str ~= \"world\";\n\n        return str.len - 11;\n    "_fu };
                                #endif

                                #ifndef STR_7ys8sIXls83
                                #define STR_7ys8sIXls83
static const fu::str str_7ys8sIXls83 fu_INIT_PRIORITY(1015) { "\n        let str = \"hello \" ~ \"world\";\n\n        return str.starts(with: \"hel\")\n             ? str  .ends(with: \"rld\")\n             ? str.len - 11\n             : 171\n             : 173;\n    "_fu };
                                #endif

                                #ifndef STR_P0zSFqzApMi
                                #define STR_P0zSFqzApMi
static const fu::str str_P0zSFqzApMi fu_INIT_PRIORITY(1015) { "\n        let str = \"a\" ~ 1710010;\n\n        return str == \"a1710010\"\n             ? 0 : 101;\n    "_fu };
                                #endif

                                #ifndef STR_umJRsttiPqe
                                #define STR_umJRsttiPqe
static const fu::str str_umJRsttiPqe fu_INIT_PRIORITY(1015) { "\n        let str = \"hello world\";\n        mut cpy = \"\";\n        for (mut i = 0; i < str.len; i++)\n            cpy ~= str[i];\n\n        return (cpy.len - 11) + (cpy == str ? 0 : 1);\n    "_fu };
                                #endif

                                #ifndef STR_lihkIoeFYSg
                                #define STR_lihkIoeFYSg
static const fu::str str_lihkIoeFYSg fu_INIT_PRIORITY(1015) { "\n        fn xorshift(mut x: u8)  { x ^= x <<  5; x ^= x >>  3; x ^= x <<  7 }\n        fn xorshift(mut x: u16) { x ^= x <<  3; x ^= x >>  5; x ^= x << 11 }\n        fn xorshift(mut x: u32) { x ^= x << 13; x ^= x >> 17; x ^= x <<  5 }\n        fn xorshift(mut x: u64) { x ^= x << 13; x ^= x >>  7; x ^= x << 17 }\n\n        fn main() {                                             ;; DuplicateFunctions\n            mut rnd_state = 1.u32;\n            fn rnd() {\n                rnd_state = xorshift(rnd_state);\n                return rnd_state + 0;\n            }\n\n            fn check(a: string, b: string, expect: int, next = -1)\n            {\n                let a0 = a.find(b);\n                assert(a0 == expect);\n\n                if (expect >= 0) {\n                    let a1 = a.find(b, start: expect + b.len);\n                    assert(a1 == next);\n                }\n\n                if (!b) return;\n\n                if (b.len < 256) {\n                    mut aa = \"\";\n                    mut bb = \"\";\n                    for (mut i = 0; i < a.len; i++) aa ~= [ a[i], a[i] ];\n                    for (mut i = 0; i < b.len; i++) bb ~= [ b[i], b[i] ];\n\n                    check(aa, bb, expect < 0 ? -1 : expect * 2,\n                                    next < 0 ? -1 :   next * 2);\n                }\n\n                if (!b.has('x')) {\n                    let bi = b.len && (rnd % b.len.u32).int;\n                    check(a, b[.. bi] ~ 'x' ~ b[bi ..], -1, -1);\n\n                    if (b.len >= 2 && expect >= 0 && next < 0) {\n                        let bmid = b.len - 2;\n                        let ai = expect + 1 + (bmid && rnd % bmid.u32).int;\n                        check(a[.. ai] ~ 'c' ~ a[ai ..], b, -1, -1);\n                    }\n\n                    fn check(type as!<T>) {\n                        shadow let rnd = rnd;\n                        fn randomize(v: byte) xorshift(v.T + rnd.T);\n                        shadow let a = a.map(.randomize);\n                        shadow let b = b.map(.randomize);\n\n                        shadow let a0 = a.find(b);\n                        assert(a0 == expect);\n\n                        if (expect >= 0) {\n                            shadow let a1 = a.find(b, start: expect + b.len);\n                            assert(a1 == next);\n                        }\n                    }\n\n                    check(as: u8); check(as: u16); check(as: u32); check(as: u64);\n\n                    if (expect >= 0 && !(b.len & 1) && !(a.has('n')))\n                    {\n                        check(a ~ 'n', b, expect, next);\n                        check('n' ~ a, b, expect + 1, next < 0 ? next : next + 1);\n\n                        if (!b.has('n') && a.len)\n                        {\n                            let replace = b[int(rnd % b.len.u32)];\n                            shadow let a = a.replace(all: replace, with: 'n');\n                            shadow let b = b.replace(all: replace, with: 'n');\n\n                            {\n                                shadow let expect = expect < 0 ? expect : expect - 1;\n                                shadow let next   = next   < 0 ? next   : next   - 1;\n\n                                if (expect >= 0 || next < 0)\n                                    check(a[1 ..], b, expect, next);\n                            }\n\n                            check(a[.. a.len - 1], b, expect < a.len - b.len ? expect : -1\n                                                    , next   < a.len - b.len ? next   : -1);\n                        }\n                    }\n                }\n            }\n\n            check(\"hello world\", \"\", 0, 0);\n            check(\"hello world\", \"h\", 0);\n            check(\"hello world\", \" \", 5);\n            check(\"hello world\", \"d\", 10);\n            check(\"hello world\", \"hello\", 0);\n            check(\"hello world\", \"helllo\", -1);\n            check(\"hello world\", \"ello \", 1);\n            check(\"hello world\", \"lllo \", -1);\n            check(\"hello world\", \"lllo \", -1);\n            check(\"hello world\", \"wrld\", -1);\n            check(\"hello world\", \"world \", -1);\n            check(\"hello world\", \"worldd\", -1);\n            check(\"hello world\", \"hh\", -1);\n            check(\"hello world\", \"dd\", -1);\n            check(\"hello world\", \"ll\", 2);\n            check(\"hello world\", \" w\", 5);\n            check(\"hello world\", \"o \", 4);\n            check(\"hello world\", \"world\", 6);\n            check(\"hello world\", \"hello world\", 0);\n            check(\"hello world\", \"eello world\", -1);\n            check(\"hello world\", \" hello world\", -1);\n            check(\"hello world\", \"hello world \", -1);\n            check(\"hellohellohello\", \"hello\", 0, 5);\n            check(\"hellhellohello\", \"hello\", 4, 9);\n            check(\"hellhellhello\", \"hello\", 8);\n            return 0;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_9oFL12Kkfl6
                                #define STR_9oFL12Kkfl6
static const fu::str str_9oFL12Kkfl6 fu_INIT_PRIORITY(1015) { "\n        return \"hello world\".find(\"world\")\n             - 2 * [1, 7, 13, 14, 19].find(14);\n    "_fu };
                                #endif

                                #ifndef STR_Vnaxj62T9M6
                                #define STR_Vnaxj62T9M6
static const fu::str str_Vnaxj62T9M6 fu_INIT_PRIORITY(1015) { "\n        return (\"hello world\".has(\"world\") ? 1 : 0)\n             + ([1, 14, 96, 2].has(14)     ? 2 : 0)\n             - 3;\n    "_fu };
                                #endif

                                #ifndef STR_AeFAohzOMk2
                                #define STR_AeFAohzOMk2
static const fu::str str_AeFAohzOMk2 fu_INIT_PRIORITY(1015) { "\n        let hw = \"hello world!\";\n        let a = hw.slice(6, 6 + 5);\n        let b = hw[6 .. 6 + 5];\n        return a == b && a == \"world\" ? a.len - 5 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_1LNlS1C2Bmj
                                #define STR_1LNlS1C2Bmj
static const fu::str str_1LNlS1C2Bmj fu_INIT_PRIORITY(1015) { "\n        let tests =\n        [\n            \"\",\n            \" \",\n            \"  \",\n            \"hey you duders\",\n            \" hey you duders\",\n            \"hey you duders \",\n            \"  hey you duders \",\n            \"  hey you  duders \",\n            \"  hey you  duders  \"\n        ];\n\n        fn test(item: string)\n            item == item.split(\" \").join(\" \")\n                ? 0\n                : item.len;\n\n        mut sum = 0;\n        for (mut i = 0; i < tests.len; i++)\n            sum += test(tests[i]);\n\n        return sum;\n    "_fu };
                                #endif

                                #ifndef STR_twBsqF7IAQ9
                                #define STR_twBsqF7IAQ9
static const fu::str str_twBsqF7IAQ9 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            let sj = \"heelloo\"  .split(\"ee\").join(\"e\")\n                                .split('o').join(\"o!\")\n                                .split(\"he\").join();            ;; DuplicateFunctions\n\n            return sj == \"llo!o!\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_zE5BBJXzIe9
                                #define STR_zE5BBJXzIe9
static const fu::str str_zE5BBJXzIe9 fu_INIT_PRIORITY(1015) { "\n        fn main() '\\e'.i32 - 27\n             ||   '\\0'.i32\n             || '\\x11'.i32 - 17\n             || '\\xaA'.i32 - 170;\n    "_fu };
                                #endif

                                #ifndef STR_JC7vGTy2Y96
                                #define STR_JC7vGTy2Y96
static const fu::str str_JC7vGTy2Y96 fu_INIT_PRIORITY(1015) { "\n        fn main()   <fail unterminated char literal 3:13+2>\n            'c      <fail/>  // '\n            'c\n            '       <pass/>\n            'c'     </fail>\n                .i32 - 99;\n    "_fu };
                                #endif

                                #ifndef STR_goc6tLsUuXd
                                #define STR_goc6tLsUuXd
static const fu::str str_goc6tLsUuXd fu_INIT_PRIORITY(1015) { "\n        fn main()   <fail invalid char literal 3:13+4>\n            'cb'    <pass/>\n            'c'     </fail>\n                .i32 - 99;\n    "_fu };
                                #endif

                                #ifndef STR_Jh5IjP2w3F1
                                #define STR_Jh5IjP2w3F1
static const fu::str str_Jh5IjP2w3F1 fu_INIT_PRIORITY(1015) { "\n        fn main()   <fail unterminated string use backticks 3:13+2>\n            \"c      <fail/>  // \"\n            \"c\n            \"       <pass/>\n            `c\n            `      </fail>\n                [0].i32 - 99;\n    "_fu };
                                #endif

                                #ifndef STR_j0Z0cYzBc9f
                                #define STR_j0Z0cYzBc9f
static const fu::str str_j0Z0cYzBc9f fu_INIT_PRIORITY(1015) { "\n        fn main()                           <fail invalid code point 3:14+10>\n            \"\\u{ffffff}\".u32               <pass/>\n            \"\\u{042e}\" == \"\xD0\xAE\"  ? 0 : 1     </fail>\n            ;\n    "_fu };
                                #endif

                                #ifndef STR_SEIrynv0s06
                                #define STR_SEIrynv0s06
static const fu::str str_SEIrynv0s06 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut hello = \"hello\";\n            mut olleh = hello;\n            olleh.reverse();\n            return olleh == \"olleh\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_nZmj0FVdyCb
                                #define STR_nZmj0FVdyCb
static const fu::str str_nZmj0FVdyCb fu_INIT_PRIORITY(1015) { "\n        fn main()\n            \"hello\".replace(all: \"h\", with: \"H\") == \"Hello\" &&\n            \"hello\".replace(all: 'e', with: 'E') == \"hEllo\" &&\n            \"hello\".replace(all: \"l\", with: 'L') == \"heLLo\" &&\n            \"hello\".replace(all: 'o', with: \"O\") == \"hellO\" &&\n            \"hello\".replace(all: \"l\", with:  []) == \"heo\"\n                ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_kW4aBnNXGk6
                                #define STR_kW4aBnNXGk6
static const fu::str str_kW4aBnNXGk6 fu_INIT_PRIORITY(1015) { "\n        fn cnct(a: string, b: string) a ~ b;\n\n        fn main()\n            cnct( <fail missing comma before world 6:29>\n                a: \"hello, \"`world!\n` <pass/>\n                a: \"hello, \", `world!\n` </fail>\n            ).len - 14;\n    "_fu };
                                #endif

                                #ifndef STR_b7YX0P13Kz1
                                #define STR_b7YX0P13Kz1
static const fu::str str_b7YX0P13Kz1 fu_INIT_PRIORITY(1015) { "\n        fn main() (\"\" ~ \"\").len;\n    "_fu };
                                #endif

                                #ifndef STR_7jBjqn7nlkf
                                #define STR_7jBjqn7nlkf
static const fu::str str_7jBjqn7nlkf fu_INIT_PRIORITY(1015) { "\n        let empty_str = \"\";\n    "_fu };
                                #endif

                                #ifndef STR_aBCi48oqauk
                                #define STR_aBCi48oqauk
static const fu::str str_aBCi48oqauk fu_INIT_PRIORITY(1015) { "\n        fn main() = _0::empty_str.len;\n    "_fu };
                                #endif

                                #ifndef STR_PV5EQW0GOJa
                                #define STR_PV5EQW0GOJa
static const fu::str str_PV5EQW0GOJa fu_INIT_PRIORITY(1015) { "\n        let empty_str = \"\";\n        let empty_str_ref = empty_str;\n    "_fu };
                                #endif

                                #ifndef STR_bdZD81b26p7
                                #define STR_bdZD81b26p7
static const fu::str str_bdZD81b26p7 fu_INIT_PRIORITY(1015) { "\n        fn main() = _0::empty_str_ref.len;\n    "_fu };
                                #endif

                                #ifndef STR_6j4WP2cfXkd
                                #define STR_6j4WP2cfXkd
static const fu::str str_6j4WP2cfXkd fu_INIT_PRIORITY(1015) { "\n        let non_empty_str = \"This is a non-empty string that's too long for small string opti.\";\n        let non_empty_str_ref = non_empty_str;\n    "_fu };
                                #endif

                                #ifndef STR_cm5Ztlk8NEa
                                #define STR_cm5Ztlk8NEa
static const fu::str str_cm5Ztlk8NEa fu_INIT_PRIORITY(1015) { "\n        fn main() = _0::non_empty_str_ref.len - 65;\n    "_fu };
                                #endif

                                #ifndef STR_LvQcpDtTeG1
                                #define STR_LvQcpDtTeG1
static const fu::str str_LvQcpDtTeG1 fu_INIT_PRIORITY(1015) { "\n        let non_empty_str = \"This is a non-empty string that's too long for small string opti.\";\n        let non_empty_slice = non_empty_str[5..];\n    "_fu };
                                #endif

                                #ifndef STR_h1bgkXAZC5a
                                #define STR_h1bgkXAZC5a
static const fu::str str_h1bgkXAZC5a fu_INIT_PRIORITY(1015) { "\n        fn main() = _0::non_empty_slice.len - 60;\n    "_fu };
                                #endif

                                #ifndef STR_pJErjlBJBze
                                #define STR_pJErjlBJBze
static const fu::str str_pJErjlBJBze fu_INIT_PRIORITY(1015) { "\n        let strA = \"0123456789abcdef0123456789ABCDEF\";\n\n        fn main()\n        {\n            let a0 = mem::ALLOC_STAT_COUNT();\n            strA.slice(0, 26) == \"0123456789abcdef0123456789\" || throw(\"bad slice\");\n\n            let a1 = mem::ALLOC_STAT_COUNT();\n            a0 == a1 || throw(\"did alloc\");\n\n            return 0;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_wCaqfnNtuKg
                                #define STR_wCaqfnNtuKg
static const fu::str str_wCaqfnNtuKg fu_INIT_PRIORITY(1015) { "\n        let strA = \"0123456789abcdef0123456789ABCDEF\";\n\n        fn main()\n            strA.slice(26, 32) == \"ABCDEF\"\n                ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_MY3H22i9HSf
                                #define STR_MY3H22i9HSf
static const fu::str str_MY3H22i9HSf fu_INIT_PRIORITY(1015) { "\n        struct NotAString { hey: string };\n        fn main() {\n            mut a = \"Hello\";\n            mut b = NotAString(\"World!\");\n            <fail NotAString not a string 7:22+1>\n            return a < b ? 0 : 1;         <pass/>\n            return a < b.hey ? 0 : 1;     </fail>\n        }\n    "_fu };
                                #endif

                                #ifndef STR_G60lwX13usg
                                #define STR_G60lwX13usg
static const fu::str str_G60lwX13usg fu_INIT_PRIORITY(1015) { "\n        fn Zero(sources: string[])\n            sources;\n\n        fn ZeroSame(alts: string[][])\n            alts.map(.Zero);\n\n        fn ZeroSame(alts: string[])\n            ZeroSame(alts.map(|x| [ x ]));\n\n        fn main() {\n            let result =\n                ZeroSame([ \"Hello\", \"World\" ])\n                    .map(|inner| inner.join(\"#\"))\n                        .join(\", \") ~ \"!\";\n\n            return result == \"Hello, World!\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_LFMuGP7zkwe
                                #define STR_LFMuGP7zkwe
static const fu::str str_LFMuGP7zkwe fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            let data = \"kung--fury\";\n            mut what = 1;\n            mut res = \"\";\n            data.split(\"--\"): |part| what *= (res ~= part).len;\n            return what == 32 && res == \"kungfury\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_qkNYGyxMEsj
                                #define STR_qkNYGyxMEsj
static const fu::str str_qkNYGyxMEsj fu_INIT_PRIORITY(1015) { "\n        fn Append(inline a: string, <alt>inline</alt> b: string) a ~ b;\n        fn main() {\n            let res = Append(\n                Append(\"12345678901234567890\", \"12345678901234567890\"),\n                \"12345678901234567890\"); ;; ALLOCS 1\n\n            return res.len == 60 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_U5OqM8Lbbn0
                                #define STR_U5OqM8Lbbn0
static const fu::str str_U5OqM8Lbbn0 fu_INIT_PRIORITY(1015) { "\n        mut x: Map(string, i32);\n\n        x[\"hello\"] = 1;\n        x[\"world\"] = 2;\n\n        return x[\"hello\"] - x[\"world\"] + 1;\n    "_fu };
                                #endif

                                #ifndef STR_d2EK5g3cKOh
                                #define STR_d2EK5g3cKOh
static const fu::str str_d2EK5g3cKOh fu_INIT_PRIORITY(1015) { "Map is not defined"_fu };
                                #endif

                                #ifndef STR_G0kA3okWkyk
                                #define STR_G0kA3okWkyk
static const fu::str str_G0kA3okWkyk fu_INIT_PRIORITY(1015) { "\n        mut x: Map(string, i32);\n\n        x[\"hello\"] = 1;\n        x[\"world\"] = 2;\n\n        let b = \"hello world\";\n        mut offset = 0;\n\n        fn pop(): string {\n            mut a = \"\";\n\n            while (offset < b.len) {\n                let c = b[offset++];\n                if (c == ' ')\n                    break;\n\n                a ~= c;\n            }\n\n            return a;\n        }\n\n        return x[pop()] - x[pop()] + 1;\n    "_fu };
                                #endif

                                #ifndef STR_0iTgITfVfb5
                                #define STR_0iTgITfVfb5
static const fu::str str_0iTgITfVfb5 fu_INIT_PRIORITY(1015) { "\n        fn test(a = 1, b = 2) a + b;\n        return test() - 3;\n    "_fu };
                                #endif

                                #ifndef STR_W3JZkC0h6aj
                                #define STR_W3JZkC0h6aj
static const fu::str str_W3JZkC0h6aj fu_INIT_PRIORITY(1015) { "\n        fn test(a = 1, b = 2) a + b;\n        return test(b: -1);\n    "_fu };
                                #endif

                                #ifndef STR_02kaJcTwNwf
                                #define STR_02kaJcTwNwf
static const fu::str str_02kaJcTwNwf fu_INIT_PRIORITY(1015) { "\n        fn test(a = 1, b = 2) a + b;\n        return test(-2);\n    "_fu };
                                #endif

                                #ifndef STR_cKyol8AMMq6
                                #define STR_cKyol8AMMq6
static const fu::str str_cKyol8AMMq6 fu_INIT_PRIORITY(1015) { "\n        struct Test { a?: i32; b?: i32; }\n        let t = Test(1);\n        return t.a - 1 + t.b * 7;\n    "_fu };
                                #endif

                                #ifndef STR_PVgwWl6S6v7
                                #define STR_PVgwWl6S6v7
static const fu::str str_PVgwWl6S6v7 fu_INIT_PRIORITY(1015) { "\n        struct Test { a?: i32; b?: i32; }\n        let t = Test(1);\n        return t.b;\n    "_fu };
                                #endif

                                #ifndef STR_0pVxBuEzeKc
                                #define STR_0pVxBuEzeKc
static const fu::str str_0pVxBuEzeKc fu_INIT_PRIORITY(1015) { "\n        struct Test { a?: i32; b?: i32; }\n        let t = Test(a: 1);\n        return t.a - 1 + t.b * 7;\n    "_fu };
                                #endif

                                #ifndef STR_tECsgmQFKG3
                                #define STR_tECsgmQFKG3
static const fu::str str_tECsgmQFKG3 fu_INIT_PRIORITY(1015) { "\n        struct Test { a?: i32; b?: i32; }\n        let t = Test(b: 1);\n        return t.b - 1 + t.a * 7;\n    "_fu };
                                #endif

                                #ifndef STR_WrcRN68Mxah
                                #define STR_WrcRN68Mxah
static const fu::str str_WrcRN68Mxah fu_INIT_PRIORITY(1015) { "\n        struct Test { x?: i32; };\n        fn hey() Test();\n        return hey.x;\n    "_fu };
                                #endif

                                #ifndef STR_KZ9ysYdoyKa
                                #define STR_KZ9ysYdoyKa
static const fu::str str_KZ9ysYdoyKa fu_INIT_PRIORITY(1015) { "\n        struct Test { x?: i32; };\n        fn hey(y: i32 = 0)\n            y   ? Test(1)\n                : Test();\n\n        return hey.x;\n    "_fu };
                                #endif

                                #ifndef STR_1ojPKRf7Utf
                                #define STR_1ojPKRf7Utf
static const fu::str str_1ojPKRf7Utf fu_INIT_PRIORITY(1015) { "\n        <fail bad call test string, i32 4:19+4>\n        fn test(a = \"hello\") a.len;     <pass/>\n        fn test(a = 0) a + 1;           </fail>\n        fn main() test(-1);\n    "_fu };
                                #endif

                                #ifndef STR_ZTkZZ88ngTa
                                #define STR_ZTkZZ88ngTa
static const fu::str str_ZTkZZ88ngTa fu_INIT_PRIORITY(1015) { "\n        fn test(a = 3, b = a * 2) a + b;\n        fn main() test + test(a: -1) * 3;\n    "_fu };
                                #endif

                                #ifndef STR_4M4TRkKm0y5
                                #define STR_4M4TRkKm0y5
static const fu::str str_4M4TRkKm0y5 fu_INIT_PRIORITY(1015) { "\n        fn test(a = 3, b = a * a) a + b;\n        fn main() test + test(a: 5) - 42;\n    "_fu };
                                #endif

                                #ifndef STR_EraeyyqTNTj
                                #define STR_EraeyyqTNTj
static const fu::str str_EraeyyqTNTj fu_INIT_PRIORITY(1015) { "\n        fn woot(ref a: i32, ref b: i32) {\n            ref c = a || b;                                         <alt>\n            fn arg_defaulted_to_closure(ref x = c)     x *= 2;      <alt/>\n            fn arg_defaulted_to_closure(ref x = c, y = x *= 2) y;   </alt>\n\n            arg_defaulted_to_closure( );\n            arg_defaulted_to_closure(a);\n            arg_defaulted_to_closure(b);\n        }\n\n        fn main() {\n            mut a = 1;\n            mut b = 1;\n            woot(a, b);\n            return a == 4 && b == 2 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_jpaJCCAutgf
                                #define STR_jpaJCCAutgf
static const fu::str str_jpaJCCAutgf fu_INIT_PRIORITY(1015) { "\n        fn test(ref a: i32, mut incr: i32) {\n            fn woot(ref x, ref b = a) { // 'a' closes over here!\n                if (x & 1) {\n                    x /= 2;\n                    return test(x, b);\n                }\n                return b += x;\n            }\n\n            return woot(incr<alt>, a</alt>);\n        }\n\n        fn main() {\n            mut x = 10;\n            return test(x, 5) == 12 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_aQXZCd48W3f
                                #define STR_aQXZCd48W3f
static const fu::str str_aQXZCd48W3f fu_INIT_PRIORITY(1015) { "\n        struct Arg { name: string };\n        fn main() {\n            let arg = Arg(<fail argument name id>id<pass/>name</fail>: \"hey\");\n            return arg.name.len - 3;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_uW64YBGUVfe
                                #define STR_uW64YBGUVfe
static const fu::str str_uW64YBGUVfe fu_INIT_PRIORITY(1015) { "\n        fn uses_implicit(implicit ref sum: i32) {\n            return sum++;\n        }\n        <split/>\n        inline fn inline_implicit_from_defarg(hello: i32, defaulted_argument: i32 = uses_implicit) {\n            return hello * defaulted_argument;\n        }\n        <split/>\n        fn main() {\n            implicit mut sum = 3;\n            let res = inline_implicit_from_defarg(sum);\n            return sum == 4 && res == 9 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_QSAeWDug9Rh
                                #define STR_QSAeWDug9Rh
static const fu::str str_QSAeWDug9Rh fu_INIT_PRIORITY(1015) { "\n        // reduct: inline_implicit_from_defarg ooe bug\n        fn main() {\n            <alt>\n            return ooe_block_arg(z: 0, a: 3);\n        }\n\n        fn ooe_block_arg(mut z: i32, mut a: i32) {\n            <alt/>\n            mut z = 0;\n            mut a = 3;\n            return ooe_block_arg(:z, :a);\n        }\n\n        fn ooe_block_arg(ref z: i32, ref a: i32) {\n            <alt/>\n            mut z = 0;\n            mut a = 3;\n            </alt>\n                        ;; N_BckMustSeq\n            <alt>\n            let res = a * { ref x = z || a; x++ };\n            return a == 4 && res == 9 ? 0 : 1;\n            <alt/>\n            let res = { ref x = z || a; x++ } * a;\n            return a == 4 && res == 12 ? 0 : 1;\n            </alt>\n        }\n    "_fu };
                                #endif

                                #ifndef STR_PUvI6e7LUJi
                                #define STR_PUvI6e7LUJi
static const fu::str str_PUvI6e7LUJi fu_INIT_PRIORITY(1015) { "\n        // reduct: inline_implicit_from_defarg\n        fn test(ref a: i32, ref z: i32) {\n            <alt>\n            inline                                              ;; N_BckMustSeq\n            <alt/>\n            noinline                                            ;; N_AARMustSeq\n            </alt>\n            fn ooe_closure(ref hello<alt>: i32</alt>) {\n                let res = hello * { ref x = z || a; x++ };\n                hello += 10;\n                return res;\n            }\n\n            let res = ooe_closure(a);\n            return a == 14 && res == 9 ? 0 : 1;\n        }\n\n        fn main() {\n            mut a = 3;\n            mut z = 0;\n            return test(:a, :z);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_c9OPYAg3Bwi
                                #define STR_c9OPYAg3Bwi
static const fu::str str_c9OPYAg3Bwi fu_INIT_PRIORITY(1015) { "\n        // gcc doesn't cg RTL with just * for this testcase, but this breaks it\n        noinline fn mul(a: i32, b: i32) = a * b;\n\n        // reduct: inline_implicit_from_defarg\n        fn test(ref a: i32, ref z: i32) {\n            <alt>\n            inline                                              ;; N_BckMustSeq\n            <alt/>\n            noinline                                            ;; N_AARMustSeq\n            </alt>\n            fn ooe_closure(ref hello<alt>: i32</alt>) {\n                let res = mul({ ref x = z || a; x++ }, hello);\n                hello += 10;\n                return res;\n            }\n\n            let res = ooe_closure(a);\n            return a == 14 && res == 12 ? 0 : 1;\n        }\n\n        fn main() {\n            mut a = 3;\n            mut z = 0;\n            return test(:a, :z);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Ko7K1mMYe83
                                #define STR_Ko7K1mMYe83
static const fu::str str_Ko7K1mMYe83 fu_INIT_PRIORITY(1015) { "\n        inline fn uses_implicit_inside() {\n            inline fn uses_implicit(implicit ref sum: i32) {\n                return sum++;\n            }\n\n            return uses_implicit;\n        }\n\n        <alt>\n        inline                  <alt/>\n        ;; N_BckMustSeq         </alt>\n        fn inline_implicit_from_defarg(hello: i32, defaulted_argument: i32 = uses_implicit_inside) {\n            return hello * defaulted_argument;\n        }\n\n        fn main() {\n            implicit mut sum = 3;\n            let res = inline_implicit_from_defarg(sum);\n            return sum == 4 && res == 9 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_LcMduGygZN0
                                #define STR_LcMduGygZN0
static const fu::str str_LcMduGygZN0 fu_INIT_PRIORITY(1015) { "\n        inline fn uses_implicit(implicit ref sum: i32) = sum++;\n        inline fn uses_implicit_inside() = uses_implicit;\n\n        <alt>\n        inline                  <alt/>\n        ;; N_BckMustSeq         </alt>\n        fn inline_implicit_from_defarg(defaulted_argument: i32 = uses_implicit_inside, hello: i32 = 0)\n            hello * defaulted_argument;\n\n        fn main() {\n            implicit mut sum = 3;\n            let res = inline_implicit_from_defarg(hello: sum);\n            return sum == 4 && res == 12 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_L73JyuUJ7Ej
                                #define STR_L73JyuUJ7Ej
static const fu::str str_L73JyuUJ7Ej fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            struct Type { canon: string };\n\n            mut _lookups: int;\n            mut _t_bool: Type;\n\n            fn t_bool() {\n                return _t_bool ||= Scope_lookupType(\"bool\");\n            }\n\n            fn Scope_lookupType(canon: string) {\n                _lookups++;\n                return Type(:canon);\n            }\n\n            fn check(a<alt>: Type</alt>, b = t_bool) {\n                return a.canon.len + b.canon.len;\n            }\n\n            return check(t_bool) + _lookups - 9;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_wwG8lk7Habe
                                #define STR_wwG8lk7Habe
static const fu::str str_wwG8lk7Habe fu_INIT_PRIORITY(1015) { "\n        struct Type { canon: string };\n        struct Node { kind: string; value: string };\n        struct SolvedNode { value: string; type: Type };\n\n        fn solve(root: Node)\n        {\n            mut _t_bool: Type;\n\n            fn createBool(value: string, type = t_bool)\n                return SolvedNode(:value, :type);\n\n            fn solveNode(node: Node)\n                return node.kind == \"bool\"\n                    && createBool(:node.value);\n    <alt>\n            fn solveNode(canon: string)\n                return Type(:canon);\n\n            fn t_bool()\n                return _t_bool ||= solveNode(\"t_bool\");\n    <alt/>\n            fn t_bool()\n                return _t_bool ||= Type(\"t_bool\");\n    </alt>\n            return solveNode(root);\n        }\n\n        fn main() {\n            let s = solve(Node(kind: \"bool\", value: \"Hello!\"));\n            return s.value      == \"Hello!\"\n                && s.type.canon == \"t_bool\"\n                    ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_1Ttx9EsoFp6
                                #define STR_1Ttx9EsoFp6
static const fu::str str_1Ttx9EsoFp6 fu_INIT_PRIORITY(1015) { "Declaration cycle 10:16+10"_fu };
                                #endif

                                #ifndef STR_ZzIHvRi2MZc
                                #define STR_ZzIHvRi2MZc
static const fu::str str_ZzIHvRi2MZc fu_INIT_PRIORITY(1015) { "\n        struct Type { canon: string };\n        struct Node { kind: string; value: string };\n        struct SolvedNode { value: string; type: Type };\n\n        fn createBool(value: string, type = t_bool)\n            return SolvedNode(:value, :type);\n\n        fn solveNode(node: Node)\n            return node.kind == \"bool\"\n                && createBool(:node.value);\n<alt>\n        fn solveNode(canon: string)\n            return Type(:canon);\n\n        fn t_bool(implicit ref _t_bool: Type)\n            return _t_bool ||= solveNode(\"t_bool\");\n<alt/>\n        fn t_bool(implicit ref _t_bool: Type)\n            return _t_bool ||= Type(\"t_bool\");\n</alt>\n        fn solve(root: Node)\n        {\n            implicit mut _t_bool: Type;\n            return solveNode(root);\n        }\n\n        fn main() {\n            let s = solve(Node(kind: \"bool\", value: \"Hello!\"));\n            return s.value      == \"Hello!\"\n                && s.type.canon == \"t_bool\"\n                    ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_eEfU4xm8eid
                                #define STR_eEfU4xm8eid
static const fu::str str_eEfU4xm8eid fu_INIT_PRIORITY(1015) { "Declaration cycle 11:20+10"_fu };
                                #endif

                                #ifndef STR_LaHR0qoD3Xk
                                #define STR_LaHR0qoD3Xk
static const fu::str str_LaHR0qoD3Xk fu_INIT_PRIORITY(1015) { "\n        fn woot(hello!?, world!?) {\n            hello(one?: 1);\n            world(two?: 2);\n        }\n\n        fn main() {\n            mut res = 0;\n            woot(hello: |one| res += one);\n            woot(world: |two| res += two);\n            return res - 3;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_dzJjfKCnwS7
                                #define STR_dzJjfKCnwS7
static const fu::str str_dzJjfKCnwS7 fu_INIT_PRIORITY(1015) { "\n        fn woot(hello!?, world!?) {\n            hello(one?: 1);\n            world(two?: 2);\n        }\n\n        fn main() {\n            mut res = 0;\n            <fail duplicate explicitly named argument hello 10:13+4>\n            woot(hello: |one| res += one, hello: |one| res += one); <pass/>\n            woot(hello: |one| res += one, world: |two| res += two); </fail>\n            return res - 3;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_0P7j8d7E7ca
                                #define STR_0P7j8d7E7ca
static const fu::str str_0P7j8d7E7ca fu_INIT_PRIORITY(1015) { "\n        struct Node { bullet?: byte; pointer: int }\n\n        fn skipNonTrailingDefaultedStructField() {\n            mut bullet = byte();        <fail missing required arg pointer 6:20+4>\n            return Node(:bullet);       <pass/>\n            return Node([], :bullet);   </fail>\n        }\n\n        fn main() skipNonTrailingDefaultedStructField.pointer;\n    "_fu };
                                #endif

                                #ifndef STR_gWDY3TD1Kg5
                                #define STR_gWDY3TD1Kg5
static const fu::str str_gWDY3TD1Kg5 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            fn approx_p(a: f32, b = a)\n                2 * f32.PI * sqrt(0.5 * (a * a + b * b));\n\n            assert(approx_p(10) == approx_p(10, 10));\n            return 0;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_z1R24yn8Nl3
                                #define STR_z1R24yn8Nl3
static const fu::str str_z1R24yn8Nl3 fu_INIT_PRIORITY(1015) { "\n        struct Layout { atlas_width: u16; atlas_height: u16 }\n        enum Size: u8 { x2 = 1; x4 = 2; x8 = 3; x16 = 4; x32 = 5; x64 = 6 }\n\n        fn Layout(\n            slot_size:      Size,\n            atlas_width   = Size(slot_size.u8 + 2),\n            atlas_height  = atlas_width)\n        {\n            shadow mut slot_size    =  1 << slot_size.min(\"x32\").u16;\n            shadow mut atlas_width  = (1 << atlas_width.u16)    .max(slot_size * 2);\n            shadow mut atlas_height = (1 << atlas_height.u16)   .max(slot_size * 2);\n\n            return Layout(:atlas_width, :atlas_height);\n        }\n\n        let ATLAS_LAYOUT = Layout(slot_size: \"x16\");\n\n        fn main() ATLAS_LAYOUT.atlas_width == 32 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_BiRtOLbIsI9
                                #define STR_BiRtOLbIsI9
static const fu::str str_BiRtOLbIsI9 fu_INIT_PRIORITY(1015) { "BUG nested(): bad locid 17:28+6"_fu };
                                #endif

                                #ifndef STR_ywYrKcAdUnf
                                #define STR_ywYrKcAdUnf
static const fu::str str_ywYrKcAdUnf fu_INIT_PRIORITY(1015) { "\n        let s = 7;\n        return s ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_zpvbMVfBBQ3
                                #define STR_zpvbMVfBBQ3
static const fu::str str_zpvbMVfBBQ3 fu_INIT_PRIORITY(1015) { "\n        let s = 0;\n        return s ? 1 : 0;\n    "_fu };
                                #endif

                                #ifndef STR_XUtUfEkHOu3
                                #define STR_XUtUfEkHOu3
static const fu::str str_XUtUfEkHOu3 fu_INIT_PRIORITY(1015) { "\n        let s = \"hello\";\n        return s ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_P791Hu3rUrh
                                #define STR_P791Hu3rUrh
static const fu::str str_P791Hu3rUrh fu_INIT_PRIORITY(1015) { "\n        let s = \"\";\n        return s ? 1 : 0;\n    "_fu };
                                #endif

                                #ifndef STR_SuwjQW5Kr68
                                #define STR_SuwjQW5Kr68
static const fu::str str_SuwjQW5Kr68 fu_INIT_PRIORITY(1015) { "\n        let s = [ 4 ];\n        return s ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_1bHJQDC15ua
                                #define STR_1bHJQDC15ua
static const fu::str str_1bHJQDC15ua fu_INIT_PRIORITY(1015) { "\n        mut s = [ 4 ];\n        s.pop();\n        return s ? 1 : 0;\n    "_fu };
                                #endif

                                #ifndef STR_rAljFnDSThl
                                #define STR_rAljFnDSThl
static const fu::str str_rAljFnDSThl fu_INIT_PRIORITY(1015) { "\n        struct S { x: i32; }\n        let s: S = S(1);\n        return s ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_szgVyETT578
                                #define STR_szgVyETT578
static const fu::str str_szgVyETT578 fu_INIT_PRIORITY(1015) { "\n        struct S { x: i32; }\n        let s: S;\n        return s ? 1 : 0;\n    "_fu };
                                #endif

                                #ifndef STR_GGdFk8M2Fld
                                #define STR_GGdFk8M2Fld
static const fu::str str_GGdFk8M2Fld fu_INIT_PRIORITY(1015) { "\n        mut sum = 0;\n        :OUTER for (mut y = 1; y < 10; y++)\n        {\n            sum += y * 10; // 10, 20\n            for (mut x = 1; x < 10; x++)\n            {\n                sum += x; // 1, 1, 2\n                if (y == 1) continue :OUTER;                    ;; Goto\n                if (x == 2) break    :OUTER;\n            }\n        }\n\n        return sum - 34;\n    "_fu };
                                #endif

                                #ifndef STR_MAG8L6bSGz0
                                #define STR_MAG8L6bSGz0
static const fu::str str_MAG8L6bSGz0 fu_INIT_PRIORITY(1015) { "\n        fn for_fn(mut i: i32, n: i32, visit)\n            for (; i < n; i++)\n                visit(i);\n\n        mut sum = 0;\n        :OUTER for_fn(1, 10): |y| // same as above but via helper fn\n        {\n            sum += y * 10; // 10, 20\n            for_fn(1, 10): |x|\n            {\n                sum += x; // 1, 1, 2\n                if (y == 1) continue :OUTER;                    ;; Goto\n                if (x == 2) break    :OUTER;\n            }\n        }\n\n        return sum - 34;\n    "_fu };
                                #endif

                                #ifndef STR_6u237Ikarvg
                                #define STR_6u237Ikarvg
static const fu::str str_6u237Ikarvg fu_INIT_PRIORITY(1015) { "\n        fn twice(what)\n            for (mut i = 0; i < 2; i++)\n                what(i);\n\n        mut x = 0;\n        :TWICE twice: |i<alt>: int</alt>| {\n            x += i;\n            if (!x++) continue :TWICE;\n        }\n\n        return x - 3;\n    "_fu };
                                #endif

                                #ifndef STR_5bs9m6ujLV6
                                #define STR_5bs9m6ujLV6
static const fu::str str_5bs9m6ujLV6 fu_INIT_PRIORITY(1015) { "\n        mut sum = 0;\n        :OUTER for (mut x = 0;; x++) {\n            for (mut y = 0; y < x; y++) {\n                if (y & 1 && !(x & 1))\n                    continue :OUTER;                            ;; Goto\n\n                sum += x;\n            }\n\n            sum += x * 1000 + 100;\n            if (x > 1)                                          ;; EXPECT break;\n                break; // anon\n        }\n\n        // x=0:           + 0100\n        // x=1: 1         + 1100\n        // x=2: 2\n        // x=3: 3 + 3 + 3 + 3100 break\n        return sum - 4312;\n    "_fu };
                                #endif

                                #ifndef STR_sc6XvZ5Gej6
                                #define STR_sc6XvZ5Gej6
static const fu::str str_sc6XvZ5Gej6 fu_INIT_PRIORITY(1015) { "\n        fn test(ref sum: i32) {\n            :FIRST {\n                if (sum & 1)\n                    break:\n                        FIRST;\n                sum++;\n            }\n            :SECOND {\n                if (sum & 1)\n                    break:\n                        <fail label>\n                        FIRST;      <pass/>\n                        SECOND;     </fail>\n                sum++;\n\n                if (sum & 2)\n                    break:\n                        SECOND;\n                sum++;\n            }\n        }\n\n        fn main() {\n            mut sum = 0;\n            test(sum);\n            return sum - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_2YcHzbNsMfe
                                #define STR_2YcHzbNsMfe
static const fu::str str_2YcHzbNsMfe fu_INIT_PRIORITY(1015) { "\n        let x = \"hello\";\n        lax let y = \"world\";\n        let w = x || y;\n\n        return w == \"hello\" ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_Rz7woBLtT75
                                #define STR_Rz7woBLtT75
static const fu::str str_Rz7woBLtT75 fu_INIT_PRIORITY(1015) { "\n        let x = \"hello\";\n        let y = \"world\";\n        let w = x && y;\n\n        return w == \"world\" ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_6pM9yj51Tel
                                #define STR_6pM9yj51Tel
static const fu::str str_6pM9yj51Tel fu_INIT_PRIORITY(1015) { "\n        let x = \"hello\";\n        lax let y = \"world\";\n        let w = 3 && x || y;\n\n        return w == \"hello\" ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_n2DYVZF2199
                                #define STR_n2DYVZF2199
static const fu::str str_n2DYVZF2199 fu_INIT_PRIORITY(1015) { "\n        let x = \"hello\";\n        let y = \"world\";\n        let arr: i32[];\n        let w = arr && x || y;\n\n        return w == \"world\" ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_6n2LeTogpY2
                                #define STR_6n2LeTogpY2
static const fu::str str_6n2LeTogpY2 fu_INIT_PRIORITY(1015) { "\n        let x = \"hello\";\n        let y = \"world\";\n        let arr: i32[];\n        let w = arr && x || y || throw(\"Nope.\");\n\n        return w == \"world\" ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_QnYmFTJZ1h8
                                #define STR_QnYmFTJZ1h8
static const fu::str str_QnYmFTJZ1h8 fu_INIT_PRIORITY(1015) { "\n        fn what(a: i32) {\n            a == 2 || a & 1 || throw(\"what1\");\n            a  > 1 && a & 1 && throw(\"what2\");\n            a  > 0 && a & 3 || throw(\"what3\");\n            return a + 4;\n        }\n        fn main() 1.what - 2.what + 1;\n    "_fu };
                                #endif

                                #ifndef STR_t4Fd3HAwhdi
                                #define STR_t4Fd3HAwhdi
static const fu::str str_t4Fd3HAwhdi fu_INIT_PRIORITY(1015) { "\n        fn gen(len: i32) {\n            mut res: i32[];\n            for (mut i = 0; i < len; i++) res ~= i;\n            return res;\n        }\n        fn test(len: i32) {\n            let x = [-5, +5];\n            let y = len.gen && x;\n            return x[y.len / 2];\n        }\n        fn main() 0.test + 1.test;\n    "_fu };
                                #endif

                                #ifndef STR_srtqeGvhyE3
                                #define STR_srtqeGvhyE3
static const fu::str str_srtqeGvhyE3 fu_INIT_PRIORITY(1015) { "\n        fn is_mutref(t: string)     t.len == 6;\n        fn is_never(t: string)      t.len == 5;\n\n        fn test(ref init: string, ref annot: string)\n            init.is_mutref && annot ||\n            init.is_never  && annot || throw(\"noreturn\");\n\n        fn main() {\n            mut annot = \"hey!\";\n            mut init = \"woot!\";\n            return test(:init, :annot).len - 4;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_TcBrCVupfag
                                #define STR_TcBrCVupfag
static const fu::str str_TcBrCVupfag fu_INIT_PRIORITY(1015) { "\n        fn test(mut init: string) {\n            init.len && init || throw(\"noreturn\");\n            return init.len;\n        }\n\n        fn main() test(\"woot!\") - 5;\n    "_fu };
                                #endif

                                #ifndef STR_TELWImXuCx5
                                #define STR_TELWImXuCx5
static const fu::str str_TELWImXuCx5 fu_INIT_PRIORITY(1015) { "\n        fn is_mutref(t: string)     t.len == 6;\n        fn is_never(t: string)      t.len == 5;\n        let F_ARG = 1;\n\n        fn test(ref init: string, ref annot: string, mut flags: i32) {\n            init.is_mutref  || init.is_never  && annot\n                            || !init && flags & F_ARG\n                            || throw(\"noreturn\");\n            return flags;\n        }\n\n        fn main() {\n            mut annot = \"hey!\";\n            mut init = \"woot!\";\n            return test(:init, :annot, 0);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_giZL1d581j6
                                #define STR_giZL1d581j6
static const fu::str str_giZL1d581j6 fu_INIT_PRIORITY(1015) { "\n        fn a(a)  a ?  a : [];   // ifs used cons-type to seed alt-type\n        fn b(b) !b ? [] : b;    //  which works for 'a', but not for 'b'.\n        fn main() 1.a - 1.b;\n    "_fu };
                                #endif

                                #ifndef STR_YhCXrPMlHhk
                                #define STR_YhCXrPMlHhk
static const fu::str str_YhCXrPMlHhk fu_INIT_PRIORITY(1015) { "\n        struct Type { i: i32 };\n        fn is_mutref (t: Type) !!(t.i & 3);\n        fn is_ref    (t: Type) !!(t.i & 1);\n        fn clear_refs(t: Type) Type(t.i &~ 3);\n\n        fn tryClearRefs(t: Type, mutref?: bool): Type =     // type-hints vs type-assertions:\n            (mutref ? t.is_mutref : t.is_ref)               //  solveBlocks used within '&&' and '?'\n                && clear_refs(t);                           //   so the '?' complained 'bool' doesnt assign to 'Type'\n\n        fn main() {\n            let a = tryClearRefs(Type(6), true);\n            let b = tryClearRefs(Type(6), false);\n            return a.i + b.i - 4;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_vZhpRufJ9Gg
                                #define STR_vZhpRufJ9Gg
static const fu::str str_vZhpRufJ9Gg fu_INIT_PRIORITY(1015) { "\n        fn ambig_or(x: i32, y: f32)\n            \"Hello: \" ~\n                <fail ambig operand non bool context>       // So it happened that at some point I had an 'a || b'\n                    (x || y)                  <pass/>       //  where a and b were of the same type used in string concat like this,\n                    (x || y.i32)              </fail>       //   and then later when the types no longer matched this fell back silently to a '!!a || !!b'\n                ;                                           //    which was is not the intent but compiled fine because str concat also accepts bool.\n\n        fn main() {\n            mut res = ambig_or(1, 2);\n            return res == \"Hello: 1\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Vt9jmHW7RJ4
                                #define STR_Vt9jmHW7RJ4
static const fu::str str_Vt9jmHW7RJ4 fu_INIT_PRIORITY(1015) { "\n        fn unambig_or(b: bool, i: i32, f: f32)  <alt>\n            b || i || f;                        <alt/>      // But currently the thinking is that so long as one operand is a bool\n            i || f || b;                        </alt>      //  the whole thing should weaken to (!!a || !!b) instead of erroring out.\n\n        fn main() = unambig_or(false, 0, 0).i32;\n    "_fu };
                                #endif

                                #ifndef STR_409E0Pbj6Tc
                                #define STR_409E0Pbj6Tc
static const fu::str str_409E0Pbj6Tc fu_INIT_PRIORITY(1015) { "\n        struct Node { items: Node[] };\n\n        fn isFieldChain(arg: Node) {\n            if (arg.items.len > 1)\n                return false;\n\n            return !arg.items || isFieldChain(arg.items[0]);\n        }\n\n        fn main() {\n            let empty       = Node();\n            let chain       = Node([ Node ]);\n            let not_chain   = Node([ Node, Node ]);\n\n            return empty.isFieldChain\n                && chain.isFieldChain\n                && !not_chain.isFieldChain ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_OURuRS7GKjj
                                #define STR_OURuRS7GKjj
static const fu::str str_OURuRS7GKjj fu_INIT_PRIORITY(1015) { "\n        fn underconcat(dedupe: string, sighash: string)\n            dedupe && sighash\n                ? dedupe ~ '_' ~ sighash\n                : dedupe || sighash;\n\n        fn main() {\n            let a   = underconcat(\"a\", \"\");\n            let b   = underconcat(\"\", \"b\");\n            let c   = underconcat(\"\", \"\");\n            let ab  = underconcat(\"a\", \"b\");\n\n            let res = a ~ \",\" ~ b ~ \",\" ~ c ~ \",\" ~ ab;\n            return res == \"a,b,,a_b\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_mn5GD0Tnlm0
                                #define STR_mn5GD0Tnlm0
static const fu::str str_mn5GD0Tnlm0 fu_INIT_PRIORITY(1015) { "\n        <alt>\n        noinline                <alt/>\n        inline                  </alt>\n        fn twiceUnlessEmpty(x) {\n            return x && [ x, x ];\n        }\n\n        fn main() {\n            return  twiceUnlessEmpty(2)\n                && !twiceUnlessEmpty(0) ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_sseec7v7rjk
                                #define STR_sseec7v7rjk
static const fu::str str_sseec7v7rjk fu_INIT_PRIORITY(1015) { "\n        fn hello(ref str) {\n            str ~= \"world\";\n            <fail condition is void 9:17+1 2:12+5>  <pass/>\n            return str.len & 1;                     </fail>\n        }\n\n        fn main() {\n            mut str = \"hello, \";\n            if (!hello(str)) str ~= \"!\";\n            return str.len - 13;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_lv2KzaPx7Mb
                                #define STR_lv2KzaPx7Mb
static const fu::str str_lv2KzaPx7Mb fu_INIT_PRIORITY(1015) { "\n        fn test(x: i32) {\n            <fail y is not defined 6:24+1>\n            if (x > 1) let y = 20;      <pass/>\n            let y = x > 1 && 20;        </fail>\n\n            return x + y;\n        }\n\n        fn main() test(7) - 27;\n    "_fu };
                                #endif

                                #ifndef STR_W2wJsPI7Orc
                                #define STR_W2wJsPI7Orc
static const fu::str str_W2wJsPI7Orc fu_INIT_PRIORITY(1015) { "\n        fn test(x: i32) {\n            <fail misleading indent 5:13+3>\n            if (x > 1)\n            let y = 20;                 <pass/>\n            let y = x > 1 && 20;        </fail>\n\n            return x + y;\n        }\n\n        fn main() test(7) - 27;\n    "_fu };
                                #endif

                                #ifndef STR_8UfyX8E022e
                                #define STR_8UfyX8E022e
static const fu::str str_8UfyX8E022e fu_INIT_PRIORITY(1015) { "\n        using flags State: u8 { ReadEOF; WriteEOF; WantsRead; WantsWrite }\n\n        fn mustClose(state: State)\n            !!(state & ReadEOF\n                ? state & WriteEOF || !(state & WantsWrite)\n                : state & WantsRead);\n\n        fn main() = State().mustClose.i32;\n    "_fu };
                                #endif

                                #ifndef STR_tDvPFy2YCP0
                                #define STR_tDvPFy2YCP0
static const fu::str str_tDvPFy2YCP0 fu_INIT_PRIORITY(1015) { "\n        struct State { v: u8 };\n\n        let ReadEOF     = State(1);\n        let WriteEOF    = State(2);\n        let WantsRead   = State(4);\n        let WantsWrite  = State(8);\n\n        infix fn &(a: State, b: State) State(a.v & b.v);\n\n        fn mustClose(state: State)\n            !!(state & ReadEOF\n                ? state & WriteEOF || !(state & WantsWrite)\n                : state & WantsRead);\n\n        fn main() = State().mustClose.i32;\n    "_fu };
                                #endif

                                #ifndef STR_MOjORdaaAnl
                                #define STR_MOjORdaaAnl
static const fu::str str_MOjORdaaAnl fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut match: int;\n\n            fn and_brokenInference(my_int): int {\n                return my_int > 0\n                    && { indir_rec_inner(my_int.uint); true }\n                    && match;\n            }\n\n            fn indir_rec_inner(my_uint: uint) {\n                match = my_uint > 0 && and_brokenInference(my_uint - 1);\n            }\n\n            fn indir_rec(my_uint: uint) {\n                indir_rec_inner(my_uint);\n            }\n\n            return and_brokenInference(3);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_EqbJPTaEFn0
                                #define STR_EqbJPTaEFn0
static const fu::str str_EqbJPTaEFn0 fu_INIT_PRIORITY(1015) { "\n        nocopy struct NC { items: NC[]; }\n\n        noinline fn silly_ctz(x: u32) {\n            for (mut i: u32 = 0; i < 32; i++)\n                if (x & (1 << i))\n                    return i.int;\n\n            return 32;\n        }\n\n        inline fn max_probes(index: NC[])\n            index.len && index[0] && silly_ctz(index.len.uint).int\n\n        noinline fn either(a: NC[], b: NC[]) a || b;            ;; ConstCast\n        fn main() max_probes(either([], [ NC([ NC() ]), NC() ])) - 1;\n    "_fu };
                                #endif

                                #ifndef STR_YshiuNEQ9Y0
                                #define STR_YshiuNEQ9Y0
static const fu::str str_YshiuNEQ9Y0 fu_INIT_PRIORITY(1015) { "\n        fn grow_if_oob(ref a: _[], i: i32) {\n            if (a.len <= i) a.grow(i + 1);\n            return a[i];\n        }\n\n        fn init !T(ref a: T[], i: i32, mut v: T) {\n            (a.grow_if_oob(i) && { return false; }) = v;        ;; GNUStmtExpr\n            return true;\n        }\n\n        fn main() {\n            mut hello = [ 1, 2, 3 ];\n            let a = hello.init(2, 30);\n            let b = hello.init(3, 40);\n            mut sum = 0;\n            for (mut i = 0; i < hello.len; i++) sum += hello[i];\n            return !a && b && sum == 46 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_7O0waSDwiDc
                                #define STR_7O0waSDwiDc
static const fu::str str_7O0waSDwiDc fu_INIT_PRIORITY(1015) { "\n        fn either(a: string, b: string) // dont copy before either branch taken\n            a || \"Hello, \" ~ b ~ \"!\";   ;; EXPECT return a ? fu::str(a) :\n    "_fu };
                                #endif

                                #ifndef STR_DTlmAaSG8Zc
                                #define STR_DTlmAaSG8Zc
static const fu::str str_DTlmAaSG8Zc fu_INIT_PRIORITY(1015) { "\n        import _0;\n        fn main() either(either(\"\", \"World\"), \"\") == \"Hello, World!\" ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_YfFHDPDtSE8
                                #define STR_YfFHDPDtSE8
static const fu::str str_YfFHDPDtSE8 fu_INIT_PRIORITY(1015) { "\n        mut i = 7;\n        i ||= 11;\n        return i - 7;\n    "_fu };
                                #endif

                                #ifndef STR_WTIvJmFmE80
                                #define STR_WTIvJmFmE80
static const fu::str str_WTIvJmFmE80 fu_INIT_PRIORITY(1015) { "\n        mut i = 0;\n        i ||= 11;\n        return i - 11;\n    "_fu };
                                #endif

                                #ifndef STR_XIIK1e1qIe4
                                #define STR_XIIK1e1qIe4
static const fu::str str_XIIK1e1qIe4 fu_INIT_PRIORITY(1015) { "\n        mut a = 1;\n        mut b = 0;\n        a ||= ++b;\n        return  b;\n    "_fu };
                                #endif

                                #ifndef STR_ur1bbemEqwd
                                #define STR_ur1bbemEqwd
static const fu::str str_ur1bbemEqwd fu_INIT_PRIORITY(1015) { "\n        mut CHANGE = false;\n        CHANGE ||= true;\n        return CHANGE.i32 - 1;\n    "_fu };
                                #endif

                                #ifndef STR_xwqTz633eVl
                                #define STR_xwqTz633eVl
static const fu::str str_xwqTz633eVl fu_INIT_PRIORITY(1015) { "\n        mut m: Map(string, string);\n        mut g = 0;\n\n        m[\"hello\"] = \"world\";\n        fn f() {\n            g++;\n            return \"cruel world\";\n        }\n\n        m[\"hello\"] ||= f();\n        return g;\n    "_fu };
                                #endif

                                #ifndef STR_dO8E494jT9l
                                #define STR_dO8E494jT9l
static const fu::str str_dO8E494jT9l fu_INIT_PRIORITY(1015) { "\n        mut m: Map(string, string);\n        mut g = 0;\n\n        m[\"_not_hello_\"] = \"world\";\n        fn f() {\n            g++;\n            return \"cruel world\";\n        }\n\n        m[\"hello\"] ||= f();\n        return g - 1;\n    "_fu };
                                #endif

                                #ifndef STR_7iXyrWEHuqi
                                #define STR_7iXyrWEHuqi
static const fu::str str_7iXyrWEHuqi fu_INIT_PRIORITY(1015) { "\n        fn and_incr(ref x: i32, v: i32)\n            x &&= x + v;\n\n        fn main() {\n            mut x: i32 = 0;\n            and_incr(x, 10);\n            return x;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_fdtSYNgZ7ri
                                #define STR_fdtSYNgZ7ri
static const fu::str str_fdtSYNgZ7ri fu_INIT_PRIORITY(1015) { "\n        struct Test { x: i32; }\n        fn test(ref t: Test) t.x++;\n        mut t = Test();\n        <fail orphan call () 9:9+1>\n        t.test;             <pass/>\n        t.test();           </fail>\n        return t.x - 1;\n    "_fu };
                                #endif

                                #ifndef STR_DRwbmXUWkHl
                                #define STR_DRwbmXUWkHl
static const fu::str str_DRwbmXUWkHl fu_INIT_PRIORITY(1015) { "\n        {\n            {\n                return 0;\n            }\n        }\n    "_fu };
                                #endif

                                #ifndef STR_BFKa8WMJDob
                                #define STR_BFKa8WMJDob
static const fu::str str_BFKa8WMJDob fu_INIT_PRIORITY(1015) { "\n        {\n        <fail block>\n        {\n            return 0;\n        }\n        <pass/>\n            {\n                return 0;\n            }\n        </fail>\n        }\n    "_fu };
                                #endif

                                #ifndef STR_eiUwpjkJfl4
                                #define STR_eiUwpjkJfl4
static const fu::str str_eiUwpjkJfl4 fu_INIT_PRIORITY(1015) { "\n        {\n            return 0;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_SnScbuuo7e7
                                #define STR_SnScbuuo7e7
static const fu::str str_SnScbuuo7e7 fu_INIT_PRIORITY(1015) { "\n        {\n            return 0;\n        <fail block>\n       }\n        <pass/>\n        }\n        </fail>\n    "_fu };
                                #endif

                                #ifndef STR_klRBwTVqJz2
                                #define STR_klRBwTVqJz2
static const fu::str str_klRBwTVqJz2 fu_INIT_PRIORITY(1015) { "\n        {\n            return 0;\n        <fail block>\n         }\n        <pass/>\n        }\n        </fail>\n    "_fu };
                                #endif

                                #ifndef STR_Um3bUHKTMbe
                                #define STR_Um3bUHKTMbe
static const fu::str str_Um3bUHKTMbe fu_INIT_PRIORITY(1015) { "\n        let y = [ 1 ];              ;; TODO fu::slate<1, int> y\n        let <fail unused><pass/>lax</fail>\n            z = [ 2 ];              ;; TODO fu::slate<1, int> z\n\n        return y[0] - 1\n    "_fu };
                                #endif

                                #ifndef STR_djULcnFW6Gh
                                #define STR_djULcnFW6Gh
static const fu::str str_djULcnFW6Gh fu_INIT_PRIORITY(1015) { "\n        fn fail(a: string) throw(\"hey: \" ~ a);\n        fn hello(a: string,\n            <fail unused><pass/>lax</fail>\n            b: string)\n                a && fail(a) ? b : a;\n\n        fn main() hello(\"\", \"nope\").len;\n    "_fu };
                                #endif

                                #ifndef STR_HVYN9NaXKZa
                                #define STR_HVYN9NaXKZa
static const fu::str str_HVYN9NaXKZa fu_INIT_PRIORITY(1015) { "\n        fn incr(ref x: i32) x++;\n        fn lints_ambig_expr_indent(ref a: i32, ref b: i32) {\n            return a.incr\n            <fail indent>\n            +\n            <pass/>\n              +\n            </fail>\n                b.incr;\n        }\n\n        fn main() {\n            mut a = 0; mut b = 0;\n            lints_ambig_expr_indent(a, b);\n            return a - b;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_AIFkvGpL8c6
                                #define STR_AIFkvGpL8c6
static const fu::str str_AIFkvGpL8c6 fu_INIT_PRIORITY(1015) { "\n        fn lints_ambig_jump_semis(mut x: i32) {\n            <fail indent>\n            return\n            x;\n            <pass/>\n            return x;\n            </fail>\n        }\n\n        fn main() 0.lints_ambig_jump_semis;\n    "_fu };
                                #endif

                                #ifndef STR_g8AmOijSlef
                                #define STR_g8AmOijSlef
static const fu::str str_g8AmOijSlef fu_INIT_PRIORITY(1015) { "\n        fn incr(ref a: i32) ++a;\n        fn A(ref a: i32) a || <fail parenthes left side>\n                              a = A(incr(a));    <pass/> // Lint should complain here,\n                             (a = A(incr(a)));   </fail> //  this was an honest mistake.\n\n        fn main() { mut v = 0; return A(v) - 1; }\n    "_fu };
                                #endif

                                #ifndef STR_tF9BfWR3fr8
                                #define STR_tF9BfWR3fr8
static const fu::str str_tF9BfWR3fr8 fu_INIT_PRIORITY(1015) { "\n        fn test(is_mutref: bool, args: i32[], ref sum: i32) {\n            <fail indent else>\n            if (is_mutref)\n                for (mut i = 0; i < args.len; i++)\n                    if (args[i] & 1)\n                        sum += args[i];\n            <pass/>\n            if (is_mutref) {\n                for (mut i = 0; i < args.len; i++)\n                    if (args[i] & 1)\n                        sum += args[i];\n            }\n            </fail>\n            else\n                for (mut i = 0; i < args.len; i++)\n                    if (args[i] & 2)\n                        sum += args[i];\n        }\n\n        fn main() {\n            mut sum = 0;\n            test(true , [ 1,  2,  3  ], sum);\n            test(false, [ 11, 22, 33 ], sum);\n            return sum - 1 - 3 - 11 - 22;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_ecT9BI9Znt6
                                #define STR_ecT9BI9Znt6
static const fu::str str_ecT9BI9Znt6 fu_INIT_PRIORITY(1015) { "\n        //\n        // The -1.abs problem.\n        //\n        // Ruby lexes the minus into the numeric literal.\n        //  This is kinda inconsistent, altough it does make sense.\n        //\n        // Rust & all c-likes lex to -abs(1).\n        //  Rust linters warn about this.\n        //\n        // One thing we can do is change the precedence of some unaries\n        //  to above method call - others, like ! benefit from usual precedence.\n        //   In my experience, the unary * op in c/cpp always disappoints re: precedence,\n        //    but the & op usually works the way you want it to.\n        //     So introducing more precedence rules is a really questionable idea.\n        //\n        // We'll go the rust way for starters,\n        //  this will be a compile time error for now.\n        //\n        fn test()   <fail parenthes explicit>\n            -1.0    <pass/>\n            (-1.0)  </fail>\n                .abs;\n\n        fn main() test ? 0 : 7;\n    "_fu };
                                #endif

                                #ifndef STR_Hscug6rbDla
                                #define STR_Hscug6rbDla
static const fu::str str_Hscug6rbDla fu_INIT_PRIORITY(1015) { "\n        fn id(x) = x;\n        fn main() {\n            return id(\n                0 +\n            <fail ambig indent>\n               0  <pass/>\n                0 </fail>\n            );\n        }\n    "_fu };
                                #endif

                                #ifndef STR_eydOPEBfKj1
                                #define STR_eydOPEBfKj1
static const fu::str str_eydOPEBfKj1 fu_INIT_PRIORITY(1015) { "\n        fn doStuff(stuff) {\n            stuff();\n        }\n\n        fn main() {\n            doStuff(\n                <alt>\n                stuff: |_?| {\n                <alt/>\n                stuff: |_?|\n                {\n                <alt/>\n                stuff: |\n                    _?| {\n                <alt/>\n                stuff: |\n                    _?|\n                {\n                </alt>\n                    return 0;\n                });\n        }\n    "_fu };
                                #endif

                                #ifndef STR_qb1yHn5kQZ2
                                #define STR_qb1yHn5kQZ2
static const fu::str str_qb1yHn5kQZ2 fu_INIT_PRIORITY(1015) { "\n        fn doStuff(stuff) {\n            stuff();\n        }\n\n        fn main() {\n            <alt>\n            doStuff(stuff: || {\n            <alt/>\n            doStuff(stuff: ||\n                {\n            </alt>\n                    return 0;\n                });\n        }\n    "_fu };
                                #endif

                                #ifndef STR_82KJ9geMHkg
                                #define STR_82KJ9geMHkg
static const fu::str str_82KJ9geMHkg fu_INIT_PRIORITY(1015) { "\n        nodiscard primitive Errcode: i32;\n\n        fn try_incr(implicit ref x: i32): Errcode {\n            if (++x > 0) return 10;\n            return 0;\n        }\n\n        fn main() {\n            implicit mut x = -1;\n        <fail nodiscard Errcode return try_incr (13:13+8|14:13+8)>\n            try_incr();\n            try_incr();\n            return x - 1;\n        <pass/>\n            shadow let err = try_incr() || try_incr();\n            return err.i32 + x - 11;\n        </fail>\n        }\n    "_fu };
                                #endif

                                #ifndef STR_1eTW176MsZf
                                #define STR_1eTW176MsZf
static const fu::str str_1eTW176MsZf fu_INIT_PRIORITY(1015) { "\n        using flags Flags { F_LAMBDA; F_IMPLICIT }\n        fn precedenceWhitespace(NICEERR_missingReturn: bool)\n        {\n            <fail misleading whitespace 7:18+1 parenthesize>\n            return NICEERR_missingReturn && F_IMPLICIT      <pass/>\n            return (NICEERR_missingReturn && F_IMPLICIT)    </fail>\n                 | F_LAMBDA;\n        }\n\n        fn main() precedenceWhitespace(false) == F_LAMBDA ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_J66srUeRWz3
                                #define STR_J66srUeRWz3
static const fu::str str_J66srUeRWz3 fu_INIT_PRIORITY(1015) { "\n        using flags Flags { F_LAMBDA; F_IMPLICIT }\n        fn precedenceWhitespace(NICEERR_missingReturn: bool)\n        {\n            return F_LAMBDA\n            <fail misleading whitespace 7:18+1 parenthesize>\n                 | NICEERR_missingReturn && F_IMPLICIT;     <pass/>\n                 | (NICEERR_missingReturn && F_IMPLICIT);   </fail>\n        }\n\n        fn main() precedenceWhitespace(false) == F_LAMBDA ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_RX6IaFnghBk
                                #define STR_RX6IaFnghBk
static const fu::str str_RX6IaFnghBk fu_INIT_PRIORITY(1015) { "\n        fn main()              <fail parenthesize 3:25+1>\n                    6-3 * 2    <pass/>\n                    6-(3 * 2)  </fail> ;\n    "_fu };
                                #endif

                                #ifndef STR_6bYwXoF3Vje
                                #define STR_6bYwXoF3Vje
static const fu::str str_6bYwXoF3Vje fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut x = 5;\n            for (mut i = 10; i --> 0; ) {   <fail unparenthesized assignment 5:23+1>\n                if (x = i) {                <pass/>\n                if (x == i) {               </fail>\n                    x += i;\n                    break;\n                }\n            }\n\n            return x - 10;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Fi1DHU0qL3e
                                #define STR_Fi1DHU0qL3e
static const fu::str str_Fi1DHU0qL3e fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut total = 100;\n            for (mut i = 0; i < total; i++) {\n                if (i & 1) continue;\n                total-- // no semi\n            }\n\n            return total - 66\n        }\n    "_fu };
                                #endif

                                #ifndef STR_g2xJfeY7Bc2
                                #define STR_g2xJfeY7Bc2
static const fu::str str_g2xJfeY7Bc2 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut total = 100;\n            for (mut i = 0; i < total; i++) {\n                if (i & 1) continue;\n                if (i & 3) continue <fail bad jump expression expects void, got i32>i<pass/></fail>;\n                total--; // no semi\n            }\n\n            return total - 80\n        }\n    "_fu };
                                #endif

                                #ifndef STR_crlS0Mew724
                                #define STR_crlS0Mew724
static const fu::str str_crlS0Mew724 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut total = 100;\n            fn iteration(i: int) {\n                if (i & 1) return;\n                total-- //fail subseq return no common supertype void i32 6:22+2><pass/>;</fail>\n            }\n\n            for (mut i = 0; i < total; i++) iteration(i);\n            return total - 66\n        }\n    "_fu };
                                #endif

                                #ifndef STR_z8uLIH7OiGd
                                #define STR_z8uLIH7OiGd
static const fu::str str_z8uLIH7OiGd fu_INIT_PRIORITY(1015) { "\n        fn for(<alt>const </alt>ref n: int, what) for (mut i = 0; i < n; i++) what(i);\n\n        fn main(): i32 {\n            mut total = 100;\n            total.for: |i| {            <fail main: return type does not match annot i32, got void 7:28+6>\n                if (i & 1) return;      <pass/>\n                if (i & 1) continue;    </fail>\n                total--\n            };\n\n            return total - 66\n        }\n    "_fu };
                                #endif

                                #ifndef STR_eksbrMjHXQj
                                #define STR_eksbrMjHXQj
static const fu::str str_eksbrMjHXQj fu_INIT_PRIORITY(1015) { "\n        noinline fn test(ref a: i32, ref b: i32) {\n            return (++a) + 10 * (++b);                          ;; N_AARMustSeq\n        }\n\n        fn main() {                                             ;; N_AARSoftRisk\n            mut x = 0;\n        <alt>\n            let z = test(x, x);\n        <alt/>\n            ref y = x;\n            let z = test(x, y);\n        </alt>\n            return x == 2 && z == 21 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_bVqcDaJNIq7
                                #define STR_bVqcDaJNIq7
static const fu::str str_bVqcDaJNIq7 fu_INIT_PRIORITY(1015) { "\n        noinline fn test_inner(ref a: i32, ref b: i32)\n            (++a) + 10 * (++b);                                 ;; N_AARMustSeq\n\n        noinline fn test_outer(ref a: i32, ref b: i32)\n            test_inner(a, b);\n\n        fn main() {                                             ;; N_AARSoftRisk\n            mut x = 0;\n        <alt>\n            let z = test_outer(x, x);\n        <alt/>\n            ref y = x;\n            let z = test_outer(x, y);\n        </alt>\n            return x == 2 && z == 21 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_0E9DX5mh2g5
                                #define STR_0E9DX5mh2g5
static const fu::str str_0E9DX5mh2g5 fu_INIT_PRIORITY(1015) { "\n        noinline fn test(ref a: i32[]) {\n            ref b = a[0];\n            if (a.len & 1) {\n                <fail invalidate 9:13 6:19>\n                a ~= 1; // Invalidates 'b'.\n                <pass/>\n                b++;\n                </fail>\n            }\n            b++;\n        }\n\n        fn main() {\n            mut arr = [ 1 ]; test(arr);\n            mut sum = 0;\n            for (mut i = 0; i < arr.len; i++) sum += arr[i];\n            return sum - 3;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_dJ2hCXHqoH9
                                #define STR_dJ2hCXHqoH9
static const fu::str str_dJ2hCXHqoH9 fu_INIT_PRIORITY(1015) { "\n        nocopy struct nci32 { i: i32; };\n\n        noinline fn test(ref a: nci32, b: nci32) a.i++ || b.i;\n        fn main() {\n            mut x = nci32(0);\n            <fail arguments b and a both alias mut x 6:17+1>\n            ref y = x;                        <pass/>\n            let y = nci32(0);                 </fail>\n\n            return test(x, y);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_TYEtinCvsN6
                                #define STR_TYEtinCvsN6
static const fu::str str_TYEtinCvsN6 fu_INIT_PRIORITY(1015) { "\n        noinline fn test(ref a: i32[]) {\n            ref b = a[0];\n            if (a.len & 1) { // Lets be extra sure here.\n                <fail invalidate 7:17 6:19>\n                a ~= 1; // Invalidates 'b'.\n                b++;\n                <pass/>\n                b++;\n                a ~= 1;\n                </fail>\n            }\n        }\n\n        fn main() {\n            mut arr = [ 1 ]; test(arr);\n            mut sum = 0;\n            for (mut i = 0; i < arr.len; i++) sum += arr[i];\n            return sum - 3;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_wh4Og3s07ib
                                #define STR_wh4Og3s07ib
static const fu::str str_wh4Og3s07ib fu_INIT_PRIORITY(1015) { "\n        noinline fn test(ref a: i32[]) {\n            ref b = a[0];\n            for (mut i = 2; i --> 0; )\n            {\n                b++; // Same thing but reordered as a loop.\n                if (a.len & 3) {\n                    <fail inval next iter 9:23 6:17>\n                    a ~= 1; // Invalidates 'b'.\n                    <pass/>\n                    b++;\n                    </fail>\n                }\n            }\n            a ~= 100; // Invalidates 'b' but that's fine!\n        }\n\n        fn main() {\n            mut arr = [ 1 ]; test(arr);\n            mut sum = 0;\n            for (mut i = 0; i < arr.len; i++) sum += arr[i];\n            return sum - 105;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_sUh5jygOo64
                                #define STR_sUh5jygOo64
static const fu::str str_sUh5jygOo64 fu_INIT_PRIORITY(1015) { "\n        noinline fn test(ref a: i32[]) {\n            ref b = a[0];\n            for (mut i = 2; i --> 0; )\n            {\n                if (i & 1) {\n                    b += 2; // Same thing but reordered as a loop.\n                }\n                else {\n                    <fail inval next iter 11:23 7:21>\n                    a ~= 1; // Invalidates 'b', same as a above, but now in an if/else -\n                    <pass/> //  got the used-in-a-loop stuff wrong when switching to cant_invalidate.\n                    b += 3;\n                    </fail>\n                }\n            }\n            a ~= 100; // Invalidates 'b' but that's fine!\n        }\n\n        fn main() {\n            mut arr = [ 1 ]; test(arr);\n            mut sum = 0;\n            for (mut i = 0; i < arr.len; i++) sum += arr[i];\n            return sum - 106;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_8RQQYUiveF9
                                #define STR_8RQQYUiveF9
static const fu::str str_8RQQYUiveF9 fu_INIT_PRIORITY(1015) { "\n        // both args alias, but there's no risk of inval.\n        noinline fn incr_a_or_b(ref a: i32, ref b: i32)\n            (a || b)++;\n\n        fn main() {\n            mut Z = 0;\n            mut A = 1;\n            mut B = 0;\n\n            incr_a_or_b(Z, B); // incr B, now 1\n            incr_a_or_b(A, B); // incr A, now 2\n            incr_a_or_b(B, B); // incr _target, now 2 // alias!\n\n            return (100*A + B) - 202;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_lqbsvROjIpe
                                #define STR_lqbsvROjIpe
static const fu::str str_lqbsvROjIpe fu_INIT_PRIORITY(1015) { "\n        struct V { v: i32; };\n\n        fn main() {\n            mut A: V = [ 1 ];\n            ref a = A.v;\n            ref b = A.v;\n            ref c = a || b;\n            return ++++c - 3; // double mutation of a union\n        }\n    "_fu };
                                #endif

                                #ifndef STR_bLZdNb0horl
                                #define STR_bLZdNb0horl
static const fu::str str_bLZdNb0horl fu_INIT_PRIORITY(1015) { "\n        struct V { v: i32; };\n\n        fn main() {\n            mut A: V = [ 1 ];\n            ref a = A.v;\n            ref b = A.v;\n            return ++++(a || b) - 3; // same, without a helper var\n        }\n    "_fu };
                                #endif

                                #ifndef STR_l8AEL6TqHy1
                                #define STR_l8AEL6TqHy1
static const fu::str str_l8AEL6TqHy1 fu_INIT_PRIORITY(1015) { "\n        struct V { v: i32; w?: i32; ww?: i32; };\n\n        fn main() {\n            mut A: V = [ 1 ];\n            mut B: V = [ 1 ];\n\n            <fail invalidate 20:20 18:15>\n            ref aa = A.v || A.w; <pass/>\n            fn  aa = A.v || A.w; </fail>\n\n            ref bb = B.v || B.w;\n            ++++bb;\n\n            ref a = A.v || A.ww;\n            ref b = B.v || B.ww;\n\n            ref c = a || b;\n            ++++c;\n\n            return aa - 3; // same, without a helper var\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Q0KJQbm3kw3
                                #define STR_Q0KJQbm3kw3
static const fu::str str_Q0KJQbm3kw3 fu_INIT_PRIORITY(1015) { "\n        // a can alias b\n        // c can alias d\n        noinline fn ab_cd(ref a: i32, ref b: i32, ref c: i32, ref d: i32) {\n            ref ab = a || b;\n            ref cd = c || d;\n            ++++ab;\n            ++++cd;\n        }\n\n        fn main() {\n            mut ab = 0;\n            mut cd = 0;\n\n            <fail alias>\n            ab_cd(ab, cd, ab, cd); <pass/>\n            ab_cd(ab, ab, cd, cd); </fail>\n\n            return ab - cd;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Jr57XGWeqH9
                                #define STR_Jr57XGWeqH9
static const fu::str str_Jr57XGWeqH9 fu_INIT_PRIORITY(1015) { "\n        struct X { i: i32; j: i32; };\n        // a can alias b\n        // c can alias d\n        noinline fn ab_cd_defer(ref a: X, ref b: X, ref c: X, ref d: X, j?: bool) {\n            ref ab = a || b;\n            defer {\n                ref abi = j ? ab.j : ab.i;\n                ++++abi;\n            }\n            ref cd = c || d;\n            ref cdi = j ? cd.j : cd.i;\n            ++++cdi;\n        }\n\n        fn main() {\n            mut ab = X(0, 0);\n            mut cd = X(0, 0);\n\n            <fail alias>\n            ab_cd_defer(ab, cd, ab, cd); <pass/>\n            ab_cd_defer(ab, ab, cd, cd); </fail>\n\n            return ab.i - cd.i;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_3ckcyNDBZb9
                                #define STR_3ckcyNDBZb9
static const fu::str str_3ckcyNDBZb9 fu_INIT_PRIORITY(1015) { "\n        // a can alias b\n        // c can alias d\n        noinline fn ab_cd_inner(ref a: i32, ref b: i32, ref c: i32, ref d: i32) {\n            ref ab = a || b;\n            ref cd = c || d;\n            ++++ab;\n            ++++cd;\n        }\n\n        noinline fn ab_cd_outer(ref a: i32, ref b: i32, ref c: i32, ref d: i32)\n            ab_cd_inner(a, b, c, d);\n\n        fn main() {\n            mut ab = 0;\n            mut cd = 0;\n\n            <fail alias>\n            ab_cd_outer(ab, cd, ab, cd); <pass/>\n            ab_cd_outer(ab, ab, cd, cd); </fail>\n\n            return ab - cd;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_aZa4IHN6Qna
                                #define STR_aZa4IHN6Qna
static const fu::str str_aZa4IHN6Qna fu_INIT_PRIORITY(1015) { "\n        // a can alias b\n        // c can alias d\n        // e can alias f\n        // g can alias h\n        noinline fn abcd_efgh(\n            ref a: i32, ref b: i32, ref c: i32, ref d: i32,\n            ref e: i32, ref f: i32, ref g: i32, ref h: i32)\n        {\n            ref ab = a || b; ref cd = c || d; ref abcd = ab || cd;\n            ref ef = e || f; ref gh = g || h; ref efgh = ef || gh;\n            ++++abcd; ++++ab; ++++cd;\n            ++++efgh; ++++ef; ++++gh;\n        }\n\n        fn main() {\n            mut ab = 0; mut cd = 0;\n            mut ef = 0; mut gh = 0;\n\n            <fail alias mut cd 17:29+2>\n            abcd_efgh(ab, ab, cd, gh, ef, ef, cd, gh); <pass/>\n            abcd_efgh(ab, ab, cd, cd, ef, ef, gh, gh); </fail>\n\n            return (ab + cd) - (ef + gh);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Ks9lRjj1ey2
                                #define STR_Ks9lRjj1ey2
static const fu::str str_Ks9lRjj1ey2 fu_INIT_PRIORITY(1015) { "\n        noinline fn incr_a_or_b_and_b_or_a(ref a: i32, ref b: i32) {\n            ref x = a || b; ++x;\n            ref y = b || a; ++y;                                ;; N_AARSoftRisk\n        }\n\n        fn main() {\n            mut a = 0;\n\n            <alt>\n            incr_a_or_b_and_b_or_a(a, a);\n            <alt/>\n            ref b = a;\n            incr_a_or_b_and_b_or_a(a, b);\n            </alt>\n\n            return a - 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_QGl2kvLVc4j
                                #define STR_QGl2kvLVc4j
static const fu::str str_QGl2kvLVc4j fu_INIT_PRIORITY(1015) { "\n        // same as below -\n        //  but using a helper variable\n        //   which provides a \"name\" for the outcome of a|b.\n        noinline fn incr_a_or_b_by2_via_x(ref a: i32, ref b: i32) {\n            ref x = a || b;\n            ++++x;\n        }\n\n        fn main() {\n            mut Z = 0;\n            mut A = 2;\n            mut B = 0;\n\n            incr_a_or_b_by2_via_x(Z, B); // incr B, now 2\n            incr_a_or_b_by2_via_x(A, B); // incr A, now 4\n            incr_a_or_b_by2_via_x(B, B); // incr _target, now 4 // alias!\n\n            return (100*A + B) - 404;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_WbvoADcs9pd
                                #define STR_WbvoADcs9pd
static const fu::str str_WbvoADcs9pd fu_INIT_PRIORITY(1015) { "\n        // same as above -\n        //  but notice we increment twice, which breaks current setup.\n        noinline fn incr_a_or_b_by2(ref a: i32, ref b: i32)\n            ++++(a || b);\n\n        fn main() {\n            mut Z = 0;\n            mut A = 2;\n            mut B = 0;\n\n            incr_a_or_b_by2(Z, B); // incr B, now 2\n            incr_a_or_b_by2(A, B); // incr A, now 4\n            incr_a_or_b_by2(B, B); // incr _target, now 4 // alias!\n\n            return (100*A + B) - 404;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_HyLZx5lUgyj
                                #define STR_HyLZx5lUgyj
static const fu::str str_HyLZx5lUgyj fu_INIT_PRIORITY(1015) { "\n        noinline fn alias(ref arr: i32[], ref item: i32) {\n            arr ~= 1;\n            return item;\n        }\n\n        fn main() {\n            mut a = [ 0 ];\n            <fail alias>\n            ref c = alias(a, a[0]);\n            <pass/>\n            mut b = [ 0 ];\n            ref c = alias(a, b[0]);\n            </fail>\n            return c++;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_JglcmOHnQH2
                                #define STR_JglcmOHnQH2
static const fu::str str_JglcmOHnQH2 fu_INIT_PRIORITY(1015) { "\n        noinline fn test(ref a: i32[], ref b: i32[]) {\n            <fail invalidate 7:28 6:30>\n            ref aa = a[0]; <pass/>\n            fn  aa() a[0]; </fail>\n\n            ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.\n            ref cc = bb || aa;     // Mustn't compile.\n            return cc;\n        }\n\n        fn main() { mut a = [ 0 ]; mut b = [ 0 ]; return test(a, b); }\n    "_fu };
                                #endif

                                #ifndef STR_GIF3ajUTKqb
                                #define STR_GIF3ajUTKqb
static const fu::str str_GIF3ajUTKqb fu_INIT_PRIORITY(1015) { "\n        noinline fn test(ref a: i32[], ref b: i32[]) {\n            <fail invalidate 7:26 6:30>\n            ref aa = a[0]; <pass/>\n            fn  aa() a[0]; </fail>\n\n            ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.\n            return bb || aa;       // Same as above, but no explicit binding.\n        }\n\n        fn main() { mut a = [ 0 ]; mut b = [ 0 ]; return test(a, b); }\n    "_fu };
                                #endif

                                #ifndef STR_11HBVV9lLOf
                                #define STR_11HBVV9lLOf
static const fu::str str_11HBVV9lLOf fu_INIT_PRIORITY(1015) { "\n        noinline fn noop(x) x;\n        noinline fn test(ref a: i32[], ref b: i32[]) {\n            <fail invalidate 8:31 7:30>\n            ref aa = a[0]; <pass/>\n            fn  aa() a[0]; </fail>\n\n            ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.\n            return noop(bb || aa); // Same as above, but bound at callsite.\n        }\n\n        fn main() { mut a = [ 0 ]; mut b = [ 0 ]; return test(a, b); }\n    "_fu };
                                #endif

                                #ifndef STR_M99gVht5uy7
                                #define STR_M99gVht5uy7
static const fu::str str_M99gVht5uy7 fu_INIT_PRIORITY(1015) { "\n        noinline fn either(a, b) a || b;\n        noinline fn test(ref a: i32[], ref b: i32[]) {\n            <fail invalidate 8:31 7:30>\n            ref aa = a[0]; <pass/>\n            fn aa()  a[0]; </fail>\n\n            ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.\n            return either(bb, aa); // For completeness.\n        }\n\n        fn main() { mut a = [ 0 ]; mut b = [ 0 ]; return test(a, b); }\n    "_fu };
                                #endif

                                #ifndef STR_iVRwMHSEtGl
                                #define STR_iVRwMHSEtGl
static const fu::str str_iVRwMHSEtGl fu_INIT_PRIORITY(1015) { "\n        noinline fn what(ref cond: i32, ref cons: i32)\n            cond && (cons += 1);\n\n        fn main() {\n            mut x = 1;\n            return what(x, x) - 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_cuTxap0V8xk
                                #define STR_cuTxap0V8xk
static const fu::str str_cuTxap0V8xk fu_INIT_PRIORITY(1015) { "\n        struct Target {\n            overload: i32[];\n            extended: i32[];\n        };\n\n        noinline fn which(ref t: Target, i: i32) i & 1\n            ? t.overload\n            : t.extended;\n\n        fn test(ref target: Target) {\n            ref overload = target.which(target.overload.len);\n            ref extended = target.which(target.overload.len + 1);\n\n            mut change = false;\n            if (overload) {\n                for (mut i = 0; i < overload.len; i++) {\n                    let a = overload[i];\n                    let b = extended[i];\n                    if (a != b) {\n                        change = true;\n                        break;\n                    }\n                }\n            }\n\n            if (change) {\n                extended[0] = 3;\n\n                shadow ref overload = target.which(target.overload.len);\n                overload[0] = 5; // Said write to overload invalidates ext on next loop iter.\n            }\n        }\n\n        fn main() {\n            mut target = Target([ 0 ], [ 1 ]);\n            target.test();\n            return target.overload[0] * 10 + target.extended[0] * 100 - 350;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_GLatQIzftql
                                #define STR_GLatQIzftql
static const fu::str str_GLatQIzftql fu_INIT_PRIORITY(1015) { "\n        fn test(ref a: i32, ref b: i32) {\n            a += b;\n            b += a;\n        }\n\n        struct AB { a: i32; b: i32 };\n\n        fn main() {\n            mut ab = AB(1, 2);\n<fail test:a test:b both alias ab 16:21+1>\n        <alt>\n            ref a = ab.a;\n            ref b = ab.a;\n        <alt/>\n            ref a = ab.b;\n            ref b = ab.b;\n        </alt>\n            test(a, b);\n<pass/>\n        <alt>\n            ref a = ab.a;\n            ref b = ab.b;\n            test(a, b);\n        <alt/>\n            ref a = ab.a;\n            test(a, ab.b);\n        <alt/>\n            test(ab.a, ab.b);\n        </alt>\n</fail>\n            return ab.b - 5;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_LIyMZPSX0Z4
                                #define STR_LIyMZPSX0Z4
static const fu::str str_LIyMZPSX0Z4 fu_INIT_PRIORITY(1015) { "\n        struct Helper { vars: i32[]; };\n\n        fn test(ref _helpers: Helper[], helpers_idx: i32) {\n            ref old = _helpers[helpers_idx - 1].vars;\n            ref new = _helpers[helpers_idx    ].vars;\n            new    ~= old[helpers_idx];\n        }\n\n        fn main() {\n            mut helpers = [ Helpers([ 1, 2 ]), Helpers([ 4, 8 ]) ];\n            test(helpers, 1);\n            return helpers[1][2] - 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_DD9tKgbERtj
                                #define STR_DD9tKgbERtj
static const fu::str str_DD9tKgbERtj fu_INIT_PRIORITY(1015) { "ref old 7:23+3"_fu };
                                #endif

                                #ifndef STR_VZYkDdTYrwa
                                #define STR_VZYkDdTYrwa
static const fu::str str_VZYkDdTYrwa fu_INIT_PRIORITY(1015) { "\n        fn outer() {\n            mut sum = 0;\n            mut x = 1;\n            for (;;) {      // bck complained that the write to 'x' at the end\n                let v = x;  //  invalidates use of 'v' on next loop iter here, which is not true\n                for (mut i = 0; i < 10; i++) {\n                    sum += v;\n                    if (sum > 40)\n                        return sum;\n                }\n\n                x = v * 2;\n            }\n        }\n\n        fn main() outer - 42;\n    "_fu };
                                #endif

                                #ifndef STR_U892qezW07a
                                #define STR_U892qezW07a
static const fu::str str_U892qezW07a fu_INIT_PRIORITY(1015) { "\n        fn append_self(ref a: i32[]) {\n            let b = a;\n            a ~= b; // b narrowed down to a slice which is non-copyable\n                    //  but it (unfortunately) wanted to copy to a temp.\n        }\n\n        fn main() {\n            mut arr = [1, 2];\n            arr.append_self();\n            return arr[2] + arr[3] - 3;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_W0HDjpcW0o8
                                #define STR_W0HDjpcW0o8
static const fu::str str_W0HDjpcW0o8 fu_INIT_PRIORITY(1015) { "\n        <fail invalid annotation not a fn decl 3:9+4>\n        pure <pass/></fail>\n        struct X { x: i32 };\n        fn main() X(0).x;\n    "_fu };
                                #endif

                                #ifndef STR_R9mQlLnjNri
                                #define STR_R9mQlLnjNri
static const fu::str str_R9mQlLnjNri fu_INIT_PRIORITY(1015) { "\n        fn but_is_it_pure(ref x: i32) {\n            <fail not pure 6:9+4 writes to (a|b) (6:38+1|6:50+1) 8:20+14 4:21+2>\n            return x++; <pass/>\n            return x;   </fail>\n        }\n        pure <alt>  inline<alt/>noinline</alt> fn pure_fn(ref a: i32, ref b: i32) {\n            ref x = a || b;\n            return but_is_it_pure(x);\n        }\n        fn main() {\n            mut x = 0;\n            mut y = 0;\n            return pure_fn(x, y);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_i9gqlzlD4c7
                                #define STR_i9gqlzlD4c7
static const fu::str str_i9gqlzlD4c7 fu_INIT_PRIORITY(1015) { "\n        struct Map { index: int[]; data: int[] }\n\n        pure fn Verify(ref map: Map) {\n            mut count = 0\n            for (mut i = 0; i < map.index.len; i++) {\n                <fail Verify not pure 4:9+4 writes to ref arg map (8:41+1|10:30+1)>\n                ref<pass/>\n                mut</fail> data_pos = map.index[i]\n                while (data_pos > 0 && data_pos <= map.data.len) {\n                    data_pos = map.data[data_pos - 1]\n                    count++\n                }\n            }\n\n            return count\n        }\n\n        fn main() { mut m: Map; m.Verify }\n    "_fu };
                                #endif

                                #ifndef STR_fV1buoCgdzk
                                #define STR_fV1buoCgdzk
static const fu::str str_fV1buoCgdzk fu_INIT_PRIORITY(1015) { "\n        noinline fn inner(ref x: i32, n: i32) {\n            return outer(x, n);\n        }\n\n        noinline fn report_write_here(ref x: i32, n: i32) {\n            <fail outer 24:20+5 report_write_here 16:28+17 += 8:22+2>\n            return x += n;                             <pass/>\n            return x + n;                              </fail>\n        }\n\n        noinline fn outer(ref x: i32, n: i32) {\n            if (n & 3) {\n                if (n & 2)\n                    return inner(x, n / 2);\n                else\n                    return report_write_here(x, n);\n            }\n            else {\n                return inner(x, n + 1);\n            }\n        }\n\n        pure fn not_pure(ref x: i32, n: i32) {\n            return outer(x, n);\n        }\n\n        fn main() {\n            mut x = 0;\n            return not_pure(x, 0) == 1 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_7tOpRfOR61e
                                #define STR_7tOpRfOR61e
static const fu::str str_7tOpRfOR61e fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut _info: string[];\n\n            pure fn fail(mut reason: string = \"\") {\n                for (mut i = _info.len; i --> 0; ) {\n                    ref info = _info[i]; // notice the ref, has to relax away\n                    reason ~= info<alt> && i<alt/> ? i : []</alt>;\n                }\n\n                return reason;\n            }\n\n            return fail.len;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_TWCZ1aJKESk
                                #define STR_TWCZ1aJKESk
static const fu::str str_TWCZ1aJKESk fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut _info = [ 101 ];\n\n            pure fn fail(mut reason: string = \"\") {\n                ref info = _info[0]; // <- notice the ref, has to relax away\n                reason ~= info<alt> && (\"\" ~ info)<alt/> ? (\"\" ~ info) : []</alt>;\n                return reason;\n            }\n\n            return fail.len - 3; // \"101\".len is 3.\n        }\n    "_fu };
                                #endif

                                #ifndef STR_QHdcOBxDM8a
                                #define STR_QHdcOBxDM8a
static const fu::str str_QHdcOBxDM8a fu_INIT_PRIORITY(1015) { "\n        struct Helpers { row: i32[]; };\n\n        fn test(ref _helpers: Helpers[], mut N: i32, row: i32)\n        {\n            fn solveNode_H(h: Helpers) {\n                while (N % h.row[h.row.len - 1]) {\n                    N--;\n                    _helpers.grow(_helpers.len * 2);\n                }\n            }\n\n            fn solveJump() {\n                solveNode_H(_helpers[row]);\n                return _helpers.len;\n            }\n\n            return solveJump() - 1 * 2*2*2*2;\n        }\n\n        fn main()\n        {\n            mut _helpers = [ Helpers([ 1, 2, 3, 4, 5 ]) ];\n            return test(_helpers, row: 0, N: 4)\n        }\n    "_fu };
                                #endif

                                #ifndef STR_XHrxKqaMW81
                                #define STR_XHrxKqaMW81
static const fu::str str_XHrxKqaMW81 fu_INIT_PRIORITY(1015) { "\n        struct Helpers { row: i32[]; };\n\n        fn test(ref _helpers: Helpers[], mut N: i32, row: i32)\n        {\n            fn solveNode_HH_inner(h: Helpers) {\n                while (N % h.row[h.row.len - 1]) {\n                    N--;\n                    _helpers.grow(_helpers.len * 2);\n                }\n            }\n\n            fn solveNode_HH(h: Helpers) {\n                return solveNode_HH_inner(h);\n            }\n\n            fn solveJump() {\n                solveNode_HH(_helpers[row]);\n                return _helpers.len;\n            }\n\n            return solveJump() - 1 * 2*2*2*2;\n        }\n\n        fn main()\n        {\n            mut _helpers = [ Helpers([ 1, 2, 3, 4, 5 ]) ];\n            return test(_helpers, row: 0, N: 4)\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Bmzik1QY5R4
                                #define STR_Bmzik1QY5R4
static const fu::str str_Bmzik1QY5R4 fu_INIT_PRIORITY(1015) { "\n        fn test(ref _helpers: i32[][], mut N: i32, row: i32)\n        {\n            fn solveNode_a(h: i32[]) {\n                while (N % h[h.len - 1]) {\n                    N--;\n                    _helpers.grow(_helpers.len * 2);\n                }\n            }\n\n            fn solveJump() {\n                solveNode_a(_helpers[row]); // We've relaxed to a view, which bck can't copy\n                return _helpers.len;\n            }\n\n            return solveJump() - 1 * 2*2*2*2;\n        }\n\n        fn main()\n        {\n            mut _helpers = [[ 1, 2, 3, 4, 5 ]];\n            return test(_helpers, row: 0, N: 4)\n        }\n    "_fu };
                                #endif

                                #ifndef STR_N02QFubGyme
                                #define STR_N02QFubGyme
static const fu::str str_N02QFubGyme fu_INIT_PRIORITY(1015) { "\n        struct Arg { i: i32; };\n\n        // A mutref fail.\n        fn mutargs(ref args: Arg[])\n        {\n            // This miscompiles to ref into args,\n            //  after which we invalidate the reference.\n            //\n            <fail inval badref>\n            ref <pass/>\n            mut </fail> badref = args[0];\n\n            args = [ Arg(11) ]; // INVALIDATE badref.\n            return badref;\n        }       // oct2021: now latest issue here is that\n                //  this gets bcked AFTER jump lifetimes are unwound\n                //   and it all looks as if everything's fine (lt badref == lt args).\n\n        fn main()\n        {\n            mut args = [ Arg(7) ];\n            return mutargs(args).i - 7;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_L6XBo5dkQc7
                                #define STR_L6XBo5dkQc7
static const fu::str str_L6XBo5dkQc7 fu_INIT_PRIORITY(1015) { "\n        struct Arg { i: i32[]; };\n\n        fn witharg(using a: Arg)\n            i[i.len - 1] * 4;\n\n        fn mutargs(ref args: Arg[]) {\n            <fail invalidate badref>\n            ref <pass/>\n            let </fail> badref = args[0];\n\n            args = [ Arg([ 11 ]) ]; // INVALIDATE badref.\n            return witharg(badref);\n        }\n\n        fn main() {\n            mut args = [ Arg([ 7 ]) ];\n            return mutargs(args) - 28;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_S6mDo19N32d
                                #define STR_S6mDo19N32d
static const fu::str str_S6mDo19N32d fu_INIT_PRIORITY(1015) { "\n        struct Arg { i: i32[]; };\n\n        fn witharg(using a: Arg, x: i32)\n            i[i.len - 1] * x;\n\n        fn mutargs(ref args: Arg[]) {\n            <fail inval badref>\n            ref <pass/>\n            let </fail> badref = args[0];\n\n            for (mut i = 0;; i++) {\n                let ret = witharg(badref, i * 4);\n                if (ret)\n                    return ret;\n\n                args = [ Arg([ 11 ]) ]; // INVALIDATE badref.\n            }\n        }\n\n        fn main() {\n            mut args = [ Arg([ 7 ]) ];\n            return mutargs(args) - 28;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_vIinEHLDIc1
                                #define STR_vIinEHLDIc1
static const fu::str str_vIinEHLDIc1 fu_INIT_PRIORITY(1015) { "\n        fn test(ref woot: i32[], x: i32, y: i32) {\n            ref b = woot[y];\n            ref a = woot[x]; // the 'shadow ref' below ...\n            if (a == 1) {\n                <fail invalidate write to woot at 4:25>\n                <pass/>\n                shadow ref a = woot[x]; // ... should relax 'ref a' above to a let ...\n                </fail>\n                a += 1;\n            }\n            else {\n                b += 1; // ... and this should ignore cond write above.\n            }\n        }\n\n        fn main() {\n            mut x = [ -1, +1 ];\n            test(x, 0, 1);\n            return x[1] - 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_ojAnNtyGmca
                                #define STR_ojAnNtyGmca
static const fu::str str_ojAnNtyGmca fu_INIT_PRIORITY(1015) { "\n        fn test(ref a: i32[], ref b: i32[]) {\n            <alt>\n            if (a[0]++ == 1)                                    ;; N_AARSoftRisk\n            <alt/>\n            if (a[0] == 1)\n            </alt>\n                a ~= 1;\n            else\n                b ~= 1;\n        }\n\n        fn main() {\n            mut x = [ 1 ];\n            test(x, x);\n            return x.len - 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_hJQdvfVJ8Zh
                                #define STR_hJQdvfVJ8Zh
static const fu::str str_hJQdvfVJ8Zh fu_INIT_PRIORITY(1015) { "\n        nocopy struct Woot { x: i32[]; y: i32[] };\n\n        fn test(ref w: Woot) {\n            ref x = w.x;\n            <fail cannot access x 9:13+1 inval write y 8:15+2>\n            ref y = w.x; <pass/>\n            ref y = w.y; </fail>\n            y ~= y; // <- DONT RESOLVE BY COPY! ref can relax to let\n            x ~= y;\n        }\n\n        fn main() {\n            mut w = Woot([ 1, 2, 3, 4, 5, 6, 7 ], [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]);\n            test(w);\n            return w.x.len - 25;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_RHmvnrW5N7g
                                #define STR_RHmvnrW5N7g
static const fu::str str_RHmvnrW5N7g fu_INIT_PRIORITY(1015) { "\n        nocopy struct Woot { x: i32[]; y: i32[] };\n\n        fn test(ref w0: Woot, ref w1: Woot) {\n            ref x = w0.x;\n            <fail arguments test:w1 and test:w0 14:21+1 both alias mut w 13:17+1>\n            ref y = w1.x; <pass/>\n            ref y = w1.y; </fail>\n            y ~= y;\n            x ~= x; // <- This is the only diff wrt test below, x ~= x vs x ~= y.\n        }\n\n        fn main() {\n            mut w: Woot;\n            test(w, w);\n            return w.x.len;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_D1FndQTVgpg
                                #define STR_D1FndQTVgpg
static const fu::str str_D1FndQTVgpg fu_INIT_PRIORITY(1015) { "\n        nocopy struct Woot { x: i32[]; y: i32[] };\n\n        fn test(ref w0: Woot, ref w1: Woot) {\n            ref x = w0.x;\n            <fail arguments test:w1 and test:w0 14:21+1 both alias mut w 13:17+1>\n            ref y = w1.x; <pass/>\n            ref y = w1.y; </fail> // <- doesnt realize w0.x can't alias w1.y\n            y ~= y; // <- DONT RESOLVE BY COPY! ref can relax to let\n            x ~= y;\n        }\n\n        fn main() {\n            mut w: Woot;\n            test(w, w);\n            return w.x.len;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_6XDblbrQ37k
                                #define STR_6XDblbrQ37k
static const fu::str str_6XDblbrQ37k fu_INIT_PRIORITY(1015) { "\n        fn indexIntoImplicit(j: i32, implicit strings: string[]) strings[j];\n\n        fn selfRecurBeforeImplicitDep(x: i32)\n        {\n            // On second solve we're talking about a region, but the argnode is gone.\n            fn T(i: i32) selfRecurBeforeImplicitDep(i / 2);\n            if (x > 1) return T(x);\n            return indexIntoImplicit(x);\n        }\n\n        fn main() {\n            let implicit strings = [ \"a\", \"b\" ];\n            return selfRecurBeforeImplicitDep(2) == \"b\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_rExTxD9KWle
                                #define STR_rExTxD9KWle
static const fu::str str_rExTxD9KWle fu_INIT_PRIORITY(1015) { "\n        <fail arg a 27:41+1 inval by subseq write injected arg out 27:47+1 via grow 8:17+4>\n        nocopy                 <pass/></fail>\n        struct Type       { canon: string; };\n        struct SolvedNode {  type: Type;   };\n\n        fn solved(type: Type, implicit ref out: SolvedNode[]) {\n            out.grow(out.len * 100 + 1);\n\n            ref tail = out[out.len - 1];\n            tail.type.canon = type.canon;\n            return tail;\n        }\n\n        fn createMap(a: Type, b: Type): Type {\n            return Type(a.canon ~ b.canon);\n        }\n\n        fn evalTypeAnnot(nodes: string[]): SolvedNode\n        {\n            fn T(i: i32)\n                evalTypeAnnot([ nodes[i] ]).type;\n\n            // Each T() call should invalidate the results from previous T() calls -\n            //  so this shouldn't compile if Type is nocopy.\n            if (nodes.len > 1)\n                return solved(createMap(T(0), T(1)));\n\n            return solved(Type(nodes[0]));\n        }\n\n        fn main() {\n            implicit mut out: SolvedNode[];\n            let annot = evalTypeAnnot([ \"a\", \"b\" ]);\n            return out.len == 10101 && annot.type.canon.len == 2 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_6prroUJvfqi
                                #define STR_6prroUJvfqi
static const fu::str str_6prroUJvfqi fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut x = 0;\n            let s = ++x + ++x;\n            return s - 3; // Not 4! one arg must invalidate\n        }\n    "_fu };
                                #endif

                                #ifndef STR_JejnyFwGJQd
                                #define STR_JejnyFwGJQd
static const fu::str str_JejnyFwGJQd fu_INIT_PRIORITY(1015) { "\n        <fail arg inval subsequent write 14:20+3 14:26+4 14:34+4 8:16+2>\n        nocopy <pass/></fail>\n        struct X { x: i32; }\n        fn sum(a: X, b: X) a.x + b.x;\n\n        fn incr(ref x: X) {\n            x.x++;\n            return x;\n        }\n\n        fn main() {\n            mut x: X;\n            return sum(x.incr, x.incr) - 3; // Not 4! one arg must invalidate\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Fh7f6lXl4Ok
                                #define STR_Fh7f6lXl4Ok
static const fu::str str_Fh7f6lXl4Ok fu_INIT_PRIORITY(1015) { "\n        <fail arg inval subsequent write 23:20+3 23:26+4 23:34+4 16:18+2>\n        nocopy <pass/></fail>\n        struct X { x: i32; }\n        struct Y { y: X;   }\n\n        fn x(y: Y) y.y.x;\n        fn sum(a, b) a.x + b.x;\n\n        fn incr(ref x: X) {\n            x.x++;\n            return x;\n        }\n\n        fn incr(ref y: Y) {\n            y.y.x++;\n            return y;\n        }\n\n        fn main() {\n            mut x: Y;\n            ref y = x.y;\n            return sum(y.incr, x.incr) - 3; // Not 4! one arg must invalidate\n        }\n    "_fu };
                                #endif

                                #ifndef STR_hH51Cpbtf58
                                #define STR_hH51Cpbtf58
static const fu::str str_hH51Cpbtf58 fu_INIT_PRIORITY(1015) { "\n        <fail arg inval subsequent write 19:27+2 19:33+4 19:22+4 7:16+2>\n        nocopy <pass/></fail>\n        struct X { x: i32; };\n\n        fn incr(ref x: X) {\n            x.x++;\n            return x;\n        }\n\n        fn +=(a: X, b: X) {\n            // Notice, this is not a real +=,\n            //  just checking the order of eval here.\n            return a.x + b.x;\n        }\n\n        fn test(ref x: X, ref y: X) {\n            ref xy = y || x;\n            return x.incr += xy.incr; // <- xy invalidated by x.incr\n        }\n\n        fn main() {\n            mut x: X;\n            mut y: X;\n            return test(x, y) - 3;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_uq16CtSTcbe
                                #define STR_uq16CtSTcbe
static const fu::str str_uq16CtSTcbe fu_INIT_PRIORITY(1015) { "\n        <alt>\n        nocopy\n        </alt>\n        struct X { items: i32[]; };\n        fn popfirst(mut arr: X[]) arr[0]; // mcom_BlockReturn after relax: arr[] adds 'static\n        fn main() popfirst([ X() ]).items.len;\n    "_fu };
                                #endif

                                #ifndef STR_JOmkFEpnqVk
                                #define STR_JOmkFEpnqVk
static const fu::str str_JOmkFEpnqVk fu_INIT_PRIORITY(1015) { "cannot be copied or moved 6:38+1 ref static"_fu };
                                #endif

                                #ifndef STR_fWEwtmoZ4p4
                                #define STR_fWEwtmoZ4p4
static const fu::str str_fWEwtmoZ4p4 fu_INIT_PRIORITY(1015) { "\n        struct AB { a: i32[][]; b: i32[][]; };\n\n        fn problematic_moves(mut ab: AB) {\n            ref ra = ab.a;\n            return ra.len & 1 ? ra[0] : ab.b[0];\n        }\n\n        fn main() {\n            mut ab = AB(\n                [[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9]],\n                [[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]]);\n\n            mut pick = ab.problematic_moves;\n            return pick[9] - ab.a[0][9];\n        }\n    "_fu };
                                #endif

                                #ifndef STR_5YLWjJsVHJg
                                #define STR_5YLWjJsVHJg
static const fu::str str_5YLWjJsVHJg fu_INIT_PRIORITY(1015) { "\n        <fail cannot be copied or moved 20:31>\n        nocopy <pass/></fail>\n        struct NC { x: i32; y: i32 };\n\n        fn wants_val(mut a: NC) {\n            a.x++;\n            a.y++;\n            return a;\n        }\n\n        fn incr_by(mut a: NC, b: NC) {\n            a.x += b.x;\n            a.y += b.y;\n            return a;\n        }\n\n        fn main() {\n            mut v = NC(-1, -1);\n            mut w = wants_val(v);\n            return (w || v).x + 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_YiTd2hxhIP6
                                #define STR_YiTd2hxhIP6
static const fu::str str_YiTd2hxhIP6 fu_INIT_PRIORITY(1015) { "\n        nocopy struct SolvedNode {\n            items: SolvedNode[];\n        };\n\n        fn test(mut a: SolvedNode, mut b: SolvedNode) {\n            <alt>\n            ref n = a || b;\n            <alt/>\n            ref n = a.items ? a : b;\n            </alt>\n            return n;\n        }\n\n        fn main() test([], []).items.len;\n    "_fu };
                                #endif

                                #ifndef STR_oiAmt23sPz8
                                #define STR_oiAmt23sPz8
static const fu::str str_oiAmt23sPz8 fu_INIT_PRIORITY(1015) { "\n        <fail cannot access invalidated>\n        nocopy            <pass/></fail>\n        struct SolvedNode { len: i32; }\n\n        fn createBlock(mut last: SolvedNode) {\n            let tail     = last || last;\n            let unwrap   = tail || tail;\n            last.len--;\n            return unwrap;\n        }\n\n        fn main() {\n            return createBlock([]).len;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_eTJr1ebVqJ9
                                #define STR_eTJr1ebVqJ9
static const fu::str str_eTJr1ebVqJ9 fu_INIT_PRIORITY(1015) { "\n        <fail cannot access invalidated>\n        nocopy            <pass/></fail>\n        struct SolvedNode { items: SolvedNode[] };\n\n        fn popAndOr(ref node: SolvedNode) {\n            let N = node.items.len;\n\n            let pop = node.items[N - 1];\n            if (N > 2) {\n                node.items.pop();\n            }\n            else {\n                let head = node.items[0];\n                node = head;\n            }\n\n            return pop;\n        }\n\n        fn main() {\n            mut a = SolvedNode([ SolvedNode, SolvedNode ]);\n            let b = a.popAndOr();\n            return a.items.len + b.items.len;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_lP4FFxnma2k
                                #define STR_lP4FFxnma2k
static const fu::str str_lP4FFxnma2k fu_INIT_PRIORITY(1015) { "\n        <fail cannot access invalidated>\n        nocopy            <pass/></fail>\n        struct Items {\n            len: i32;\n        }\n\n        struct SolvedNode {\n            items: Items;\n        }\n\n        struct Nodes {\n            last: SolvedNode;\n        }\n\n        fn pop(ref n: Nodes) {\n            n.last.items.len--;\n        }\n\n        fn createBlock(mut items: Nodes) {\n            let tail = items.last;\n            let unwrap = tail.items;\n            items.pop();\n            return unwrap;\n        }\n\n        fn main() {\n            return createBlock(Nodes(SolvedNode([]))).len;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_0SAYqnOVvR8
                                #define STR_0SAYqnOVvR8
static const fu::str str_0SAYqnOVvR8 fu_INIT_PRIORITY(1015) { "\n        <fail cannot access invalidated>\n        nocopy            <pass/></fail>\n        struct SolvedNode {\n            items: SolvedNode[];\n        };\n\n        // Reducing the thing below.\n        fn createBlock(mut items: SolvedNode[]) {\n            let tail = items[items.len - 1];\n            let unwrap = tail.items;\n            items.pop();\n            return unwrap;\n        }\n\n        fn main() {\n            return createBlock([ SolvedNode ]).len;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_SL3fl0R9uI4
                                #define STR_SL3fl0R9uI4
static const fu::str str_SL3fl0R9uI4 fu_INIT_PRIORITY(1015) { "\n        <fail cannot access invalidated>\n        nocopy            <pass/></fail>\n        struct SolvedNode {\n            kind: string;\n            items: SolvedNode[];\n        };\n\n        // Same as below but mut.\n        fn createBlock(mut items: SolvedNode[]) {\n            if (items.len) for (;;) {\n                let tail = items[items.len - 1]; // const-indexed but generated mutref tail, must be F_RRET?\n                if (tail.kind != \"block\")\n                    break;\n\n                let unwrap = tail.items;\n                items.pop();\n                return unwrap;\n            }\n\n            return [];\n        }\n\n        fn main() {\n            return createBlock([]).len;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_5yOgoSyfAEh
                                #define STR_5yOgoSyfAEh
static const fu::str str_5yOgoSyfAEh fu_INIT_PRIORITY(1015) { "\n        <fail cannot access invalidated>\n        nocopy            <pass/></fail>\n        struct SolvedNode {\n            kind: string;\n            items: SolvedNode[];\n        };\n\n        // Same as above but ref.\n        fn createBlock(ref items: SolvedNode[]) {\n            if (items.len) for (;;) {\n                let tail = items[items.len - 1];\n                if (tail.kind != \"block\")\n                    break;\n\n                let unwrap = tail.items; // unwrap needs to copy here\n                items.pop(); ////////////// <- nuked here, but ignored!\n                return unwrap;\n            }\n\n            return [];\n        }\n\n        fn main() {\n            mut items: SolvedNode[];\n            return createBlock(items).len;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_CMNEVaFpkhk
                                #define STR_CMNEVaFpkhk
static const fu::str str_CMNEVaFpkhk fu_INIT_PRIORITY(1015) { "\n        fn test(ref a: i32[]) = a.swap(0, 1);\n\n        fn main() {\n            mut nums = [1, 2];\n            nums.test();\n            return nums.len == 2 && nums[0] == 2 && nums[1] == 1\n                 ? 0\n                 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_zBbGuuCsVtj
                                #define STR_zBbGuuCsVtj
static const fu::str str_zBbGuuCsVtj fu_INIT_PRIORITY(1015) { "\n        fn Swap(ref arr: i32[], x: i32, y: i32)\n            swap(arr[x], arr[y]);\n\n        fn main() {\n            mut a = [ 1, 2 ];\n            a.Swap(0, 1);\n            return a[0] - 2 == 0 && a[1] - 1 == 0 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_XO9hHrgUcre
                                #define STR_XO9hHrgUcre
static const fu::str str_XO9hHrgUcre fu_INIT_PRIORITY(1015) { "arg a 3:21+1 inval by subseq write arr 3:29+1"_fu };
                                #endif

                                #ifndef STR_cGYJWXP0GY2
                                #define STR_cGYJWXP0GY2
static const fu::str str_cGYJWXP0GY2 fu_INIT_PRIORITY(1015) { "\n        fn test(ref arg: i32[]) {\n            let encloses_unchanged = arg;\n\n            fn closure()\n                for (mut i = 0; i < arg.len; i++)\n                    arg[i] += encloses_unchanged[i];\n\n            closure();\n            if (arg.len & 1)\n                closure();\n        }\n\n        fn main() {\n            mut a = [ 3 ];\n            test(a);\n            return a[0] - 9;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_y4XNKMoPxB9
                                #define STR_y4XNKMoPxB9
static const fu::str str_y4XNKMoPxB9 fu_INIT_PRIORITY(1015) { "\n        inline fn must_not_return_ref_or_view(ref x: i32[][]) {\n            let y = x[100];\n            x.shrink(y.len);\n            return y;\n        }\n\n        fn main() {\n            mut arr: i32[][];\n            arr.grow(101);\n            arr[100] = [ 7 ]\n            return arr.must_not_return_ref_or_view()[0] - 7;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_kWgil0IZ8hh
                                #define STR_kWgil0IZ8hh
static const fu::str str_kWgil0IZ8hh fu_INIT_PRIORITY(1015) { "\n        struct HasVec { x: i32[] };\n        inline fn Last(x: i32[]) x[x.len - 1];\n\n        <alt>\n        inline                                                  ;; PointlessLocal\n        </alt>\n        fn will_return_value(ref x: HasVec) {\n            let bck_will_cpy = x;\n\n            let vec0 = bck_will_cpy.x;\n            if (bck_will_cpy.x.len & 1)\n                return vec0;\n\n            x.x ~= x.x.len;\n            let vec1 = bck_will_cpy.x;\n            return vec1;\n        }\n\n        fn main() {\n            mut x = HasVec([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]);\n            return will_return_value(x).Last/*9*/ - x.x.Last/*10*/ + 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_ny2UNPvcWNa
                                #define STR_ny2UNPvcWNa
static const fu::str str_ny2UNPvcWNa fu_INIT_PRIORITY(1015) { "\n        fn PASS_borrowCheck_incr_a_ret_b(ref a: i32, ref b: i32) {\n            a++;        // we're done writing to a before\n            return b;   //  EXTRA DRAMA: we dont cg const refs for primitives right now\n        }\n\n        fn main() {\n            mut x = 5;\n            PASS_borrowCheck_incr_a_ret_b(x, x);\n            return x - 6;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_FbPjSz6slI0
                                #define STR_FbPjSz6slI0
static const fu::str str_FbPjSz6slI0 fu_INIT_PRIORITY(1015) { "\n        fn PASS_borrowCheck_reduct(ref a: i32, ref b: i32[])\n        {\n            // If this were (ref!b a, ref b):\n            //\n            // When a points into b:\n            //  - a++ read ok, write ok\n            //   - b read ok, write ok + invalidates a\n            //    - a not usable from here on\n            //\n            // The point is we should be able to deduce this automatically,\n            //  if nothing a-related is used after b gets used for the first time,\n            //   then we're fine if b aliases a ...\n            //\n            // ... EXCEPT that's if b doesn't acceptTempCopies -\n            //  meaning it's either F_IMPLICIT or F_REF -\n            //   otherwise there's ambiguity.\n            //\n            a++;\n            b ~= 10;\n        }\n\n        fn main() {\n            mut arr = [ 9 ];\n            PASS_borrowCheck_reduct(arr[0], arr);\n            return arr[0] - arr[1];\n        }\n    "_fu };
                                #endif

                                #ifndef STR_17zw1FjBgtg
                                #define STR_17zw1FjBgtg
static const fu::str str_17zw1FjBgtg fu_INIT_PRIORITY(1015) { "\n        struct Node { id: i32; items?: Node[]; };\n\n        fn traverse(node: Node, visit) {\n            visit(node);\n            for (mut i = 0; i < node.items.len; i++)\n                traverse(node.items[i], fn visit);\n        }\n\n        fn PASS_borrowCheck(ref root: Node) {\n            mut n: i32;\n            fn count(id: i32)\n                traverse(root): |i|\n                    if (i.id == id)\n                        n++;\n\n            fn check(ref node: Node) {\n                if (node.items)\n                    for (mut i = 0; i < node.items.len; i++)\n                        check(node.items[i]);                   ;; PointlessMustSeq\n                else\n                    count(node.id++);\n            }\n\n            check(root);\n            return n;\n        }\n\n        fn main() {\n            mut tree = Node(0, [ Node(2), Node(2) ]);\n            return PASS_borrowCheck(tree) - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_MgnEzgw4zR6
                                #define STR_MgnEzgw4zR6
static const fu::str str_MgnEzgw4zR6 fu_INIT_PRIORITY(1015) { "\n        fn check(implicit root: i32[], node: i32[])\n            root.len - node.len;\n\n        fn PASS_borrowCheck(        <fail because of 2:27+4 NOT implicit arg root 6:22+4>\n                     root: i32[])   <pass/>\n            implicit root: i32[])   </fail>\n                check(root);\n\n        fn main()\n            [ 1, 2, 3 ].PASS_borrowCheck();\n    "_fu };
                                #endif

                                #ifndef STR_5pGje5BjZpf
                                #define STR_5pGje5BjZpf
static const fu::str str_5pGje5BjZpf fu_INIT_PRIORITY(1015) { "\n        struct Node { id: i32; items?: Node[]; };\n\n        fn traverse(node: Node, visit) {\n            visit(node);\n            for (mut i = 0; i < node.items.len; i++)\n                traverse(node.items[i], fn visit);\n        }\n\n        // Same as above, but not a closure.\n        fn count(id: i32, implicit root: Node, implicit ref n: i32)\n            traverse(root): |i|\n                if (i.id == id)\n                    n++;\n\n        fn check(ref node: Node) {\n            if (node.items)\n                for (mut i = 0; i < node.items.len; i++)\n                    check(node.items[i]);                   ;; PointlessMustSeq\n            else\n                count(node.id++);\n        }\n\n        fn PASS_borrowCheck(implicit ref root: Node) {\n            implicit mut n: i32;\n            check(root); // <- Usage intersection failure: Node & Node\n            return n;\n        }\n\n        fn main() {\n            mut tree = Node(0, [ Node(2), Node(2) ]);\n            return PASS_borrowCheck(tree) - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_sdMnewT3hc5
                                #define STR_sdMnewT3hc5
static const fu::str str_sdMnewT3hc5 fu_INIT_PRIORITY(1015) { "\n        struct Node { id: i32; items?: Node[]; };\n\n        fn traverse(node: Node, visit) {\n            visit(node);\n            for (mut i = 0; i < node.items.len; i++)\n                traverse(node.items[i], fn visit);\n        }\n\n        // Same as above, but no implicits.\n        fn count(id: i32, ref root: Node, implicit ref n: i32)\n            traverse(root): |i|\n                if (i.id == id)\n                    n++;\n\n        // AAR: check(ref node, ref root) accepted,\n        //       but (ref root, ref node) rejected.\n        <alt>\n        fn check(ref root: Node, ref node: Node) { <alt/>\n        fn check(ref node: Node, ref root: Node) { </alt>\n            if (node.items)\n                for (mut i = 0; i < node.items.len; i++)\n                    check(:root, node.items[i]);                ;; PointlessMustSeq\n            else\n                count(:root, node.id++);\n        }\n\n        fn PASS_borrowCheck(ref root: Node) {\n            implicit mut n: i32;\n            check(:root, root);\n            return n;\n        }\n\n        fn main() {\n            mut tree = Node(0, [ Node(2), Node(2) ]);\n            return PASS_borrowCheck(tree) - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_mFFg7nJEXhi
                                #define STR_mFFg7nJEXhi
static const fu::str str_mFFg7nJEXhi fu_INIT_PRIORITY(1015) { "\n        pub fn grow_if_oob(ref a: $T[], i: i32) {\n            if (a.len <= i) a.grow(i + 1);\n            return a[i];\n        }\n\n        fn grow_if_oob_to_len_from_self(ref arr: i32[], idx: i32)\n            arr.grow_if_oob(arr[idx]); // i was F_REF for some reason\n\n        fn main() {\n            mut arr = [3];\n            arr.grow_if_oob_to_len_from_self(0) = 2;\n\n            mut sum = 0;\n            for (mut i = 0; i < arr.len; i++) sum += arr[i];\n            return sum - 5;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_XedCLuKmHKl
                                #define STR_XedCLuKmHKl
static const fu::str str_XedCLuKmHKl fu_INIT_PRIORITY(1015) { "\n        fn used_in_a_loop__invalidated__by_new_var(\n            ref arr: i32[], ref barr: i32[], ref carr: i32[])\n        {\n            ref head = arr[arr.len - 1];\n            for (mut i = 0; i < arr.len; i++) {\n                head += arr.len;\n                let head_cpy = head + 0;\n                ref barrcarr = barr || carr;\n                barrcarr.resize(head_cpy);\n            }\n        }\n\n        fn main() {\n            mut arr = [ 1 ];\n\n            <fail both alias arr 15:17+3>\n            ref barr = arr; <pass/>\n            mut barr = arr; </fail>\n\n            used_in_a_loop__invalidated__by_new_var(arr, barr, barr);\n            return barr.len == 2 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_bVqyeUPNNs0
                                #define STR_bVqyeUPNNs0
static const fu::str str_bVqyeUPNNs0 fu_INIT_PRIORITY(1015) { "\n        fn grow_if_oob(ref a: i32[], i: i32) {\n            if (a.len <= i) a.grow(i + 1);\n            return a[i];\n        }\n\n        fn assign(ref what: i32, ref to: i32) to = what;\n\n        fn two_writes_in_an_arg(ref arr: i32[], ref brr: i32[], ref x: i32)\n            assign( what: x ? arr.grow_if_oob(10)\n                            : brr.grow_if_oob(10), to: x );\n\n        fn main() {\n            mut arr = [ 0, 1, 2, 3 ];\n            mut brr = [ 0, 2, 4, 6 ];\n\n            <fail arg 3 x 2 brr both alias 20:51>\n            ref x = brr[0];               <pass/>\n            mut x = 0;                    </fail>               ;; PointlessMustSeq\n\n            return two_writes_in_an_arg(arr, brr, x);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_NzzOKOBtuxa
                                #define STR_NzzOKOBtuxa
static const fu::str str_NzzOKOBtuxa fu_INIT_PRIORITY(1015) { "\n        fn grow_if_oob(ref a: i32[], i: i32) {\n            if (a.len <= i) a.grow(i + 1);\n            return a[i];\n        }\n\n        fn assign(ref what: i32, ref to: i32) to = what;\n\n        fn two_writes_in_an_arg(ref arr: i32[], ref brr: i32[], ref x: i32)\n            assign( what: x ? arr.grow_if_oob(10)\n                            : brr.grow_if_oob(10), to: x );\n\n        fn main() {                         <flip>\n            mut zero = 0;\n            mut empty: i32[];               <flip/>\n            mut arr = [ 0, 1, 2, 3 ];\n            mut brr = [ 0, 2, 4, 6 ];       </flip>\n\n            <fail arg 3 x 2 brr both alias 25:58+8>\n            ref x = brr[0];                 <pass/>\n            mut x = 0;                      </fail>             ;; PointlessMustSeq\n\n            ref opaque_x    = brr.len > arr.len ? zero  : x;\n            ref opaque_brr  = brr.len > arr.len ? empty : brr;\n\n            return two_writes_in_an_arg(arr, opaque_brr, opaque_x);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_XpHE3cnJwwh
                                #define STR_XpHE3cnJwwh
static const fu::str str_XpHE3cnJwwh fu_INIT_PRIORITY(1015) { "\n        struct Node { items: Node[] };\n\n        fn main() {\n            mut root = Node([\n                Node([ Node, Node ])\n            ]);\n\n            <fail both arg alias root>\n            swap(root.items[0], root);  <pass/> // write to root invalidates root.items[0]\n            root = root.items[0];       </fail> // this is fine\n\n            return root.items.len - 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_L0KvwRIemNg
                                #define STR_L0KvwRIemNg
static const fu::str str_L0KvwRIemNg fu_INIT_PRIORITY(1015) { "\n        fn grow_if_oob(ref a: i32[], i: i32) {\n            if (a.len <= i) a.grow(i + 1);\n            return a[i];\n        }\n\n        fn assign(ref to: i32, ref what: i32) to = what;\n\n        fn two_writes_in_an_arg(ref x: i32, ref arr: i32[], ref brr: i32[])\n            assign( to: x,  what: arr.grow_if_oob(10)           ;; !N_BckMustSeq\n                               || brr.grow_if_oob(10));         ;; !N_MoveMustSeq\n\n        fn test(ref x: i32, ref arr: i32[], ref brr: i32[]) {\n            two_writes_in_an_arg(\n                <fail arg 2 arr 1 x both alias 17:22>\n                    x || arr[0],              <pass/>\n                    x,                        </fail>           ;; PointlessMustSeq\n                    :arr, :brr);\n\n            return x;\n        }\n\n        fn main() {\n            mut arr = [ 0 ];\n            mut brr = [ 0 ];\n            mut x   = 0;\n\n            return test(:x, :arr, :brr);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_8O8sw0xqA79
                                #define STR_8O8sw0xqA79
static const fu::str str_8O8sw0xqA79 fu_INIT_PRIORITY(1015) { "\n        fn writes_to_two_args(ref item: i32, ref arr: i32[], ref brr: i32[]) {\n            ref arrbrr = arr || brr;\n            arrbrr.resize(100 + arrbrr.len);\n            return item += arrbrr.len;\n        }\n\n        fn main() {\n            mut arr: i32[] = [      ];\n            mut brr: i32[] = [ -101 ];\n\n            <fail alias brr>\n            ref item = brr[0]; <pass/>\n            mut item = brr[0]; </fail>\n\n            return writes_to_two_args(:item, :arr, :brr);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_KFvMtS49Hs3
                                #define STR_KFvMtS49Hs3
static const fu::str str_KFvMtS49Hs3 fu_INIT_PRIORITY(1015) { "\n        fn reads_from_two_args(ref left: i32, ref right: i32, ref arr: i32[], ref brr: i32[]) {\n            ref arrbrr = arr || brr;\n            ref item = left || right;\n            arrbrr.resize(100 + arrbrr.len);\n            return item += arrbrr.len;\n        }\n\n        fn main() {\n            mut arr: i32[] = [      ];\n            mut brr: i32[] = [ -101 ];\n\n            mut left = 0;\n\n            <fail alias brr>\n            ref right = brr[0]; <pass/>\n            mut right = brr[0]; </fail>\n\n            return reads_from_two_args(:left, :right, :arr, :brr);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_gP6VlFGkdDl
                                #define STR_gP6VlFGkdDl
static const fu::str str_gP6VlFGkdDl fu_INIT_PRIORITY(1015) { "\n        fn grow(ref arr: i32[], by!n: i32) {\n            arr.resize(arr.len + n);\n            return arr;\n        }\n\n        fn incr__ltr_oee(ref what: i32, by: i32)\n            what += by;\n\n        fn reads_from_two_args__single_expr(ref left: i32, ref right: i32, ref arr: i32[], ref brr: i32[])\n            incr__ltr_oee(left || right, grow(arr || brr, by: 100).len);\n\n        fn main() {\n            mut arr: i32[] = [      ];\n            mut brr: i32[] = [ -101 ];\n\n            mut left = 0;\n\n            <fail alias brr>\n            ref right = brr[0]; <pass/>\n            mut right = brr[0]; </fail>\n\n            return reads_from_two_args__single_expr(:left, :right, :arr, :brr);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_tv8l2904UOk
                                #define STR_tv8l2904UOk
static const fu::str str_tv8l2904UOk fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut arr = [ 1,1,1,1,1,10,10,10,10,10 ];\n            mut sum = 0;\n\n            // veach(view) should decay to a slice -\n            //  which push will invalidate.\n            //\n            fn veach(                   <fail (both|expects) (alias|mutref) (3:17+3|20:20+2)>\n                /* no explicit val */   <pass/>\n                mut                     </fail>\n                    view, fn)\n            {\n                for (mut i = 0; i < view.len; i++) {\n                    fn(view[i]);\n                    arr ~= arr; // Relocate arr.\n                }\n            }\n\n            arr.veach: |ref i| sum +=   <alt>\n                (i *= 2)                <alt/>\n                (i *  2)                </alt>;\n\n            return sum - 110;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_plFsAGo0xo1
                                #define STR_plFsAGo0xo1
static const fu::str str_plFsAGo0xo1 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut arr = [ 1,1,1,1,1,10,10,10,10,10 ];\n            mut sum = 0;\n\n            // veach(view) should decay to a slice -\n            //  which push will invalidate.\n            //\n            fn veach(ref view, fn) {\n                for (mut i = view.len; i --> 0; ) {\n                    fn(view[i]);\n                    arr ~= arr.map(|x| x * 1); // Relocate arr.\n                }\n            }\n\n            arr.veach: |ref i| sum +=   <alt>\n                (i *= 2)                ;; PointlessMustSeq\n                                        <alt/>\n                (i *  2)                </alt>;\n\n            return sum - 110;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_BnOYCh0VHje
                                #define STR_BnOYCh0VHje
static const fu::str str_BnOYCh0VHje fu_INIT_PRIORITY(1015) { "\n        struct Context {\n            modules:    Module[];\n        };\n\n        nocopy struct Module {\n            in?:        string;\n            fname:      string;\n        };\n\n        fn getFile(implicit ref ctx: Context, fname: string) {\n            for (mut i = 0; i < ctx.modules.len; i++)\n                if (ctx.modules[i].fname == fname)\n                    return ctx.modules[i].in;\n\n            ctx.modules ~= Module(:fname, in: fname ~ '\\n' ~ fname ~ '\\n');\n            return ctx.modules[ctx.modules.len - 1].in;\n        }\n\n        fn getModule(implicit ref ctx: Context, fname: string) {\n            for (mut i = 0; i < ctx.modules.len; i++)\n                if (ctx.modules[i].fname == fname)\n                    return ctx.modules[i];\n\n            return [];\n        }\n    "_fu };
                                #endif

                                #ifndef STR_foZwTdEsr0g
                                #define STR_foZwTdEsr0g
static const fu::str str_foZwTdEsr0g fu_INIT_PRIORITY(1015) { "\n        import _0;\n\n        fn ensureParsed(fname: string) {\n            let module = getModule(fname);\n            if (!module.in)\n                return getFile(fname).len\n                <fail module invalidated by write to ctx>\n                    || module.in.len;\n                <pass/>\n                    || throw(fname);\n                </fail>\n\n            return module.in.len;\n        }\n\n        fn main() {\n            implicit mut ctx: Context;\n            return ensureParsed(\"a\") - 4;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_3rEfgWuLkFh
                                #define STR_3rEfgWuLkFh
static const fu::str str_3rEfgWuLkFh fu_INIT_PRIORITY(1015) { "\n        nocopy struct NCThing {\n            items: i32[];\n        };\n\n        fn mut_in_loop_before_break(ref thing: NCThing) {\n            mut sum = 0;\n\n            ref items = thing.items;\n            for (mut i = 0; i < items.len; i++)\n            {\n                sum += items[i];\n                if (sum > 10)\n                {\n                    thing = NCThing();\n                    <fail write 15:27 inval use items next loop iter 10:33>\n                    if (sum > 20)                                   <pass/>\n                    if (true)                                       </fail> ;; !DEV_DontFoldLiterals\n                        break;\n                }\n\n                items[i] *= 2;\n            }\n\n            return sum;\n        }\n\n        fn main() {\n            mut thing = NCThing([ 10 ]);\n            return mut_in_loop_before_break(thing)\n                 + mut_in_loop_before_break(thing)\n                 - 30\n                 + thing.items.len;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_hiwfv3zXKDk
                                #define STR_hiwfv3zXKDk
static const fu::str str_hiwfv3zXKDk fu_INIT_PRIORITY(1015) { "\n        struct XY { x: i32; y: i32 };\n\n        fn main() {\n            mut xy: XY;\n            <fail ref x 13:20+1 invalidated by write to xy 10:18+2>\n            ref x = xy.x;                                   <pass/>\n            fn  x = xy.x;                                   </fail>\n\n            pragma emit(`\n                `xy`.x++;\n            `);\n\n            return x - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_VWfM6qTtBqa
                                #define STR_VWfM6qTtBqa
static const fu::str str_VWfM6qTtBqa fu_INIT_PRIORITY(1015) { "\n        struct XY { x: i32; y: i32 };\n\n        fn main() {\n            mut xy: XY;\n            <fail 11:22 inval next loop iter 9:21>\n            ref x = xy.x;                  <pass/>\n            fn  x = xy.x;                  </fail>\n\n            while (!x)\n                pragma emit(`\n                    `xy`.x++;\n                `);\n\n            return xy.x - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_iXIxqeQot3g
                                #define STR_iXIxqeQot3g
static const fu::str str_iXIxqeQot3g fu_INIT_PRIORITY(1015) { "\n        struct XY { x: i32; y: i32 };\n\n        fn bckErr_fromPragmaEmit(ref xy: XY) {\n            pragma emit(`\n                `xy`.x++;\n            `);\n        }\n\n        fn main() {\n            mut xy: XY;\n            <fail bckErr_fromPragmaEmit>\n            ref x = xy.x;        <pass/>\n            fn  x = xy.x;        </fail>\n\n            bckErr_fromPragmaEmit(xy);\n            return x - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_H7kMh8p7Ns6
                                #define STR_H7kMh8p7Ns6
static const fu::str str_H7kMh8p7Ns6 fu_INIT_PRIORITY(1015) { "\n        struct XY { x: i32; y: i32 };\n\n        fn test(ref xy: XY, ref zw: XY) {\n            <fail cannot access ref x 12:20+1 inval by write xy 9:21+2>\n            ref x = xy.x;                                   <pass/>\n            fn  x = xy.x;                                   </fail>\n\n            pragma emit(`\n                `xy || zw`.x++;\n            `);\n\n            return x;\n        }\n\n        fn main() {\n            mut xy: XY;\n            return test(xy, xy) - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Lxam3a7czm3
                                #define STR_Lxam3a7czm3
static const fu::str str_Lxam3a7czm3 fu_INIT_PRIORITY(1015) { "\n        struct Ext { ext: Ext[] };\n\n        fn EXT(implicit ext: Ext[], a: i32) ext[a];\n\n        fn EXT_insert(implicit ref ext: Ext[], a: i32) {\n            ext.insert(a, Ext());\n            return ext[a];\n        }\n\n        fn solveTypedef(a: i32, b: i32) EXT_insert(a) = EXT(b);\n\n        fn main() {\n            implicit mut ext = [ Ext([ Ext, Ext ]) ];\n\n            for (mut i = 0; i < 128; i++)\n                solveTypedef(0, 0);\n\n            return ext[0].ext.len == 2 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_G9xtOZowzjk
                                #define STR_G9xtOZowzjk
static const fu::str str_G9xtOZowzjk fu_INIT_PRIORITY(1015) { "\n        fn ints(implicit ref _ints: i32[]) _ints;\n        fn sum (implicit ref _sum:  i32)   _sum;\n\n        // while trying to sort implicit args i noticed tests didnt catch\n        //  args getting reordered but AAR masks not updating\n        //   this tries to reproduce the same thing\n        fn flippedInjectedArgsWithBrokenAARMasks()\n            if (sum) // the point of this is to inject _sum before _ints\n                for (mut i = ints.len; i --> 0; )\n                    ints.push(sum);\n\n        fn main() {\n            implicit mut _ints: i32[] = [ 0 ];\n            <fail alias _ints>\n            implicit ref _sum = _ints[0];\n            <pass/>\n            implicit mut _sum = 0;\n            </fail>\n\n            flippedInjectedArgsWithBrokenAARMasks();\n            return ints[0];\n        }\n    "_fu };
                                #endif

                                #ifndef STR_ImXZnV6wOZe
                                #define STR_ImXZnV6wOZe
static const fu::str str_ImXZnV6wOZe fu_INIT_PRIORITY(1015) { "\n        struct Node {\n            nodes: Node[];\n        };\n\n        noinline fn append_a_onto_b_100_times(ref willPush: Node, ref pushWhat: Node) {\n            for (mut i = 0; i < 100; i++)\n                willPush.nodes ~= pushWhat;\n        }\n\n        noinline fn clear_and_return_ref_to_self(ref node: Node) {\n            node.nodes.clear();\n            return node;\n        }\n\n        noinline fn crash_if_b_refs_into_a(ref willEmpty: Node, ref willPush: Node) {\n            return append_a_onto_b_100_times(\n                // indexes inside, should crash\n                willPush.nodes[0],\n                // empties the nodes\n                clear_and_return_ref_to_self(willEmpty));\n        }\n\n        fn main() {\n            mut willEmpty: Node = [[ Node() ]];\n\n            <fail both alias willEmpty 28:47>\n            crash_if_b_refs_into_a(willEmpty, willEmpty);\n            <pass/>\n            mut willPush = willEmpty;\n            crash_if_b_refs_into_a(willEmpty, willPush);\n            </fail>\n\n            return willEmpty.nodes.len == 0 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Q4CMKzY4mke
                                #define STR_Q4CMKzY4mke
static const fu::str str_Q4CMKzY4mke fu_INIT_PRIORITY(1015) { "\n        struct Node { nodes: Node[] };\n\n        noinline fn soft_risk_inner(ref a: Node, ref b: Node)\n            for (mut i = 0; i < 100; i++)\n                a.nodes ~= b;\n\n        noinline fn soft_risk_outer(ref a: Node, ref b: Node)\n            soft_risk_inner(a, b.nodes[0]);\n\n        fn main() {\n            mut root = Node([ Node ]);\n\n            <fail both alias root 12:17+4>\n            soft_risk_outer(root, root);    <pass/>\n            mut cpy = root;\n            soft_risk_outer(root, cpy);     </fail>\n\n            return root.nodes.len == 101 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_WzfveXxsIHh
                                #define STR_WzfveXxsIHh
static const fu::str str_WzfveXxsIHh fu_INIT_PRIORITY(1015) { "\n        struct ScopeItem { k: string; v: i32 };\n\n        fn dequalify_andGetScope(ref id: string, implicit locals: ScopeItem[], implicit globals: ScopeItem[]) {\n            if (id.ends(with: \"g\")) {\n                id.pop();\n                return globals;\n            }\n\n            return locals;\n        }\n\n        fn solveAddrOfFn(mut id: string) {\n            fn visitScope(items: ScopeItem[]) {\n                items.each: |item|\n                    if (item.k == id)\n                        return item.v;\n\n                return -1;\n            }\n\n            // on gcc visitScope:id bound to a slice before mutation\n            return visitScope(dequalify_andGetScope(id));       ;; N_BckMustSeq\n        }\n\n        fn main() {\n            let implicit locals  = [ ScopeItem(\"a\", 1), ScopeItem(\"b\", 2), ScopeItem(\"c\", 3) ];\n            let implicit globals = [ ScopeItem(\"a\", 10), ScopeItem(\"b\", 20), ScopeItem(\"c\", 30) ];\n            let result = solveAddrOfFn(\"a\") + solveAddrOfFn(\"bg\");\n            return result == 21 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_zV2QBWp4vr6
                                #define STR_zV2QBWp4vr6
static const fu::str str_zV2QBWp4vr6 fu_INIT_PRIORITY(1015) { "\n        fn cmp_ooe(mut stuff: i32[], ref needSort: bool) {\n            mut result: i32[] = [];\n            mut last = -1;\n            for (mut i = 0; i < stuff.len; i++) {\n                let t = stuff[i];\n                if !(t & 1) continue;\n                if (last > (last = t)) needSort = true;\n                result ~= t;\n            }\n\n            if (needSort) result.sort();\n            return result;\n        }\n\n        fn checksum(stuff: i32[]) {\n            mut result = 0;\n            for (mut i = 0; i < stuff.len; i++) {\n                result *= stuff[i];\n                result += stuff[i];\n            }\n            return result;\n        }\n\n        fn main() {\n            mut needSort = false;\n            let aa = checksum(cmp_ooe([1, 2, 3, 4, 5], :needSort));\n            let bb = !needSort\n                  && checksum(cmp_ooe([7, 4, 3, 2, 1], :needSort));\n\n            return needSort ? aa * 100 + bb - 3549 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_hLJPgMfTQbi
                                #define STR_hLJPgMfTQbi
static const fu::str str_hLJPgMfTQbi fu_INIT_PRIORITY(1015) { "\n        fn clearAndReturn(ref a: i32[]) {\n            a.clear();\n            return a;\n        }\n\n        <alt>\n        fn refOOE(ref a: i32[], b: i32[]) <alt/>\n        fn refOOE(b: i32[], ref a: i32[]) </alt>\n            a ~= b;\n\n        fn main() {\n            mut ints = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];\n            refOOE(a: clearAndReturn(ints), b: ints);\n            return ints.len - 10;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_zm97G0DZxg3
                                #define STR_zm97G0DZxg3
static const fu::str str_zm97G0DZxg3 fu_INIT_PRIORITY(1015) { "\n        struct Type { nontriv: Type[] };\n        struct Node { type: Type };\n\n        let zero    = Type();\n        let one     = Type([ Type ]);\n        let two     = Type([ Type, Type ]);\n\n        noinline fn solve(ref nodes: Node[])\n        {\n            noinline fn propagateType(ref node: Node, val slot: Type) {\n                shadow let slot =\n                    node.type.nontriv.len == 2 ? two : slot;\n\n            <alt>\n                for (mut i = 0; i < nodes.len; i++)\n                    nodes[i].type = zero;\n            <alt/>\n                nodes = nodes.map(|lax n| Node(zero));\n            </alt>\n\n                nodes ~= Node(slot);\n            }\n\n            for (mut i = nodes.len; i --> 0; ) {\n                ref node = nodes[i];\n\n                propagateType(node,\n                <alt>\n                    node.type.nontriv.len == 0 ? zero : node.type\n                    //              missing copy around ^^^^^^^^^\n                    //      alt-1: wrong result, alt-2: segfault\n                <alt/>\n                    node.type\n                </alt>);\n            }\n        }\n\n        fn main() {\n            mut nodes = [ Node(one) ];\n            solve(nodes);\n\n            return nodes.len == 2\n                && nodes[0].type == zero\n                && nodes[1].type == one\n                    ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_R6XOifmRMec
                                #define STR_R6XOifmRMec
static const fu::str str_R6XOifmRMec fu_INIT_PRIORITY(1015) { "\n        nocopy struct NC { x: i32 };\n\n        noinline fn add(a: i32, b: i32)\n            a + b;\n\n        noinline fn test(a: NC, ref b: NC)\n            add(10 * a.x, ++b.x);                               ;; N_AARMustSeq\n\n        fn main() {\n            mut nc = NC(1);\n            return test(nc, nc) - 12;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_NRBFKKNrYf8
                                #define STR_NRBFKKNrYf8
static const fu::str str_NRBFKKNrYf8 fu_INIT_PRIORITY(1015) { "\n        struct Node { value: i32; children?: Node[] };\n\n        noinline fn used_in_a_nested_loop_after_break(ref n: Node)\n        {\n            ref first = n.children[0];\n\n            mut sum = 0;\n            for (mut i = 0; i < n.children.len; i++) {\n                for (shadow mut i = 0; i < n.children.len; i++) {\n                    sum += n.children[i].value;\n\n                    if (sum & 1) {\n                        // write followed by inner-loop break -\n                        //  not on the same path as the use of first below ...\n                        n.children ~= Node(i);\n\n                        <fail cannot access first 23:21+5 inval by write n 16:36+2>\n                        break;                                              <pass/>\n                        return sum;                                         </fail>\n                    }\n\n                    // ... which will be used again on next outer-loop iter.\n                    first.value += sum;\n                }\n            }\n\n            return sum;\n        }\n\n        fn main() {\n            mut n = Node(0, [ Node(2), Node(1) ]);\n            let sum = used_in_a_nested_loop_after_break(n);\n            return sum - 3;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_t2nHn9h7boa
                                #define STR_t2nHn9h7boa
static const fu::str str_t2nHn9h7boa fu_INIT_PRIORITY(1015) { "\n        struct Node { value: i32; children?: Node[] };\n\n        noinline fn used_in_a_preceding_nested_loop(ref n: Node)\n        {\n            ref first = n.children[0];\n\n            mut sum = 0;\n            for (mut i = 0; i < n.children.len; i++) {\n\n                for (shadow mut i = 0; i < n.children.len; i++)\n                    first.children ~= Node(i);\n\n                for (shadow mut i = 0; i < n.children.len; i++) {\n                    sum += n.children[i].value;\n\n                    if (sum & 1) {\n                        n.children ~= Node(i);\n\n                        <fail write to n 18:36+2 inval use of first 12:21+5 on next loop iter>\n                        break;          <pass/>\n                        return sum;     </fail>\n                    }\n                }\n            }\n\n            return sum;\n        }\n\n        fn main() {\n            mut n = Node(0, [ Node(2), Node(1) ]);\n            let sum = used_in_a_preceding_nested_loop(n);\n            return sum - 3;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_R4vLFPcN651
                                #define STR_R4vLFPcN651
static const fu::str str_R4vLFPcN651 fu_INIT_PRIORITY(1015) { "\n        noinline fn used_after_break_from_block(ref arr: i32[])\n        {\n            <fail cannot access first 18:20+5 inval by write to arr 10:29+5>\n            ref <pass/>\n            mut </fail> first = arr[0];\n\n            :BLOCK {\n                if (first & 2) {\n                    if (first & 1) {\n                        arr.clear();\n                        break :BLOCK;                           ;; Goto\n                    }\n\n                    first++;\n                }\n            }\n\n            return first;\n        }\n\n        fn main() {\n            mut arr = [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 18, 19 ];\n            return used_after_break_from_block(arr) - 3;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Oi4pkq80wSd
                                #define STR_Oi4pkq80wSd
static const fu::str str_Oi4pkq80wSd fu_INIT_PRIORITY(1015) { "\n        fn hello(ref arr: i32[], ref item: i32)\n            arr ~= ++item;\n\n        fn ret_last(ref arr: i32[])\n            arr[arr.len - 1];\n\n        fn concat_self_ret_last(ref arr: i32[])\n            ret_last(arr ~= arr)\n\n        fn main() {\n            mut arr = [ 1, 2, 3 ];\n            hello(arr, concat_self_ret_last(arr));\n            return ret_last(arr) - 4;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_vAJvMVcmBid
                                #define STR_vAJvMVcmBid
static const fu::str str_vAJvMVcmBid fu_INIT_PRIORITY(1015) { "hello 13:13+5 arr 13:19+3 inval by subseq concat_self_ret_last 13:24+20"_fu };
                                #endif

                                #ifndef STR_foZUrZXSP7i
                                #define STR_foZUrZXSP7i
static const fu::str str_foZUrZXSP7i fu_INIT_PRIORITY(1015) { "\n        fn Last(ref arr: i32[])\n            arr[arr.len - 1];\n\n        fn Push(ref arr: i32[]) {\n            arr.push([]);\n            return arr.Last;\n        }\n\n        fn Assign(ref b: i32, ref into: i32)\n            into = ++b;\n\n        fn main() {\n            mut arr = [ 1, 2, 3 ];\n\n            <fail write to arr 21:39+4 inval use b 21:30+1 next loop iter>\n            ref <pass/>\n            fn  </fail> b = arr.Last;\n\n            for (mut i = 0; i < 10; i++) {\n                mut tmp: i32;\n                Assign(tmp = b, into: Push(arr));\n            }\n\n            return arr.Last - 13;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_vUTRGRAwDqe
                                #define STR_vUTRGRAwDqe
static const fu::str str_vUTRGRAwDqe fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut arr = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ];\n            <fail ref item4 11:26+5 inval by write to arr 10:18+3>\n            ref <pass/>\n            let </fail> item4 = arr[4];\n\n            mut out = 7;\n\n            pragma emit(`\n                `arr` = {};\n                `out` = `item4`;\n            `);\n\n            return out * 2 - 8;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_BHENw2Sl5F2
                                #define STR_BHENw2Sl5F2
static const fu::str str_BHENw2Sl5F2 fu_INIT_PRIORITY(1015) { "\n        struct A { ints: i32[] };\n        struct B { a0: A; a1: A };\n\n        noinline fn either(ref a: B) a.a0 || a.a1;\n\n        fn main() {\n            mut b0 = B( A([ 1, 2, 3, 4, 5, 6, 7, 8 ]),\n                        A([ 9, 10, 11, 12, 13, 14, 15, 16 ]));\n\n            let b1 = b0;\n\n            ref a0 = either(b0);\n            a0.ints.clear();\n            a0.ints ~= 1;\n\n            return    1 * b0.a0.ints.len +   10 * b0.a1.ints.len\n                 +  100 * b1.a0.ints.len + 1000 * b1.a1.ints.len\n                 - 8881;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_PUvBFFkwSCc
                                #define STR_PUvBFFkwSCc
static const fu::str str_PUvBFFkwSCc fu_INIT_PRIORITY(1015) { "\n        struct TokenIdx { tokidx: i32 };\n\n        fn FAIL(implicit _here: TokenIdx, reason: string): never\n            throw(_here && reason);\n\n        noinline fn opaque_bool_check(lt: string)\n            return !!lt;\n\n        fn Lifetime_process(lt: string, each) {\n            fn visit(chars) {\n                for (mut i = 0; i < chars.len; i++) {\n                    fn climb(mut parent: string) {\n                        visit(parent);\n                        continue;\n                    }\n\n                    each(climb?: fn climb, chars.slice(i, chars.len))\n                    i == chars.len - 1 || <alt>FAIL<alt/>throw</alt>(\"here-0\");\n                }\n            }\n\n            visit(lt);\n        }\n\n        fn main() {\n            let implicit mut _here: TokenIdx;\n\n            fn fail(mut reason: string, backtrack!?: string): never {\n                if (backtrack) _here = [];\n                return FAIL(reason);\n            }\n\n            fn climbWhat(mut str: string) {\n                str || fail(\"here-1\");\n                str.pop();\n                return str;\n            }\n\n            mut result = \"\";\n            Lifetime_process(\"abc\", each: |lt, climb|\n            {\n                result ~= lt;\n                let init = lt.climbWhat;\n                if (init.opaque_bool_check)\n                    climb(init);\n            });\n\n            return result == \"abcababbcbc\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Ax1cuLTlcrd
                                #define STR_Ax1cuLTlcrd
static const fu::str str_Ax1cuLTlcrd fu_INIT_PRIORITY(1015) { "\n        struct Module { modid: i32; scope: string[] }\n        struct Target { modid: i32; globid: i32 }\n        struct Solver { scope: string[]; tp: string }\n\n        // This hit flatCount asserts in lifetime paths during bck\n        fn test(\n            implicit ref ctx:       Module[],\n            using implicit ref ss:  Solver,\n            target:                 Target)\n        {\n            ref s = ctx.len > target.modid\n                    ? ctx[target.modid].scope\n                    : scope;\n\n            return s.len > target.globid\n                    ? s[target.globid]\n                    : tp;\n        }\n\n        fn main() {\n            implicit mut ss = Solver(scope: [ \"h\", \"w\" ], tp: \"Hello!\");\n            implicit mut ctx = [\n                Module(modid: 0, scope: [ \"hello\", \"world\" ]),\n                Module(modid: 1, scope: [ \"Hello\", \"World\" ]),\n            ];\n\n            let append = \", \" ~ test(Target(modid: 1, globid: 1))\n                       ~ \"! \" ~ test(Target(modid: 0, globid: 2));\n\n            ref res = test(Target(modid: 0, globid: 0));\n            res ~= append;\n\n            return res == \"hello, World! Hello!\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Opn6EtAfLEa
                                #define STR_Opn6EtAfLEa
static const fu::str str_Opn6EtAfLEa fu_INIT_PRIORITY(1015) { "\n        struct Target       { modid: i32; globid: i32 }\n        struct SolvedNode   { items: SolvedNode[]; target?: Target }\n\n        fn stealInit(ref allNodes: SolvedNode[], t: Target)\n        {\n            fn GET_mut(target: Target)\n                allNodes[target.globid];\n\n            ref node = GET_mut(t);\n            if (node.items && node.items[0]) {\n                mut init: SolvedNode;\n                swap(init, node.items[0]); // flatCount mismatch here\n                return init;\n            }\n\n            return [];\n        }\n\n        fn main() {\n            mut allNodes = [\n                SolvedNode([\n                    SolvedNode([\n                        SolvedNode(),\n                    ]),\n                ]),\n            ];\n\n            novec fn count(items: SolvedNode[]) {\n                mut count = items.len;\n                items.each: |node| count += node.items.count;\n                return count;\n            }\n\n            let cnt0 = allNodes.count;\n            let init = stealInit(allNodes, Target(0, 0));\n            let cnt1 = [ init ].count;\n            let cnt2 = allNodes.count;\n\n            return cnt0 == 3 && cnt1 == 2 && cnt2 == 2 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_AOmOYBUv8d8
                                #define STR_AOmOYBUv8d8
static const fu::str str_AOmOYBUv8d8 fu_INIT_PRIORITY(1015) { "\n        noinline fn test(ref ints: i32[], ref iview: i32[..]) {\n            inline fn a() {\n                mut empty: i32[];\n                ref indirect = ints || empty;\n                indirect ~= indirect;\n            }\n\n            inline fn b() {\n                mut empty: i32[];\n                ref indirect = iview || empty;\n\n                ref head = indirect[.. indirect.len / 2];\n                for (mut i = 0; i < head.len; i++) head[i] *= 2;\n\n                ref tail = indirect[indirect.len - indirect.len / 2 ..];\n                for (mut i = 0; i < tail.len; i++) tail[i] *= 2;\n            }\n\n            <fail at call to test 26:24+4 both alias ints 25:17+4>\n            a(); b(); <pass/>\n            b(); a(); </fail>\n        }\n\n        fn main() {\n            mut ints = [ 1, 2, 3, 4, 5 ];\n            test(ints, ints);\n            return ints == [ 2, 4, 3, 8, 10, 2, 4, 3, 8, 10 ] ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_PKgFEDbZS74
                                #define STR_PKgFEDbZS74
static const fu::str str_PKgFEDbZS74 fu_INIT_PRIORITY(1015) { "\n        struct TEA { a: byte[]; b: byte[] };\n\n        fn hash(ref res: TEA, u8view: byte[]) {\n            let u32len  = u8view.len & ~3;\n            let u32view = u8view[.. u32len];\n            ref out     = res.a || res.b;\n            out        ~= out;\n            mut x       = u32view ~ \"?\";\n            out        ~= x;\n        }\n\n        fn main() {\n            mut res: TEA;\n            res.b = \"hello, world! \";\n            hash(res, res.b);\n            return res.b == \"hello, world! hello, world! hello, world?\"\n                 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_nbN5PDOmP5a
                                #define STR_nbN5PDOmP5a
static const fu::str str_nbN5PDOmP5a fu_INIT_PRIORITY(1015) { "\n        struct TwoVecs { a: i32[]; b: i32[] };\n\n        noinline fn disjoint_refs(ref tv: TwoVecs) {\n            <alt>\n            ref         <alt/>\n            noinline fn <alt/>\n            inline fn   </alt> a = tv.a;\n\n            <alt>\n            ref         <alt/>\n            noinline fn <alt/>\n            inline fn   </alt> b = tv.b;\n\n            a ~= b; // 21\n            b ~= a; // 32\n            a ~= b; // 53\n        }\n\n        fn main() {\n            mut tv = TwoVecs(\n                [  1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ],\n                [ 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ]);\n\n            disjoint_refs(tv);\n            return tv.a.len - 53;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_pKtGSuMWjE8
                                #define STR_pKtGSuMWjE8
static const fu::str str_pKtGSuMWjE8 fu_INIT_PRIORITY(1015) { "\n        nocopy struct PrimArray { prims: i32[]; }\n        nocopy struct Node { index: i32; items?: Node[]; }\n        nocopy struct SolverState { _root: Node; _prim_arrays: PrimArray[] }\n\n        noinline fn AAR_typesCantAlias_lifetimesIntersect(using ref ss: SolverState)\n        {\n            fn unorderedPrep_B(ref root: Node) {\n                let index  = root.index;\n                if (_prim_arrays.len > index) {\n                    ref eph     = _prim_arrays[index];\n                    eph.prims  ~= root.index += eph.prims.len;\n                               // ^^^^^^^^^^ should notice eph can't alias root\n                }\n            }\n\n            return _root.unorderedPrep_B();\n        }\n\n        fn main() {\n            mut ss = SolverState(Node(), [ PrimArray() ]);\n            ss.AAR_typesCantAlias_lifetimesIntersect();\n            return ss._prim_arrays.len == 1 && ss._prim_arrays[0].prims.len == 1 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_M2KtAtxahm4
                                #define STR_M2KtAtxahm4
static const fu::str str_M2KtAtxahm4 fu_INIT_PRIORITY(1015) { "\n        struct TokenIdx { modid: i32 }\n        struct SolverState { _solver_safety: int }\n\n        noinline fn doTrySpecialize(\n            there: TokenIdx,\n            using implicit ref _ss: SolverState,\n            implicit ref _here: TokenIdx)\n        {\n            let here0   = _here; ///// <- this emitted a const auto&,\n            _here       = TokenIdx( /////// immediately clobbered here\n                _here.modid + there.modid);\n\n            let solver_safety0  = _solver_safety++;\n            if (solver_safety0 > 1)\n                return _here.modid ~ \":\" ~ there.modid ~ \";\";\n\n            defer {\n                _here           = here0;\n                _solver_safety  = solver_safety0;\n            }\n\n            return _here.modid ~ \";\";\n        }\n\n        fn main() {\n            implicit mut _here: TokenIdx;\n            implicit mut _ss: SolverState;\n\n            mut res = \"\";           res ~= doTrySpecialize(TokenIdx(1));\n            _ss._solver_safety++;   res ~= doTrySpecialize(TokenIdx(2));\n            _ss._solver_safety++;   res ~= doTrySpecialize(TokenIdx(3));\n            _ss._solver_safety++;   res ~= doTrySpecialize(TokenIdx(4));\n\n            return res == \"1;2;3:3;7:4;\" ? 0 : 1;                 ;; DuplicateFunctions\n        }\n    "_fu };
                                #endif

                                #ifndef STR_umNewjR2R63
                                #define STR_umNewjR2R63
static const fu::str str_umNewjR2R63 fu_INIT_PRIORITY(1015) { "\n        struct TokenIdx { modid: i32 }\n        struct SolverState { _solver_safety: int }\n\n        noinline fn doTrySpecialize(\n            there: TokenIdx,\n            using implicit ref _ss: SolverState,\n            implicit ref _here: TokenIdx)\n        {\n            let here0   = _here; ///// <- this emitted a const auto&,\n            _here       = TokenIdx( /////// immediately clobbered here\n                _here.modid + there.modid);\n\n            let solver_safety0  = _solver_safety++;\n            if (solver_safety0 > 1) {\n                return _here.modid ~ \":\" ~ there.modid ~ \";\";\n            }\n            else {\n                defer {\n                    _here           = here0;\n                    _solver_safety  = solver_safety0;\n                }\n\n                if (_here.modid & 1)\n                    return _here.modid ~ \";\";\n            }\n\n            return _here.modid ~ \"!\";\n        }\n\n        fn main() {\n            implicit mut _here: TokenIdx;\n            implicit mut _ss: SolverState;\n\n            mut res = \"\";           res ~= doTrySpecialize(TokenIdx(1));\n            _ss._solver_safety++;   res ~= doTrySpecialize(TokenIdx(2));\n            _ss._solver_safety++;   res ~= doTrySpecialize(TokenIdx(3));\n            _ss._solver_safety++;   res ~= doTrySpecialize(TokenIdx(4));\n\n            return res == \"1;0!3:3;7:4;\" ? 0 : 1;                 ;; DuplicateFunctions\n        }\n    "_fu };
                                #endif

                                #ifndef STR_hDZQ3DkoIoe
                                #define STR_hDZQ3DkoIoe
static const fu::str str_hDZQ3DkoIoe fu_INIT_PRIORITY(1015) { "\n        // Same thing as above, i had forgotten to remove a missing-failcase note,\n        //  reduced again and only saw the test above once i was looking for a spot for this one.\n        fn deferAfterConditionalThrow_danglesConstRef(\n            mut _here: string, ref _solver_safety: int)\n        {\n            fn doTrySpecialize() {\n                let here0   = _here;        ;; N_NonTrivAutoCopy\n                _here       = [];\n                if (_solver_safety++ >= 128) throw(\"woot\");\n                defer _here = here0;\n                return 0;\n            }\n\n            doTrySpecialize();\n            return _here;\n        }\n\n        fn main() {\n            mut _solver_safety = 0;\n            return deferAfterConditionalThrow_danglesConstRef(\n                \"Hello\", _solver_safety).len - 5;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_qpb1j19imC7
                                #define STR_qpb1j19imC7
static const fu::str str_qpb1j19imC7 fu_INIT_PRIORITY(1015) { "\n        fn incr_out(ref out: i32[][], a: i32[], b: i32[]) {\n            out ~= a;\n            out ~= b;\n        }\n\n        fn incr_state(ref state: i32[]) {\n            state ~= state.len;\n            return state;\n        }\n\n        fn bck_discards_its_edits_to_defer_nodes(\n            ref out: i32[][], ref state: i32[])\n        {\n            incr_out        (:out, incr_state(state), incr_state(state));\n            defer incr_out  (:out, incr_state(state), incr_state(state));\n            return out;\n        }\n\n        fn main() {\n            mut state = [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ];\n            mut out: i32[][];\n            bck_discards_its_edits_to_defer_nodes(:out, :state);\n\n            mut result = 0;\n            for (mut i = 0; i < out.len; i++) {\n                let item = out[i];\n                result += item.len << ((3 - i) * 4);\n            }\n\n            return result.u32 == 0xabcd ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_JAKl4QAgDLh
                                #define STR_JAKl4QAgDLh
static const fu::str str_JAKl4QAgDLh fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            ref res = {                                         ;; GNUStmtExpr\n                :BRK {\n                    mut data = [ 1, 2, 3, 4, 5 ];\n                    <fail ref DONT_DANGLE_ME invalidated by write to data 11:38+2>\n                    ref <pass/>\n                    let </fail> DONT_DANGLE_ME = data[2 .. 3];\n                    for (mut i = 0; i < 2; i++)\n                        if !(i & 1)\n                            for (mut j = 0; j < 8; j++)\n                                data ~= data;\n                        else\n                            break :BRK DONT_DANGLE_ME;          ;; Goto\n\n                    data\n                }\n            };\n\n            mut sum = 0;\n            for (mut i = 0; i < res.len; i++) sum += res[i];\n            return sum - 3;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_ZxdCm8kgzvj
                                #define STR_ZxdCm8kgzvj
static const fu::str str_ZxdCm8kgzvj fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            ref res = {                                         ;; GNUStmtExpr\n                :BRK {\n                    mut data = [ 1, 2, 3, 4, 5 ];\n                    <fail write to mut data 12:34+2 invalidates ref DONT_DANGLE_ME invalidates 10:40+14 next loop iter>\n                    ref <pass/>\n                    let </fail> DONT_DANGLE_ME = data[2 .. 3];\n                    for (mut i = 0; i < 2; i++)\n                        if (i & 1)\n                            break :BRK DONT_DANGLE_ME;          ;; Goto\n                        else for (mut j = 0; j < 8; j++)\n                            data ~= data;\n\n                    data\n                }\n            };\n\n            mut sum = 0;\n            for (mut i = 0; i < res.len; i++) sum += res[i];\n            return sum - 3;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_W4ssiwgNQLb
                                #define STR_W4ssiwgNQLb
static const fu::str str_W4ssiwgNQLb fu_INIT_PRIORITY(1015) { "\n        noinline fn test(ref data: int[],\n            <fail at call to test 26:37+14 both alias mut data 17:17+4>\n            ref <pass/>\n            mut </fail>DONT_DANGLE_ME: int[])\n        {\n            for (mut i = 0; i < 2; i++)\n    <alt>\n                if (i & 1)\n                    return DONT_DANGLE_ME;\n                else for (mut j = 0; j < 8; j++)\n                    data ~= data;\n    <alt/>\n                if !(i & 1) for (mut j = 0; j < 8; j++)\n                                data ~= data;\n                else\n                    return DONT_DANGLE_ME;\n    </alt>\n            return data;\n        }\n\n        fn main() {\n            mut data = [ 1, 2, 3, 4, 5 ];\n            ref DONT_DANGLE_ME = data[2 .. 3];\n\n            fn sum(arr: int[]) {\n                mut sum = 0;\n                for (mut i = 0; i < arr.len; i++) sum += arr[i];\n                return sum;\n            }\n\n            return sum(test(:data, :DONT_DANGLE_ME)) - 3;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Ncrg9Qd4OV0
                                #define STR_Ncrg9Qd4OV0
static const fu::str str_Ncrg9Qd4OV0 fu_INIT_PRIORITY(1015) { "\n        noinline fn test(ref data: int[]) {\n            for (mut i = 0; i < 2; i++)\n    <alt>\n                if (i & 1)\n                    return DONT_DANGLE_ME;\n                else for (mut j = 0; j < 8; j++)\n                    data ~= data;\n    <alt/>\n                if !(i & 1) for (mut j = 0; j < 8; j++)\n                                data ~= data;\n                else\n                    return DONT_DANGLE_ME;\n    </alt>\n            return data;\n        }\n\n        fn main() {\n            mut data = [ 1, 2, 3, 4, 5 ];\n            implicit shadow <fail at call to test 24:24+4 both alias mut data 14:17+4>\n                        ref <pass/>\n                        mut </fail>DONT_DANGLE_ME = data[2 .. 3];\n\n            fn sum(arr: int[]) {\n                mut sum = 0;\n                for (mut i = 0; i < arr.len; i++) sum += arr[i];\n                return sum;\n            }\n\n            return sum(test(:data)) - 3;\n        }\n\n        fn DONT_DANGLE_ME(implicit shadow DONT_DANGLE_ME: int[]) {\n            return DONT_DANGLE_ME;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_nymB0yMEwFi
                                #define STR_nymB0yMEwFi
static const fu::str str_nymB0yMEwFi fu_INIT_PRIORITY(1015) { "Cannot resolve aliasing by temporary copy test:DONT_DANGLE_ME is implicit 24:24+4 14:17+4"_fu };
                                #endif

                                #ifndef STR_5dc6nxGHwC2
                                #define STR_5dc6nxGHwC2
static const fu::str str_5dc6nxGHwC2 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut data = [ 1, 2, 3, 4, 5 ];\n\n            <fail main:DONT_DANGLE_ME main:data both alias mut data 3:17+4>\n            ref <pass/>\n            let </fail> DONT_DANGLE_ME = data[2 .. 3];\n            noinline fn test() {\n                for (mut i = 0; i < 2; i++)\n        <alt>\n                    if (i & 1)\n                        return DONT_DANGLE_ME;\n                    else for (mut j = 0; j < 8; j++)\n                        data ~= data;\n        <alt/>\n                    if !(i & 1) for (mut j = 0; j < 8; j++)\n                                    data ~= data;\n                    else\n                        return DONT_DANGLE_ME;\n        </alt>\n                return data;\n            }\n\n            fn sum(arr: int[]) {\n                mut sum = 0;\n                for (mut i = 0; i < arr.len; i++) sum += arr[i];\n                return sum;\n            }\n\n            return sum(test) - 3;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Y9s0dAohcZk
                                #define STR_Y9s0dAohcZk
static const fu::str str_Y9s0dAohcZk fu_INIT_PRIORITY(1015) { "\n        struct Map(type K) { index: K[] }\n\n        noinline fn bckUsedInALoopFalsePositive(ref map: Map(int)) {\n            map.index ~= 10\n\n            // Original manual inline of the testcase below\n            ref outer = map.index[0 .. map.index.len];\n            for (mut i = 0; i < outer.len; i++) {\n                let b = outer[i]\n\n                // Writes to 'inner' invalidate 'outer',\n                //  but the return below makes sure we'll never use 'outer' again.\n                shadow ref inner = map.index[0 .. map.index.len];\n                for (shadow mut i = 0; i < inner.len; i++) {\n                    ref a = inner[i]\n                    a = b + 1\n                }\n\n                inner ~= inner.len;\n                return; // <- we dont use 'outer' again if we wrote through 'inner'\n            }\n\n            outer ~= outer.len;\n        }\n\n        fn main() {\n            mut map: Map(int)\n            map.bckUsedInALoopFalsePositive()\n            return map.index[0] == 11 ? 0 : 1\n        }\n    "_fu };
                                #endif

                                #ifndef STR_sajh9U8V839
                                #define STR_sajh9U8V839
static const fu::str str_sajh9U8V839 fu_INIT_PRIORITY(1015) { "\n        struct Map(type K) { index: K[] }\n\n        noinline fn bckUsedInALoopFalsePositive(ref map: Map(int))\n        {\n            // Manual inline of the testcase that follows.\n            ref outer = map.index[0 .. map.index.len - 1];\n            for (mut i = 0; i < outer.len; i++) {\n                ref b = outer[i]\n                if !(b & 1)\n                {\n                    // Writes to 'inner' invalidate 'outer',\n                    //  but the return below makes sure we'll never use 'outer' again.\n                    shadow ref inner = map.index[i ..];\n                    for (shadow mut i = 0; i < inner.len; i++)\n                        inner = [ inner[i] + 1 ]\n\n                    return; // <- we dont use 'outer' again if we wrote through 'inner'\n                }\n\n                b++\n            }\n        }\n\n        fn main() {\n            mut map = Map(int)([ 9, 10, 101, 102, 1001, 1002, 10001, 10002 ])\n            map.bckUsedInALoopFalsePositive()\n            return map.index == [ 10, 11 ] ? 0 : 1\n        }\n    "_fu };
                                #endif

                                #ifndef STR_InyKrlsJrp4
                                #define STR_InyKrlsJrp4
static const fu::str str_InyKrlsJrp4 fu_INIT_PRIORITY(1015) { "\n        struct Map(type K) { index: K[] }\n\n        inline fn probe(ref index: int[], hash: int, visit) {\n            for (mut i = 0; i < index.len; i++)\n                visit(entry: index[(hash + i) & (index.len - 1)])\n\n            index ~= index.len // Rellocate to trigger bck\n        }\n\n        inline fn incr(ref map: Map(int), hash: int, visit?) {\n            probe(:map.index, :hash): |entry!b| {\n                map.index.probe(:hash): |ref entry!a| a = b + 1 ;; PointlessMustSeq\n                return visit()\n            }\n        }\n\n        noinline fn bckUsedInALoopFalsePositive(ref map: Map(int)) {\n            map.index ~= 10\n            map.incr(0)\n        }\n\n        fn main() {\n            mut map: Map(int)\n            map.bckUsedInALoopFalsePositive()\n            return map.index[0] == 11 ? 0 : 1\n        }\n    "_fu };
                                #endif

                                #ifndef STR_g8p58qVSzIc
                                #define STR_g8p58qVSzIc
static const fu::str str_g8p58qVSzIc fu_INIT_PRIORITY(1015) { "\n        primitive DataPos:  int\n\n        nocopy struct IndexEntry {\n            hash:           int\n            data_pos:       DataPos\n        }\n\n        pub struct Map {\n            index:          IndexEntry[]\n            data:           int[]\n        }\n\n        inline fn hash_mask(index)\n            index.len && index.len - 1\n\n        fn ref(ref map: Map, hash!: int, visit) {\n            mut ref value = {\n                :SEARCH {                                       ;; GNUStmtExpr\n                    for (;;) {                                  ;; Goto\n                        ref index   = map.index\n                        let mask    = index.hash_mask           ;; !N_NonTrivAutoCopy\n                        let i       = hash & mask\n\n                        if (index.len > i) {\n                            ref index_entry = index[i]\n                            let data_pos = DataPos(map.data.len)\n                            index_entry = IndexEntry(:hash, :data_pos)\n\n                            map.data.grow(map.data.len + 1)\n                            break :SEARCH map.data[data_pos.int]\n                        }\n                        else {\n                            index.grow(index.len + 1)\n                        }\n                    }\n                }\n            }\n\n            return visit(:value)\n        }\n\n        fn main() {\n            mut map: Map\n            map.ref(hash: 0, visit: |ref value| value = 0)\n            return map.data.len - 1\n        }\n    "_fu };
                                #endif

                                #ifndef STR_v2Ob5tAa8Lc
                                #define STR_v2Ob5tAa8Lc
static const fu::str str_v2Ob5tAa8Lc fu_INIT_PRIORITY(1015) { "\n        nocopy struct IndexEntry { data_pos: int }\n        struct Map { index: IndexEntry[]; data: int[] }\n\n        inline fn hash_mask(index) index.len && index.len - 1;\n\n        fn ref(ref map: Map, hash!: int, visit) {\n            mut ref data_entry = {\n                :SEARCH {\n                    for (;;) {\n                        ref index   = map.index;\n                        let mask    = index.hash_mask;          ;; GNUStmtExpr\n                        let i       = hash & mask;\n\n                        for (;;) {\n                            if (i >= index.len) {\n                                index.grow(index.len + 1);      <alt>\n                                if (index.len & 1)\n                                    break;                      </alt>\n                            }\n                            else {\n                                ref index_entry = index[i];\n                                index_entry.data_pos = map.data.len;\n                                map.data.grow(map.data.len + 1);\n                                break :SEARCH map.data[index_entry.data_pos];\n                            }                                   ;; Goto\n                        }\n                    }\n                }\n            }\n                                        <alt>\n            visit(data_entry);          <alt/>\n            return visit(data_entry);   </alt>\n        }\n\n        noinline fn test(ref map: Map, i: int)\n            map.ref(hash: i, visit: |ref value| value = i);\n\n        fn main() {\n            mut map: Map;\n            test(map, 1);\n            return map.data.len - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_svVY0gA6fu5
                                #define STR_svVY0gA6fu5
static const fu::str str_svVY0gA6fu5 fu_INIT_PRIORITY(1015) { "\n        noinline fn sliceRelaxDanglesView(ref array: i32[], ref view: i32[]) {\n            for (mut j = 0; j < 4; j++)\n                for (mut i = view.len; i --> 0; )\n                    array ~= view[i];\n\n            return view;\n        }\n\n        fn main() {\n            mut array = [ 1, 1, 1, 1, 1, 1, 1, 1 ];\n            sliceRelaxDanglesView(array, array);\n            mut sum = 0;\n            for (mut i = 0; i < array.len; i++) sum += array[i];\n            return sum == 128 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_XSAPer3T5fl
                                #define STR_XSAPer3T5fl
static const fu::str str_XSAPer3T5fl fu_INIT_PRIORITY(1015) { "\n        struct TwoArrays { a: i32[]; b: i32[] };\n        noinline fn what(ref arr: i32[], ref w: TwoArrays) {\n            w.b ~= w.a;\n            w.b ~= arr;\n        }\n\n        fn main() {\n            mut ab = TwoArrays([ 1, 2, 3 ], [ 4, 5, 6 ]);\n            what(ab.a[1 ..], ab);\n            return ab.b == [ 4, 5, 6, 1, 2, 3, 2, 3 ] ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_GNZDg2ofY9l
                                #define STR_GNZDg2ofY9l
static const fu::str str_GNZDg2ofY9l fu_INIT_PRIORITY(1015) { "\n        struct SolvedNode                           <alt>\n            { items: SolvedNode[]; target: int }    <alt/>\n            { target: int; items: SolvedNode[] }    </alt>\n\n        fn assertPathsValidChainTooDeep(ref node: SolvedNode) {\n            fn isFieldChain(n: SolvedNode)\n                n.items.len == 1 && n.items[0].isFieldChain || n.target;\n\n            return isFieldChain(node);\n        }\n\n        fn main() {\n            mut v  = SolvedNode([    ], target: 1);\n            mut f1 = SolvedNode([  v ], target: 2);\n            mut f2 = SolvedNode([ f1 ], target: 3);\n            return assertPathsValidChainTooDeep(f2) -= 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_xiA4fkkpz2a
                                #define STR_xiA4fkkpz2a
static const fu::str str_xiA4fkkpz2a fu_INIT_PRIORITY(1015) { "BUG pathDepth > 64, we're likely stuck in an infinite loop 7:48+12"_fu };
                                #endif

                                #ifndef STR_Uxd6RwIJ5K4
                                #define STR_Uxd6RwIJ5K4
static const fu::str str_Uxd6RwIJ5K4 fu_INIT_PRIORITY(1015) { "\n        struct Target   { globid: int[] }\n        struct Entity   { quals: int[]; specs?: Spec[] }\n        struct Spec     { relax: int[]; inst: Target }\n\n        noinline fn redundantCopiesOfCopies(    <fail not mutref redundantCopiesOfCopies:entities 7:17+8><pass/>\n            ref                                 </fail>\n                entities: Entity[], target: Target)\n        {\n            fn GET_mut(t) entities[t.globid.len];\n\n            fn lazySolveStart(t: Target) {\n                ref o           = GET_mut(t);\n                let specs       = o.specs;\n                let actual      = o.quals;\n\n                for (mut i = 0; i < specs.len; i++) {\n                    let spec        = specs[i];\n                    shadow let t    = spec.inst;\n                    shadow ref o    = GET_mut(t);\n\n                    if (min(actual.len, spec.relax.len) == spec.relax.len) {\n                        o = [];\n                        return lazySolveStart(t);\n                    }\n                }\n            }\n\n            return lazySolveStart(target);\n        }\n\n        fn main() {\n            mut entities = [\n                Entity([ 1 ], [ Spec([ 1 ], Target([ 1 ])) ]),\n                Entity([ 2, 2 ]),\n                Entity([ 3, 3, 3 ]),\n            ];\n\n            redundantCopiesOfCopies(entities, []);\n            mut sum = 0;\n            entities.map(|v| sum += v.quals.len);\n            return sum - 4;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_MhZJG7dx5x6
                                #define STR_MhZJG7dx5x6
static const fu::str str_MhZJG7dx5x6 fu_INIT_PRIORITY(1015) { "\n        nocopy struct Node { items: Node[]; type: Node[] };\n\n        fn append_one(ref items: Node[]) {\n            items.push(Node());\n            return items;\n        }\n\n        fn count(ref type: Node[], ref items: Node[]) {\n            mut count = 0;\n            fn visit(n: Node) {\n                count++;\n                n.type.each(.visit);\n                n.items.each(.visit);\n            }\n\n            type.each(.visit);\n            items.each(.visit);\n            return count;\n        }\n\n        fn process(ref node: Node) {\n            return count(node.type, append_one(node.items));\n        }\n\n        fn main() {\n            mut node = Node( type: [ Node() ], items: [ Node(), Node() ] );\n            let count = process(node);\n            return count - 5;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_1cxfkW9df2j
                                #define STR_1cxfkW9df2j
static const fu::str str_1cxfkW9df2j fu_INIT_PRIORITY(1015) { "BUG CODEGEN recur without SS_FN_RECUR 13:24+4"_fu };
                                #endif

                                #ifndef STR_sJhZOKz92T7
                                #define STR_sJhZOKz92T7
static const fu::str str_sJhZOKz92T7 fu_INIT_PRIORITY(1015) { "\n        struct Node     { items?: Node[]; target: int }\n        struct Extended { min: i32; node?: Node }\n\n        fn solve(root: Node, ref _extended: Extended)\n        {\n            noinline fn GET() _extended.node;\n            noinline fn EXT() _extended;\n\n            fn unorderedPrep_A(node: Node) {\n                ref o       = GET();\n                ref ext     = EXT();\n                ext.min     = 0x7fffffff.i32;\n                o           = node;\n            }\n\n            return unorderedPrep_A(root);\n        }\n\n        fn main() {\n            mut _extended: Extended;\n            solve(Node([], 11), :_extended);\n            return _extended.min == i32.MAX && _extended.node.target == 11 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_L67XPFk7rS9
                                #define STR_L67XPFk7rS9
static const fu::str str_L67XPFk7rS9 fu_INIT_PRIORITY(1015) { "\n        struct Child  { hello: int; irrelevant?: string };\n        struct Parent { world?: int; children?: Child[] };\n\n        fn test(ref parents: Parent[], t: int) {\n            fn getParent(index: int)    parents[index];\n            fn getChild(index: int)     getParent(index).children[index];\n\n            ref c = getChild(t);        c.hello++;\n            ref p = getParent(t);       p.world++;\n        }\n\n        fn main() {\n            mut parents = [ Parent(children: [ Child() ]) ];\n            test(parents, 0);\n\n            mut sum = 0;\n            fn count(what: <What>)\n                case (What.is::primitive)       sum += what.int;\n                case (What -> _[])              what.each(.count);\n                default for (fieldname i: What) what.i.count();\n\n            count(parents);\n            return sum - 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_lbVGS9KSFgc
                                #define STR_lbVGS9KSFgc
static const fu::str str_lbVGS9KSFgc fu_INIT_PRIORITY(1015) { "\n        struct ArrayTuple { a: i32[]; b: i32[] };\n        struct TupleTuple { a: ArrayTuple; b: ArrayTuple };\n        fn main() {\n            mut tt: TupleTuple;\n            tt.b.b      = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, -1 ];\n\n            <fail cannot access ref fin 16:22+3 ref inval ref other_2 14:25+2>\n            ref <pass/>\n            mut </fail> fin = tt.b.b[tt.b.b.len - 1];\n\n            ref other   = tt.b;\n            ref other_2 = other.b;\n            for (mut i = 0; i < 8; i++)\n                other_2 ~= other_2.map(|v| v + 1);\n\n            return ++fin;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_hNJgAGwCBn3
                                #define STR_hNJgAGwCBn3
static const fu::str str_hNJgAGwCBn3 fu_INIT_PRIORITY(1015) { "\n        struct Pad4 { a: int; b: int; c: int; d: int };\n        struct Pad16 { a: Pad4; b: Pad4; c: Pad4; d: Pad4 };\n        struct Pad64 { a: Pad16; b: Pad16; c: Pad16; d: Pad16 };\n        struct Pad256 { a: Pad64; b: Pad64; c: Pad64; d: Pad64 };\n\n        struct Data {\n            pad_front?: Pad256;\n            ints: int[];\n            pad_back?: Pad256;\n        }\n\n        fn main() {\n            mut data = Data(ints: [ 1, 2, 3, 4, 5, 6, 7, 8, 9, -1 ]);\n\n            <fail cannot access ref fin 22:22+3 ref inval (data|v) (20:27+2|20:43+2)>\n            ref <pass/>\n            mut </fail> fin = data.ints[data.ints.len - 1];\n    <alt>\n            ref v = data.ints;\n            for (mut i = 0; i < 8; i++) v ~= v.map(|w| w + 1);\n    <alt/>\n            for (mut i = 0; i < 8; i++)\n                data.ints ~= data.ints.map(|v| v + 1);\n    </alt>\n            return ++fin;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_FKqrN6Hm17b
                                #define STR_FKqrN6Hm17b
static const fu::str str_FKqrN6Hm17b fu_INIT_PRIORITY(1015) { "\n        fn Ensure(ref a: <T>[], exists!i: int) {\n            if (a.len <= i) a.grow(i + 1);\n            return a[i];\n        }\n\n        struct Thing4   { a: int; b: int; c: int; d: int }\n        struct Thing16  { a: Thing4; b: Thing4; c: Thing4; d: Thing4 }\n        struct Thing64  { a: Thing16; b: Thing16; c: Thing16; d: Thing16 }\n        struct Thing256 { a: Thing64; b: Thing64; c: Thing64; d: Thing64 }\n\n        struct SolverState {\n            _pad_before:    Thing256;\n            _warnings:      int[];\n            _pad_after:     Thing256;\n        }\n\n        fn search(using ref ss: SolverState, t: int)\n            _warnings.Ensure(exists: t) ||= t;\n\n        fn main() {\n            mut ss: SolverState;\n            ss.search(0);\n            ss._warnings.len - 1\n        }\n    "_fu };
                                #endif

                                #ifndef STR_oAhHoHEU56g
                                #define STR_oAhHoHEU56g
static const fu::str str_oAhHoHEU56g fu_INIT_PRIORITY(1015) { "\n        nocopy struct AB { a: int; b: int };\n\n        fn main() {\n            mut v0 = AB(1, 2);\n            mut v1 = v0;\n            ref a = v0.a;\n            ref b = v1.b;\n            a += 10;\n            b += a;\n            return b - 13;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_sB9bzAwwUdc
                                #define STR_sB9bzAwwUdc
static const fu::str str_sB9bzAwwUdc fu_INIT_PRIORITY(1015) { "cannot cop or mov 6:22+2"_fu };
                                #endif

                                #ifndef STR_p1TRI1HZycj
                                #define STR_p1TRI1HZycj
static const fu::str str_p1TRI1HZycj fu_INIT_PRIORITY(1015) { "\n        <fail cannot cop or mov 8:22+2 v0 is used again>\n        nocopy <pass/></fail>\n        struct AB { a: int; b: int };\n\n        fn main() {\n            mut v0 = AB(1, 2);\n            mut v1 = v0;\n            ref a = v0.a;\n            ref b = v1.a;\n            a += 10;\n            b += a;\n            return b - 12;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_ERkLCYTa8N5
                                #define STR_ERkLCYTa8N5
static const fu::str str_ERkLCYTa8N5 fu_INIT_PRIORITY(1015) { "\n        struct SolverState  {\n            overloads:          string[];\n            eph?:               int;\n        }\n\n        fn solve(ref ss: SolverState) {\n            fn GET(t) ss.overloads[t];\n            ref t = ss.eph;\n            t.GET = t.GET ~ \", world!\";\n            return t.GET;\n        }\n\n        fn main() {\n            mut ss = SolverState(overloads: [ \"hello\" ] );\n            ss.solve();\n            return ss.overloads.only.len - 13;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_SNYVOshXQJ2
                                #define STR_SNYVOshXQJ2
static const fu::str str_SNYVOshXQJ2 fu_INIT_PRIORITY(1015) { "cannot access t 11:20+1 inval by GET 8:35+1"_fu };
                                #endif

                                #ifndef STR_0fBGgGkT5fi
                                #define STR_0fBGgGkT5fi
static const fu::str str_0fBGgGkT5fi fu_INIT_PRIORITY(1015) { "\n        struct SolverState {\n            overloads:          string[];\n            eph:                int;\n        };\n\n        fn solve(ref ss: SolverState) {\n            mut output = \"\";\n            fn qID(id: string) id || \"?\";\n            fn name(t: int) ss.overloads[t].qID;\n            ref t = ss.eph;\n            output = t.name();\n            t = [];\n            return output;\n        }\n\n        fn main() {\n            mut ss = SolverState([ \"hello\", \"world!\" ], 1);\n            return ss.solve.len + ss.solve.len - 11;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_UtWTYNNeeV4
                                #define STR_UtWTYNNeeV4
static const fu::str str_UtWTYNNeeV4 fu_INIT_PRIORITY(1015) { "\n        struct Node { handle: int; items: Node[] }\n        struct Doc { raw_plaintexts: string[]; root_node?: Node }\n\n        fn assertPathsValid_badFlatCount(ref tree: Doc) {\n            fn visit(ref node: Node) {\n                mut plaintext: string;\n                swap(tree.raw_plaintexts[node.handle], plaintext);\n\n                node.handle = [];\n                node.items  = [];\n                return plaintext;\n            }\n\n            return visit(tree.root_node);\n        }\n\n        fn main() {\n            mut d = Doc(raw_plaintexts: [ \"Hello!\" ]);\n            return d.assertPathsValid_badFlatCount.len - 6;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_CcCHgTPau7h
                                #define STR_CcCHgTPau7h
static const fu::str str_CcCHgTPau7h fu_INIT_PRIORITY(1015) { "\n        struct Node { handle: int; items: Node[] }\n        struct Doc { raw_plaintexts: string[]; root_node?: Node }\n\n        fn assertPathsValid_badFlatCount(ref tree: Doc) {\n            fn visit(ref node) {\n                node.items.each(.visit);                        ;; PointlessMustSeq\n\n                mut plaintext: string;\n                swap(plaintext, tree.raw_plaintexts[node.handle]);\n\n                node.handle = 0;\n                return plaintext;\n            }\n\n            return visit(tree.root_node);\n        }\n\n        fn main() {\n            mut d = Doc(raw_plaintexts: [ \"Hello!\" ]);\n            return d.assertPathsValid_badFlatCount.len - 6;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_sIoceH3ZiTa
                                #define STR_sIoceH3ZiTa
static const fu::str str_sIoceH3ZiTa fu_INIT_PRIORITY(1015) { "\n        fn hello(a: <A>, do) {\n            mut ev = [ 10, 20, 30, 40, 50 ];        <alt>\n            ref ev_WITH_A = !(A -> []) && ev;       <alt/>\n            let WITH_A = !(A -> []);\n            ref ev_WITH_A = WITH_A && ev;           </alt>\n            ev ~= 60;\n            (do(ev_WITH_A));\n        }\n\n        fn main() {\n            hello(0): |ref x| {\n                x ~= 70;\n                return x.len - 7;\n            }\n        }\n    "_fu };
                                #endif

                                #ifndef STR_b5SHhsoZdCc
                                #define STR_b5SHhsoZdCc
static const fu::str str_b5SHhsoZdCc fu_INIT_PRIORITY(1015) { "\n        struct TEA { v0: u32; v1: u32 }\n\n        noinline fn r8(using ref _: TEA)\n            for (mut i = 0; i < 8; i++)\n                v1 += ((v0<<4) + 0xAD90777D)\n                    ^ ((v0>>5) + 0x7E95761E);\n\n        struct RenderCache(type T) { tea: TEA; noise: T[] };\n\n        noinline fn renderFrame(ref rc: RenderCache(_))\n            simulated_annealing(:rc.noise, :rc.tea);\n\n        noinline fn simulated_annealing(ref noise: _[], ref tea: TEA)\n            for (mut iter = noise.len; iter --> 0; ) {\n                tea.r8();\n                noise.swap(\n                    (tea.v0 % noise.len.unsigned).signed,\n                    (tea.v1 % noise.len.unsigned).signed);\n            }\n\n        fn main() {\n            mut rc = RenderCache(int)(TEA(), [ 1, 2, 3, 4 ]);\n            rc.renderFrame();\n            mut sum = 0;\n            rc.noise.each: |v| sum += v;\n            return sum - 10;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_1cLasDUM6h7
                                #define STR_1cLasDUM6h7
static const fu::str str_1cLasDUM6h7 fu_INIT_PRIORITY(1015) { "BUG assertPathsValid expect_flatCount(1) != flatCount(2) 12:45+2"_fu };
                                #endif

                                #ifndef STR_m9B302EJS32
                                #define STR_m9B302EJS32
static const fu::str str_m9B302EJS32 fu_INIT_PRIORITY(1015) { "\n        nocopy struct Val { x: i32 };\n        struct Out { v: Val };\n        fn move_Val_into_Out(mut v: Val)    = Out(:v);\n        fn main()                           = move_Val_into_Out(Val(0)).v.x;\n    "_fu };
                                #endif

                                #ifndef STR_0tG5TYZbLY1
                                #define STR_0tG5TYZbLY1
static const fu::str str_0tG5TYZbLY1 fu_INIT_PRIORITY(1015) { "\n        fn must_not_move_mystr(n: i32) {\n            mut mystr = \"\";\n            for (mut i = 0; i < n; i++)\n                mystr ~= \"!\";\n\n            mut result: string[];\n            for (mut i = 0; i < n; i++)\n                result ~= mystr;\n\n            return result.join();\n        }\n\n        fn main() = must_not_move_mystr(3).len - 9;\n    "_fu };
                                #endif

                                #ifndef STR_lPGwgVhKOKl
                                #define STR_lPGwgVhKOKl
static const fu::str str_lPGwgVhKOKl fu_INIT_PRIORITY(1015) { "\n        struct Type {\n            canon: string;\n            quals: int;\n        };\n\n        fn takes_ref_and_val(ref r!: Type, mut v!: Type) {\n            v.canon ~= r.canon;\n            r.canon ~= v.canon;\n            v.quals |= r.quals;\n            return r;\n        }\n\n        fn main() {\n            mut t = Type(\"abc\", 123);\n            return takes_ref_and_val(r: t, v: t).canon.len - 9;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_jbOHBlEMYi7
                                #define STR_jbOHBlEMYi7
static const fu::str str_jbOHBlEMYi7 fu_INIT_PRIORITY(1015) { "\n        struct Type {\n            canon: string;\n            quals: int;\n        };\n\n        fn takes_two_strings(mut a: Type, mut b: Type) {\n            b.canon ~= a.canon;\n            a.canon ~= b.canon;\n            a.quals |= b.quals;\n            return a;\n        }\n\n        fn move_on_last_use_OOE(mut canon: string, quals: int) {\n            canon ~= canon;\n            return takes_two_strings(   ;; N_MoveMustSeq\n                Type(:canon, :quals),\n                Type(:canon, :quals));  // out of order move-into-struct will break this\n        }\n\n        fn main() {\n            let res = move_on_last_use_OOE(\n                \"1234567890abcdef1234567890abcdef\" // len=32, *2 = 64, *3 = 192\n                    1000);\n\n            return res.canon.len + res.quals - 1192;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_nHH3vGaxek9
                                #define STR_nHH3vGaxek9
static const fu::str str_nHH3vGaxek9 fu_INIT_PRIORITY(1015) { "\n        struct Type {\n            canon: string;\n            quals: int;\n        };\n\n        fn takes_two_strings_and_an_int(mut a: Type, mut b: Type, c: int) {\n            b.canon ~= a.canon;\n            a.canon ~= b.canon;\n            a.quals |= b.quals;\n            a.quals += c;\n            return a;\n        }\n\n        fn moves_reordered_by_bck_OOE(mut canon: string, mut quals: int) {\n            canon ~= canon;\n            return takes_two_strings_and_an_int(    ;; N_MoveMustSeq\n                Type(:canon, 0),\n                Type(:canon, quals++), // quals++ triggered bck MUSTSEQ\n                             quals  ); //  which reordered arg b BEFORE arg a,\n        }                              //   which broke move-on-last-use.\n\n        fn main() {\n            let res = moves_reordered_by_bck_OOE(\n                \"1234567890abcdef1234567890abcdef\" // len=32, *2 = 64, *3 = 192\n                    0);\n\n            return res.canon.len + res.quals - 193;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_C9pp6hmkode
                                #define STR_C9pp6hmkode
static const fu::str str_C9pp6hmkode fu_INIT_PRIORITY(1015) { "\n        fn track_last_loop_confusion(mut a: string, mut b: string)\n        {\n            for (mut i = 0; i < 6; i++) {\n                a ~= a; // foil smallstring opti\n                b ~= b; //  both are 64 chars long\n            }\n\n            ref x = a.len == 64 ? b : a;\n            ref y = b.len == 64 ? x : a; // y points to b two refs deep\n\n            mut result = b; // <-- BROKEN MOVE FROM b HERE\n\n            // once\n            for (mut i = result.len / 64; i --> 0; ) {\n                y ~= y;         // now 128, ensures y not a view\n                result ~= y;    // for a total of 192\n            }\n\n            return result;\n        }\n\n        fn main() {\n            mut res = track_last_loop_confusion(\"a\", \"b\");\n            return res.len == 192 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_UdVSZ8zMVk2
                                #define STR_UdVSZ8zMVk2
static const fu::str str_UdVSZ8zMVk2 fu_INIT_PRIORITY(1015) { "COW will break 17:27+1 9:17+1"_fu };
                                #endif

                                #ifndef STR_e07NkpWpAP6
                                #define STR_e07NkpWpAP6
static const fu::str str_e07NkpWpAP6 fu_INIT_PRIORITY(1015) { "\n        nocopy struct NCItem { x: i32 };\n\n        fn unshift_odds_push_evens(n: i32) {\n            mut arr: NCItem[];\n            for (mut i = 0; i < n; i++) {\n                let item = NCItem(i);\n                if (i & 1)  arr.unshift(item);                  ;; !*MustSeq\n                else        arr.push(item);\n            }\n            return arr;\n        }\n\n        fn main() {\n            let arr = unshift_odds_push_evens(3);\n            return arr[0].x == 1\n                && arr[1].x == 0\n                && arr[2].x == 2 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_K4CGxXvZ5P0
                                #define STR_K4CGxXvZ5P0
static const fu::str str_K4CGxXvZ5P0 fu_INIT_PRIORITY(1015) { "\n        nocopy struct NCThing { x: i32 };\n\n        fn last_used_before_break(mut nc: NCThing, N: i32) {\n            mut res: NCThing;\n            for (mut i = 0; i < N; i++) {\n                nc.x *= 2;\n                if (nc.x > 10) {\n                    if (nc.x > 20) return nc;\n                    res = nc; // <- should move here ...\n                    break;\n                }\n            }\n\n            <fail cannot be copied or moved 10:27 mut arg nc is used again>\n            if (nc.x > 15) return nc; // <- ... unless used here.\n            <pass/></fail>\n\n            res.x *= 10;\n            return res;\n        }\n\n        fn main() {\n            let res = last_used_before_break(NCThing(3), 10);\n            return res.x - 120;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_8ReSaeZX6V7
                                #define STR_8ReSaeZX6V7
static const fu::str str_8ReSaeZX6V7 fu_INIT_PRIORITY(1015) { "\n        nocopy struct NCThing { str: string };\n\n        fn last_used_in_defer(mut nc: NCThing, ref other: NCThing) {\n            defer other = nc; // last use, move here!\n            while (nc.str.len < 64)\n                nc.str ~= nc.str;\n\n            <fail cannot be copied or moved 10:20 mut arg nc is used again>\n            return nc;                     <pass/>\n            return nc.str.len;             </fail>\n        }\n\n        fn main() {\n            mut other: NCThing;\n            last_used_in_defer(NCThing(\"Hello!\"), other);\n            return other.str.len - 96;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_ZXGTHhqKwF9
                                #define STR_ZXGTHhqKwF9
static const fu::str str_ZXGTHhqKwF9 fu_INIT_PRIORITY(1015) { "\n        nocopy struct Node { nodes: Node[]; }\n\n        noinline fn add(a: i32, b: i32) {\n            return a + b;\n        }\n\n        fn main() {\n            mut res = Node([ Node ]);\n            mut cpy: Node;\n\n            mut res_len = 0;\n            mut cpy_len = 0;                                    ;; N_MoveMustSeq\n            <alt>\n            mut sum = (res_len = res.nodes.len) + (cpy_len = (cpy = res).nodes.len); <alt/>\n            mut sum = add(res_len = res.nodes.len, cpy_len = (cpy = res).nodes.len); </alt>\n\n            return cpy.nodes.len == cpy_len\n                && res_len == 1\n                && cpy_len == 1\n                && sum == 2             ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_MfFWscBTsVd
                                #define STR_MfFWscBTsVd
static const fu::str str_MfFWscBTsVd fu_INIT_PRIORITY(1015) { "\n        nocopy struct NC { ncs: NC[] };\n\n        struct Foreign { name: NC; kind: i32; flags: i32 };\n        struct Local   { kind: i32; flags: i32; name: NC };\n\n        fn intoLocal(using mut f: Foreign) = Local(:kind, :flags, :name);\n\n        <split/>\n        fn main() {\n            let foreign = Foreign(NC([ NC(), NC() ]), 0, 0);\n            let local = intoLocal(foreign);\n            return local.name.ncs.len - 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Er28gnY0mj3
                                #define STR_Er28gnY0mj3
static const fu::str str_Er28gnY0mj3 fu_INIT_PRIORITY(1015) { "\n        struct A { items: i32[] };\n        struct B { items: i32[] };\n\n        <alt>\n        fn takesRef_OOE(ref a: A, b: B) <alt/>\n        fn takesRef_OOE(b: B, ref a: A) </alt>\n            a.items ~= b.items;\n\n        struct C { items: i32[] };\n\n        fn C2B(mut c: C) B(c.items);\n\n        fn selectA(mut c: C, ref a0: A, ref a1: A) {\n            ref a   = c.items.len & 1 ? a0 : a1;\n            a.items = c.items;\n            return a;\n        }\n\n        fn main() {\n            mut c = C([ 1, 2, 3, 4, 5, 6, 7 ]);\n            mut a0: A;\n            mut a1: A;\n\n            takesRef_OOE(                                       ;; N_MoveMustSeq\n                a: selectA(:c, :a0, :a1),\n                b: C2B(:c));\n\n            return a0.items.len - 14;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_N5EyWI2Biyh
                                #define STR_N5EyWI2Biyh
static const fu::str str_N5EyWI2Biyh fu_INIT_PRIORITY(1015) { "\n        nocopy struct NoCopy { a: i32[]; b: i32[] };\n\n        noinline fn mustRelaxMut(mut nc: NoCopy)\n            nc.a.len - nc.b.len;\n\n        fn main() {\n            mut x = NoCopy([ 0 ], [ 0, 1 ]);\n            mut y = NoCopy([ 0, 1, 2, 3 ], [ 0, 1, 2 ]);\n            for (mut i = 0; i < 10; i++) {\n                if (mustRelaxMut(x) + mustRelaxMut(y))\n                    return 1;\n\n                x.a.push(x.a.len);\n                y.b.push(y.b.len);\n            }\n\n            return 0;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_lOjRy2S54C7
                                #define STR_lOjRy2S54C7
static const fu::str str_lOjRy2S54C7 fu_INIT_PRIORITY(1015) { "\n        nocopy struct NonTriv { items: NonTriv[] }\n                                                                            <alt>\n        fn moveViaHoisted(mut a: NonTriv, mut b: NonTriv) {                 <alt/>\n        fn moveViaHoisted(val a: NonTriv, val b: NonTriv) { ;; ConstCast    <alt/>\n        fn moveViaHoisted(ref a: NonTriv, ref b: NonTriv) { ;; ConstCast    <alt/>\n        fn moveViaHoisted(    a: NonTriv,     b: NonTriv) { ;; ConstCast    </alt>\n            if (ref either = a || b) return either;\n            return [];\n        }\n\n        fn main() {\n            mut b = moveViaHoisted(NonTriv(), NonTriv([ NonTriv() ]));\n            mut a: NonTriv;\n            swap(b, a);\n            return a.items.len - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_ZKeYzfmbqR2
                                #define STR_ZKeYzfmbqR2
static const fu::str str_ZKeYzfmbqR2 fu_INIT_PRIORITY(1015) { "\n        <alt>\n        nocopy </alt>\n        struct NonTriv { a: NonTriv[]; b: NonTriv[] }\n\n        noinline fn test(a: NonTriv[], b: NonTriv[], which: int) which & 1 ? a : b;\n        noinline fn balance(ref a: NonTriv[]) while !(a.len & 1) a ~= NonTriv();\n    "_fu };
                                #endif

                                #ifndef STR_RjAh6PW3xu1
                                #define STR_RjAh6PW3xu1
static const fu::str str_RjAh6PW3xu1 fu_INIT_PRIORITY(1015) { "\n        import _0;\n        fn moveOrDefault(which: int) {\n            mut a = [ NonTriv(), NonTriv() ];\n        <alt>\n            mut b = test(a, [], which);                         ;; ConstCast\n        <alt/>\n            ref c = which & 1 ? a : [];\n            mut b = test(a, c, which);                          ;; ConstCast\n        </alt>\n            b.balance();\n            return (b.len + 1) & 1;\n        }\n        fn main() moveOrDefault(0) * 10 + moveOrDefault(1) * 100;\n    "_fu };
                                #endif

                                #ifndef STR_eq1W8BeKfu5
                                #define STR_eq1W8BeKfu5
static const fu::str str_eq1W8BeKfu5 fu_INIT_PRIORITY(1015) { "\n        <alt>\n        nocopy </alt>\n        struct NonTriv { a: NonTriv[]; b: NonTriv[] }\n\n        noinline fn test(a: NonTriv, b: NonTriv, which: int) which & 1 ? a : b;\n        noinline fn balance(ref a: NonTriv) while (a.b.len < a.a.len) a.b ~= NonTriv();\n    "_fu };
                                #endif

                                #ifndef STR_Y5RmIFOFVt8
                                #define STR_Y5RmIFOFVt8
static const fu::str str_Y5RmIFOFVt8 fu_INIT_PRIORITY(1015) { "\n        import _0;\n        fn moveOrDefault(which: int) {\n            mut a = NonTriv([ NonTriv(), NonTriv() ], [ NonTriv() ]);\n        <alt>\n            mut b = test(a, [], which);                         ;; ConstCast\n        <alt/>\n            ref c = which & 1 ? a : [];\n            mut b = test(a, c, which);                          ;; ConstCast\n        </alt>\n            b.balance();\n            return b.a.len - b.b.len;\n        }\n        fn main() moveOrDefault(0) * 10 + moveOrDefault(1) * 100;\n    "_fu };
                                #endif

                                #ifndef STR_ty91wj3Sla8
                                #define STR_ty91wj3Sla8
static const fu::str str_ty91wj3Sla8 fu_INIT_PRIORITY(1015) { "\n        fn E(modid: int) {\n            try {\n                modid && throw(modid & 1 && \"A\" ~ modid);\n                return [];\n            }\n            catch (e) {\n                return e || \"B\" ~ modid;\n            }\n        }\n\n        fn main() {\n            let e = E(0) ~ E(1) ~ E(2);\n            return e == \"A1B2\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_6uMGyExTuKh
                                #define STR_6uMGyExTuKh
static const fu::str str_6uMGyExTuKh fu_INIT_PRIORITY(1015) { "\n        inline   fn inl  (x: string) x;\n        noinline fn noinl(x: string) x;\n\n        noinline fn opaque_concat(                          <alt>\n            items.inl[]:   string[..]   ;; ConstCast\n                                        ;; PointlessLocal   <alt/>\n            items.noinl[]: string[..]   ;; ConstCast        <alt/>\n            items[]:       string[..]                       </alt>\n        ) {\n            mut sum = 0;\n            for (mut i = 0; i < items.len; i++) sum += items[i].len;\n            return sum;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_0AYAm403K2j
                                #define STR_0AYAm403K2j
static const fu::str str_0AYAm403K2j fu_INIT_PRIORITY(1015) { "\n        import _0;\n        fn main() opaque_concat(\"\", []);\n    "_fu };
                                #endif

                                #ifndef STR_X9aWJCzFH87
                                #define STR_X9aWJCzFH87
static const fu::str str_X9aWJCzFH87 fu_INIT_PRIORITY(1015) { "\n        fn setupOperators() {\n            mut out: struct { P: Map(string, i32) };\n            fn binop(op: string) out.P[op] = 7;\n            binop(\",\");\n            return out;\n        }\n\n        let BINOP = setupOperators();\n        let P_COMMA = BINOP.P[\",\"] || throw(\"Assertion failed.\");\n        fn main() P_COMMA - 7;\n    "_fu };
                                #endif

                                #ifndef STR_vyKKp6AnhJa
                                #define STR_vyKKp6AnhJa
static const fu::str str_vyKKp6AnhJa fu_INIT_PRIORITY(1015) { "\n        // -no-lambda\n        // This converted to a ref-returning\n        // logical chain for some reason.\n        let hex = true;\n        let trail = \"x\";\n        if (!(trail >= \"0\" && trail <= \"9\") &&\n            !(hex && (trail >= \"a\" && trail <= \"f\"\n                   || trail >= \"A\" && trail <= \"F\")))\n        {\n            return 0;\n        }\n\n        return 1;\n    "_fu };
                                #endif

                                #ifndef STR_LaX2eFJlOpk
                                #define STR_LaX2eFJlOpk
static const fu::str str_LaX2eFJlOpk fu_INIT_PRIORITY(1015) { "\n        struct Type     { i: i32; };\n        struct Token    { i: i32; };\n        struct ScopeIdx { i: i32; };\n\n        struct SolvedNode\n        {\n            kind:       string;\n            flags?:     i32;\n            value?:     string;\n            items?:     SolvedNode[];\n            token:      Token;\n\n            type:       Type;\n            target?:    ScopeIdx;\n        };\n\n        let _here: Token;\n\n        fn createDefaultInit(type: Type): SolvedNode\n        {\n            // Broken arg re-arrange.\n            return SolvedNode(\n                kind: \"definit\",\n                token: _here,\n                :type);\n        }\n\n        return createDefaultInit(Type()).target.i;\n    "_fu };
                                #endif

                                #ifndef STR_XOofzIkzwXl
                                #define STR_XOofzIkzwXl
static const fu::str str_XOofzIkzwXl fu_INIT_PRIORITY(1015) { "\n        struct Type         { i: i32; };\n        struct Scope        { i: i32; };\n        struct Partial      { i: i32; };\n        struct Template     { i: i32; };\n        struct SolvedNode   { i: i32; };\n\n        fn Scope_add(\n            ref scope: Scope,\n            kind: string, id: string, type: Type,\n\n            min: i32 = 0,\n            max: i32 = 0,\n            arg_n: string[]     = [],\n            arg_t: Type[]       = [],\n            arg_d: SolvedNode[] = [],\n            template: Template  = [],\n            partial: Partial    = []): i32\n        {\n            return scope.i\n                 + kind.len + id.len + type.i\n                 + min + max + arg_n.len + arg_t.len + arg_d.len\n                 + template.i + partial.i;\n        }\n\n        mut _scope: Scope;\n        let id: string;\n        let t_template: Type;\n        let min: i32;\n        let max: i32;\n        let arg_n: string[];\n        let template: Template;\n\n        return Scope_add(\n            _scope,\n            \"\", id, t_template,\n            min, max, arg_n,\n            :template);\n    "_fu };
                                #endif

                                #ifndef STR_n2qDSukJtXb
                                #define STR_n2qDSukJtXb
static const fu::str str_n2qDSukJtXb fu_INIT_PRIORITY(1015) { "\n        let i = 0;\n        let items = [ \"\" ];\n        i == items.len - 1 || throw(\"what?\");\n        return i;\n    "_fu };
                                #endif

                                #ifndef STR_yuIUno1H8j3
                                #define STR_yuIUno1H8j3
static const fu::str str_yuIUno1H8j3 fu_INIT_PRIORITY(1015) { "\n        return false /* test */\n             ? 0xffffff.i32 // what is this\n             : 0 // madness\n             ;\n    "_fu };
                                #endif

                                #ifndef STR_mNK2Vf31P2k
                                #define STR_mNK2Vf31P2k
static const fu::str str_mNK2Vf31P2k fu_INIT_PRIORITY(1015) { "\n        fn test(id: i32) id;\n        return test(/*id*/0); // <- bad parse\n    "_fu };
                                #endif

                                #ifndef STR_3DA9WPFB5i9
                                #define STR_3DA9WPFB5i9
static const fu::str str_3DA9WPFB5i9 fu_INIT_PRIORITY(1015) { "\n        fn path_normalize(p: string): string {\n            mut path = p.split(\"/\");\n\n            for (mut i = path.len; i --> 0; ) {\n                let part: &string = path[i];\n                if (part == \".\" || !part && i > 0 && i < path.len - 1)\n                    path.splice(i, 1);\n            }\n\n            return path.join(\"/\");\n        }\n\n        fn main() path_normalize(\"./hello///hey\") == \"hello/hey\" ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_EuOZOWWnzai
                                #define STR_EuOZOWWnzai
static const fu::str str_EuOZOWWnzai fu_INIT_PRIORITY(1015) { "\n        fn path_normalize(p: string): string {\n            mut path = p.split(\"/\");\n\n            for (mut i = path.len; i --> 0; ) {\n                let part = path[i];\n                if (part == \".\" || !part && i > 0 && i < path.len - 1)\n                    path.splice(i, 1);\n            }\n\n            for (mut i = 1; i < path.len; i++) {\n                if (path[i] == \"..\")\n                    path.splice(--i, 2);\n            }\n\n            return path.join(\"/\");\n        }\n\n        fn path_join(a: string, b: string)\n            path_normalize(a ~ \"/\" ~ b);\n\n        fn main()\n            path_join(\"hello/hey\", \"./../you//\") == \"hello/you/\"\n                ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_nu3MwoZEQR8
                                #define STR_nu3MwoZEQR8
static const fu::str str_nu3MwoZEQR8 fu_INIT_PRIORITY(1015) { "\n        pub struct Template { locals: ScopeMemo; }; // <- used ahead of the def, was missing q_trivial\n        pub struct ScopeMemo { x: i32; }; // <- trivial, discovered on solve here after Template is done\n        pub fn +(a: ScopeMemo, b: ScopeMemo) a.x + b.x; // <- used here after both structs are done\n\n        pub fn main() {\n            let a = Template(ScopeMemo(+3));\n            let b = Template(ScopeMemo(-3));\n            return a.locals + b.locals; // <- fails to match.\n        }\n    "_fu };
                                #endif

                                #ifndef STR_2J19eVEnGuh
                                #define STR_2J19eVEnGuh
static const fu::str str_2J19eVEnGuh fu_INIT_PRIORITY(1015) { "\n        novec fn novec_each(ref a: $T[], fn)\n            for (mut i = 0; i < a.len; i++)\n                fn(a[i]);\n\n        fn main() {\n            mut a = [ 1 ];\n            a.novec_each: |ref i| i *= 2;\n            return a[0] - 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Slt2amkSfyg
                                #define STR_Slt2amkSfyg
static const fu::str str_Slt2amkSfyg fu_INIT_PRIORITY(1015) { "\n        novec fn Each(ref a: $T[..], fn)\n            for (mut i = 0; i < a.len; i++)\n                fn(a[i]);\n\n        struct Node { kind: string; items: Node[]; flags: i32; };\n\n        let F_PREDICATE = 2;\n\n        fn parse(tokens: byte[]): Node {\n            mut _idx = 0;\n\n            fn parseStructDecl(flags! = 0): Node {\n                mut items = parseBlockLike('}');\n\n                :F_PREDICATE {\n                    items.Each: |item|\n                        if (item.kind == \"let\")\n                            if (item.flags & F_PREDICATE)\n                                break :F_PREDICATE;             ;; Goto\n\n                    items.Each: |ref item|\n                        if (item.kind == \"let\")\n                            item.flags |= F_PREDICATE;\n                }\n\n                return Node(\"struct\", items, :flags);\n            }\n\n            fn parseBlockLike(endToken: byte): Node[] {\n                mut items: Node[] = [];\n                for (;;) {\n                    let token = tokens[_idx++];                 ;; !N_BckMustSeq\n                    if (token == endToken)                      ;; !N_MoveMustSeq\n                        break;\n\n                    items ~= Node(\"let\", [], flags: token == '+' && F_PREDICATE);\n                }\n\n                return items;\n            }\n\n            return parseStructDecl();\n        }\n\n        fn main() {\n            let tokens = \"+-}\";\n            let p = parse(tokens).items;\n            return p.len - p[0].flags\n                         + p[1].flags * 17;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_jjYdDvf5mp9
                                #define STR_jjYdDvf5mp9
static const fu::str str_jjYdDvf5mp9 fu_INIT_PRIORITY(1015) { "\n        pub struct MeshBuilder\n        {\n            verts?:     byte[];\n            indices?:   byte[];\n            vert_bytes: i32;\n            num_verts?: i32;\n        };\n\n        pub fn alloc(\n            using ref mb: MeshBuilder,\n            new_verts: i32,\n            new_indices: i32)\n        {\n            verts.resize_junk((verts.len + new_verts) * vert_bytes);\n\n            let index_bytes = 4;\n            indices.resize_junk((indices.len + new_indices) * index_bytes);\n        }\n\n        pub fn setup_quads(\n            using ref mb: MeshBuilder,  // <- the 'using' introduced more bindings,\n            num_quads: i32)             // <-  advancing the target index number of this arg,\n                : &mut byte[..]         // <-   confusing the callsite lifetime of this view.\n        {\n            let b0 = verts.len;\n            let v0 = num_verts;\n            let i0 = indices.len;\n\n            mut v1 = v0;\n\n            alloc(num_quads * 4, num_quads * 6);\n\n            ref indices_i32: i32[..] =\n                indices[i0 .. indices.len]\n                    .view(i32);\n\n            for (mut i = 0; i < indices_i32.len; i += 6)\n            {\n                indices_i32[i    ] = v1;\n                indices_i32[i + 1] = v1 + 1;\n                indices_i32[i + 2] = v1 + 2;\n\n                indices_i32[i + 3] = v1;\n                indices_i32[i + 4] = v1 + 2;\n                indices_i32[i + 5] = v1 + 3;\n\n                v1 += 4;\n            }\n\n            num_verts = v1;\n\n            return verts[b0 .. verts.len];\n        }\n\n        let QUAD_VBO: f32[] =\n        [\n            -1, -1, 0,      0, 0, 1,    0, 0,\n            +1, -1, 0,      0, 0, 1,    1, 0,\n            +1, +1, 0,      0, 0, 1,    1, 1,\n            -1, +1, 0,      0, 0, 1,    0, 1,\n        ];\n\n        pub fn main()\n        {\n            mut mb = MeshBuilder(\n                vert_bytes: 4 * (3+3+2));\n\n            mb.setup_quads(1).view(f32) .= QUAD_VBO;\n\n            return mb.num_verts - 4;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_LywBYH3xxzj
                                #define STR_LywBYH3xxzj
static const fu::str str_LywBYH3xxzj fu_INIT_PRIORITY(1015) { "\n        fn target(implicit ref _target: i32) _target;\n\n        // this suddenly reported that it doesn't see __solveStruct\n        fn GET_mut(ref x: i32) x || target;\n\n        // while i was trying to reproduce an ambig \"o\" fail here\n        fn __solveStruct(mut arg: i32): i32 {\n            if (arg) {\n                ref o = GET_mut(arg);\n                o++;\n                checkRecursions(o, o);\n            }\n            return arg;\n        }\n\n        fn checkRecursions(ref o: i32, incr: i32): void { GET_mut(o) += incr; }\n\n        fn main() {\n            implicit mut _target = 0;\n            return __solveStruct(1) - 4;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_9asArZHWPj4
                                #define STR_9asArZHWPj4
static const fu::str str_9asArZHWPj4 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut target = 0;\n            fn GET_mut(ref x: i32) x || GET_mut(target += 1);   ;; PointlessMustSeq\n            return GET_mut(target) - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_v9T2ZiteUuf
                                #define STR_v9T2ZiteUuf
static const fu::str str_v9T2ZiteUuf fu_INIT_PRIORITY(1015) { "\n        fn target(implicit ref _itarg: i32) _itarg;\n\n        fn main() {\n            implicit mut _itarg = 0;\n            fn GET_mut(ref x: i32) x || GET_mut(target += 1);   ;; PointlessMustSeq\n            return GET_mut(target) - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_KmftRAv7li1
                                #define STR_KmftRAv7li1
static const fu::str str_KmftRAv7li1 fu_INIT_PRIORITY(1015) { "\n        fn target(implicit ref _itarg: i32) _itarg;\n        fn GET_mut(ref x: i32) x || GET_mut(target += 1);       ;; PointlessMustSeq\n\n        fn main() {\n            implicit mut _itarg = 0;\n            return GET_mut(target) - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_8WN9I0ePNTh
                                #define STR_8WN9I0ePNTh
static const fu::str str_8WN9I0ePNTh fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut target = 0;\n            fn GET_mut(ref x: i32) x || GET_mut(++target);      ;; PointlessMustSeq\n            return GET_mut(target) - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_MBSJv6qgMVl
                                #define STR_MBSJv6qgMVl
static const fu::str str_MBSJv6qgMVl fu_INIT_PRIORITY(1015) { "\n        // TODO use something like pragma lax to opt-out of cc warnings.\n        // Output looks fine & works on gcc/clang but gcc warns and breaks build.\n        pragma emit(`#pragma GCC diagnostic ignored \"-Wsequence-point\"`);\n\n        fn main() {\n            mut target = 0;\n            fn __solveStruct(mut arg: i32): i32 {\n                ref o = GET_mut(arg); o += target;\n                return target;\n            }\n\n            fn GET_mut(ref x: i32)\n                x || (target = __solveStruct(target += 1));     ;; PointlessMustSeq\n\n            return __solveStruct(0) - 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_YLC0Y5M0zQ5
                                #define STR_YLC0Y5M0zQ5
static const fu::str str_YLC0Y5M0zQ5 fu_INIT_PRIORITY(1015) { "\n        fn incr(ref a: i32) ++a;\n        fn A(ref a: i32) a || (a = B(incr(a)));\n        fn B(ref b: i32) b || (b = A(incr(b)));\n        fn main() { mut v = 0; return A(v) - 1; }\n    "_fu };
                                #endif

                                #ifndef STR_JTKSIzNITn3
                                #define STR_JTKSIzNITn3
static const fu::str str_JTKSIzNITn3 fu_INIT_PRIORITY(1015) { "\n        fn incr(ref a: i32) ++a;\n        fn A(ref a: i32) { ref aa = a || (a = B(incr(a))); return aa; }\n        fn B(ref b: i32) { ref bb = b || (b = A(incr(b))); return bb; }\n        fn main() { mut v = 0; return A(v) - 1; }\n    "_fu };
                                #endif

                                #ifndef STR_eCJplqU8Hpe
                                #define STR_eCJplqU8Hpe
static const fu::str str_eCJplqU8Hpe fu_INIT_PRIORITY(1015) { "\n        fn main()\n        {\n            fn Each(cond, cons) cond && cons();\n            fn arg(implicit ref __arg: i32) __arg;\n            fn __solveStruct(x = 3) Each(arg, || arg += x);\n            implicit mut __arg = 1;\n            return __solveStruct - 4;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_U7f8Xk2iFF9
                                #define STR_U7f8Xk2iFF9
static const fu::str str_U7f8Xk2iFF9 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            fn Each(cond, cons)                     cond && cons();\n            fn arg_incr_x(mut arg: i32)             Each(arg, || arg);\n            return arg_incr_x(+7) - 7;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_I6Q0tBLEzu2
                                #define STR_I6Q0tBLEzu2
static const fu::str str_I6Q0tBLEzu2 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            fn Each(cond, cons)                     cond && cons();\n            fn arg_incr_x(mut arg: i32, x = 0)      Each(arg, || arg += x);\n            return arg_incr_x(+7, -11) + 4;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_NYr3DKkgNJf
                                #define STR_NYr3DKkgNJf
static const fu::str str_NYr3DKkgNJf fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            fn Each(cond, cons)                     cond && cons();\n            fn arg_incr_x(mut arg: i32, x = 0): i32 {\n                Each(arg, || arg += x);\n                return arg;\n            }\n            return arg_incr_x(+7, -11) + 4;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_bEx282N2IOg
                                #define STR_bEx282N2IOg
static const fu::str str_bEx282N2IOg fu_INIT_PRIORITY(1015) { "\n        fn main()\n        {\n            mut target = 0;\n\n            fn Each(cond, cons) cond && cons();\n\n            fn GET_mut(ref x: i32) x || (target = __solveStruct(target));\n\n            fn __solveStruct(mut arg: i32, x = 0): i32 {\n                Each(arg, || arg += x);\n                if (arg) {\n                    ref o = GET_mut(arg);\n                    o++;\n                    checkRecursions(o, o);\n                }\n                return arg;\n            }\n\n            fn checkRecursions(ref o: i32, incr: i32): void { GET_mut(o) += incr; }\n\n            return __solveStruct(1) - 4;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_qRHUeJQze50
                                #define STR_qRHUeJQze50
static const fu::str str_qRHUeJQze50 fu_INIT_PRIORITY(1015) { "\n        fn main()\n        {\n            mut target = 0;\n\n            // this suddenly reported that it doesn't see __solveStruct\n            fn GET_mut(ref x) x || (target = __solveStruct(target));\n\n            // while i was trying to reproduce an ambig \"o\" fail here\n            fn __solveStruct(mut arg: i32): i32 {\n                if (arg) {\n                    ref o = GET_mut(arg);\n                    o++;\n                    checkRecursions(o, o);\n                }\n                return arg;\n            }\n\n            fn checkRecursions(ref o: i32, incr: i32): void { GET_mut(o) += incr; }\n\n            return __solveStruct(1) - 4;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Blft4cK8ZLk
                                #define STR_Blft4cK8ZLk
static const fu::str str_Blft4cK8ZLk fu_INIT_PRIORITY(1015) { "\n        struct ValueType { modid: i32; };\n        struct Type { using vtype: ValueType; };\n        struct Target { modid: i32; index: i32; };\n        struct Overload { name: string; id: string; };\n\n        fn GET(target: Target): Overload =\n            Overload(\n                name: \"N\" ~ target.index,\n                  id: \"I\" ~ target.index);\n\n        fn main() {\n            mut specs: Map(string, Target);\n\n            fn setSpec(mangle: string) {\n                ref t = specs[mangle] ||= Target;\n\n                // This template should start expanding on GET(target).name,\n                //  which should conflict with overload name.\n                fn name(shadow target)\n                    GET(target) <fail ambig>\n                        .name;  <pass/>\n                        .id;    </fail>\n\n                return t.name;\n            }\n\n            return setSpec(\"hey\").len - 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_1PTEV8Q36t9
                                #define STR_1PTEV8Q36t9
static const fu::str str_1PTEV8Q36t9 fu_INIT_PRIORITY(1015) { "\n        pub struct ScopeSkip { start: i32; end: i32; };\n\n        pub fn Each(items: $T[..], scope_skip: ScopeSkip[], fn, start = 0) {\n            let END_DUMMY = ScopeSkip(start: items.len, end: items.len);\n\n            mut i0 = start;\n            for (mut i = 0; i < scope_skip.len + 1; i++) {\n                let ss = i < scope_skip.len ? scope_skip[i] : END_DUMMY;\n                if (ss.end <= i0)\n                    continue;\n\n                let i1 = ss.start;\n                for (shadow mut i = i0; i < i1; i++)\n                    fn(items[i]);\n\n                i0 = ss.end;\n            }\n        }\n\n        pub fn test(items?: i32[]) {\n            mut sum = 0;\n            let ss: ScopeSkip[];\n            items.Each(ss, |item| sum += item, start: sum);\n            return sum;\n        }\n\n        pub fn main() test();\n    "_fu };
                                #endif

                                #ifndef STR_I3G1yBinSj0
                                #define STR_I3G1yBinSj0
static const fu::str str_I3G1yBinSj0 fu_INIT_PRIORITY(1015) { "\n        fn setupOperators(P_PREFIX_UNARY) // <- template\n        {\n            struct BINOP {\n                PRECEDENCE:     Map(string, i32);\n                RIGHT_TO_LEFT:  Map(i32,   bool);\n            };\n\n            mut out: BINOP; // <- no BINOP in scope\n            mut precedence = P_PREFIX_UNARY;\n            mut rightToLeft = false;\n\n            fn binop(ops: string[]) {\n                precedence++;\n                out.RIGHT_TO_LEFT[precedence] = rightToLeft;\n                for (mut i = 0; i < ops.len; i++)\n                    out.PRECEDENCE[ops[i]] = precedence;\n            }\n\n            binop([ \"|>\" ]);\n\n            //\n            return out;\n        }\n\n        let BINOP = setupOperators(-1);\n\n        fn main() {\n            let precedence = BINOP.PRECEDENCE[\"|>\"];\n            return precedence;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_rOjQb9fxWab
                                #define STR_rOjQb9fxWab
static const fu::str str_rOjQb9fxWab fu_INIT_PRIORITY(1015) { "\n        fn Each(a: $T[..], fn, start!?: i32)\n            for (mut i = start; i < a.len; i++)\n                fn(a[i]);\n\n        fn main() {\n            mut sum = 0;\n            let a = [ 1, 2, 3 ];\n            a.Each(|i| sum += i, start: sum);   // <- start inferred to ref i32, which couldnt definit\n            return sum - 6;                     //     perhaps we can use the optionality to infer constness\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Lk8NMQEMyv4
                                #define STR_Lk8NMQEMyv4
static const fu::str str_Lk8NMQEMyv4 fu_INIT_PRIORITY(1015) { "\n        <fail novec>\n        novec // Abusing to test novec, unrelated to the test\n        <pass/></fail>\n        fn ScopeSkip_push(ref scope_skip: i32[]) {\n            if (scope_skip) scope_skip[0]++;\n            else            scope_skip ~= 1;\n        }\n\n        fn main() {\n            mut scope_skip = [ 1 ];\n            ScopeSkip_push(scope_skip);\n            return scope_skip[0] - 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_c3zqNj2eSHa
                                #define STR_c3zqNj2eSHa
static const fu::str str_c3zqNj2eSHa fu_INIT_PRIORITY(1015) { "\n        struct Hello { v: i32[] };\n\n        fn main() {\n            let h = Hello();\n\n            <fail novec>\n            novec // qSTACK bug with args.len == 0 at call to Hello\n            <pass/></fail>\n            fn hello(woot?: i32)\n                woot ? Hello() : h;\n\n            return hello.v.len;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_lROtY1IbeH0
                                #define STR_lROtY1IbeH0
static const fu::str str_lROtY1IbeH0 fu_INIT_PRIORITY(1015) { "\n        struct Module  { cpp:    string; };\n        struct Context { module: Module; };     // Simplification of next test, no need to consider COW here\n\n        fn snippet2cpp(cpp: string): string {\n            let ctx = Context( Module(cpp) );\n            {\n                let module = ctx.module;        // This was const Module& =  ... which can't be moved from.\n                if (module.cpp)\n                    return module.cpp;          ;; EXPECT return static_cast<fu::str&&>(module.cpp)\n            }\n\n            return \"\";\n        }\n\n        fn main() snippet2cpp(\"1\").len - 1;\n    "_fu };
                                #endif

                                #ifndef STR_Zbv96DdNHNf
                                #define STR_Zbv96DdNHNf
static const fu::str str_Zbv96DdNHNf fu_INIT_PRIORITY(1015) { "\n        struct Module  { cpp:     string;   };\n        struct Context { modules: Module[]; };  // Module[] is COW-capable -\n                                                //  - either prove there's no COW,\n        fn snippet2cpp(cpp: string): string {   //  - or don't attempt to move out the item.\n            let ctx = Context([ Module(cpp) ]);\n            for (mut i = 0; i < ctx.modules.len; i++)\n            {\n                let module = ctx.modules[i];    ;; TODO .unique(i)\n                if (module.cpp)\n                    return module.cpp;          ;; TODO return static_cast<fu::str&&>(module.cpp)\n            }\n\n            return \"\";\n        }\n\n        fn main() snippet2cpp(\"1\").len - 1;\n    "_fu };
                                #endif

                                #ifndef STR_gleWCRHfXnj
                                #define STR_gleWCRHfXnj
static const fu::str str_gleWCRHfXnj fu_INIT_PRIORITY(1015) { "\n        fn test(x: string) {\n            // cg fail: fwd annots of the two fns where unconsting hey to \"enable move\",\n            //          basically the decision was made in the wrong scope.\n            let hey = \"hey\";\n            fn inner(you: string) you && hey ~ you || outer(\"what#1\");\n            fn outer(arg: string) inner(arg && \" \" ~ arg) || inner(\"what#2\");\n            return outer(x);\n        }\n\n        fn main() test(\"you\").len - 7;\n    "_fu };
                                #endif

                                #ifndef STR_EyC9LKicYJ5
                                #define STR_EyC9LKicYJ5
static const fu::str str_EyC9LKicYJ5 fu_INIT_PRIORITY(1015) { "\n        struct Target { modid!: i32; packed!: i32; };\n        inline fn index(a: Target) a.packed;\n\n        <split/>\n\n        struct CurrentFn { using target: Target; };\n        fn hello(c?: CurrentFn) c.index;\n        fn main() hello;\n    "_fu };
                                #endif

                                #ifndef STR_DEGSojuzqOk
                                #define STR_DEGSojuzqOk
static const fu::str str_DEGSojuzqOk fu_INIT_PRIORITY(1015) { "\n        struct ID   { offset: i32;  };\n        struct Data { items:  ID[]; };\n\n        using fn Data(implicit all: Data[], nid: ID): Data {\n            return all[nid.offset];\n        }\n\n        fn test(node: ID) {\n            let init = node.items[0];\n            return init.items.len;\n        }\n\n        fn main() {\n            let implicit all =  [ Data([ ID(1)      ])\n                                , Data([ ID, ID, ID ]) ];\n\n            return 0.ID.test - 3;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_hjNW5v60Ch0
                                #define STR_hjNW5v60Ch0
static const fu::str str_hjNW5v60Ch0 fu_INIT_PRIORITY(1015) { "\n        struct Context\n        {\n            fuzzy: Map(string, string);\n            files: string[];\n        }\n\n        fn resolveFile(\n            implicit ref ctx: Context,\n            from: string, name: string): string\n        {\n            let path    = from ~ name;\n            let cached  = ctx.fuzzy[path];\n            if (cached)\n                return cached == \"\v\" ? \"\" : cached;\n\n            fn tryResolve(): string\n            {\n                let exists = file::size(path) >= 0;\n                if (exists)\n                    return path;\n\n                return \"\";\n            };\n\n            let resolve = tryResolve();\n            ctx.fuzzy[path] = resolve || \"\v\";\n            return resolve;\n        }\n\n        pub fn resolveFile(\n            implicit ref ctx: Context,\n            path: string): string\n        {\n            let fuzzy = path.find('\v');\n            if (fuzzy > 0)\n            {\n                let from = path.slice(0, fuzzy);\n                let name = path.slice(fuzzy + 1);\n                if (from && name && !name.has('\v'))\n                {\n                    let res = resolveFile(:from, :name);\n                    if (res)\n                        return res;\n\n                    // Tests have the files prepopulated,\n                    //  we only pay the cost of lookup when about to fail compile.\n                    let prepopulated = from ~ name;\n                    if (ctx.files.has(prepopulated))\n                        return prepopulated;\n                }\n            }\n\n            return path;\n        }\n\n        fn main() {\n            implicit mut ctx: Context;\n            return resolveFile(\"a\").len - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_hPsjR0vRtDk
                                #define STR_hPsjR0vRtDk
static const fu::str str_hPsjR0vRtDk fu_INIT_PRIORITY(1015) { "\n        struct S { i: i32; };\n\n        fn hello(ref s: S, w: i32) {\n            infix fn |=(<fail ambig 6:17><pass/>shadow </fail>ref s: S, v: i32)\n                s.i |= v << w;\n\n            s |= 2;\n        }\n\n        fn main() {\n            mut s = 1.S;\n            s.hello(3);\n            return s.i - 17;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_qzQlo69mI6i
                                #define STR_qzQlo69mI6i
static const fu::str str_qzQlo69mI6i fu_INIT_PRIORITY(1015) { "\n        fn lex(src: string) {\n            let end = src.len;\n            mut idx = 0;\n\n            fn err_str(idx1: i32) {\n                while (idx < end && src[idx] == ' ') idx++;\n                return src.slice(idx, idx1);\n            }\n\n            fn err(idx1_x2: i32) err_str(idx1_x2 /2);\n            return err(end *2);\n        }\n\n        fn main() lex(\"    hello\").len - 5;\n    "_fu };
                                #endif

                                #ifndef STR_lmnTq0pYQ25
                                #define STR_lmnTq0pYQ25
static const fu::str str_lmnTq0pYQ25 fu_INIT_PRIORITY(1015) { "\n        pub fn ZERO(implicit ref sum: i32, mut sources: string[]): void\n        {\n            // Fuzzing module splits.\n            for (mut i = 0; i < sources.len; i++)\n            {\n                for (;;)\n                {\n                    ref src     = sources[i];\n\n                    mut start0  = src.find(\"[split/]\");\n                    if (start0 < 0)\n                        break;\n\n                    let start00 = start0;\n                    let start1  = start0 + 8;\n                    while (start0 && src[start0 - 1] == ' ') start0--;\n\n                    let moduleA = src.slice(0, start0);\n                    let moduleB = src[start0 .. start00] ~ \"import _\" ~ i ~ \";\" ~ src[start1 .. src.len];\n                    let without = src[0 .. start0] ~ src[start1 .. src.len];\n\n                    sources[i]  = without;\n                    ZERO(:sources);\n\n                    sources[i]  = moduleA;\n                    sources.insert(i + 1, moduleB);\n                }\n\n                sum += sources[i].len;\n            }\n        }\n\n        fn main() {\n            implicit mut sum: i32;\n\n            ZERO( \"AAAA|BB[split/]CC\".split(\"|\") );\n            let expect = 4+2+2 + 4+2+2 + 10; // 10 = \"import _0;\"\n\n            return sum - expect;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_P8okKIaxyed
                                #define STR_P8okKIaxyed
static const fu::str str_P8okKIaxyed fu_INIT_PRIORITY(1015) { "\n        struct SolvedNode {\n            bli: i32;\n        };\n\n        // --> [2] ... triggered the solve of this fn, ...\n        fn SolvedNode(blah: string) {\n            return SolvedNode(blah.len.NOT_PREPPED_YET);\n        }\n\n        // [1] During prep, this type annotation ...\n        fn ARG_ANNOT_TRIGGERS_SOLVE(node: SolvedNode) {\n            return node.bli + 2;\n        }\n\n        // --> --> [3] ... which couldnt yet see this fn (prep didnt reach here).\n        fn NOT_PREPPED_YET(x: i32) {\n            return x * 2;\n        }\n\n        fn main() {\n            return ARG_ANNOT_TRIGGERS_SOLVE(SolvedNode(\"hello\")) - (2*5+2);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_mv2oOuIMnDj
                                #define STR_mv2oOuIMnDj
static const fu::str str_mv2oOuIMnDj fu_INIT_PRIORITY(1015) { "\n        struct SolvedNode       { nodeidx: i32; };\n        struct CurrentFn        { using out: SolvedNode; };\n\n        struct Target           { index: i32; };\n        struct SolvedNodeData   { target: Target; };\n        struct Overload         { nodes: SolvedNodeData[]; };\n\n        fn test(ref overloads: Overload[],\n                ref _current_fn: CurrentFn)\n        {\n            using fn GET(target: Target) {\n                let o = overloads[target.index];\n                return o;\n            }\n\n            using fn SolvedNodeData(nid: SolvedNode) {\n                let nodes = overloads[nid.nodeidx].nodes;\n                return nodes[nid.nodeidx];\n            }\n\n            let current_fn  = _current_fn.target;               // <- this is a ref into overloads\n            let debug_2     = current_fn && GET(current_fn);    // <- this is the perceived write to overloads\n            return debug_2 && current_fn.index;                 // <- which invalidates this read\n        }\n\n        fn main() {\n            mut _current_fn = CurrentFn(SolvedNode(0));\n            mut overloads   = [ Overload([ SolvedNodeData(Target(0)) ]) ];\n\n            return test(overloads, _current_fn);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_GYg4RLYQMAj
                                #define STR_GYg4RLYQMAj
static const fu::str str_GYg4RLYQMAj fu_INIT_PRIORITY(1015) { "\n        struct SolvedNode       { nodeidx: i32; };\n        struct CurrentFn        { using out: SolvedNode; };\n\n        struct Target           { index: i32; };\n        struct SolvedNodeData   { target: Target; };\n        struct Overload         { nodes: SolvedNodeData[]; };\n\n        fn test(ref overloads: Overload[],\n                ref _current_fn: CurrentFn)\n        {\n            using fn GET(target: Target) {\n                if (target.index != 303) // Same as above, different setup.\n                    return overloads[target.index];\n\n                return []; // Also this fails to solve: cannot definit mutref\n            }\n\n            using fn SolvedNodeData(nid: SolvedNode) {\n                return nid.nodeidx != 303 // Same as above, rewording as a logical.\n                    && overloads[nid.nodeidx].nodes[nid.nodeidx];\n            }\n\n            let current_fn  = _current_fn.target;               // <- this is a ref into overloads\n            let debug_2     = current_fn && GET(current_fn);    // <- this is the perceived write to overloads\n            return debug_2 && current_fn.index;                 // <- which invalidates this read\n        }\n\n        fn main() {\n            mut _current_fn = CurrentFn(SolvedNode(0));\n            mut overloads   = [ Overload([ SolvedNodeData(Target(0)) ]) ];\n\n            return test(overloads, _current_fn);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Ba2HIPbQOic
                                #define STR_Ba2HIPbQOic
static const fu::str str_Ba2HIPbQOic fu_INIT_PRIORITY(1015) { "\n        struct Token {\n            col: i32;\n            line: i32;\n            value: string;\n        };\n\n        fn parse(tokens: Token[]) {\n            mut _idx = 0;\n            mut _loc = 0;\n\n            fn fail(mut reason = \"\") {\n                let loc  = tokens[_loc];\n                let here = tokens[_idx];\n                if (!reason)\n                    reason = \"Unexpected '\" ~ here.value ~ \"'.\";\n\n                let l0 = loc.line;  let c0 = loc.col;\n                let l1 = here.line; let c1 = here.col;\n\n                let addr = l1 == l0\n                    ? \"@\" ~ l1 ~ \":\" ~ c1\n                    : \"@\" ~ l0 ~ \":\" ~ c0 ~ \"..\" ~ l1 ~ \":\" ~ c1;\n\n                return throw(addr ~ \":\\n\\t\" ~ reason);\n            }\n\n            fn consume(value: byte[..], err = \"\") {\n                let token = tokens[_idx];\n                if (token.value == value) {\n                    _idx++;\n                    return token;\n                }\n\n                return fail((err || \"Expected\") ~ \" '\" ~ value ~ \"', got '\" ~ token.value ~ \"'.\");\n            }\n\n            fn parseRoot() {\n                let ret = consume(\"sof\");\n                _loc = _idx;\n                return ret;\n            }\n\n            return parseRoot();\n        }\n\n        fn main() {\n            return parse([ Token(1, 1, \"sof\") ]).value.len - 3;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_antU2vtMPt3
                                #define STR_antU2vtMPt3
static const fu::str str_antU2vtMPt3 fu_INIT_PRIORITY(1015) { "\n        fn CallerNode(mut t?: i32, arr?: i32[])\n        {\n            for (mut i = 0; i < arr.len; i++) {\n                return CallerNode(arr[i]);\n                //     ^^^^^^^^^^\n                // fn CallerNode: Arg #1, arr not assignable to host_arg:\n                //      expect: []+252i32: ref copy resize\n                //      actual: []+252i32: ref\n            }\n\n            return t;\n        }\n\n        fn main() = CallerNode();\n    "_fu };
                                #endif

                                #ifndef STR_drETF6n0tH8
                                #define STR_drETF6n0tH8
static const fu::str str_drETF6n0tH8 fu_INIT_PRIORITY(1015) { "\n        struct Target       { index: i32; };\n        struct SolvedNode   { target: Target; args: SolvedNode[]; };\n\n        fn CallerNode(\n            mut target: Target,\n            mut args: SolvedNode[] = [],\n            reorder?: i32[],\n            conversions?: Target[][]): SolvedNode\n        {\n            if (reorder) {\n                mut args_out: SolvedNode[]; args_out.resize(reorder.len);\n                for (mut i = 0; i < reorder.len; i++) {\n                    let idx = reorder[i];\n                    if (idx >= 0)\n                        args_out[i] = args[idx];\n                }\n\n                args = args_out;\n            }\n\n            for (mut argIdx = 0; argIdx < conversions.len; argIdx++) {\n                let conversion = conversions[argIdx];\n                for (mut i = 0; i < conversion.len; i++) {\n                    args[argIdx] = CallerNode(conversion[i]);\n                    //             ^^^^^^^^^^\n                    // fn CallerNode: Arg #2, reorder not assignable to host_arg:\n                    //      expect: []+252i32: ref copy resize\n                    //      actual: []+252i32: ref copy\n                }\n            }\n\n            return SolvedNode(:target, :args);\n        }\n\n        fn main() {\n            return CallerNode(Target(0)).target.index;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_EXodQPgiNCd
                                #define STR_EXodQPgiNCd
static const fu::str str_EXodQPgiNCd fu_INIT_PRIORITY(1015) { "\n        fn qSTACK(x: i32) {\n            let rec = x & 1 && \"rec \";\n            let via = !rec && qSTACK(x / 2);\n            return \"\\n\" ~ rec ~ \"at #\" ~ x ~ via;\n        }\n\n        fn main() qSTACK(2).len - 2 - 4 - 8 - 2;\n    "_fu };
                                #endif

                                #ifndef STR_pbPXqZxiTv3
                                #define STR_pbPXqZxiTv3
static const fu::str str_pbPXqZxiTv3 fu_INIT_PRIORITY(1015) { "\n        struct SolvedNode { items: SolvedNode[] };\n\n        fn solve(node: SolvedNode) {\n            mut events = 0;\n\n            fn propagateType(shadow node: SolvedNode) {\n                fn tryTrackLastUse() !(node.items.len & 1);\n                let canDiscard = node.items.len != 0;\n                fn discardIntoBlock() tryTrackLastUse();\n\n                if (canDiscard && discardIntoBlock)\n                    propagateType(node.items[0]);\n\n                events++;\n            }\n\n            propagateType(node);\n            return events;\n        }\n\n        fn main() solve(SolvedNode([ SolvedNode(), SolvedNode() ])) == 2 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_1Fw5b3LHYse
                                #define STR_1Fw5b3LHYse
static const fu::str str_1Fw5b3LHYse fu_INIT_PRIORITY(1015) { "\n        fn path_relative(from: string, to: string): string {\n            let min = from.len < to.len ? from.len : to.len;\n\n            mut same = 0;\n            for (mut i = 0; i < min; i++) {\n                let a = from[i];\n                let b = to[i];\n\n                if (b != a)\n                    break;\n\n                if (b == '/')\n                    same = i + 1;\n            }\n\n            mut res: string;\n            for (mut i = same; i < from.len; i++)\n                if (from[i] == '/')\n                    res ~= \"../\";\n\n            res ~= to.slice(same);\n            return res;\n        }\n\n        fn main() {\n            let from    = \"/a/b/c\";\n            let to      = \"/a/e/f\";\n            let rel     = path_relative(:from, :to);\n\n            return rel == \"../e/f\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_QtGDBwaVqkh
                                #define STR_QtGDBwaVqkh
static const fu::str str_QtGDBwaVqkh fu_INIT_PRIORITY(1015) { "\n        inline fn test(ref a: i32[]) {\n            if ((a[0] + a[2]) & 1) {\n                shadow ref a = a[0 .. 2];                       ;; GNUStmtExpr\n                return a;\n            }\n            else {\n                shadow ref a = a[2 .. 4];                       ;; PointlessLocal\n                return a;\n            }\n        }\n\n        inline fn sum(ref a: i32[..]) {\n            mut sum = 0;\n            for (mut i = 0; i < a.len; i++) sum += a[i];\n            for (mut i = 0; i < a.len; i++) a[i] = sum;\n            return a;\n        }\n\n        fn main() {\n            mut a = [ 1, 2, 3, 4 ];\n            return sum(test(a))[0] - 7;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_GdfPdNDmfR2
                                #define STR_GdfPdNDmfR2
static const fu::str str_GdfPdNDmfR2 fu_INIT_PRIORITY(1015) { "\n        inline fn test(ref a: i32[], ref b: i32[]) {\n            if ((a[0] + b[0]) & 1)\n                return a;\n\n            return b;\n        }\n\n        inline fn sum(ref a: i32[]) {\n            mut sum = 0;\n            for (mut i = 0; i < a.len; i++) sum += a[i];\n            a.shrink(1);\n            a[0] = sum;\n            return a;\n        }\n\n        fn main() {\n            mut a = [ 1, 2 ];\n            mut b = [ 3, 4 ];\n            return sum(test(a, b))[0] - 7;                      ;; GNUStmtExpr\n        }\n    "_fu };
                                #endif

                                #ifndef STR_7LA43D3UPHa
                                #define STR_7LA43D3UPHa
static const fu::str str_7LA43D3UPHa fu_INIT_PRIORITY(1015) { "\n        inline fn grow_if_oob(ref a: $T[], i: i32): &mut $T {\n            if (a.len <= i)\n                a.grow(i + 1);\n\n            return a[i];\n        }\n\n        inline fn hey(ref arr: i32[], a: i32) {\n            if (a & 1) {\n                arr.grow_if_oob(a)++;\n                <alt>\n                return arr[0 .. a + 1];\n                </alt>\n            }\n\n            return arr;\n        }\n\n        fn main() {\n            mut a = [ 1 ];\n            return a[0] - hey(a, 1)[1];\n        }\n    "_fu };
                                #endif

                                #ifndef STR_31misFGSQg0
                                #define STR_31misFGSQg0
static const fu::str str_31misFGSQg0 fu_INIT_PRIORITY(1015) { "\n        fn serializeType(type: string, debug: string)\n            debug ~ \":\" ~ type;\n\n        fn mangleArguments(args: $T[..]): string {\n            mut mangle = \"\";\n            for (mut i = 0; i < args.len; i++) {\n                if (i) mangle ~= \",\";\n                mangle ~= serializeType(args[i], debug: \"M\");\n            }\n            return mangle;\n        }\n\n        fn trySpecialize(args: string[], ref args_mangled: string) {\n            args_mangled ||= mangleArguments(args);\n            return args_mangled.len;\n        }\n\n        fn main() {\n            mut args_mangled: string;\n            return trySpecialize([ \"a\", \"b\" ], args_mangled) - 7;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_8vnvzTPC19i
                                #define STR_8vnvzTPC19i
static const fu::str str_8vnvzTPC19i fu_INIT_PRIORITY(1015) { "\n        let EMIT_CPP = 1 << 0;\n        let EMIT_OBJ = 1 << 1;\n        let EMIT_BIN = 1 << 2;\n\n        struct Cmd { self: string; options: i32 };\n\n        inline fn unlessHasExt(str: string) {\n            let idx = str.find('.');\n            if (idx > 0)\n                return [];\n\n            return str;\n        }\n\n        fn parseOptions(argv: string[]) {\n            mut idx = 0;\n            fn next(): string {\n                let i = idx++;\n                if (i < argv.len) return argv[i];\n                return \"\";\n            }\n\n            let self = next();\n            if (argv.len == 1) // Exit 0 on no command, else we fail build-checks.\n                return [];\n\n            mut options: i32;\n            mut val = next();\n            while (val.len > 1 && val[0] == '-') {\n                mut opt = val;\n                if (opt[1] != '-') {\n                    opt = [ opt[1] ];\n                    val = '-' ~ val.slice(2);\n                    if (val == \"-\")\n                        val = next();\n                }\n                else\n                    val = next();\n\n                fn option(short: string, o: i32) {\n                    if (opt == short) {\n                        options |= o;\n                        opt = \"\";\n                    }\n                }\n\n                option(\"c\", EMIT_CPP);\n                option(\"o\", EMIT_OBJ);\n                option(\"b\", EMIT_BIN);\n\n                if (opt)\n                    throw(\"Unknown option: '\" ~ opt ~ \"'.\");\n            }\n\n            return Cmd(unlessHasExt(self), options);\n        }\n\n        fn main() = parseOptions([ \"./hey\", \"-c\", \"-b\" ]).options - (EMIT_CPP | EMIT_BIN);\n    "_fu };
                                #endif

                                #ifndef STR_5Gpkh68a3q0
                                #define STR_5Gpkh68a3q0
static const fu::str str_5Gpkh68a3q0 fu_INIT_PRIORITY(1015) { "\n        fn withPrefixed(b: byte, view: byte[..], fn) {\n            mut tmp: string;\n            return fn(view.len > 1 ? view : tmp = b ~ view);\n        }\n\n        fn main() withPrefixed('a', \"b\"): |ab| return ab.len - 2;\n    "_fu };
                                #endif

                                #ifndef STR_NUi5GlAGGbl
                                #define STR_NUi5GlAGGbl
static const fu::str str_NUi5GlAGGbl fu_INIT_PRIORITY(1015) { "\n        fn tryIntersect(left: byte[..], right: byte[..], withMatch) {\n            let l =  left[0];\n            let r = right[0];\n            let lq = l > '0' && l < '8';\n            let rq = r > '0' && r < '8';\n\n            if (left[lq && 1 .. left.len] != right[rq && 1 .. right.len])\n                return false;\n\n            let ll = lq && l.i32 - '0'.i32;\n            let rr = rq && r.i32 - '0'.i32;\n            let qq = ll | rr;\n\n            <alt>\n            mut tmp: string;\n            return withMatch(qq == ll ? left\n                           : qq == rr ? right\n                           : tmp = (qq.byte ~ left[lq && 1 .. left.len]),\n            <alt/>\n            return withMatch(qq == ll ? left\n                           : qq == rr ? right\n                           : qq.byte ~ left[lq && 1 .. left.len],\n            </alt>\n                left?:  qq == ll,\n                right?: qq == rr);\n        }\n\n        fn main() {\n            tryIntersect(\"7a012345678900123456789001234567890\"\n                       , \"5a012345678900123456789001234567890\"): |m, left!|\n            {\n                return m == \"7a012345678900123456789001234567890\" && left ? 0 : 100;\n            }\n\n            return 101;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_xm6xHd9JU10
                                #define STR_xm6xHd9JU10
static const fu::str str_xm6xHd9JU10 fu_INIT_PRIORITY(1015) { "\n        fn tryIntersect(left: byte[..], right: byte[..], ifLeft, ifNotLeft) {\n            let l =  left[0];\n            let r = right[0];\n            let lq = l > '0' && l < '8';\n            let rq = r > '0' && r < '8';\n\n            if (left[lq && 1 .. left.len] != right[rq && 1 .. right.len])\n                return false;\n\n            let ll = lq && l.i32 - '0'.i32;\n            let rr = rq && r.i32 - '0'.i32;\n            let qq = ll | rr;\n\n            if (qq == ll)   ifLeft();\n            else            ifNotLeft(qq == rr ? right : qq ~ right[rq && 1 .. right.len]);\n\n            return true;\n        }\n\n        fn TP_get(typeParams!: string, id!: string)\n        {\n            id || throw(\"Assertion failed.\");\n\n            mut start = 0;\n            for (;;)\n            {\n                let idx = typeParams.find(id, :start);\n                if (idx < 0)\n                    return -1;\n\n                start = id.len;\n                if (typeParams[start] == ' ')\n                    return start + 1;\n            }\n        }\n\n        fn TP_upsert(ref typeParams!: string, id!: string, canon: string) {\n            let start = TP_get(:typeParams, :id);\n            if (start < 0) {\n                typeParams ~= id;\n                typeParams ~= canon;\n                typeParams ~= '\t';\n                return true;\n            }\n\n            let end = typeParams.find('\t', :start);\n            return tryIntersect(typeParams[start .. end], canon,\n                ifLeft: || { /* egyptian */\n                    return true;\n                },                  // <- Lint complained about the nested curlies here ...\n                ifNotLeft: |inter|\n                { /* pedantic */\n                    typeParams.splice(start, end - start, inter);\n                    return true;\n                });                 // <-  ... and here.\n\n            return false;\n        }\n\n        fn main() {\n            mut typeParams = \"$T 3hey\t\";\n\n            // I was fiddling with jumps, and broke return type reporting,\n            //  so that TP_upsert here was always assumed to return true (tryIntersect can return false above),\n            //   adding this because the test didn't care.\n            if (TP_upsert(:typeParams, id: \"$T\", \"x4x\"))\n                return 202;\n\n            return TP_upsert(:typeParams, id: \"$T\", \"4hey\")\n                && typeParams == \"$T 7hey\t\" ? 0 : 101;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_3QU1IyFMHyd
                                #define STR_3QU1IyFMHyd
static const fu::str str_3QU1IyFMHyd fu_INIT_PRIORITY(1015) { "\n        fn fails_with_silly_error(ref set: i32[], i) {\n            <fail bad call arg 4:18>\n            set  ||= i; <pass/> // this BUGged out instead of\n            set   ~= i; </fail> //  outputing a decent err msg\n            return set;\n        }\n\n        fn main() {\n            mut set = [ 0 ];\n            fails_with_silly_error(set, 2);\n\n            mut sum = 0;\n            for (mut i = 0; i < set.len; i++) sum += set[i];\n            return sum - 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_JEPVcxr9bj8
                                #define STR_JEPVcxr9bj8
static const fu::str str_JEPVcxr9bj8 fu_INIT_PRIORITY(1015) { "\n        fn solve(ref output: i32[], input: i32[])\n        {\n            fn SLOW_traverse(visit)\n                for (mut i = 0; i < input.len; i++)\n                    visit(input[i]);\n\n            fn qSTACK(id: i32, implicit _current_fnort: i32) {\n                SLOW_traverse: |x|\n                    if (id == x)\n                        return id || _current_fnort;\n\n                return 0;\n            }\n\n            fn doTrySpecialize(target: i32)\n            {\n                fn updateScope(result: i32)\n                    output ~= result || qSTACK(result + 1);\n\n                if (target & 1) {\n                    updateScope(target); // 1 - 1\n                    return;\n                }\n\n                let implicit _current_fnort = target;\n                updateScope(target / 2); // 4 - 2, 2 - 1, 0 - 0\n            }\n\n            let implicit _current_fnort = 1;\n\n            doTrySpecialize(1);\n            for (mut i = 0; i < input.len; i++)\n                doTrySpecialize(input[i]);\n        }\n\n        fn main() {\n            mut output: i32[];\n            solve(output, input: [ 0, 3 ]);\n\n            return output[0] == 1\n                && output[1] == 0\n                && output[2] == 3 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_UL3mDG0WLtg
                                #define STR_UL3mDG0WLtg
static const fu::str str_UL3mDG0WLtg fu_INIT_PRIORITY(1015) { "\n        <fail does nothing><pass/>\n        lax                </fail>\n        fn noop_let_lax(lax ref x: i32) {\n            let lax y = x;\n        }\n\n        fn main() {\n            mut x = 0;\n            noop_let_lax(x);\n            return x;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_YQZvhWU6aG6
                                #define STR_YQZvhWU6aG6
static const fu::str str_YQZvhWU6aG6 fu_INIT_PRIORITY(1015) { "\n        fn compile_begin(mul: i32) {\n            let id = mul * 10;\n            let implicit options = getModule(:id);\n            return compile(:id);\n        }\n\n        fn compile(implicit options: i32, id: i32) {\n            return getModule(id) + options;\n        }\n\n        fn getModule(id: i32, implicit ctx: i32) {\n            return ctx + id;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_GcF9x4MzLwi
                                #define STR_GcF9x4MzLwi
static const fu::str str_GcF9x4MzLwi fu_INIT_PRIORITY(1015) { "\n        import _0;\n\n        fn main() {\n            let implicit ctx = 2;\n            return compile_begin(3) - 64;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_V2oo3Ctmmyb
                                #define STR_V2oo3Ctmmyb
static const fu::str str_V2oo3Ctmmyb fu_INIT_PRIORITY(1015) { "\n        // An empty file.\n    "_fu };
                                #endif

                                #ifndef STR_HGJwbnKNj1c
                                #define STR_HGJwbnKNj1c
static const fu::str str_HGJwbnKNj1c fu_INIT_PRIORITY(1015) { "\n        fn sqr(x: i32) x * x;\n    "_fu };
                                #endif

                                #ifndef STR_de7qbmiyKI0
                                #define STR_de7qbmiyKI0
static const fu::str str_de7qbmiyKI0 fu_INIT_PRIORITY(1015) { "\n        import _0;\n        import _1;\n\n        fn main() = 0.sqr;\n    "_fu };
                                #endif

                                #ifndef STR_oVLpCj7iXH0
                                #define STR_oVLpCj7iXH0
static const fu::str str_oVLpCj7iXH0 fu_INIT_PRIORITY(1015) { "\n        struct vec2 {\n            x?: f32;\n            y?: f32;\n        };\n\n        inline fn *=(ref a: vec2, b: f32) {\n            a.x *= b;\n            a.y *= b;\n            return a;\n        }\n\n        fn main() {\n            mut v = vec2(1, 1);\n            v *= 0.5; // BUG: Considering copy or move for incompatible types: vec2: copy <- f32: copy\n            return v.x.i32;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_RT053X7XUSc
                                #define STR_RT053X7XUSc
static const fu::str str_RT053X7XUSc fu_INIT_PRIORITY(1015) { "\n        struct vec3 { x: f32; y: f32; z: f32; };\n\n        inline fn vec3(fill!: f32) vec3(fill, fill, fill);\n        inline fn vec3(x!: f32, y!?: f32, z!?: f32) vec3(x, y, z);\n        inline fn vec3(y!: f32, x!?: f32, z!?: f32) vec3(x, y, z);\n        inline fn vec3(z!: f32, x!?: f32, y!?: f32) vec3(x, y, z);\n\n        inline fn *(a: vec3, b: f32) vec3(a.x * b, a.y * b, a.z * b);\n    "_fu };
                                #endif

                                #ifndef STR_X9A88hvZ5yi
                                #define STR_X9A88hvZ5yi
static const fu::str str_X9A88hvZ5yi fu_INIT_PRIORITY(1015) { "\n        import _0;\n\n        struct Atmosphere { pView: vec3; rPlanet: f32; };\n\n        let rEarth: f32 = 1e3;\n\n        fn Atmosphere(\n            altitude: f32,\n            rPlanet: f32 = rEarth,\n            vUp = vec3(z: 1)) // <- this crashes\n        {\n            let pView = vUp * (rPlanet + altitude);\n            return Atmosphere(:rPlanet, :pView);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_alJ5CkJI5D1
                                #define STR_alJ5CkJI5D1
static const fu::str str_alJ5CkJI5D1 fu_INIT_PRIORITY(1015) { "\n        import _0;\n        import _1;\n\n        fn main() {\n            let atmo = Atmosphere(altitude: 1e2);\n            return atmo.pView.z == 11e2 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_HI5gbBCp0M8
                                #define STR_HI5gbBCp0M8
static const fu::str str_HI5gbBCp0M8 fu_INIT_PRIORITY(1015) { "\n        inline fn vec3(fill!: f32) fill;\n\n        let kMie_min: f32 = 3e-6;\n        inline fn Atmo(kMie = vec3(fill: kMie_min)) = kMie;     ;; PointlessLocal\n\n        fn main() Atmo == 3e-6 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_3ZwYaCj9IG3
                                #define STR_3ZwYaCj9IG3
static const fu::str str_3ZwYaCj9IG3 fu_INIT_PRIORITY(1015) { "\n        struct vec3 { x: f32; y: f32; z: f32; };\n        inline fn vec3(fill!: f32) vec3(fill, fill, fill);\n        inline fn *(a: vec3, b: f32) vec3(a.x * b, a.y * b, a.z * b);\n\n        <split/>\n        let kMie_min: f32 = 3e-6;\n        inline fn Atmosphere(kMie = vec3(fill: kMie_min)) = kMie.y * 2;\n\n        <split/>\n        fn main() Atmosphere == 6e-6 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_c28272KFHKj
                                #define STR_c28272KFHKj
static const fu::str str_c28272KFHKj fu_INIT_PRIORITY(1015) { "\n        struct Loop { l: i32 };\n        struct Ring { r: i32 };\n        struct Mesh { m: i32 };\n\n        fn op(ref m: Mesh, x: i32, l: Loop) m.m += l.l + x;\n        fn op(ref m: Mesh, r: Ring, x: i32) m.m *= r.r + x;\n        fn op(using ref m: Mesh, l: Loop, r: Ring, x: i32) {\n            l.op(:x);\n            r.op(:x);\n        }\n\n        fn main() {\n            mut m = Mesh(1);\n            m.op(Loop(2), Ring(7), x: 1);\n            return m.m == 32 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_PfB1ja8Why0
                                #define STR_PfB1ja8Why0
static const fu::str str_PfB1ja8Why0 fu_INIT_PRIORITY(1015) { "\n        pub struct MultiDraw { id: i32; }\n    "_fu };
                                #endif

                                #ifndef STR_BhMDRFxgM48
                                #define STR_BhMDRFxgM48
static const fu::str str_BhMDRFxgM48 fu_INIT_PRIORITY(1015) { "\n        import _0;\n        type ViewQuads = MultiDraw;\n\n        fn ViewQuads(id!: i32, populate!): ViewQuads {\n            mut vq = ViewQuads(:id);\n            populate(vq);\n            return vq;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_9CQoT2BjKtc
                                #define STR_9CQoT2BjKtc
static const fu::str str_9CQoT2BjKtc fu_INIT_PRIORITY(1015) { "\n        import _1;\n        fn ViewQuads(id!: i32, camera!: i32): ViewQuads {\n            return ViewQuads(:id, populate: |ref vq| vq.id += camera);\n        }\n\n        fn main() {\n            return ViewQuads(id: 2, camera: 5).id - 7;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_HaE3P6rCOP1
                                #define STR_HaE3P6rCOP1
static const fu::str str_HaE3P6rCOP1 fu_INIT_PRIORITY(1015) { "\n        fn setupOperators()\n        {\n            struct Maplike {\n                keys: string[];\n                vals: i32[];\n            };\n\n            fn set(ref m: Maplike, k: string, v: i32) {\n                m.keys ~= k;\n                m.vals ~= v;\n            }\n\n            struct BINOP {\n                PRECEDENCE: Maplike;\n                RIGHT_TO_LEFT: bool[];\n            };\n\n            mut out: BINOP;\n            mut precedence: i32 = -1;\n            mut rightToLeft = false;\n\n            fn binop(ops: string[]) {\n                precedence++;\n                out.RIGHT_TO_LEFT ~= rightToLeft;\n                for (mut i = 0; i < ops.len; i++)\n                    out.PRECEDENCE.set(ops[i], precedence);\n            }\n\n            rightToLeft = false;\n            binop([ \"*\", \"/\", \"%\" ]);\n\n            rightToLeft = true;\n            binop([ \"*=\", \"/=\", \"%=\" ]);\n\n            return out;\n        }\n\n        let BINOP = setupOperators();\n        fn main() BINOP.RIGHT_TO_LEFT[1] && BINOP.PRECEDENCE.vals[3] == 1 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_LYjyBX46jLc
                                #define STR_LYjyBX46jLc
static const fu::str str_LYjyBX46jLc fu_INIT_PRIORITY(1015) { "\n        fn Split !T(str: T[], sep: T or T[..], each) {\n            mut last_idx = 0;\n            mut next_idx = 0;\n\n            let N = typeof(sep) -> T[..] ? sep.len : 1;\n            if (N) while ((next_idx = str.find(sep, start: last_idx)) >= 0) {\n                each(str.slice(last_idx, next_idx), first?: !last_idx, last?: false);\n                last_idx = next_idx + N;\n            }\n\n            if (last_idx)\n                each(str.slice(last_idx), first?: false, last?: true);\n            else\n                each(str, first?: true, last?: true);\n        }\n\n        fn Replace !T(str: T[], all: T or T[..], with: T or T[..] or []) {\n            mut result: T[];\n            Split(str, sep: all, |substr, lax first, lax last| {\n                if !(first) {\n                    if !(typeof(with) -> [])\n                        result ~= with;\n                }\n                else if (last) {\n                    return str;\n                }\n\n                result ~= substr;\n            });\n\n            return result;\n        }\n\n        fn main() {\n            let res = \"hello\".Replace(all: \"ll\", with: []);\n            return res == \"heo\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_YNXO209j2o3
                                #define STR_YNXO209j2o3
static const fu::str str_YNXO209j2o3 fu_INIT_PRIORITY(1015) { "\n        struct BitSet { _data: u8[] };\n\n        fn add(using ref _: BitSet, idx: int) {\n            let no_neg = idx & int.MIN;\n            let bucket = idx >> 3 | no_neg;\n            let bit    = idx & 7;\n            let mask   = 1 << bit.u8;\n\n            if (_data.len <= bucket)\n                _data.grow(bucket + 1);\n\n            _data[bucket] |= mask;\n        }\n\n        fn each(using _: BitSet, visit) {\n            for (mut i = 0; i < _data.len; i++) {\n                let item = _data[i];\n                if (item) for (mut b = 0; b < 8; b++) {\n                    let mask = 1 << b.u8;\n                    if (item & mask)\n                        visit(i << 3 | b.int);\n                }\n            }\n        }\n\n        struct Node { items: Node[] }\n\n        fn each(using n: Node, visit)\n            for (mut i = 0; i < n.items.len; i++)\n                visit(n.items[i]);\n\n        fn traverse(ref node: Node, ref bitset: BitSet) {\n            bitset.add(node.items.len);\n            node.each(.traverse(:bitset));\n\n            mut res = 0;\n            bitset.each: |index|\n                res += index;\n\n            return res;\n        }\n\n        fn main() {\n            mut bitset: BitSet;\n            return traverse(Node([ Node([ Node, Node, Node ]), Node ]), :bitset) == 5 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_BxekpC0UBsk
                                #define STR_BxekpC0UBsk
static const fu::str str_BxekpC0UBsk fu_INIT_PRIORITY(1015) { "\n        struct Type {\n            quals: i32;\n            canon: string;\n        };\n\n        fn is_never (t: Type) t.canon == \"never\";\n        fn is_zeroes(t: Type) t.canon == \"zeroes\";\n\n        let CANNOT_definit_mutrefs = true;\n\n        fn clear_mutref(mut t: Type) {\n            t.quals &= ~1;\n            return t;\n        }\n\n        fn union(a: Type, b: Type, DONT_match_zeroes!?: bool) {\n            if (a.canon != b.canon)\n                return a.is_never  ? b\n                     : b.is_never  ? a\n                     : a.is_zeroes && !DONT_match_zeroes ? CANNOT_definit_mutrefs ? clear_mutref(b) : b\n                     : b.is_zeroes && !DONT_match_zeroes ? CANNOT_definit_mutrefs ? clear_mutref(a) : a\n                     : [];\n\n            return Type(:a.canon, a.quals | b.quals);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_N4jTXSfl7Rc
                                #define STR_N4jTXSfl7Rc
static const fu::str str_N4jTXSfl7Rc fu_INIT_PRIORITY(1015) { "\n        import _0;\n        fn main() {\n            let Hey1    = Type(1, \"hey\");\n            let Zeroes  = Type(0, \"zeroes\");\n            let res     = union(Hey1, Zeroes);\n            return res.canon == \"hey\" && res.quals == 0 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_1JOMjfBoU7d
                                #define STR_1JOMjfBoU7d
static const fu::str str_1JOMjfBoU7d fu_INIT_PRIORITY(1015) { "\n        fn inline_args_and_closures(inline nums: i32[]) {       ;; GNUStmtExpr\n            mut sum: i32;\n            noinline fn woot(z: i32)                // previously a new woot was emitted\n                for (mut i = 0; i < nums.len; i++)  //  with the nums expr inlined,\n                    sum += nums[i] & z;             //   now nums doesnt inline inside woot\n\n            for (mut i = 0; i < nums.len; i++) {\n                if (i > 0) woot(nums[i] & nums[i - 1]);         ;; PointlessMustSeq\n                if (i > 1) woot(nums[i] & nums[i - 2]);\n            }\n\n            return sum;\n        }\n\n        fn main() {\n            mut x = 0;\n            let res = inline_args_and_closures([ x++, x++, x++ ]);\n            return x == 93 && res == 290 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Wis5H3E3g56
                                #define STR_Wis5H3E3g56
static const fu::str str_Wis5H3E3g56 fu_INIT_PRIORITY(1015) { "Inline arguments can only be inlined once 9:33+4"_fu };
                                #endif

                                #ifndef STR_U3Fq7CgnPZ3
                                #define STR_U3Fq7CgnPZ3
static const fu::str str_U3Fq7CgnPZ3 fu_INIT_PRIORITY(1015) { "\n        <fail cannot inline recursive inlineSelfRecursion 8:19+19>\n        inline <pass/></fail>\n        fn inlineSelfRecursion(x: int)\n            x > 10  ? inlineSelfRecursion(x / 2)\n                    : x;\n\n        fn main() inlineSelfRecursion(15) == 7 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_xIge1tUIAva
                                #define STR_xIge1tUIAva
static const fu::str str_xIge1tUIAva fu_INIT_PRIORITY(1015) { "\n        <fail cannot inline recursive inlineMutualRecursion_a 9:23+23>\n        inline <pass/></fail>\n        fn inlineMutualRecursion_a(x: int)\n            x > 10  ? inlineMutualRecursion_b(x / 2)\n                    : x;\n\n        inline fn inlineMutualRecursion_b(x: int)\n            x > 5   ? inlineMutualRecursion_a(x / 2)\n                    : x;\n\n        fn main() inlineMutualRecursion_a(15) == 3 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_iW50pX4u2lj
                                #define STR_iW50pX4u2lj
static const fu::str str_iW50pX4u2lj fu_INIT_PRIORITY(1015) { "\n        nocopy struct SolverOutput {\n            content?: SolverOutput[];\n        };\n\n        fn test(ref _helpers_data: i32[], mut content: SolverOutput[])\n        {\n            _helpers_data.len & 1 && _helpers_data.pop();\n            {\n                _helpers_data && throw(\"non-empty _helpers_data.\");\n                {\n                    content.len & 1 && content.pop();\n                    {\n                        return SolverOutput(:content);\n                    }\n                }\n            }\n        }\n\n        fn main() {\n            mut _helpers_data: i32[];\n            mut content: SolverOutput[];\n            return test(_helpers_data, content).content.len;    ;; !*MustSeq\n        }\n    "_fu };
                                #endif

                                #ifndef STR_P6hDUXr6CSe
                                #define STR_P6hDUXr6CSe
static const fu::str str_P6hDUXr6CSe fu_INIT_PRIORITY(1015) { "\n        struct Type { quals: i32; };\n        struct Node { type: Type; };\n\n        fn unusedLetExprOrBlock(args_in: Node[..], default: Node) {\n            mut inType: Type;\n            for (mut i = 0; i < args_in.len; i++) {\n                // got this while auto-reducing smth else,\n                //  nonsense but currently bugs mcom\n                lax let inValue = args_in[i] || {\n                    inType = default.type;  //      <- then, mcom tries to copy here\n                    default                 // <- first this gets discarded\n                };\n            }\n\n            return inType;\n        }\n\n        fn main() {\n            return unusedLetExprOrBlock([ Node() ], Node(Type(1))).quals - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_YjFDAs6qR3c
                                #define STR_YjFDAs6qR3c
static const fu::str str_YjFDAs6qR3c fu_INIT_PRIORITY(1015) { "\n        fn parse !T(v: byte[..], lax as!: T) {\n            mut result: T;\n\n            if (T.is::bitfield) {\n                for (mut i = 1; i < v.len; i++) {\n                    if (v[i] == '|') {\n                        return parse(v[0 .. i], :as) | parse(v[i + 1 .. v.len], :as);\n                    }\n                }\n            }\n\n            for (mut i = 0; i < v.len; i++) {\n                if (v[i] == '*') {\n                    let prefix = v[0 .. i];\n                    let suffix = v[i + 1 .. v.len]\n\n                    for (fieldname i: T) {\n                        let opt = \"i\";\n                        if (opt.starts(with: prefix) && opt.ends(with: suffix))\n                            result |= T.i;\n                    }\n\n                    return result;\n                }\n                else if (i > 0 && v[i] == '|') {\n                    return parse(v[0 .. i], :as) | parse(v[i + 1 .. v.len], :as);\n                }\n            }\n\n            for (fieldname i: T)\n                if (v == \"i\")\n                    return T.i;\n\n            return [];\n        }\n\n        flags UpperCase { Hello = 1; World = 2; Cruel = 4; CruelWorld = 8 };\n        flags LowerCase { hello = 16; world = 32; cruel = 64; cruel_world = 128 };\n\n        fn parseUpperOrLower(str: string) {\n            if (let upper = parse(str, as: UpperCase))\n                return upper.i32;\n            else if (let lower = parse(str, as: LowerCase))\n                return lower.i32;\n            else\n                return 0;\n        }\n\n        fn main() {\n            if (parseUpperOrLower(\"World|Cruel*\") != 2|4|8) return 1;\n            if (parseUpperOrLower(\"*world|hello\") != 16|32|128) return 2;\n            return 0;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_zCi9LCJWHT0
                                #define STR_zCi9LCJWHT0
static const fu::str str_zCi9LCJWHT0 fu_INIT_PRIORITY(1015) { "\n        struct Type { items: Type[]; }\n\n        fn solve(root: Type) {\n            mut out = 0;\n            fn test_node(node: Type) {\n                for (mut i = 0; i < node.items.len; i++)\n                    test_node(node.items[i]);\n\n                fn checkLt(actual: Type) {\n                    out += node.items.len;\n                    for (mut i = 0; i < actual.items.len; i++)\n                        checkLt(actual.items[i]);\n                }\n\n                checkLt(node);\n            }\n\n            test_node(root);\n            return out;\n        }\n\n        fn main() solve(Type([ Type([ Type, Type ]), Type([ Type, Type, Type ]) ])) == 34 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_jqhwrRfd8H1
                                #define STR_jqhwrRfd8H1
static const fu::str str_jqhwrRfd8H1 fu_INIT_PRIORITY(1015) { "\n        fn runSolver(\n            implicit ref notes: i32,\n            break_notes: i32,\n            implicit ref value: i32)\n        {\n            fn makeNote(note: i32, inline reason: string) {\n                if (break_notes & note)\n                    throw(\"#\" ~ note ~ \": \" ~ reason);\n\n                notes |= note;\n            }\n\n            if (value > 0) {\n                if (value++ & 1) return makeNote(1, \"A: \" ~ value);\n                if (value++ & 2) return makeNote(2, \"B: \" ~ value);\n            }\n            else {\n                if (value++ & 4) return makeNote(4, \"C: \" ~ value);\n                if (value++ & 8) return makeNote(8, \"D: \" ~ value);\n            }\n        }\n\n        fn main() {\n            implicit mut notes: i32;\n            <fail unused print>\n            implicit mut print: string; <pass/></fail>\n            implicit mut value = 0;\n\n            runSolver(1|2);\n            runSolver(4|8);\n            return value == 4 && notes == 2 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_g2qktFUCfV6
                                #define STR_g2qktFUCfV6
static const fu::str str_g2qktFUCfV6 fu_INIT_PRIORITY(1015) { "\n        struct Target { x: i32; };\n\n        fn ScopeSkip_push_bad_args(targets: Target[], ref sum: i32) {\n            fn descend(acc?: bool) {\n                fn foreach(t: Target) {\n                    if (acc)    sum += t.x;\n                    else        descend(true);\n                }\n\n                targets.each(|u| foreach(u));\n            }\n\n            descend();\n        }\n\n        fn main() {\n            mut targets = [ Target(1), Target(2) ];\n            mut sum = 0;\n            ScopeSkip_push_bad_args(:targets, :sum);\n            return sum == 6 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_JQE4nZlIV7j
                                #define STR_JQE4nZlIV7j
static const fu::str str_JQE4nZlIV7j fu_INIT_PRIORITY(1015) { "\n        struct Module { events: i32; };\n\n        <alt>\n        inline   <alt/>\n        noinline </alt>\n        fn profile(implicit ref module: Module, id: i32, op) {\n            let events0 = module.events;\n            op();\n            module.events += (events0 + id);\n        }\n\n        <alt>\n        inline   <alt/>\n        noinline </alt>\n        fn propagateType(implicit ref module: Module) {\n            profile(2, |<alt>lax unused?</alt>| module.events = 1);\n        }\n\n        <alt>\n        inline   <alt/>\n        noinline </alt>\n        fn runAllPasses() {\n            profile(3, fn propagateType);\n        }\n\n        fn main() {\n            implicit mut module: Module;\n            runAllPasses();\n            return module.events == 1 + 2 + 3 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Epo07hZ3Ht4
                                #define STR_Epo07hZ3Ht4
static const fu::str str_Epo07hZ3Ht4 fu_INIT_PRIORITY(1015) { "\n        struct Module { events: i32; };\n\n        // Same as above but uses unwrap.\n        fn profile(implicit ref module: Module, id: i32) unwrap {\n            let events0 = module.events;\n            defer module.events += (events0 + id);\n        }\n\n        <alt>\n        inline   <alt/>\n        noinline </alt>\n        fn propagateType(implicit ref module: Module) {\n            profile(2);\n            module.events = 1;\n        }\n\n        <alt>\n        inline   <alt/>\n        noinline </alt>\n        fn runAllPasses() {\n            profile(3);\n            propagateType();\n        }\n\n        fn main() {\n            implicit mut module: Module;\n            runAllPasses();\n            return module.events == 1 + 2 + 3 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_FWkyqWnmdc5
                                #define STR_FWkyqWnmdc5
static const fu::str str_FWkyqWnmdc5 fu_INIT_PRIORITY(1015) { "\n        struct Target { template: string; };\n        fn BUG(what?: string) throw(what || \"Assertion failed.\");\n\n        fn assign_WOOT(ref into: Target) {\n            mut name = \"\";\n            mut what = \"WOOT\";\n            name ||= what || BUG(); // arg inliner out of range local\n            into.template = name;\n        }\n\n        fn main() {\n            mut t = Target();\n            assign_WOOT(into: t);\n            return t.template == \"WOOT\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_0x77MPjkNse
                                #define STR_0x77MPjkNse
static const fu::str str_0x77MPjkNse fu_INIT_PRIORITY(1015) { "\n        struct Overload { type: Type; }\n        struct Type     { lifetime: i32[]; }\n\n        fn BUG(implicit _here: i32, reason: string)\n            throw(_here ~ \": \" ~ reason);\n\n        fn is_even(type: Type) {\n            let a = !(type.lifetime.len & 1);\n            let b =   type.lifetime.len < 4;\n            a && !b && BUG(\"THROW-1\");\n            return a;\n        }\n\n        fn solve(check: Type) {\n            let implicit mut _here: i32;\n\n            using fn GET(implicit overloads: Overload[], target: i32)\n                target < 0 || target >= overloads.len\n                    ? BUG(\"THROW-2\")\n                    : overloads[target];\n\n            fn Lifetime_each(type, visit)\n                for (mut i = type.lifetime.len; i --> 0; )\n                    visit(t: type.lifetime[i]);\n\n            fn Lifetime_allEven(type: Type): bool {\n                Lifetime_each(:type, visit: |t| {\n                    if (!t.type.is_even)                return false;\n                    if (!Lifetime_allEven(t.type))      return false;\n                    _here = t;\n                });\n\n                return true;\n            }\n\n            return Lifetime_allEven(check);\n        }\n\n        fn main() {\n            let implicit overloads = [\n                Overload(),             // 0] even\n                Overload(Type([0])),    // 1] odd\n                Overload(Type([0, 0])), // 2] even\n                Overload(Type([0, 2])), // 3] even\n            ];\n\n            if !(solve(Type()))         return 1;\n            if  (solve(Type([ 1, 2 ]))) return 2;\n            if !(solve(Type([ 2, 3 ]))) return 3;\n            return 0;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_f37z66mgEJg
                                #define STR_f37z66mgEJg
static const fu::str str_f37z66mgEJg fu_INIT_PRIORITY(1015) { "\n        struct Overload { name: string; args?: Argument[]; }\n        struct Argument { name: string; }\n        struct Target   { index: i32; }\n\n        fn solve(overloads: Overload[], check: Target, from?: Target)\n        {\n            fn fail(mut reason: string) {\n                if (from)\n                    reason ~= GET(from).qWHAT;\n\n                return throw(reason);\n            }\n\n            fn qWHAT(o: Overload) o.name.human;\n            fn qWHAT(a: Argument) a.name.human;\n\n            fn tryParse(id: string)\n                id.len == 1 && id[0] >= '0' && id[0] <= '9'\n                    && Target(index: id[0].i32 - '0'.i32);\n\n            fn human(id: string) {\n                let t = tryParse(:id);\n                return t ? GET(t).name : id;\n            }\n\n            fn parent(target: Target)\n                target.index > 0\n                    && Target(target.index - 1);\n\n            using fn GET(target: Target) {\n                if (overloads.len < target.index)\n                    fail(\"Parent: \" ~ (target.parent ? GET(target.parent).name : \"-\"));\n\n                return overloads[target.index - 1];\n            }\n\n            return check.qWHAT;\n        }\n\n        fn main() {\n            let overloads = [\n                Overload(\"hello\"),\n                Overload(\"1\"),\n            ];\n\n            return solve(overloads, check: Target(2)) == \"hello\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_ZkxOd0GDND8
                                #define STR_ZkxOd0GDND8
static const fu::str str_ZkxOd0GDND8 fu_INIT_PRIORITY(1015) { "\n        struct Type { quals: i32; lifet: i32 };\n\n        fn tryInter(a: Type, b: Type) {\n            let quals = a.quals & b.quals;\n            let lifet = a.lifet & b.lifet;\n            if (!lifet && (a.lifet || b.lifet))\n                return [];\n\n            return quals;\n        }\n\n        fn fail(reason: string) {\n            return 101 + reason.len;\n        }\n\n        fn intersect(reason: string, a: Type, b: Type) {\n            return tryInter(a, b) || fail(reason);\n        }\n\n        fn main() {\n            let a = Type(quals: 1, lifet: 1);\n            let b = Type(quals: 3, lifet: 3);\n            return intersect(\"Hello!\", a, b) == 1 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Ai0XLpTxgJ3
                                #define STR_Ai0XLpTxgJ3
static const fu::str str_Ai0XLpTxgJ3 fu_INIT_PRIORITY(1015) { "\n        struct Item { val: i32 };\n\n        fn Each !T(ref a: T[..], fn)\n            for (mut i = 0; i < a.len; i++)\n                fn(a[i], i?: i);\n\n        fn parseStructDecl(ref items: Item[..], ref sum: i32) {\n            if (items.len & 2)\n                parseStructDecl(items[1 .. items.len], sum);    ;; PointlessMustSeq\n\n            :BLOCK {\n                items.Each: |item|\n                    if ((sum += item.val) & 2)\n                        break :BLOCK;                           ;; Goto\n\n                items.Each: |ref item|\n                    item.val += sum;\n            }\n\n            items.Each: |ref item|\n                item.val++;\n        }\n\n        fn main() {\n            mut sum = 0;\n            mut items = [ Item(0), Item(1) ];\n            parseStructDecl(items, sum);\n            return sum == 4\n                && items[0].val == 5\n                && items[1].val == 8 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_RSrR1PnvQbg
                                #define STR_RSrR1PnvQbg
static const fu::str str_RSrR1PnvQbg fu_INIT_PRIORITY(1015) { "\n        struct Node {\n            value?: string;\n            items?: Node[];\n        };\n\n        fn SLOW_traverse(node: Node, visit) {\n            mut stack = [ node ];\n            while (stack) {\n                shadow mut node = stack[stack.len - 1];\n                stack.pop();\n                visit(node);\n                for (mut i = node.items.len; i --> 0; )\n                    stack ~= node.items[i];\n            }\n        }\n\n        fn qSTACK(node: Node) {\n            SLOW_traverse(node): |n| {\n                if (n.value && n.items)\n                    return n.value ~ \", \" ~ qSTACK(n.items[0]);\n            }\n\n            return node.value ~ \"!\";\n        }\n\n        fn main() {\n            let res = qSTACK(\n                Node(items: [\n                    Node(\"Ignore me\"),\n                    Node(\"Hello\", [ Node(\"World\") ]),\n                ]));\n\n            return res == \"Hello, World!\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_yaXhjElFK6e
                                #define STR_yaXhjElFK6e
static const fu::str str_yaXhjElFK6e fu_INIT_PRIORITY(1015) { "\n        fn merge !T(l: T[..], r: T[..], left, right, both) {\n            mut li = 0;\n            mut ri = 0;\n            for (;;) {\n                inline fn L = l[li];\n                inline fn R = r[ri];\n                let l_done = li == l.len;\n                let r_done = ri == r.len;\n\n                let cmp = l_done ? r_done ? { return; } : +1\n                                 : r_done ? -1\n                                 : L <> R;\n                if (cmp == 0) {\n                    both(L, left?: li, right?: ri);\n                    li++;\n                    ri++;\n                }\n                else if (cmp < 0) {\n                    left(L, left?: li, right?: ri);\n                    li++;\n                }\n                else {\n                    right(R, left?: li, right?: ri);\n                    ri++;\n                }\n            }\n        }\n\n        fn inter !T(l: T[], r: T[]) {\n            if (r.len < l.len)\n                return inter(r, l);\n\n            mut result: T[];\n            mut useResult = false;\n\n            merge(l, r,\n\n            left: |_, left| {\n                if (!useResult) {\n                    useResult = true;\n                    result = l.slice(0, left);\n                }\n            },\n\n            right: |_| {},\n\n            both: |item| {\n                if (useResult)\n                    result ~= item;\n            });\n\n            return useResult ? result : l;\n        }\n\n        <split/>\n        struct Region { index: i32 };\n        struct Lifetime { uni0n: i32[]; };\n\n        fn Lifetime_inter(a: Lifetime, b: Lifetime): Lifetime = // nested { return } in merge\n            Lifetime(uni0n: inter(a.uni0n, b.uni0n));           ;; GNUStmtExpr\n\n        <split/>\n        fn main() {\n            mut a = Lifetime([ 1, 2, 3 ]);\n            mut b = Lifetime([ 2, 3, 4 ]);\n            mut c = Lifetime_inter(a, b);\n            return c.uni0n == [ 2, 3 ] ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_AW5GLkCm1rg
                                #define STR_AW5GLkCm1rg
static const fu::str str_AW5GLkCm1rg fu_INIT_PRIORITY(1015) { "\n        struct Type { canon: string; quals: i32 };\n        struct Node { type: Type; value: string };\n\n        let t_f32 = Type(\"f32\", 2);\n        let t_f64 = Type(\"f32\", 2);\n\n        fn solveReal(lax v: string, type: Type): Type {\n            if (type.canon == t_f32.canon) return t_f32;\n            return t_f64;\n        }\n\n        fn tryRetype(node: Node, expect: Type): Type {\n            return solveReal(node.value, expect);\n        }\n\n        fn main() {\n            let a = Node(t_f64, \"0.0\");\n            let b = tryRetype(a, t_f32);\n            return b.canon == \"f32\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_yKbGo8YCzZe
                                #define STR_yKbGo8YCzZe
static const fu::str str_yKbGo8YCzZe fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            nocopy struct Nc { items: Nc[]; };\n\n            fn rem_odd(ref items: Nc[])\n                for (mut i = items.len; i --> 0; )\n                    if (i & 1)\n                        items.splice(i, 1);\n\n            mut items: Nc[];\n            for (mut i = 0; i < 11; i++)\n                items ~= Nc(i & 1 ? [ Nc ] : [ Nc, Nc ]);\n\n            rem_odd(items);\n\n            mut sum = 0;\n            fn visit(shadow items: Nc[..])\n            {\n                fn visit(nc: Nc) {\n                    sum++;\n                    visit(nc.items);\n                }\n\n                for (mut i = 0; i < items.len; i++)\n                    visit(items[i]);\n            }\n\n            visit(items);\n            return sum == 18 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_RZCPT3fZfz3
                                #define STR_RZCPT3fZfz3
static const fu::str str_RZCPT3fZfz3 fu_INIT_PRIORITY(1015) { "\n        let SMTH = false;                                       ;; !DEV_DontFoldLiterals\n        fn LITFIX(reason: f32) reason;\n        fn litfix(lax mut reason: string) LITFIX(SMTH ? reason : 0);\n        fn main() litfix(\"hello\").i32;\n    "_fu };
                                #endif

                                #ifndef STR_lfuxNE9f2Y5
                                #define STR_lfuxNE9f2Y5
static const fu::str str_lfuxNE9f2Y5 fu_INIT_PRIORITY(1015) { "\n        let SMTH = false;\n\n        fn FAIL(reason: string, implicit ref log: string)\n            log ~= reason ~ '\\n';\n\n        fn fail_appendStack(lax mut reason: string)\n            SMTH ? reason : [];\n\n        fn fail(mut reason: string)\n            FAIL(reason.fail_appendStack());\n\n        fn main() {\n            implicit mut log = \"\";\n            fail(\"Hello!\");\n            return log.len - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_9IYK1g4d6ia
                                #define STR_9IYK1g4d6ia
static const fu::str str_9IYK1g4d6ia fu_INIT_PRIORITY(1015) { "\n        struct Type { quals: i32 };\n        pub fn tryLookupUserType(type: Type) = type;\n        fn propagateType(type: Type) {\n            let s = tryLookupUserType(type);\n            if (s.quals != 13 || true) return 17;\n            return 19;\n        }\n\n        fn main = 1.Type.propagateType - 17;\n    "_fu };
                                #endif

                                #ifndef STR_FMnRr5Dr6gi
                                #define STR_FMnRr5Dr6gi
static const fu::str str_FMnRr5Dr6gi fu_INIT_PRIORITY(1015) { "\n        <alt>\n        inline          <alt/>\n        noinline        </alt>\n        fn voidfn(ref a: i32) { a += 100; }\n\n        <alt>\n        inline   ;; Goto<alt/>\n        noinline        </alt>\n        fn returnVoidExpr(ref a: i32, ref b: i32) {\n            while (b --> 0) {\n                a++;        // bad cg emitted just 'return;'\n                if (a & 1)  return voidfn(a);\n            }\n        }\n\n        fn main() {\n            mut a = 0;\n            mut b = 10;\n            returnVoidExpr(a, b);\n            return a == 101 && b == 9 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_96ZDJIk4Tb7
                                #define STR_96ZDJIk4Tb7
static const fu::str str_96ZDJIk4Tb7 fu_INIT_PRIORITY(1015) { "\n        fn hello(implicit<alt>: i32</alt>) = implicit;\n        fn main() = 0.hello;\n    "_fu };
                                #endif

                                #ifndef STR_LBEkNBfWyH6
                                #define STR_LBEkNBfWyH6
static const fu::str str_LBEkNBfWyH6 fu_INIT_PRIORITY(1015) { "\n        fn voidIf(ref a: i32, ref b: u32)\n            <fail no common supertype i32 u32 4:17+1>\n            a   ? a++\n                : b++;\n            <pass/>\n            if (a)  a++;\n            else    b++;\n            </fail>\n\n        fn main() {\n            mut a: i32;\n            mut b: u32;\n            voidIf(:a, :b);\n            return !a && b ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_2VO9qrsYgaa
                                #define STR_2VO9qrsYgaa
static const fu::str str_2VO9qrsYgaa fu_INIT_PRIORITY(1015) { "\n        struct ScopeItem { id: string; uval: u32 }\n\n        fn search(ref items: ScopeItem[..], id: string, ref scope_iterator: i32): u32\n        {\n            if (!scope_iterator)\n                scope_iterator = items.len;\n\n            defer if (scope_iterator == 0)\n                scope_iterator = -1;\n\n            while (scope_iterator --> 0) {\n                let item = items[scope_iterator];\n                if (item.id == id)\n                    return item.uval;\n            }\n\n            return [];\n        }\n\n        fn main() {\n            mut items = [ ScopeItem(\"a\", 1), ScopeItem(\"a\", 2), ScopeItem(\"a\", 3) ];\n            mut scope_iterator = 0;\n            mut uval: u32;\n\n            mut result: u32;\n            while ((uval = items.search(\"a\", scope_iterator)))\n                result += uval;\n\n            return (result - 6).signed;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_qzcBzXAkyL1
                                #define STR_qzcBzXAkyL1
static const fu::str str_qzcBzXAkyL1 fu_INIT_PRIORITY(1015) { "\n        fn woot!E (e?: E) {\n            if (E -> [])\n                return 2;\n            else\n                return e(3);\n        }\n\n        fn main() woot * woot(|x| x * 5) - 30;\n    "_fu };
                                #endif

                                #ifndef STR_CTge4gbA3I2
                                #define STR_CTge4gbA3I2
static const fu::str str_CTge4gbA3I2 fu_INIT_PRIORITY(1015) { "\n        fn woot(myfn) myfn(1);\n\n        fn main() {\n            mut sum = 0;            // PARSE DRAMA\n            woot: |one| sum += one; //  stmt lambda, followed by\n            (sum += 1) += 1;        //   '(' which continued as-if-expr\n            return sum -3;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_ixb2sG8mIHk
                                #define STR_ixb2sG8mIHk
static const fu::str str_ixb2sG8mIHk fu_INIT_PRIORITY(1015) { "\n        let PROFILE = <alt>true<alt/>false</alt>;               ;; !DEV_DontFoldLiterals\n\n        struct Empty {};\n        struct NonEmpty { v: i32 };\n\n        type Item = PROFILE ? NonEmpty : Empty;\n\n        lax fn +=(ref a: Item, b: Item)\n            for (fieldname v: Item)\n                a.v += b.v;\n\n        fn get(a: Item) PROFILE ? a.v : 0;\n    "_fu };
                                #endif

                                #ifndef STR_6n6cSZlfwlb
                                #define STR_6n6cSZlfwlb
static const fu::str str_6n6cSZlfwlb fu_INIT_PRIORITY(1015) { "\n        import _0;\n        fn main() {\n            mut a: Item;\n            a += Item();\n            return a.get();\n        }\n    "_fu };
                                #endif

                                #ifndef STR_ubdWzpMsvlk
                                #define STR_ubdWzpMsvlk
static const fu::str str_ubdWzpMsvlk fu_INIT_PRIORITY(1015) { "\n        fn +=(ref a: i64, b: bool)  // Doesn't cg c++ operator (illegal, operands all prim),\n            a += b ? 100 : 0;       //  which drops the RTL ooe guarantee, solver fails to notice.\n\n        fn rellocate(ref a: i64[]) {\n            for (mut i = 0; i < 6; i++)\n                a ~= a;\n\n            return !!a.len;\n        }\n\n        fn main() {\n            mut items = [ i64(1), i64(2), i64(3), i64(4) ];\n            items[0] += rellocate(items);                       ;; N_BckMustSeq\n            return (items[0] - 101).i32;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_hd353XtBVk3
                                #define STR_hd353XtBVk3
static const fu::str str_hd353XtBVk3 fu_INIT_PRIORITY(1015) { "N_BckMustSeq not listed"_fu };
                                #endif

                                #ifndef STR_LFloVZbZU7a
                                #define STR_LFloVZbZU7a
static const fu::str str_LFloVZbZU7a fu_INIT_PRIORITY(1015) { "\n        fn test(x: i32): bool   <fail fn test is missing a final return statement bool, void 3:17+1>\n            let y = x > 10;     <pass/>\n                    x > 10;     </fail>\n\n        fn main() test(3).i32;\n    "_fu };
                                #endif

                                #ifndef STR_U8brJ7vFTWh
                                #define STR_U8brJ7vFTWh
static const fu::str str_U8brJ7vFTWh fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            struct Node {};\n\n            fn evalTypeAnnot(node: Node): bool =        <fail condition is always empty Node use != [] to suppress this warning 6:24+4>\n                return node && [];                      <pass/>\n                return node != [] && [];                </fail>\n\n            fn trySolveTypeParams(node: Node): bool =\n                evalTypeAnnot(node);\n\n            return trySolveTypeParams([]) && 0;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_8NAZgBhQrBb
                                #define STR_8NAZgBhQrBb
static const fu::str str_8NAZgBhQrBb fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            struct Node { v: int };\n    <alt>\n            fn evalTypeAnnot(node: Node) =\n                return !!node;\n    <alt/>\n            fn evalTypeAnnot(node: Node): bool =\n                return node && [];\n    </alt>\n            fn trySolveTypeParams(node: Node): bool =   <fail missing final return expects bool, got void 9:21+6>\n                let expect = evalTypeAnnot(node);       <pass/>\n                             evalTypeAnnot(node);       </fail>\n\n            return trySolveTypeParams([]) && 0;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_E2BdEjaqodi
                                #define STR_E2BdEjaqodi
static const fu::str str_E2BdEjaqodi fu_INIT_PRIORITY(1015) { "\n        fn grow_if_oob(ref a: $T[], i: i32) {\n            if (a.len <= i) a.grow(i + 1);\n            return a[i];\n        }\n\n        struct Scope    { overloads: Overload[]; extended: Extended[] };\n        struct Overload { name: string };\n        struct Extended { locals?: Overload[] };\n\n        fn Scope_create(ref scope: Scope, name: string, nest!?: i32): i32 {\n            ref overloads = nest > 0\n                ? scope.extended.grow_if_oob(nest - 1).locals\n                : scope.overloads;\n\n            overloads.push(Overload(:name));\n            return overloads.len;\n        }\n\n        fn main() {\n            mut scope = Scope(\n                overloads:  [ Overload(\"Hello!\") ],\n                extended:   []);\n\n            let a = scope.Scope_create(\"World!\", nest: 1);\n            let b = scope.Scope_create(\"Bananas!\");\n            return a * 10 + b - 12;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_IjvKDfkycm0
                                #define STR_IjvKDfkycm0
static const fu::str str_IjvKDfkycm0 fu_INIT_PRIORITY(1015) { "\n        fn bfind !T(keys, item: T, hit, miss) {\n            mut lo = 0;\n            mut hi = keys.len;\n\n            while (lo < hi) {\n                let i   = (hi + lo) >> 1;\n                let cmp = keys[i] <> item;\n                if (cmp == 0)\n                    return hit(i);\n            }\n\n            return miss(lo);\n        }\n\n        fn update !<T, U>(keys, item: T, extras, extra: U)\n            bfind(fn keys, :item,\n                hit:  |i| { extras[i] = extra; },\n                miss: |_| {});\n\n        fn get !<T, U>(keys: T[], item: T, extras: U[])\n            bfind(:keys, :item,\n                hit:  |i| { return extras[i]; },\n                miss: |_| { return []; });\n\n        fn Map(type K, type V)\n            struct { keys: K[]; vals: V[] };\n\n        fn set(using ref _: Map(_, _), key, value)\n            update(|| keys, key, || vals, value);\n\n        fn get(using _: Map(_, _), key)\n            get(keys, key, vals);\n\n        fn resolveFile(ref cache: Map(string, string), path: string): string\n        {\n            if (let cached = cache.get(path))\n                return cached == \"\v\" ? \"\" : cached;\n\n            cache.set(path, \"\v\");\n            return \"\";\n        }\n\n        fn main() {\n            mut cache: Map(string, string);\n            return cache.resolveFile(\"abc\").len;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_aiAv7Gll9p0
                                #define STR_aiAv7Gll9p0
static const fu::str str_aiAv7Gll9p0 fu_INIT_PRIORITY(1015) { "\n        struct Target       { globid: i32; locid: i32 }\n        struct Overload     { name: string }\n        struct Extended     { locals: Overload[] }\n\n        nocopy struct Scope {\n            overloads: Overload[]; extended: Extended[]; total: i32\n        }\n\n        fn grow_if_oob(ref a: $T[], i: i32) {\n            if (a.len <= i) a.grow(i + 1);\n            return a[i];\n        }\n\n        fn CREATE(ref scope: Scope, name: string, nest!?: Target) {\n            ref overloads = nest\n                ? scope.extended.grow_if_oob(nest.globid - 1).locals\n                : scope.overloads;\n\n            <flip>\n            scope.total++;\n            <flip/>\n            overloads ~= Overload(:name);\n            let index = overloads.len;\n            </flip>\n\n            return Target(\n                globid: nest ? nest.globid : index,\n                 locid: nest ? index       : 0);\n        }\n\n        fn GET(ref scope: Scope, target: Target)\n            target.locid\n                ? scope.extended[target.globid - 1].locals[target.locid - 1]\n                : scope.overloads[target.globid - 1];\n\n        fn DUPE(ref scope: Scope, target: Target)\n            CREATE(scope, GET(scope, target).name);\n\n        fn main() {\n            mut scope: Scope;\n            let hello = scope.CREATE(\"hello!\");\n            let world = scope.CREATE(\"world!\", nest: hello);\n            scope.DUPE(world);\n\n            mut result  = \"\";\n            scope.overloads.each: |o, i| {\n                result ~= \"+\" ~ o.name;\n                if (scope.extended.len > i)\n                    scope.extended[i].locals.each: |x|\n                        result ~= \"-\" ~ x.name;\n            }\n\n            return scope.total == 3 && result == \"+hello!-world!+world!\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_AADRVY4JCP5
                                #define STR_AADRVY4JCP5
static const fu::str str_AADRVY4JCP5 fu_INIT_PRIORITY(1015) { "\n        fn First(s: $T[..]) s.len && s[0];\n        struct Node { items: Node[] }\n\n        fn tryFirst(node: Node)\n            node.items\n                ? tryFirst(node.items.First)\n                : node;\n\n        fn main()\n            tryFirst(\n                Node([ Node([ Node, Node ])]))\n                    .items.len;\n    "_fu };
                                #endif

                                #ifndef STR_mx7D8BYaRAd
                                #define STR_mx7D8BYaRAd
static const fu::str str_mx7D8BYaRAd fu_INIT_PRIORITY(1015) { "\n        fn First(s: $T[..]) s.len && s[0];\n        struct Node { value: i32; items: Node[] }\n\n        fn tryFirst(node: Node)\n            node.items\n                ? tryFirst(node.items.First)\n                : node;\n\n        fn main()\n            tryFirst(\n                Node(1, [ Node(2, [ Node(3, []), Node(4, []) ])]))\n                    .value - 3;\n    "_fu };
                                #endif

                                #ifndef STR_IO0uNMPZc69
                                #define STR_IO0uNMPZc69
static const fu::str str_IO0uNMPZc69 fu_INIT_PRIORITY(1015) { "\n        fn First(s: $T[..]) s.len && s[0];\n        fn Last (s: $T[..]) s.len && s[s.len - 1];\n        struct Node { value: i32; items: Node[] }\n\n        fn tryFirst(node: Node)\n            node.items  ? tryLast(node.items.First)\n                        : node;\n\n        fn tryLast(node: Node)\n            node.items  ? tryFirst(node.items.Last)\n                        : node;\n\n        fn main()\n            tryFirst(\n                Node(1, [ Node(2, [ Node(3, []), Node(4, []) ])]))\n                    .value - 4;\n    "_fu };
                                #endif

                                #ifndef STR_mK1xbU4NnVh
                                #define STR_mK1xbU4NnVh
static const fu::str str_mK1xbU4NnVh fu_INIT_PRIORITY(1015) { "\n        struct Thing { a: i32; b: i32 };\n        struct Stuff { _gets: Thing[]; _root: Thing; _exts: Thing[] };\n\n        fn GET(ref s: Stuff, i: int) s._gets[i];\n        fn EXT(ref s: Stuff, i: int) s._exts[i];\n\n        fn lookup(ref s: Stuff, i: int) {\n            let start = s._root || s.GET(i);\n            if (!start) return start;\n            return s.EXT(i);\n        }\n\n        fn main() {\n            mut s = Stuff([ Thing(0, 1) ], Thing(1, 2), [ Thing(2, 3) ]);\n            return s.lookup(0).a - 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_jml9OOAxvN0
                                #define STR_jml9OOAxvN0
static const fu::str str_jml9OOAxvN0 fu_INIT_PRIORITY(1015) { "\n        fn Zero(implicit ref result: i32, src: i32[..]) =\n            src.each: |x, i| result += x * (i + 1);\n        fn Todo(implicit ref result: i32, src: i32[..]) =\n            src.each: |x, i| result += x * (i + 1) * 7;\n\n        fn Zero(src: i32) = Zero([ src ]);\n        fn Todo(src: i32) = Todo([ src ]);\n    "_fu };
                                #endif

                                #ifndef STR_J5k72AQT8vh
                                #define STR_J5k72AQT8vh
static const fu::str str_J5k72AQT8vh fu_INIT_PRIORITY(1015) { "\n        import _0;\n        fn main() {\n            implicit mut result = 0;\n\n            let Solo = fn Zero;\n            lax fn Solo_muteRest(_) {}\n            shadow let Zero = fn Solo_muteRest;\n            shadow let Todo = fn Solo_muteRest;\n\n            <alt>\n            mut queue: string;\n            fn Parzero(x: i32) queue ~= x;\n            shadow let result = || {\n                queue.each(.Zero);\n                result\n            };\n            shadow let Zero = fn Parzero;\n            </alt>\n\n            let Todo_A = fn Todo;\n            let Todo_B = fn Todo;\n\n            Zero([ 10 ]);   Zero(11);\n            Todo([ 12 ]);   Todo(13);\n            Todo_A([ 14 ]); Todo_A(15);\n            Todo_B([ 16 ]); Todo_B(17);\n            Solo([ 18 ]);   Solo(19);\n\n            return result - 37;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_JthWo7jvICd
                                #define STR_JthWo7jvICd
static const fu::str str_JthWo7jvICd fu_INIT_PRIORITY(1015) { "\n        struct Node { items: Node[]; }\n        struct Type { value: i32 };\n\n        let t_void = Type(0);\n\n        fn main() {\n            fn createEmpty(lax type: Type or Node = t_void) = [];\n\n            fn solveTypedef(node): Type {\n                lax let annot = node.items\n                    && solveTypedef(node.items[0]);\n\n                if (annot) {\n                    mut relaxed = annot;\n                    return createEmpty(type: relaxed);\n                }\n\n                return createEmpty();\n            }\n\n            return solveTypedef(Node()).value;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_q5K6cSDBIs7
                                #define STR_q5K6cSDBIs7
static const fu::str str_q5K6cSDBIs7 fu_INIT_PRIORITY(1015) { "\n        using flags DeclAsserts { A; B };\n        flags SomethingElse { AA; BB };\n\n        fn GET_NEXT_LOCAL_oob() {\n            fn parseNoCopy(x: DeclAsserts or SomethingElse = A) x;\n            fn parseBlockLike(y) y | parseNoCopy();\n            return parseBlockLike(B);\n        }\n\n        fn main() GET_NEXT_LOCAL_oob().i32 - 3;\n    "_fu };
                                #endif

                                #ifndef STR_Rpo89VSoDph
                                #define STR_Rpo89VSoDph
static const fu::str str_Rpo89VSoDph fu_INIT_PRIORITY(1015) { "\n        fn main() (\"hello\" == \"world\").i32;\n    "_fu };
                                #endif

                                #ifndef STR_G78onPwzfJ9
                                #define STR_G78onPwzfJ9
static const fu::str str_G78onPwzfJ9 fu_INIT_PRIORITY(1015) { "\n        struct Node { items?: Node[]; value?: i32 };\n\n        fn tryConvert(ref default: Node) {\n            if (default.items) {\n                default.items ~= default;\n                default.value += 10;\n                return true;\n            }\n\n            return false;\n        }\n\n        fn updateScope(unspecced: Node[], ref defaults: Node[]) {\n            for (mut i = 0; i < defaults.len; i++) {\n                defaults[i] = {\n                    :DEFAULT {\n                        if (!unspecced)\n                            break :DEFAULT (i < defaults.len - 1)\n                                && defaults[i + 1];\n\n                        mut default = unspecced.len > i && unspecced[i];\n                        if (default && tryConvert(default))\n                            break :DEFAULT default;\n\n                        break :DEFAULT [];\n                    }\n                };\n            }\n        }\n\n        fn main() {\n            mut nodes = [ Node(items: [ Node() ]) ];\n            for (mut i = 0; i < 4; i++) {\n                mut node = nodes[nodes.len - 1];\n                tryConvert(node);\n                nodes ~= node;\n            }\n\n            updateScope(nodes, nodes);\n\n            mut checksum = 0;\n            fn checksum(shadow nodes: Node[]) {\n                checksum += nodes.len;\n                for (mut i = 0; i < nodes.len; i++) {\n                    let node = nodes[i];\n                    checksum(node.items);\n                    checksum += 1000 * node.value;\n                }\n            }\n\n            checksum(nodes);\n            return checksum == 570124 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_JKcVp1yK6T5
                                #define STR_JKcVp1yK6T5
static const fu::str str_JKcVp1yK6T5 fu_INIT_PRIORITY(1015) { "\n        struct TEA { v0: u32; v1: u32 }\n\n        inline fn r4(using ref _: TEA, ref sum: u32) {\n            mut delta: u32 = 0x9e3779b9;\n            for (mut i = 0; i < 4; i++) {\n                sum += delta;\n                v0 += ((v1<<4) + 0xA341316C) ^ (v1 + sum) ^ ((v1>>5) + 0xC8013EA4);\n                v1 += ((v0<<4) + 0xAD90777D) ^ (v0 + sum) ^ ((v0>>5) + 0x7E95761E);\n            }\n        }\n\n        inline fn u32(tea: TEA): u32 =\n            tea.v0 ^ tea.v1;                                    ;; GNUStmtExpr\n\n        fn main() {\n            mut tea: TEA;\n            mut sum: u32;\n            tea.r4(sum);\n            let actual = tea.u32;\n            return actual == 0x93bfa05 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_pIOO3VBh8s4
                                #define STR_pIOO3VBh8s4
static const fu::str str_pIOO3VBh8s4 fu_INIT_PRIORITY(1015) { "Ambig call to u32 4:49+3 matches inline u32 13:19+3"_fu };
                                #endif

                                #ifndef STR_hKwc9fKGRZf
                                #define STR_hKwc9fKGRZf
static const fu::str str_hKwc9fKGRZf fu_INIT_PRIORITY(1015) { "\n        let a = 7;\n        let b = a && 3;\n        return b - 3;\n    "_fu };
                                #endif

                                #ifndef STR_x5G9gnMvee2
                                #define STR_x5G9gnMvee2
static const fu::str str_x5G9gnMvee2 fu_INIT_PRIORITY(1015) { "\n        struct S { i: i32; }\n\n        let a = S(0);\n        let b = S(3);\n\n        return a.i\n            || (b || S(4)).i * 2 - (a || S(6)).i\n            && throw(\"woot\");\n    "_fu };
                                #endif

                                #ifndef STR_ugDZ60Z0vKc
                                #define STR_ugDZ60Z0vKc
static const fu::str str_ugDZ60Z0vKc fu_INIT_PRIORITY(1015) { "\n        struct KindValue { kind: string; value: string; };\n\n        mut spec = KindValue(kind: \"fn\", value: \"val\");\n        spec.kind == \"fn\" && spec.value || throw(\"nope\");\n        ref v = spec.kind == \"fn\" ? spec.value : throw(\"nope\");\n\n        v ~= \"ue\";\n        return spec.value == \"value\" ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_xK9bm3Xa4zi
                                #define STR_xK9bm3Xa4zi
static const fu::str str_xK9bm3Xa4zi fu_INIT_PRIORITY(1015) { "\n        struct Token {\n            value: string;\n        };\n\n        fn consume(): Token {\n            return Token(\"hey\");\n        };\n\n        fn main(): i32 {\n            let a = 3;\n            let v = a && consume().value;\n            return v.len - a;\n        };\n    "_fu };
                                #endif

                                #ifndef STR_vcPSIkvp8ob
                                #define STR_vcPSIkvp8ob
static const fu::str str_vcPSIkvp8ob fu_INIT_PRIORITY(1015) { "\n        struct ScopeIdx { raw: i32; };\n        <fail bad call = 12:27+1 incompatible types for T>\n        fn thing(x: i32) x;             <pass/>\n        fn thing(x: i32) ScopeIdx(x);   </fail>\n        mut _return_scope: ScopeIdx;\n\n        fn hey(x: i32) {\n            let scope0 = thing(x);\n            _return_scope = scope0; //overload\n            return _return_scope.raw;\n        }\n\n        return hey(0);\n    "_fu };
                                #endif

                                #ifndef STR_WQOmA1IVh1e
                                #define STR_WQOmA1IVh1e
static const fu::str str_WQOmA1IVh1e fu_INIT_PRIORITY(1015) { "\n        fn maybe_empty(N: i32) {\n            mut res: string[];\n            for (mut i = 0; i < N; i++) res ~= [ \"world!\" ]; // same as below but wrapped\n            return res;\n        }\n        fn main() {\n            mut arr = [ \"Hello\" ];\n            for (mut i = 0; i < 2; i++) arr ~= maybe_empty(i); // will append empty\n            return arr.join(\" \") == \"Hello world!\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_nb54bLkYkRk
                                #define STR_nb54bLkYkRk
static const fu::str str_nb54bLkYkRk fu_INIT_PRIORITY(1015) { "\n        fn maybe_empty(N: i32) {\n            mut res: string[];\n            for (mut i = 0; i < N; i++) res ~= \"world!\"; // cpp template issue here\n            return res;\n        }\n        fn main() {\n            mut arr = [ \"Hello\" ];\n            for (mut i = 0; i < 2; i++) arr ~= maybe_empty(i); // will append empty\n            return arr.join(\" \") == \"Hello world!\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_kOWe0eXsI5g
                                #define STR_kOWe0eXsI5g
static const fu::str str_kOWe0eXsI5g fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut _info = \"abc\";\n\n            pure fn fail(mut reason: string = \"\") {\n                ref info = _info[0]; // <- notice the ref, has to relax away\n                reason ~= info && info.i32;\n                return reason;\n            }\n\n            return fail.len - 2; // 'a' is 97, \"97\".len is 2.\n        }\n    "_fu };
                                #endif

                                #ifndef STR_9zkccdn7AQ8
                                #define STR_9zkccdn7AQ8
static const fu::str str_9zkccdn7AQ8 fu_INIT_PRIORITY(1015) { "\n        let q_mutref = 1;\n        pub let RELAX_mutref_only = q_mutref;\n        pub fn what(relax_mask: i32) relax_mask -1;\n    "_fu };
                                #endif

                                #ifndef STR_1XtA3r4zIHg
                                #define STR_1XtA3r4zIHg
static const fu::str str_1XtA3r4zIHg fu_INIT_PRIORITY(1015) { "\n        import _0;\n        fn main() what(RELAX_mutref_only);\n    "_fu };
                                #endif

                                #ifndef STR_yHJW0nOJvE1
                                #define STR_yHJW0nOJvE1
static const fu::str str_yHJW0nOJvE1 fu_INIT_PRIORITY(1015) { "\n        pub fn pairs(a: Map($K, $V), fn) {\n            let k = a.keys;\n            let v = a.values;\n            for (mut i = 0; i < k.len; i++)\n                fn(k[i], v[i]);\n        }\n\n        fn main() {\n            mut map: Map(i32, i32);\n            map[1] = 2;\n            map[3] = 4;\n\n            mut sum = 0;\n            map.pairs(|k, v| sum += k + v * 100);\n            return sum - 604;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_CTsvbD2mvKh
                                #define STR_CTsvbD2mvKh
static const fu::str str_CTsvbD2mvKh fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            try         { return 0; }\n            catch (e)   { return e == \"x=2: even!\" ? 11 : 22; }\n        }\n    "_fu };
                                #endif

                                #ifndef STR_N6tUBF0E9cd
                                #define STR_N6tUBF0E9cd
static const fu::str str_N6tUBF0E9cd fu_INIT_PRIORITY(1015) { "\n        fn fail(str: string)\n            throw(str ~ \"!\");\n\n        fn test(x: i32)\n        {\n            // We want to override fail but\n            //  we want to call it within the override,\n            //   so we can do this i guess?\n            //\n            shadow let fail = |mut str: string| {\n                str = \"x=\" ~ x ~ \": \" ~ str;\n                fail(str);\n            };\n\n            return x & 1 || fail(\"even\");\n        }\n\n        fn main() {\n            try {\n                return test(2);\n            }\n            catch (e) {\n                <alt>\n                return e == \"x=2: even!\" ? 0 : 10;\n                <alt/>\n                shadow let e = \"hello \" ~ e;\n                return e == \"hello x=2: even!\" ? 0 : 10;\n                </alt>\n            }\n        }\n    "_fu };
                                #endif

                                #ifndef STR_WBLgVmIOy2d
                                #define STR_WBLgVmIOy2d
static const fu::str str_WBLgVmIOy2d fu_INIT_PRIORITY(1015) { "\n        // The Cats&Dogs example from\n        //  JuliaCon 2019: The Unreasonable Effectiveness of Multiple Dispatch\n        //   https://www.youtube.com/watch?v=kc9HwsxE1OY\n        //\n        fn encounter(a, b) {\n            let verb = meets(a, b);\n            return a.name ~ \" meets \" ~ b.name ~ \" and \" ~ verb ~ \"\\n\";\n        }\n\n        struct Dog { name: string };\n        struct Cat { name: string };\n\n        fn meets(lax a: Dog, lax b: Dog) \"sniffs\";\n        fn meets(lax a: Dog, lax b: Cat) \"chases\";\n        fn meets(lax a: Cat, lax b: Dog) \"hisses\";\n        fn meets(lax a: Cat, lax b: Cat) \"slinks\";\n\n        fn main() {\n            let fido        = Dog(\"Fido\");\n            let rex         = Dog(\"Rex\");\n            let whiskers    = Cat(\"Whiskers\");\n            let spots       = Cat(\"Spots\");\n\n            mut res = encounter(fido, rex)\n                    ~ encounter(fido, whiskers)\n                    ~ encounter(whiskers, rex)\n                    ~ encounter(whiskers, spots);\n\n            return res == \"Fido meets Rex and sniffs\\n\"\n                        ~ \"Fido meets Whiskers and chases\\n\"\n                        ~ \"Whiskers meets Rex and hisses\\n\"\n                        ~ \"Whiskers meets Spots and slinks\\n\"\n                            ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_EDaCgeUrtEl
                                #define STR_EDaCgeUrtEl
static const fu::str str_EDaCgeUrtEl fu_INIT_PRIORITY(1015) { "\n        struct S { i: i32; }\n        fn test(mut x: S) x.i += 1;\n        return S(-1).test;\n    "_fu };
                                #endif

                                #ifndef STR_S6gcyKuglei
                                #define STR_S6gcyKuglei
static const fu::str str_S6gcyKuglei fu_INIT_PRIORITY(1015) { "                                  ;; DuplicateFunctions\n        fn ARR_LAST(ref a: $T[])\n            a[a.len - 1];\n\n        let a = [1];\n        mut b = [2];\n\n        b.ARR_LAST += a.ARR_LAST;\n        return b.ARR_LAST - [3].ARR_LAST;\n    "_fu };
                                #endif

                                #ifndef STR_j5brj1fMTD6
                                #define STR_j5brj1fMTD6
static const fu::str str_j5brj1fMTD6 fu_INIT_PRIORITY(1015) { "\n        struct mat4 { i: i32; };\n        struct RenderFrame { u_mat4_VP: mat4; };\n\n        inline fn mat4_identity() mat4(1);\n\n        fn test(ref output: RenderFrame) {\n            output.u_mat4_VP = mat4_identity;\n        }\n\n        fn main() {\n            mut ret: RenderFrame;\n            test(ret);\n            return ret.u_mat4_VP.i - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_YKRLxJfVOua
                                #define STR_YKRLxJfVOua
static const fu::str str_YKRLxJfVOua fu_INIT_PRIORITY(1015) { "\n        pub struct ScopeSkip {\n            start: i32;\n            end:   i32;\n        };\n\n        pub fn search(skip: ScopeSkip = [])\n            skip.end - skip.start;\n\n        pub fn main()\n            <fail bad call to ScopeSkip 12:13+9>\n            ScopeSkip(min: -1, max: +1)     <pass/>\n            ScopeSkip(start: -1, end: +1)   </fail>\n                .end - 1;\n    "_fu };
                                #endif

                                #ifndef STR_VyhBOAWWWbf
                                #define STR_VyhBOAWWWbf
static const fu::str str_VyhBOAWWWbf fu_INIT_PRIORITY(1015) { "\n        struct vec3 { x?: f32; y?: f32; z?: f32; };\n\n        struct mat34 {\n            mx: vec3; my: vec3; mz: vec3;\n            mo: vec3;\n        };\n\n        inline fn mat34_identity()\n            mat34(\n                vec3(x: 1),\n                vec3(y: 1),\n                vec3(z: 1), vec3 /*point3*/);\n\n        // What broke is this using reports a conflict,\n        //  because 'determinant' got expanded within 'inverse',\n        //   and there's another using mat34 there.\n        //    Basically we totally don't want it to expand there.\n        inline fn determinant(using _: mat34): f32\n            - mz.x * my.y * mx.z + my.x * mz.y * mx.z + mz.x * mx.y * my.z\n            - mx.x * mz.y * my.z - my.x * mx.y * mz.z + mx.x * my.y * mz.z;\n\n        fn inverse(using mat: mat34): mat34\n        {\n            let idet = 1 / mat.determinant;\n\n            let i_mx = vec3(\n                idet * (- mz.y * my.z + my.y * mz.z),\n                idet * (+ mz.y * mx.z - mx.y * mz.z),\n                idet * (- my.y * mx.z + mx.y * my.z));\n\n            let i_my = vec3(\n                idet * (+ mz.x * my.z - my.x * mz.z),\n                idet * (- mz.x * mx.z + mx.x * mz.z),\n                idet * (+ my.x * mx.z - mx.x * my.z));\n\n            let i_mz = vec3(\n                idet * (- mz.x * my.y + my.x * mz.y),\n                idet * (+ mz.x * mx.y - mx.x * mz.y),\n                idet * (- my.x * mx.y + mx.x * my.y));\n\n            return mat34(\n                i_mx, i_my, i_mz,\n\n                vec3( // point3\n                      mo.x * -i_mx.x +\n                      mo.y * -i_my.x +\n                      mo.z * -i_mz.x,\n\n                      mo.x * -i_mx.y +\n                      mo.y * -i_my.y +\n                      mo.z * -i_mz.y,\n\n                      mo.x * -i_mx.z +\n                      mo.y * -i_my.z +\n                      mo.z * -i_mz.z));\n        }\n\n        fn main() i32 <|\n            mat34_identity.inverse.determinant - 1;\n    "_fu };
                                #endif

                                #ifndef STR_A6bqOp9jkQf
                                #define STR_A6bqOp9jkQf
static const fu::str str_A6bqOp9jkQf fu_INIT_PRIORITY(1015) { "\n        struct TEA { v0: u32; v1: u32 }\n\n        inline fn r4(using ref _: TEA, ref sum: u32) {\n            mut delta: u32 = 0x9e3779b9;\n            for (mut i = 0; i < 4; i++) {\n                sum += delta;\n                v0 += ((v1<<4) + 0xA341316C) ^ (v1 + sum) ^ ((v1>>5) + 0xC8013EA4);\n                v1 += ((v0<<4) + 0xAD90777D) ^ (v0 + sum) ^ ((v0>>5) + 0x7E95761E);\n            }\n        }\n\n        // Stack overflow solving this,\n        //  argmax is +inf, and it just\n        //   re-enters and re-enters.\n        inline fn r4(ref tea: TEA) {\n            mut sum: u32; tea.r4(sum);\n        }\n\n        fn main() {\n            mut tea: TEA;\n            tea.r4();\n            return (tea.v0 ^ tea.v0).i32;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Vnpz84BUw70
                                #define STR_Vnpz84BUw70
static const fu::str str_Vnpz84BUw70 fu_INIT_PRIORITY(1015) { "\n        struct ScopeSkip {\n            min: i32;\n            max: i32;\n        };\n\n        fn main() {\n            let a = 1;\n            mut x: ScopeSkip; x = []; x = [ -2, 0 ]; // Inference fail.\n            mut t: ScopeSkip; t = x.min && [ x.min, a ];\n            return a + t.min + t.max;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_obYFqukJtP7
                                #define STR_obYFqukJtP7
static const fu::str str_obYFqukJtP7 fu_INIT_PRIORITY(1015) { "Incompatible types for T 9:41+1"_fu };
                                #endif

                                #ifndef STR_0zyzS2HLe78
                                #define STR_0zyzS2HLe78
static const fu::str str_0zyzS2HLe78 fu_INIT_PRIORITY(1015) { "\n        fn setupOperators(i: i32) {\n            <alt>\n            struct sB { hey: i32; };\n            struct BINOP { i: sB; };\n            <alt/>\n            fn sB(_: $T) struct { hey: $T; };\n            struct BINOP { i: sB(i32); };\n            </alt>\n            return BINOP([ i ]); // Inference fail.\n        }\n\n        fn main() setupOperators(0).i.hey;\n    "_fu };
                                #endif

                                #ifndef STR_93NC1NGKYFa
                                #define STR_93NC1NGKYFa
static const fu::str str_93NC1NGKYFa fu_INIT_PRIORITY(1015) { "Bad call to BINOP 7:20+5"_fu };
                                #endif

                                #ifndef STR_WJZwFyazgz6
                                #define STR_WJZwFyazgz6
static const fu::str str_WJZwFyazgz6 fu_INIT_PRIORITY(1015) { "\n        struct X { i: i32; };\n        type Y = X;\n        fn main() Y(1).i / 2;\n    "_fu };
                                #endif

                                #ifndef STR_mv4hceYbq9a
                                #define STR_mv4hceYbq9a
static const fu::str str_mv4hceYbq9a fu_INIT_PRIORITY(1015) { "\n        struct Node {\n            kind  ?: string;\n            items ?: Node[];\n            value ?: string;\n        };\n\n        fn astReplace(node: Node, mutate): Node {\n            fn walk(shadow ref node: Node) {\n                for (mut i = 0; i < node.items.len; i++)\n                    walk(node.items[i]);\n\n                mutate(node);\n            }\n\n            shadow mut node = node;\n            walk(node);\n            return node;\n        }\n\n        fn test(n: Node, a: string, b: string) {\n            return astReplace(n, |ref item: Node| {\n                if (item.value == a) {\n                    if (item.items.len == 1 && item.kind == \"call\")\n                        item.value = b;\n                    else if (item.kind == \"str\")\n                        item.value = b;\n                }\n            });\n        }\n\n        fn main() {\n            let v0 = Node(kind: \"str\", value: \"woot\");\n            let v1 = v0.test(\"woot\", \"who\");\n            return v1.value.len - 3;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_F8dG5TXPNhb
                                #define STR_F8dG5TXPNhb
static const fu::str str_F8dG5TXPNhb fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut x:  <fail redundant typeof not a value 4:28+3>\n                    typeof(i32)     <pass/>\n                    i32             </fail> = 0;\n            return x;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_w8xka4WNc33
                                #define STR_w8xka4WNc33
static const fu::str str_w8xka4WNc33 fu_INIT_PRIORITY(1015) { "\n        struct SolvedNode {\n            value: i32;\n            items?: SolvedNode[];\n        };\n\n        fn visitNodes(ref _v: $V, _n: SolvedNode)\n        {\n            fn traverse(ref v: $V, n: SolvedNode) {\n                v.visit(n);\n                for (mut i = 0; i < n.items.len; i++)\n                    traverse(v, n.items[i]);\n            }\n\n            traverse(_v, _n);\n        };\n\n        struct Visitor {\n            sum: i32;\n        };\n\n        fn visit(using ref v: Visitor, node: SolvedNode) {\n            sum += node.value;\n        };\n\n        fn main(): i32 {\n            let tree = SolvedNode(3,\n                [ SolvedNode(5), SolvedNode(7) ]);\n\n            <alt>\n            // This is an aside, managed to lose the copy qual when working structs\n            //  Initially noticed it because visitNodes tried to change its sighash\n            mut cpy = tree; cpy = tree; // <- but this fails cleanly when tree is nocopy\n            </alt>\n\n            mut myVisitor: Visitor;\n            myVisitor.visitNodes(tree);\n            return myVisitor.sum - 15;\n        };\n    "_fu };
                                #endif

                                #ifndef STR_OtPU6RZhcth
                                #define STR_OtPU6RZhcth
static const fu::str str_OtPU6RZhcth fu_INIT_PRIORITY(1015) { "\n        return 0 > 1 ? throw(\"should type check\") : 0;\n    "_fu };
                                #endif

                                #ifndef STR_M2D85C9Gjie
                                #define STR_M2D85C9Gjie
static const fu::str str_M2D85C9Gjie fu_INIT_PRIORITY(1015) { "\n        fn throw_hey(): i32 {\n            throw(\"hey\");\n            return 1;\n        }\n\n        fn main(): i32 {\n            try {\n                let _x = throw_hey();\n                return _x || 7;\n            }\n            catch (err) {\n                return err.len - 3;\n            }\n        }\n    "_fu };
                                #endif

                                #ifndef STR_HngqjVSOr8d
                                #define STR_HngqjVSOr8d
static const fu::str str_HngqjVSOr8d fu_INIT_PRIORITY(1015) { "\n        fn throw_hey() {\n            throw(\"hey\");\n        }\n\n        fn main(): i32 {\n            try {\n                let _x = throw_hey();\n                return _x || 7;\n            }\n            catch (err) {\n                return err.len - 3;\n            }\n        }\n    "_fu };
                                #endif

                                #ifndef STR_EMW0GmzsNQ1
                                #define STR_EMW0GmzsNQ1
static const fu::str str_EMW0GmzsNQ1 fu_INIT_PRIORITY(1015) { "\n        fn throw_hey(): i32 {\n            throw(\"hey\");\n            return 1;\n        }\n\n        fn main(): i32 {\n            try {\n                return throw_hey();\n            }\n            catch (e) {\n                return e.len - 3;\n            }\n\n            return 11;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_hSwpopTaNsf
                                #define STR_hSwpopTaNsf
static const fu::str str_hSwpopTaNsf fu_INIT_PRIORITY(1015) { "\n        fn main()\n            cli_handle([ \"hello\", \"you\" ]);\n\n        fn cli_handle(args: string[]): i32\n        {\n            mut idx = 0;\n\n            fn next() {\n                let i = idx++;\n                if (i < args.len)\n                    return args[i];\n\n                return \"\";\n            }\n\n            // Router.\n            return next().len - 5;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_FV5pePYQVli
                                #define STR_FV5pePYQVli
static const fu::str str_FV5pePYQVli fu_INIT_PRIORITY(1015) { "\n        struct X { i: i32; };\n\n        fn         ++(using ref x: X) ++i;\n        postfix fn ++(using ref x: X) i++;\n\n        fn main() {\n            mut x: X;\n            let a = x++;\n            let b = ++x;\n            return a || b - 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_EY6j8Qm8IJc
                                #define STR_EY6j8Qm8IJc
static const fu::str str_EY6j8Qm8IJc fu_INIT_PRIORITY(1015) { "\n        fn test(s: $T) {\n            mut sum = 0;\n            for (fieldname i: $T) sum += s.i;\n            return sum;\n        }\n\n        struct XY { x: i32; y: i32; };\n\n        fn main() {\n            let thing = XY(1, 2);\n            let sum = test(thing);\n            return sum - 3;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_s2Jgjlmq8Jj
                                #define STR_s2Jgjlmq8Jj
static const fu::str str_s2Jgjlmq8Jj fu_INIT_PRIORITY(1015) { "\n        struct ScopeSkip     { imports:     i32[]; implicits:     i32[]; }\n        struct ScopeSkipMemo { imports_len: i32;   implicits_len: i32;   }\n\n        fn snap(ss: ScopeSkip) {\n            mut r: ScopeSkipMemo;\n            for (fieldname i: typeof(ss))\n                r.i_len = ss.i.len;\n\n            return r;\n        }\n\n        fn check(v) {\n            mut sum = 0; mut mul = 1;\n            for (fieldname i: typeof(v)) {\n                sum += v.i * mul; mul *= 10;\n            }\n\n            return sum;\n        }\n\n        fn main() check(snap(ScopeSkip([ 1 ], [ 2, 2 ]))) - 21;\n    "_fu };
                                #endif

                                #ifndef STR_PPtWuM5nPX7
                                #define STR_PPtWuM5nPX7
static const fu::str str_PPtWuM5nPX7 fu_INIT_PRIORITY(1015) { "\n        fn Lazy(getValue) {\n            struct Lazy {\n                evaluated?: bool;\n                value?:     typeof(getValue());\n                getValue?:  typeof(fn getValue);\n            };\n\n            return Lazy();\n        }\n\n        fn get(ref lazy) {\n            if (!lazy.evaluated) {\n                lazy.evaluated  = true;\n\n                // This is just exploratory stuff,\n                //  don't feel obliged to keep this working.\n                let getValue    = lazy.getValue;\n                lazy.value      = getValue();\n            }\n\n            return lazy.value;\n        }\n\n        fn main() {\n            mut calls   = 0;\n            mut lazy    = Lazy(|| calls++);\n            mut res     = lazy.get() + lazy.get();\n\n            return res == 0 && calls == 1 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_6F6YVtf8zu7
                                #define STR_6F6YVtf8zu7
static const fu::str str_6F6YVtf8zu7 fu_INIT_PRIORITY(1015) { "\n        fn ERRLOG(implicit ref errout: string, msg = \"Assertion failed.\\n\") {\n            errout ~= msg;\n            return [];\n        }\n\n        fn tryParse(str: string) {\n            implicit mut errout: string;\n            return parse(str) || errout;\n        }\n\n        fn parse(mut str: string)\n        {\n            fn parseExpression!T(parseHead: T = fn popOneChar) {\n                let head = parseHead();\n                return parseExpressionTail(head);\n            }\n\n            fn popOneChar() {\n                if (!str) return ERRLOG(\"str.len < 1\");\n                let lastChar = str.slice(str.len - 1, str.len);\n                str.pop();\n                return lastChar;\n            }\n\n            fn popTwoChars() {\n                if (str.len < 2) return ERRLOG(\"str.len < 2\");\n                let lastChars = str.len > 1 && str.slice(str.len - 2, str.len);\n                str.shrink(str.len - 2);\n                return lastChars;\n            }\n\n            fn parseExpressionTail(head: string) {\n                return head ~ head;\n            }\n\n            return parseExpression()\n                 ~ parseExpression(parseHead: popTwoChars);\n        }\n\n        <split/>\n        let PRELUDE =           <fail no implicit errout 2:32+6 needed to call fn parse :13+5>\n            parse(\"AAB\");       <pass/>\n            tryParse(\"AAB\");    </fail>\n\n        <split/>\n        fn main() PRELUDE.len == 6 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_yTocFvWRCJ9
                                #define STR_yTocFvWRCJ9
static const fu::str str_yTocFvWRCJ9 fu_INIT_PRIORITY(1015) { "\n        fn Zero(src) = src.len;\n        fn Todo(src) = src.NOT_DEFINED();\n\n        <split/>\n        fn main() {\n            let Solo            = fn Zero;\n\n            lax fn Solo_muteRest(lax src) {}\n            shadow let Zero     = fn Solo_muteRest;\n            shadow let Todo     = fn Solo_muteRest;\n\n            lax fn Noop(src)    = Zero(src);\n            shadow let Zero     = fn Noop;\n\n            let Todo_Renamed    = fn Todo;\n            Todo_Renamed(\"Unused!\");\n\n            return Solo(\"Hello World!\") - 12;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_YhffEIeyP4b
                                #define STR_YhffEIeyP4b
static const fu::str str_YhffEIeyP4b fu_INIT_PRIORITY(1015) { "\n        nocopy struct EventLoop { loop_fd: int };\n\n        fn ipv4_listen(else) {\n            let err = wakeUp_whenReadable();\n            if (err) (else(:err));\n        }\n\n        fn EventLoop(loop_fd: int, loop_start!) {\n            mut err = 0;\n            implicit mut event_loop = {                         ;; GNUStmtExpr\n                if (loop_fd < 0) return err = loop_fd;          ;; Goto\n                EventLoop(loop_fd)\n            };\n\n            return loop_start();\n        }\n\n        fn wakeUp_whenReadable(implicit event_loop: EventLoop) {\n            return event_loop.loop_fd;\n        }\n\n        fn main() {\n            EventLoop(loop_fd: 1, loop_start: || {\n                ipv4_listen(): |err| return err - 1;\n                return 10;\n            });\n            return 20;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_QUFM3RNo1d8
                                #define STR_QUFM3RNo1d8
static const fu::str str_QUFM3RNo1d8 fu_INIT_PRIORITY(1015) { "\n        nocopy struct EventLoop { loop_fd: string };\n\n        fn ipv4_listen(else) {\n            let err = wakeUp_whenReadable();\n            if (err) (else(:err));\n        }\n\n        fn EventLoop(loop_fd: string, loop_start!) {\n            mut err = \"none\";\n            implicit mut event_loop = {                         ;; GNUStmtExpr\n                if !(loop_fd.len & 1) return err = loop_fd;     ;; Goto\n                EventLoop(loop_fd)\n            };\n\n            return loop_start();\n        }\n\n        fn wakeUp_whenReadable(implicit event_loop: EventLoop) {\n            return event_loop.loop_fd;\n        }\n\n        fn main() {\n            EventLoop(loop_fd: \"loop_fd\", loop_start: || {\n                ipv4_listen(): |err| return err.len - 7;\n                return 10;\n            });\n            return 20;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_MXjCQVRLmH9
                                #define STR_MXjCQVRLmH9
static const fu::str str_MXjCQVRLmH9 fu_INIT_PRIORITY(1015) { "\n        struct Child { pid: int };\n        fn call(do) = (do());\n\n        noinline fn test(ref pid: int) {\n            fn spawn(else) {\n                let err = pid + 5;\n                if (err) (else(:err));\n                return pid;\n            }\n\n            fn fatal(err: int) return :test err;                ;; GNUStmtExpr\n            call(do: || pid = spawn(else: |err| fatal(err * 10)));\n            return pid;\n        }\n\n        fn main() {\n            mut pid = 5;\n            return test(pid) - 100;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_V1hZIdnZ8Yh
                                #define STR_V1hZIdnZ8Yh
static const fu::str str_V1hZIdnZ8Yh fu_INIT_PRIORITY(1015) { "\n        struct Child { pid: string };\n        fn call(do) = (do());\n\n        fn append_if_odd(pid: string, other: string)\n            pid.len & 1 ? pid ~ other : pid;\n\n        noinline fn test(ref pid: string) {\n            fn spawn(else) {\n                let err = append_if_odd(pid, \"5555555555\");\n                if (err) (else(:err));\n                return pid;\n            }\n\n            fn fatal(err: string) return :test err;                ;; GNUStmtExpr\n            call(do: || pid = spawn(else: |err| fatal(err ~ \"101010101010\")));\n            return pid;\n        }\n\n        fn main() {\n            mut pid = \"xxxyyyzzz\";\n            return test(pid) == \"xxxyyyzzz5555555555101010101010\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_2oUu7X6Eq89
                                #define STR_2oUu7X6Eq89
static const fu::str str_2oUu7X6Eq89 fu_INIT_PRIORITY(1015) { "\n        struct Hello { stuff: i32 };\n        <alt>\n        fn hello(ref .stuff) stuff; <alt/>\n        fn hello(ref h) h.stuff;    </alt>\n        fn get(h) h.hello;\n        fn incr(ref h) h.hello++;\n\n        fn main() {\n            mut h: Hello;\n            let a = get(h);\n            let b = incr(h);\n            return a == 0 && b == 0 && h.stuff == 1 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_l0iz2Emuj8a
                                #define STR_l0iz2Emuj8a
static const fu::str str_l0iz2Emuj8a fu_INIT_PRIORITY(1015) { "\n        primitive DataPos: int\n\n        struct DataEntry(type K, type V) {\n            key: K\n            value?: V\n            collision: DataPos\n        }\n\n        pub struct Map(type K, type V) {\n            index_entries: DataPos[]\n            data_entries: DataEntry(:K, :V)[]\n        }\n\n        inline fn [](ref .data_entries, data_pos)\n            data_entries[data_pos.int - 1]\n\n        fn ref !<K>(mut ref map: Map(:K, _), key: K, visit) {\n            mut ref data_entry = {\n                :SEARCH {\n                    for (mut i = 0; i < map.index_entries.len; i++) {\n                        mut data_pos = map.index_entries[i]\n                        while (data_pos) {\n                            ref data_entry = map[:data_pos]\n                            if (data_entry.key == key)\n                                break :SEARCH data_entry\n\n                            data_pos = data_entry.collision\n                        }\n                    }\n\n                    map.data_entries ~= <fail ambig ~= 32:38+2>[]<pass/>typeof(map.data_entries[0])()</fail>\n                    let data_pos = DataPos(map.data_entries.len)\n                    map.index_entries ~= data_pos\n                    break :SEARCH map[:data_pos]\n                }\n            }\n\n            return visit(:data_entry.value)\n        }\n\n        pub inline fn set !<K, V>(ref map: Map(:K, :V), key: K, mut value: V)\n            map.ref(:key, visit: |shadow ref value| value)  ;; GNUStmtExpr\n                = value                                     ;; Goto\n\n        fn len(map: Map(_, _)) {\n            mut count = 0\n            for (mut i = 0; i < map.index_entries.len; i++) {\n                mut data_pos = map.index_entries[i]\n                while (data_pos) {\n                    count++\n                    data_pos = map[:data_pos].collision\n                }\n            }\n\n            return count\n        }\n\n        fn main() {\n            mut actual: Map(int, int)\n            let len0 = actual.len\n            actual.set(0, 0)\n            let len1 = actual.len\n            let x = actual.data_entries[0].value\n            return len0 == 0 && len1 == 1 && x == 0 ? 0 : 1\n        }\n    "_fu };
                                #endif

                                #ifndef STR_D33OW2ODtI5
                                #define STR_D33OW2ODtI5
static const fu::str str_D33OW2ODtI5 fu_INIT_PRIORITY(1015) { "\n        struct Type { vfacts?: VFacts };\n        flags VFacts { RightAligned };\n        <split/>\n        fn main() Type().vfacts.i32;\n    "_fu };
                                #endif

                                #ifndef STR_gYsPBgNLeT6
                                #define STR_gYsPBgNLeT6
static const fu::str str_gYsPBgNLeT6 fu_INIT_PRIORITY(1015) { "\n        struct Type { canon: int; items: string };\n\n        fn evalTypeAnnot(node: Type) {\n            let exprType = node ? node || throw(\"always true\") : Type();\n            return exprType.canon;\n        }\n\n        fn main() evalTypeAnnot(Type());\n    "_fu };
                                #endif

                                #ifndef STR_MGhsN5uLWa9
                                #define STR_MGhsN5uLWa9
static const fu::str str_MGhsN5uLWa9 fu_INIT_PRIORITY(1015) { "\n        struct Node { items: Node[]; type: Type };\n        struct Type { canon: string; items: Type[] };\n\n        noinline fn evalTypeParam(id: int, implicit ref _typeParams: Type[]) {\n            return id >= 0 && id < _typeParams.len\n                && _typeParams[id]\n                || throw(\"always true\");\n        }\n\n        noinline fn evalTypeAnnot(node) {\n            let exprType = node.items   ? evalTypeParam(node.items.len)\n                                        : [].type;\n            return exprType.canon.len;\n        }\n\n        fn main() {\n            implicit mut _typeParams: Type[];\n            return evalTypeAnnot(Type());\n        }\n    "_fu };
                                #endif

                                #ifndef STR_UqrsF36HzOe
                                #define STR_UqrsF36HzOe
static const fu::str str_UqrsF36HzOe fu_INIT_PRIORITY(1015) { "\n        fn convolutedHelloWorld(ref _scope: int) {\n            mut TRACE_out = string();\n            fn fail(reason: string) {\n                TRACE_out ~= reason;\n                throw(\", World!\");\n            }\n\n            fn solveNode(targets = [ _scope || fail(\"Hello\") ]) {\n                _scope--;\n                if (targets) solveNode();\n            }\n\n            try         solveNode();\n            catch (e)   return TRACE_out ~ e;\n            return [];\n        }\n\n        fn main() {\n            mut _scope = 1;\n            return convolutedHelloWorld(:_scope) == \"Hello, World!\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_yRqhnevYXM0
                                #define STR_yRqhnevYXM0
static const fu::str str_yRqhnevYXM0 fu_INIT_PRIORITY(1015) { "\n        fn incr(ref x: i32) { x++; }\n        fn badRetvalAnnot(ref x: i32)   <fail badRetvalAnnot return type does not match annot bool, void 5:19+4>\n            : bool                      <pass/></fail>\n                { incr(x) }\n\n        fn main() {\n            mut x = -1;\n            badRetvalAnnot(x);\n            return x;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_rP2BlWRsuz8
                                #define STR_rP2BlWRsuz8
static const fu::str str_rP2BlWRsuz8 fu_INIT_PRIORITY(1015) { "\n        struct Shape { hash: int };\n\n        fn main() {\n            mut shape<fail needs annot type is [] 5:17+5><pass/>: Shape</fail> = [];\n            shape.hash = 3;\n            return -shape.hash + 3;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_nVamv0ewwI9
                                #define STR_nVamv0ewwI9
static const fu::str str_nVamv0ewwI9 fu_INIT_PRIORITY(1015) { "\n        struct Shape { hash: int };\n\n        fn test(mut shape<fail needs annot type is [] 4:21+5><pass/>: Shape</fail>) {\n            shape.hash = 3;\n            return shape;\n        }\n\n        fn main() {\n            let shape = test([]);\n            return -shape.hash + 3;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_6xyuOM0Fu98
                                #define STR_6xyuOM0Fu98
static const fu::str str_6xyuOM0Fu98 fu_INIT_PRIORITY(1015) { "\n        struct Shape { hash: int };\n        struct NotAShape { other: int };\n\n        fn test(ref a: <T>, mut b: T) {\n            <fail field other expects NotAShape, got Shape 7:15+5>\n            b.other += 3; <pass/>\n            b.hash  += 3; </fail>\n            a = b;\n        }\n\n        fn main() {\n            mut shape: Shape;\n            test(shape, []);\n            return -shape.hash + 3;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_5nUL3Fy5Itb
                                #define STR_5nUL3Fy5Itb
static const fu::str str_5nUL3Fy5Itb fu_INIT_PRIORITY(1015) { "\n        struct Thing { using i: int };\n\n        fn vfactsAssignableComplainsAboutAlwaysFalse(ref things: Thing[], into?: Thing) {\n            fn DISCARD(thing: Thing)    = thing && [];\n            fn THROW_IF_ZERO(i)         = Thing(i || throw(\"zero\"));\n\n            let x: Thing = into || {\n                let x: Thing = DISCARD(THROW_IF_ZERO(things.len));\n                x                                               ;; PointlessLocal\n            };\n\n            things[x.i].i++;\n        }\n\n        fn main() {\n            mut things = [ Thing() ];\n            vfactsAssignableComplainsAboutAlwaysFalse(things);\n            return things.len == 1 && things[0].i == 1 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_yKCIbEULfK0
                                #define STR_yKCIbEULfK0
static const fu::str str_yKCIbEULfK0 fu_INIT_PRIORITY(1015) { "\n        struct AB       { a: int; b: int }\n        struct IdxLocP  { _idx: int; _loc: int; _p: AB }\n\n        fn trackWritesAssertPathsValid(using ref _ps: IdxLocP, pa: AB) {\n            fn unary(p: AB) { _p = p; _loc = _idx }\n            fn nullary() { unary(_p) }\n            return pa ? { nullary(); _loc } : { unary(pa); _idx };\n        }\n\n        fn main() {\n            mut _ps: IdxLocP;\n            return trackWritesAssertPathsValid(_ps, []);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_S7Mq0JpxQra
                                #define STR_S7Mq0JpxQra
static const fu::str str_S7Mq0JpxQra fu_INIT_PRIORITY(1015) { "\n        struct Overload { flags: u32; type: Type };\n        struct Type { quals: int; lifetime: int[] };\n\n        noinline fn bckWritesAssertPathsValid(ref overload: Overload) {\n            noinline fn GET_mut() overload;\n            noinline fn clearMutVal(ref o: Overload) {\n                o.type = [];\n                o.flags &= ~0x1;\n            }\n\n            shadow ref o = GET_mut();\n            o.clearMutVal();\n        }\n\n        fn main() {\n            mut overload = Overload(3, Type(12345, [ 1, 2, 3, 4, 5 ]));\n            bckWritesAssertPathsValid(overload);\n            return overload == Overload(2, Type()) ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_dHzApFYUEd5
                                #define STR_dHzApFYUEd5
static const fu::str str_dHzApFYUEd5 fu_INIT_PRIORITY(1015) { "\n        struct Hello(type A, type B) { a: A; b: B };\n        fn main() {\n            mut h: Hello(<fail unexpected , 4:26+1><pass/>int</fail>, int);\n            return h.a + h.b;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_QvpAKAXMExk
                                #define STR_QvpAKAXMExk
static const fu::str str_QvpAKAXMExk fu_INIT_PRIORITY(1015) { "\n        struct Hello(type A, type B) { a: A; b: B };\n        fn main() {\n            mut h: Hello(i<fail missing comma 6:0+0><pass/>nt, int);\n            return h.a + h.b;\n        }\n                           </fail>\n    "_fu };
                                #endif

                                #ifndef STR_16N6tyAWDud
                                #define STR_16N6tyAWDud
static const fu::str str_16N6tyAWDud fu_INIT_PRIORITY(1015) { "\n        novec fn test(ref items: int[]) {\n            fn qStackInfLoop(mut v) {                           ;; PointlessMustSeq\n                v--;\n                if      (v > 8) qStackInfLoop(v.u64);\n                else if (v > 7) qStackInfLoop(v.i64);\n                else if (v > 6) qStackInfLoop(v.u32);\n                else if (v > 5) qStackInfLoop(v.i32);\n                else if (v > 4) qStackInfLoop(v.u16);\n                else if (v > 3) qStackInfLoop(v.i16);\n                else if (v > 2) qStackInfLoop(v.u8);\n                else if (v > 1) qStackInfLoop(v.i8);\n                else {                  <fail novec via copy 14:32+5 20:23+13 10:33+13>\n                    let back = items;\n                    for (mut i = 0; i < items.len; i++)\n                        items[i] += back[back.len - 1 - i] + v.int;             <pass/>\n                    items.each: |ref item| item *= 2 + v.int;                   </fail>\n                }\n            }\n\n            items.len.qStackInfLoop();\n        }\n\n        fn main() {\n            mut v = [ 1 ];\n            v.test();\n            return v.only - 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_DPuxQu2SWz9
                                #define STR_DPuxQu2SWz9
static const fu::str str_DPuxQu2SWz9 fu_INIT_PRIORITY(1015) { "\n        let T_unorm     = 0x1;\n        let T_8x4       = 0x1 << 8;\n        let T_rgba8un   = T_8x4 | T_unorm;\n    "_fu };
                                #endif

                                #ifndef STR_KuOqMUXRqD5
                                #define STR_KuOqMUXRqD5
static const fu::str str_KuOqMUXRqD5 fu_INIT_PRIORITY(1015) { "\n        import _0;\n\n        fn extern_integer_constant(x: uint) {\n            mut res = 1;\n            pragma output(\"switch (\"x\") { case \"T_rgba8un\": \"res\" = 0; }\");\n            return res;\n        }\n\n        fn main() T_rgba8un.extern_integer_constant;\n    "_fu };
                                #endif

                                #ifndef STR_Bmjzqh9P9dl
                                #define STR_Bmjzqh9P9dl
static const fu::str str_Bmjzqh9P9dl fu_INIT_PRIORITY(1015) { "\n        let TWO = 2;\n    "_fu };
                                #endif

                                #ifndef STR_Y5RgpZYXwMg
                                #define STR_Y5RgpZYXwMg
static const fu::str str_Y5RgpZYXwMg fu_INIT_PRIORITY(1015) { "\n        import _0;\n        pragma emit_top(\"int times_TWO(int x) { return x * \"TWO\"; }\");\n        fn main() {\n            mut res = 3;\n            pragma emit(res\" = times_TWO(\" res \");\");\n            return res - 6;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_mxYBvLRUoG9
                                #define STR_mxYBvLRUoG9
static const fu::str str_mxYBvLRUoG9 fu_INIT_PRIORITY(1015) { "\n        primitive ROPOptions: u32;\n        enum DepthTest: u32 { Always = 0; Gteq; Neq; Gt; Lteq; Eq; Lt; Never };\n        inline fn ROPOptions(depth_test: DepthTest) = ROPOptions(depth_test.u32);\n<alt>\n        let rop_Skybox = ROPOptions(\"Lteq\");\n<alt/>\n        pub let rop_Skybox = ROPOptions(\"Lteq\");\n<alt/>\n        let priv = ROPOptions(\"Lteq\");\n        pub fn rop_Skybox() = priv;\n</alt>\n        <split/>\n        fn main() rop_Skybox.int - 4;\n    "_fu };
                                #endif

                                #ifndef STR_sV06SBepb70
                                #define STR_sV06SBepb70
static const fu::str str_sV06SBepb70 fu_INIT_PRIORITY(1015) { "\n        fn test(mut x: int) {\n            if (x > 9) pragma emit(x\" += 7; \"x\" *= 3;\");\n            ++x\n        }\n\n        fn main() test(10) == 52 && test(5) == 6 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_jqtrZXhgPJ6
                                #define STR_jqtrZXhgPJ6
static const fu::str str_jqtrZXhgPJ6 fu_INIT_PRIORITY(1015) { "\n        struct Batch {};\n        type ViewQuads = Batch;\n        let VIEW_QUADS: ViewQuads = [];\n        fn main() VIEW_QUADS == Batch() ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_glAOqonimS1
                                #define STR_glAOqonimS1
static const fu::str str_glAOqonimS1 fu_INIT_PRIORITY(1015) { "\n        fn args_in_cases(a, b)              <fail not a type (3:19+1|3:32+1)>\n            case (a -> b)                   <fail/>\n            case (typeof(a) -> b)           <fail/>\n            case (a -> typeof(b))           <pass/>\n            case (typeof(a) -> typeof(b))   </fail> = a + b;\n\n        fn main() args_in_cases(+1, -1);\n    "_fu };
                                #endif

                                #ifndef STR_B5NSp6CLaY9
                                #define STR_B5NSp6CLaY9
static const fu::str str_B5NSp6CLaY9 fu_INIT_PRIORITY(1015) { "                                  ;; DuplicateFunctions\n        fn ARR_LAST(ref a: $T[])\n            case (typeof(a) -> &mut $T[]): &mut $T a[a.len - 1];\n            case (typeof(a) -> &    $T[]): &    $T a[a.len - 1];\n\n        fn main()\n        {\n            let a = [1];\n            mut b = [2];\n\n            b.ARR_LAST += a.ARR_LAST;\n            return b.ARR_LAST - 3;\n        };\n    "_fu };
                                #endif

                                #ifndef STR_rS3Gcju2tq7
                                #define STR_rS3Gcju2tq7
static const fu::str str_rS3Gcju2tq7 fu_INIT_PRIORITY(1015) { "                                  ;; DuplicateFunctions\n        fn ARR_LAST(ref a: $T[])\n            case (typeof(a) -> &mut $T[]): &mut $T a[a.len - 1];\n            case (typeof(a) -> &    $T[]): &    $T a[a.len - 1];\n\n        let a = [1];\n        mut b = [2];\n\n        b.ARR_LAST += a.ARR_LAST;\n        return b.ARR_LAST - 3;\n    "_fu };
                                #endif

                                #ifndef STR_vc56ANfj1Yk
                                #define STR_vc56ANfj1Yk
static const fu::str str_vc56ANfj1Yk fu_INIT_PRIORITY(1015) { "\n        // Same as below, but avoids the $T call, which is also broken somehow.\n        //  DONT DELETE ME after you fix the $T, its a great example of stupid codegen -\n        //   we emit useless overloads for mutrefs when its clearly useless.\n\n        fn rec_cases(a: $T)\n        case ($T.is::primitive) {\n            if (a)      return rec_cases(a / 2);\n            else        return a;\n        }\n        default {\n            if (a.i) {\n                shadow mut a = a;\n                a.i /= 2;\n                return rec_cases(a);\n            }\n            else        return rec_cases(a.i);\n        }\n\n        struct X { i: i32; };\n        fn main() X(1).rec_cases;\n    "_fu };
                                #endif

                                #ifndef STR_CwUw4SUX7i3
                                #define STR_CwUw4SUX7i3
static const fu::str str_CwUw4SUX7i3 fu_INIT_PRIORITY(1015) { "\n        fn rec_cases(a: $T)\n        case ($T.is::primitive) {\n            if (a)      return rec_cases(a / 2);\n            else        return a;\n        }\n        default {\n            if (a.i)    return rec_cases($T(i: a.i / 2));\n            else        return rec_cases(a.i);\n        }\n\n        struct X { i: i32; };\n        fn main() X(1).rec_cases;\n    "_fu };
                                #endif

                                #ifndef STR_eDCxCBP6pyk
                                #define STR_eDCxCBP6pyk
static const fu::str str_eDCxCBP6pyk fu_INIT_PRIORITY(1015) { "\n        let OK = true;                                          ;; !DEV_DontFoldLiterals\n        fn what(a: int) case (OK) a;\n        fn main() 0.what;\n    "_fu };
                                #endif

                                #ifndef STR_lE1s8tFYyu0
                                #define STR_lE1s8tFYyu0
static const fu::str str_lE1s8tFYyu0 fu_INIT_PRIORITY(1015) { "\n        enum K { A }\n\n        fn Str(n: <T>) case (T.is::enum) {\n            for (fieldname i: T) if (n == \"i\") return \"i\";\n            return \"?\";\n        }\n\n        <fail bad call concat K byte 23:13+6 cannot match autocall Print 13:12+6 11:19+5 10:19+5><pass/>\n        inline fn Print(x: byte)  : string = [ x ]; </fail>\n        inline fn Print(x: string): string = x;\n        inline fn Print(x.Str)    : string = x;\n\n        fn concat(parts.Print[]: string[..]) {\n            mut res = \"(\";\n            for (mut i = 0; i < parts.len; i++) {\n                if (i) res ~= \", \";\n                res ~= parts[i];\n            }\n            return res ~= \")\";\n        }\n\n        fn consumeNextLinePrefix(kind: K, bullet: byte)\n            concat(kind, bullet);                               ;; PointlessLocal\n\n        fn main() {\n            mut str = concat(\"A\", 'B');\n            return str == \"(A, B)\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_zVvSB0MeD83
                                #define STR_zVvSB0MeD83
static const fu::str str_zVvSB0MeD83 fu_INIT_PRIORITY(1015) { "\n        fn Concat(a: byte[..], b.PrettyPronto) a ~ b;\n        fn Concat(a.PrettyPronto, b: byte[..]) a ~ b;\n\n        fn PrettyPronto(n: <T>) n & 1 ? \"odd\" : \"even\";\n                                                            <fail bad call 9:23+6 3:12+6 2:12+6><pass/>\n        fn Concat(a.PrettyPronto, b.PrettyPronto) a ~ b;    </fail>\n\n        fn main() {\n            mut str = Concat(0, 1);\n            return str.len - 7;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_v6ny8YL303b
                                #define STR_v6ny8YL303b
static const fu::str str_v6ny8YL303b fu_INIT_PRIORITY(1015) { "\n        fn main() {                     <fail bad call 3:30+1>\n            mut str = 0      ~ 1;       <pass/>\n            mut str = 0 ~ \"\" ~ 1;       </fail>\n            return str.len - 2;                                 ;; DuplicateFunctions\n        }\n    "_fu };
                                #endif

                                #ifndef STR_BcfaWWJLNZ4
                                #define STR_BcfaWWJLNZ4
static const fu::str str_BcfaWWJLNZ4 fu_INIT_PRIORITY(1015) { "\n        fn test() {\n            mut x = 5;\n            return x;\n        }\n\n        fn main()\n            test() - 5;\n    "_fu };
                                #endif

                                #ifndef STR_X3JQlWGFpCe
                                #define STR_X3JQlWGFpCe
static const fu::str str_X3JQlWGFpCe fu_INIT_PRIORITY(1015) { "\n        struct Test { i: i32; };\n\n        fn test() {\n            mut x = Test(5);\n            return x;\n        }\n\n        fn main()\n            test().i - 5;\n    "_fu };
                                #endif

                                #ifndef STR_kKX9u85OLb5
                                #define STR_kKX9u85OLb5
static const fu::str str_kKX9u85OLb5 fu_INIT_PRIORITY(1015) { "\n        struct Test { a: i32; b: i32; };\n\n        fn test() {\n            mut x = Test(5, -5);\n            return x;\n        }\n\n        fn main()\n            test().a + test().b;\n    "_fu };
                                #endif

                                #ifndef STR_EG0xVT4HEEc
                                #define STR_EG0xVT4HEEc
static const fu::str str_EG0xVT4HEEc fu_INIT_PRIORITY(1015) { "\n        struct X { x: i32; };\n        fn ref2arg(x: X) = x;\n\n        fn main() {\n            let NOTREF = ref2arg(X(101));\n            return NOTREF.x - 101;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_CYT7wm50l69
                                #define STR_CYT7wm50l69
static const fu::str str_CYT7wm50l69 fu_INIT_PRIORITY(1015) { "\n        <fail cannot be copied or moved 8:21>\n        nocopy <pass/></fail>\n        struct Copied { x: i32; };\n\n        fn main() {\n            let a = Copied(1);\n            mut b = a;\n            b.x++;\n            return b.x - a.x * 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_QQl5MGTlBLf
                                #define STR_QQl5MGTlBLf
static const fu::str str_QQl5MGTlBLf fu_INIT_PRIORITY(1015) { "\n        struct XY { x: i32; y: i32; };\n        fn ref2arg(v: XY) = v;\n\n        fn main() {\n            let a = XY(99, 2);\n            let ref2a = ref2arg(a);\n            mut ret = 1;\n            pragma emit(`\n                `ret` -= int(&`ref2a` == &`a`);\n            `);\n            return ret;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_JvxDhW61Qfc
                                #define STR_JvxDhW61Qfc
static const fu::str str_JvxDhW61Qfc fu_INIT_PRIORITY(1015) { "\n        nocopy struct NoCopy { i: i32; };\n        fn retmutref(ref nc: NoCopy) nc;\n\n        fn main() {\n            mut nc: NoCopy;\n            nc.retmutref.retmutref.i++;\n            return nc.i - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Sn061lUEA30
                                #define STR_Sn061lUEA30
static const fu::str str_Sn061lUEA30 fu_INIT_PRIORITY(1015) { "\n        nocopy struct NoCopy { i: i32; };\n        fn mutrefself(ref nc: NoCopy) {\n            nc.i++;\n            return nc;\n        }\n\n        fn main() {\n            mut nc: NoCopy;\n            nc.mutrefself().mutrefself();\n            return nc.i - 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_0DdOamm5A2d
                                #define STR_0DdOamm5A2d
static const fu::str str_0DdOamm5A2d fu_INIT_PRIORITY(1015) { "\n        nocopy struct NoCopy { i: i32; };\n\n        fn      retarg(a: NoCopy) a;\n        fn  retargs_if(a: NoCopy, b: NoCopy) a.i ? b : a;\n        fn  retargs_or(a: NoCopy, b: NoCopy) a || b;\n        fn retargs_and(a: NoCopy, b: NoCopy) a && b;\n\n        fn main() {\n            let a: NoCopy;\n            let b: NoCopy;\n            return retarg(retargs_if(a, retargs_and(a, retargs_or(a, b)))).i;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_yds2uBcZhQf
                                #define STR_yds2uBcZhQf
static const fu::str str_yds2uBcZhQf fu_INIT_PRIORITY(1015) { "\n        nocopy struct NoCopy { i: i32; };\n\n        fn      retarg(a: NoCopy) a;\n        fn  retargs_if(a: NoCopy, b: NoCopy) a.i ? b : a;\n        fn  retargs_or(a: NoCopy, b: NoCopy) a || b;\n        fn retargs_and(a: NoCopy, b: NoCopy) a && b;\n\n        fn main() {\n            let a: NoCopy;                      // <- b now temp\n\n            return retarg(retargs_if(a, retargs_and(a, retargs_or(a, NoCopy)))).i;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_qC4SnnrbCuj
                                #define STR_qC4SnnrbCuj
static const fu::str str_qC4SnnrbCuj fu_INIT_PRIORITY(1015) { "\n        nocopy struct NoCopy { i: i32; };\n\n        fn      retarg(ref a) a;                    // <- now templates\n        fn  retargs_if(ref a, ref b) a.i ? b : a;\n        fn  retargs_or(ref a, ref b) a || b;\n        fn retargs_and(ref a, ref b) a && b;\n\n        fn main() {\n            mut a: NoCopy;                      // <- now muts\n            mut b: NoCopy;\n            retarg(retargs_if(a, retargs_and(a, retargs_or(a, b)))).i++;\n            return a.i + b.i - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_w9WiIRgP4f9
                                #define STR_w9WiIRgP4f9
static const fu::str str_w9WiIRgP4f9 fu_INIT_PRIORITY(1015) { "\n        fn as_blocks_after(x: i32) {\n            mut zero = 0;\n            if (x > 2) // a broken stmt emit lifted the loop out of the conditional\n                for (mut i = 0; i < x; i++)\n                    zero = i + i*zero;\n\n            return zero;\n        }\n\n        fn main() 2.as_blocks_after;\n    "_fu };
                                #endif

                                #ifndef STR_d7UySL4cDz9
                                #define STR_d7UySL4cDz9
static const fu::str str_d7UySL4cDz9 fu_INIT_PRIORITY(1015) { "\n        struct Lifetime { woot: Lifetime[]; };\n\n        fn Lifetime_test(x: Lifetime) {\n            x.woot.len & 1 && throw(\"This is very important.\");\n            for (mut i = 0; i < x.woot.len; i++) Lifetime_test(x.woot[i]);\n            return x;\n        }\n\n        fn Lifetime_fromBinding(x: i32) {\n            mut woot: Lifetime[];\n            for (mut i = 0; i < x; i++)\n                woot[i] = Lifetime();\n\n            ;; !N_NonTrivAutoCopy\n            //\n            //  1. Move 'woot' into Lifetime\n            //      instead of naively copying it.\n            //                             ....\n            return Lifetime_test(Lifetime(:woot));              ;; ConstCast\n            //     ....\n            //  2. Move the result out even though\n            //      Lifetime_test takes and returns refs.\n        }\n\n        fn main() 0.Lifetime_fromBinding.woot.len;\n    "_fu };
                                #endif

                                #ifndef STR_1l93oEQ75H5
                                #define STR_1l93oEQ75H5
static const fu::str str_1l93oEQ75H5 fu_INIT_PRIORITY(1015) { "\n        fn test(x: i32) {                       // none of these need vecs\n            let c = [10007];                    ;; TODO fu::slate<1, int> c\n            let a = [7, 11, 9, 21, x, x, x, x]; ;; TODO fu::slate<2, int> a\n            let b = {                           ;; TODO fu::slate<1, int> b\n                :BRK {                          // !N_NonTrivAutoCopy\n                    if (x & 2) break :BRK c;\n                    if (x & 1) break :BRK [ x ]; // a val\n                    a // a ref\n                }\n            };\n            return a[0] - b[0] * a[1];\n        }\n\n        fn main() 1.test + 4.test + 74;\n    "_fu };
                                #endif

                                #ifndef STR_bolt5VaaTX5
                                #define STR_bolt5VaaTX5
static const fu::str str_bolt5VaaTX5 fu_INIT_PRIORITY(1015) { "\n        struct Test { i: i32[]; };\n\n        fn test(mut x: Test) {\n            x.i[0] += x.i[1];\n            return x;\n        }\n\n        fn main() {\n            let s = Test([ 1, 2 ]);\n            return test(s).i[0] - s.i[0] * 3;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_ZwyqVqNclR6
                                #define STR_ZwyqVqNclR6
static const fu::str str_ZwyqVqNclR6 fu_INIT_PRIORITY(1015) { "\n        struct Test { i: i32[]; };\n\n        fn test(mut x: Test): Test {\n            x.i[0] += x.i[1];\n            return x;\n        }\n\n        fn main() {\n            let s = Test([ 1, 2 ]);\n            return test(s).i[0] - s.i[0] * 3;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_5FhXSus1Lk4
                                #define STR_5FhXSus1Lk4
static const fu::str str_5FhXSus1Lk4 fu_INIT_PRIORITY(1015) { "\n        fn compile_snippets(x0: string) x0.find('a') && throw(\"throw#1\");\n        fn ZERO(x1: string) x1.find('b') && throw(\"throw#2\");\n\n        fn FAIL(x2: string): string {                   ;; EXPECT fu::view<char> x2\n            try {\n                let ctx = compile_snippets(x2) && \"hey\";\n                return ctx;\n            }\n            catch (e) {\n                return ZERO(x2) && e;\n            }\n        }\n\n        fn main() FAIL(\"a\").len;\n    "_fu };
                                #endif

                                #ifndef STR_JFMhNmTqxt2
                                #define STR_JFMhNmTqxt2
static const fu::str str_JFMhNmTqxt2 fu_INIT_PRIORITY(1015) { "\n        // The thing below but shorter:\n        //  the '|| throw' introduces a bullshit lambda during codegen,\n        //   which misreturns a dangling reference to its own frame.\n        fn test(x: string) [x][0] || throw(\"nope!\");\n        fn main() \"what\".test.len - 4;\n    "_fu };
                                #endif

                                #ifndef STR_VE1NLogSte9
                                #define STR_VE1NLogSte9
static const fu::str str_VE1NLogSte9 fu_INIT_PRIORITY(1015) { "\n        fn Only(s: $T[]) s.len == 1 ? s[0] : throw (\"len != 1: \" ~ s.len);\n\n        struct Node       { kind: string; };\n        struct SolvedNode { kind: string; };\n\n        fn solveNodes(n: Node[]) {\n            mut r: SolvedNode[];\n            for (mut i = 0; i < n.len; i++) r ~= SolvedNode(n[i].kind);\n            return r;\n        }\n\n        // the '|| throw' introduces a bullshit lambda during codegen,\n        //  which misreturns a dangling reference to its own frame.\n        fn solveDeclExpr(n: Node) solveNodes([ n ]).Only || throw (\"!only\");\n\n        fn main() solveDeclExpr(Node(\"a\")).kind.len - 1;\n    "_fu };
                                #endif

                                #ifndef STR_iivKpq1utyj
                                #define STR_iivKpq1utyj
static const fu::str str_iivKpq1utyj fu_INIT_PRIORITY(1015) { "\n        pub fn test(x: i32): i32[] { ;; !N_NonTrivAutoCopy\n            mut a = [ 4 ];\n            mut b = [ 5 ];\n            mut c = [ 6 ];\n\n            for (mut i = 0; i < x; i++) {\n                a.unshift(x);\n                b.unshift(x);\n                c.unshift(x);\n            }\n\n            inline fn which() {\n                return :test x & 1 ? a : b;\n            }\n\n            if !(x & 2)\n                return which();\n\n            return c;\n        }\n\n        fn main() test(2)[2] + test(1)[1] - 2 * test(0)[0];\n    "_fu };
                                #endif

                                #ifndef STR_4NB2wLvVJWj
                                #define STR_4NB2wLvVJWj
static const fu::str str_4NB2wLvVJWj fu_INIT_PRIORITY(1015) { "\n        fn incr_x_to_1(ref x: i32) {\n            x && throw(\"this reports return t_never\");\n            fn incr_x() { return x++; }\n            incr_x();\n        }\n        fn main() {\n            mut x = 0;\n            incr_x_to_1(x);\n            return x - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_NjZ7HJk9wYi
                                #define STR_NjZ7HJk9wYi
static const fu::str str_NjZ7HJk9wYi fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut x = 0;\n            fn incr_x_to_1() {\n                x && throw(\"this reports return t_never\");\n                fn incr_x() { return x++; }\n                incr_x();\n            }\n            incr_x_to_1();\n            return x - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_8TTGQXtcrQl
                                #define STR_8TTGQXtcrQl
static const fu::str str_8TTGQXtcrQl fu_INIT_PRIORITY(1015) { "\n        fn apply(fn, v) fn(v);\n        fn main() {\n            mut x = 0;\n            fn scope_using(via: i32) {\n                x && throw(\"this reports return t_never\");\n                // which messed up retcount for scope_using\n                fn visit(item: i32) {\n                    if (item) return item;\n                    return x++;\n                }\n                apply(fn visit, via);\n            }\n\n            scope_using(x);\n            return x - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_caZ5HZc0am3
                                #define STR_caZ5HZc0am3
static const fu::str str_caZ5HZc0am3 fu_INIT_PRIORITY(1015) { "\n        fn main()   <fail leading zero in numeric literal 3:13+1>\n            010     <pass/>\n            0o10    </fail>\n                == 8 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_dPdIDTU5aXg
                                #define STR_dPdIDTU5aXg
static const fu::str str_dPdIDTU5aXg fu_INIT_PRIORITY(1015) { "\n        <alt>\n        fn main() 0b101 ==   5 ? 0 : 1; <alt/>\n        fn main() 0o101 ==  65 ? 0 : 1; <alt/>\n        fn main() 0x101 == 257 ? 0 : 1; </alt>\n    "_fu };
                                #endif

                                #ifndef STR_ESBEtPPDYB7
                                #define STR_ESBEtPPDYB7
static const fu::str str_ESBEtPPDYB7 fu_INIT_PRIORITY(1015) { "\n        fn main()\n            i32(f64.PI * 2.0) - 6;\n    "_fu };
                                #endif

                                #ifndef STR_kf7l5Ym0Z2f
                                #define STR_kf7l5Ym0Z2f
static const fu::str str_kf7l5Ym0Z2f fu_INIT_PRIORITY(1015) { "\n        fn main()\n            i32(f64.PI * 2 - 6);\n    "_fu };
                                #endif

                                #ifndef STR_9IsPx78WwG5
                                #define STR_9IsPx78WwG5
static const fu::str str_9IsPx78WwG5 fu_INIT_PRIORITY(1015) { "\n        fn main()\n            f64.PI * 2 - 6 |> i32;\n    "_fu };
                                #endif

                                #ifndef STR_jpjiV6OT9Yf
                                #define STR_jpjiV6OT9Yf
static const fu::str str_jpjiV6OT9Yf fu_INIT_PRIORITY(1015) { "\n        fn main()\n            i32 <| f64.PI * 2 - 6;\n    "_fu };
                                #endif

                                #ifndef STR_dwrQjpYGLu7
                                #define STR_dwrQjpYGLu7
static const fu::str str_dwrQjpYGLu7 fu_INIT_PRIORITY(1015) { "\n        let x: f32 = 1; fn main() 1 - x.i32;\n    "_fu };
                                #endif

                                #ifndef STR_Dg49jMXBJ1k
                                #define STR_Dg49jMXBJ1k
static const fu::str str_Dg49jMXBJ1k fu_INIT_PRIORITY(1015) { "\n        let x: f32 = 1.0; fn main() 1 - x.i32;\n    "_fu };
                                #endif

                                #ifndef STR_x6z7DPIwiD6
                                #define STR_x6z7DPIwiD6
static const fu::str str_x6z7DPIwiD6 fu_INIT_PRIORITY(1015) { "\n        let x: u8 = 1; fn main() 1 - x.i32;\n    "_fu };
                                #endif

                                #ifndef STR_Od3xKjDXmch
                                #define STR_Od3xKjDXmch
static const fu::str str_Od3xKjDXmch fu_INIT_PRIORITY(1015) { "\n        let x = 1.f32; fn main() 1 - x.i32;\n    "_fu };
                                #endif

                                #ifndef STR_LbArdTMBUc8
                                #define STR_LbArdTMBUc8
static const fu::str str_LbArdTMBUc8 fu_INIT_PRIORITY(1015) { "\n        fn gt0(x: f32) x > 0;\n        fn main() gt0(1.f32) ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_VLDYFSMzC9d
                                #define STR_VLDYFSMzC9d
static const fu::str str_VLDYFSMzC9d fu_INIT_PRIORITY(1015) { "\n        struct Hey { x: f32; };\n        fn hey() Hey(1);\n        fn main() hey.x.i32 - 1;\n    "_fu };
                                #endif

                                #ifndef STR_cmcEu9vf947
                                #define STR_cmcEu9vf947
static const fu::str str_cmcEu9vf947 fu_INIT_PRIORITY(1015) { "\n        struct vec3 { x?: f32; y?: f32; z?: f32; };\n        fn test(i: i32) vec3(x: (i - 2).f32, z: 1);\n        fn main() {\n            let v = test(1);\n            return (v.x + v.z).i32;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_cOXsHKSCUi4
                                #define STR_cOXsHKSCUi4
static const fu::str str_cOXsHKSCUi4 fu_INIT_PRIORITY(1015) { "\n        struct vec3 { x?: f32; y?: f32; z?: f32; };\n        fn test(f: f32) vec3(x: f, z: -1);\n        fn main() {\n            let v = test(-1);\n            return (v.x - v.z).i32;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_U5TapvWeKX9
                                #define STR_U5TapvWeKX9
static const fu::str str_U5TapvWeKX9 fu_INIT_PRIORITY(1015) { "\n        fn hey(i: f32) i.f32 + 0.5;\n        fn main() hey(1).i32 - 1;\n    "_fu };
                                #endif

                                #ifndef STR_CyT4RwLkrt4
                                #define STR_CyT4RwLkrt4
static const fu::str str_CyT4RwLkrt4 fu_INIT_PRIORITY(1015) { "\n        fn lin2srgb(l: f32): f32\n            l <= 0.0031308\n                ? l * 12.92\n                : 1.055 * pow(l, 1/2.4.f32) - 0.055;\n\n        fn lin255(v: f32) u32 <|\n            v.lin2srgb.max(0).min(1) * 255.99;\n\n        fn main() i32 <|\n            lin255(1) - 255;\n    "_fu };
                                #endif

                                #ifndef STR_PZt2fczB6T8
                                #define STR_PZt2fczB6T8
static const fu::str str_PZt2fczB6T8 fu_INIT_PRIORITY(1015) { "\n        struct vec3 { x?: f32; y?: f32; z?: f32; };\n\n        inline fn /(a: f32, b: vec3)\n            vec3(a / b.x, a / b.y, a / b.z);\n\n        fn main() i32 <|\n            (1/vec3(x: 1)).x - 1;\n    "_fu };
                                #endif

                                #ifndef STR_TXGkrnq8mli
                                #define STR_TXGkrnq8mli
static const fu::str str_TXGkrnq8mli fu_INIT_PRIORITY(1015) { "\n        let QUAD_DATA: f32[] =\n        [\n            -1, -1, 0,      0, 0, 1,    0, 0, 0,\n            +1, +1, 0,      0, 0, 1,    1, 1, 0,\n            -1, +1, 0,      0, 0, 1,    0, 1, 0,\n\n            -1, -1, 0,      0, 0, 1,    0, 0, 0,\n            +1, -1, 0,      0, 0, 1,    1, 0, 0,\n            +1, +1, 0,      0, 0, 1,    1, 1, 0,\n        ];\n\n        fn main() QUAD_DATA.len - 6 * 9;\n    "_fu };
                                #endif

                                #ifndef STR_lxMcwA2Xt77
                                #define STR_lxMcwA2Xt77
static const fu::str str_lxMcwA2Xt77 fu_INIT_PRIORITY(1015) { "\n        fn test(a: bool): u8 = a ? 1 : 0;\n\n        fn main() test(false).i32;\n    "_fu };
                                #endif

                                #ifndef STR_JCAVxpTxXvf
                                #define STR_JCAVxpTxXvf
static const fu::str str_JCAVxpTxXvf fu_INIT_PRIORITY(1015) { "\n        fn test(a: bool): u8 = a && 1;\n\n        fn main() test(false).i32;\n    "_fu };
                                #endif

                                #ifndef STR_tOlvohgMcvj
                                #define STR_tOlvohgMcvj
static const fu::str str_tOlvohgMcvj fu_INIT_PRIORITY(1015) { "\n        pub let A_u8: u8 = 0x0;\n\n        fn ATTRIB(type: u8, count: i32, srgb = false): u8\n            = type & 0x3 | count.u8 << 2\n\n            // TODO can't deep-retype the last cast unfortunately:\n            //  we need another hint to drive typing here,\n            //   perhaps monogenous signatures, or else.\n            | (srgb && 0x80.u8);\n\n        fn main() ATTRIB(A_u8, 4).i32 - 16;\n    "_fu };
                                #endif

                                #ifndef STR_NPpvtFMxxq8
                                #define STR_NPpvtFMxxq8
static const fu::str str_NPpvtFMxxq8 fu_INIT_PRIORITY(1015) { "\n        pub struct Geometry    { g: i32; };\n        pub struct Texture     { t: i32; };\n        pub struct RenderFrame { r: i32; };\n\n        pub struct LogicFrame_in\n        {\n            lastLogic:  LogicFrame;\n        };\n\n        pub struct LogicFrame\n        {\n            DATA_fbx:   Geometry;\n            TEX_A:      Texture;\n            TEX_AO:     Texture;\n            TEX_M:      Texture;\n            TEX_N:      Texture;\n            TEX_R:      Texture;\n            HDR:        Texture;\n        };\n\n        pub struct RenderFrame_in\n        {\n            w:          i16;\n            h:          i16;\n            frame:      i32;\n\n            mouseX:     f32;\n            mouseY:     f32;\n            mouseBtns:  i32;\n\n            using logic:    LogicFrame;\n            lastRender:     RenderFrame;\n        };\n\n        pub fn APP_renderFrame(using args: RenderFrame_in): RenderFrame\n        {\n            return RenderFrame(args.HDR.t);\n        }\n\n        fn main() 0;\n    "_fu };
                                #endif

                                #ifndef STR_9oHn7b5azCb
                                #define STR_9oHn7b5azCb
static const fu::str str_9oHn7b5azCb fu_INIT_PRIORITY(1015) { "\n        fn leadingDigit(name: string) name[0].u8 - '0'.u8 < 10;\n        fn main() \"hello\".leadingDigit.i32;\n    "_fu };
                                #endif

                                #ifndef STR_7sWciLLgRdb
                                #define STR_7sWciLLgRdb
static const fu::str str_7sWciLLgRdb fu_INIT_PRIORITY(1015) { "\n        fn main() 1_000_000 - 1000000\n               || 0xffff_ffff.i32 - 0xffffffff.i32\n               || 123_456.789.i32 - 123456.789.i32;\n    "_fu };
                                #endif

                                #ifndef STR_clnQL6Eb6Hi
                                #define STR_clnQL6Eb6Hi
static const fu::str str_clnQL6Eb6Hi fu_INIT_PRIORITY(1015) { "                                  // litfix through && /////\n        fn test(a: u32, shadows: bool)      (a << 1) | (shadows && 1);\n        fn main()                           test(1, true).i32 - 3;\n    "_fu };
                                #endif

                                #ifndef STR_lWGOkuzI9cd
                                #define STR_lWGOkuzI9cd
static const fu::str str_lWGOkuzI9cd fu_INIT_PRIORITY(1015) { "\n        struct vec3 { x?: f32; y?: f32; z?: f32; };\n        inline fn *(a: vec3, b: vec3) vec3(a.x * b.x, a.y * b.y, a.z * b.z);\n        inline fn *(a: vec3, b: f32) vec3(a.x * b, a.y * b, a.z * b);\n        inline fn lensq(a: vec3) a.x * a.x + a.y * a.y + a.z * a.z;\n        inline fn len(a: vec3) a.lensq.sqrt;\n\n        inline fn norm(a: vec3) {\n            mut n = 1 / a.len;\n            n = n.finite ? n : 0;\n            return a * n;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_s8GQ05yfFAa
                                #define STR_s8GQ05yfFAa
static const fu::str str_s8GQ05yfFAa fu_INIT_PRIORITY(1015) { "\n        inline fn test(ref v) {\n            v = v.norm();\n            return v.len;\n        }\n\n        fn main() {\n            mut v = _0::vec3(2, 0, 0);\n            return v.test() == 1 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_KjBlWW53nZ9
                                #define STR_KjBlWW53nZ9
static const fu::str str_KjBlWW53nZ9 fu_INIT_PRIORITY(1015) { "\n        fn sub15(x: i32) x - 15;\n        fn main() 0xf.sub15;\n    "_fu };
                                #endif

                                #ifndef STR_ix3infy8a9b
                                #define STR_ix3infy8a9b
static const fu::str str_ix3infy8a9b fu_INIT_PRIORITY(1015) { "\n        fn pick(albedo: i32 = 0x12345678, shift = 16)\n            albedo >> shift & 0xf;\n        fn main()\n            pick() == 4 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_oXaKTtLnYwe
                                #define STR_oXaKTtLnYwe
static const fu::str str_oXaKTtLnYwe fu_INIT_PRIORITY(1015) { "\n        fn main() abs(-19191) - 19191\n                + abs(+72713) - 72713;\n    "_fu };
                                #endif

                                #ifndef STR_WkQrb4jDVm9
                                #define STR_WkQrb4jDVm9
static const fu::str str_WkQrb4jDVm9 fu_INIT_PRIORITY(1015) { "\n        fn litfix_order!T(a: T, b: T) = a * 2 + b * 3;\n        fn main() = litfix_order(0.5, 2) == 7 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_ylWnmDDgQpk
                                #define STR_ylWnmDDgQpk
static const fu::str str_ylWnmDDgQpk fu_INIT_PRIORITY(1015) { "\n        fn litfix_order!T(a: T, b: T) = a * 3 + b * 2;\n        fn main() = litfix_order(2, 0.5) == 7 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_g0FIedSACr8
                                #define STR_g0FIedSACr8
static const fu::str str_g0FIedSACr8 fu_INIT_PRIORITY(1015) { "\n        fn litfix_order!T(a: T, b: T) = a * 2 + b * 3;\n        fn main() = litfix_order(a: 0.5, b: 2) == 7 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_7jPgvr3TSQc
                                #define STR_7jPgvr3TSQc
static const fu::str str_7jPgvr3TSQc fu_INIT_PRIORITY(1015) { "\n        fn litfix_order!T(a: T, b: T) = a * 3 + b * 2;\n        fn main() = litfix_order(a: 2, b: 0.5) == 7 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_S65lFLF1Mv4
                                #define STR_S65lFLF1Mv4
static const fu::str str_S65lFLF1Mv4 fu_INIT_PRIORITY(1015) { "\n        fn next_mip(ref s: i16) s = s >> 1 || 1;\n        fn main() {\n            mut v = 3.i16;\n            let a = v.next_mip();\n            let b = v.next_mip();\n            return int(a + b) - 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_VvQW5a7D8G1
                                #define STR_VvQW5a7D8G1
static const fu::str str_VvQW5a7D8G1 fu_INIT_PRIORITY(1015) { "ambig ||, incompatible operands in non-bool context i16 i32 2:44+2"_fu };
                                #endif

                                #ifndef STR_eiND4hgtvS9
                                #define STR_eiND4hgtvS9
static const fu::str str_eiND4hgtvS9 fu_INIT_PRIORITY(1015) { "\n        fn why_doesnt_this_match(list: <T><alt>[..]<alt/>[]</alt>, other: T<alt>[..]<alt/>[]</alt>) list ~ other;\n        fn main() why_doesnt_this_match([ 1, 2, 3 ], []).len - 3;\n    "_fu };
                                #endif

                                #ifndef STR_sT9YKO5zUtc
                                #define STR_sT9YKO5zUtc
static const fu::str str_sT9YKO5zUtc fu_INIT_PRIORITY(1015) { "\n        let glsl_what = [ 1, 2, 3 ] ~ <fail ambig ~ 2:37+1>[]<pass/>int[]</fail>;\n        fn main() glsl_what.len - 3;\n    "_fu };
                                #endif

                                #ifndef STR_4pWVwSyYGUe
                                #define STR_4pWVwSyYGUe
static const fu::str str_4pWVwSyYGUe fu_INIT_PRIORITY(1015) { "\n        let USE_MIPMAPS = false;\n        let glsl_what = \"A \" ~ (USE_MIPMAPS ? \"B \" : []) ~ \"C\";\n        fn main() glsl_what.len - 3;\n    "_fu };
                                #endif

                                #ifndef STR_HTpttwyWlv5
                                #define STR_HTpttwyWlv5
static const fu::str str_HTpttwyWlv5 fu_INIT_PRIORITY(1015) { "Ambig call to ~ 3:30+1"_fu };
                                #endif

                                #ifndef STR_kNQxHs1UMl8
                                #define STR_kNQxHs1UMl8
static const fu::str str_kNQxHs1UMl8 fu_INIT_PRIORITY(1015) { "\n        let USE_MIPMAPS = false;\n        let glsl_what = \"A \" ~ (USE_MIPMAPS ? 'B' : []) ~ \" C\";\n        fn main() glsl_what == \"A \\0 C\" ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_rDj67BjlPM3
                                #define STR_rDj67BjlPM3
static const fu::str str_rDj67BjlPM3 fu_INIT_PRIORITY(1015) { "\n        fn must_not_match(other: <fail bad call arg must_not_match:other string, got byte 5:19+14>\n                                 string<pass/>\n                                 byte  </fail>) \"Hello\" ~ other;\n\n        fn main() must_not_match(false && '!').len - 6;         ;; !DEV_DontFoldLiterals\n    "_fu };
                                #endif

                                #ifndef STR_vtFtiZPuEjk
                                #define STR_vtFtiZPuEjk
static const fu::str str_vtFtiZPuEjk fu_INIT_PRIORITY(1015) { "\n        fn must_not_match(other: <fail bad call arg must_not_match:other byte, got string 5:19+14>\n                                 byte  <pass/>\n                                 string</fail>) \"Hello\" ~ other;\n\n        fn main() must_not_match(false && \"!\").len - 5;         ;; !DEV_DontFoldLiterals\n    "_fu };
                                #endif

                                #ifndef STR_xuaAaFtg6Nj
                                #define STR_xuaAaFtg6Nj
static const fu::str str_xuaAaFtg6Nj fu_INIT_PRIORITY(1015) { "\n        fn must_not_match(hello: <T>[..], other: <fail bad call arg must_not_match:other not sliceable: byte 5:19+14>\n                                                 T[..]<pass/>\n                                                 T    </fail>) hello ~ other;\n\n        fn main() must_not_match(\"Hello\", 0 && '!').len - 6;    ;; !DEV_DontFoldLiterals\n    "_fu };
                                #endif

                                #ifndef STR_QfslEuUPZGf
                                #define STR_QfslEuUPZGf
static const fu::str str_QfslEuUPZGf fu_INIT_PRIORITY(1015) { "\n        fn must_not_match(hello: <T>[..], other: <fail bad call arg must_not_match:hello incompatible T string byte 5:19+14>\n                                                 T    <pass/>\n                                                 T[..]</fail>) hello ~ other;\n\n        fn main() must_not_match(\"Hello\", 0 && \"!\").len - 5;    ;; !DEV_DontFoldLiterals\n    "_fu };
                                #endif

                                #ifndef STR_ncoS6AtYCm8
                                #define STR_ncoS6AtYCm8
static const fu::str str_ncoS6AtYCm8 fu_INIT_PRIORITY(1015) { "\n        let USE_MIPMAPS = false;\n        let glsl_what = \"A \" ~ (USE_MIPMAPS && \"B \") ~ \"C\";\n        fn main() glsl_what.len - 3;\n    "_fu };
                                #endif

                                #ifndef STR_37Xu8pXqkHh
                                #define STR_37Xu8pXqkHh
static const fu::str str_37Xu8pXqkHh fu_INIT_PRIORITY(1015) { "\n        let USE_MIPMAPS = false;\n        let glsl_what = \"A \" ~ (USE_MIPMAPS && 'B') ~ \" C\";\n        fn main() glsl_what == \"A \\0 C\" ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_PhnRon16jm0
                                #define STR_PhnRon16jm0
static const fu::str str_PhnRon16jm0 fu_INIT_PRIORITY(1015) { "\n        type Test = i32[];\n        fn yo(t: Test) t[0] + t[1];\n        fn main() yo([-1, +1]);\n    "_fu };
                                #endif

                                #ifndef STR_o2eG5BmopOk
                                #define STR_o2eG5BmopOk
static const fu::str str_o2eG5BmopOk fu_INIT_PRIORITY(1015) { "\n        fn ifFirst(a: $T[]) a && a[0];\n        fn hello(a: i32[]) a.ifFirst;\n        fn main() hello([ 3 ]) - 3;\n    "_fu };
                                #endif

                                #ifndef STR_lAIQ2G9zVof
                                #define STR_lAIQ2G9zVof
static const fu::str str_lAIQ2G9zVof fu_INIT_PRIORITY(1015) { "\n        fn ifFirst(a: $T[]) a && a[0];\n        type X = i32[];\n        fn hello(a: X) a.ifFirst;\n        fn main() hello([ 3 ]) - 3;\n    "_fu };
                                #endif

                                #ifndef STR_7rSNjUwclRi
                                #define STR_7rSNjUwclRi
static const fu::str str_7rSNjUwclRi fu_INIT_PRIORITY(1015) { "\n        fn ifFirst(a: $T[]) a && a[0];\n\n        fn list(): i32[][] {\n            return [[ 3 ]];\n        }\n\n        fn hello() list.ifFirst.ifFirst;\n        fn main() hello - 3;\n    "_fu };
                                #endif

                                #ifndef STR_xJc1UIVwVQ6
                                #define STR_xJc1UIVwVQ6
static const fu::str str_xJc1UIVwVQ6 fu_INIT_PRIORITY(1015) { "\n        fn ifFirst(a: $T[]) a && a[0];\n        type X = i32[];\n\n        fn list(): X[] {\n            return [[ 3 ]];\n        }\n\n        fn hello() list.ifFirst.ifFirst;\n        fn main() hello - 3;\n    "_fu };
                                #endif

                                #ifndef STR_SccMw8BEj2b
                                #define STR_SccMw8BEj2b
static const fu::str str_SccMw8BEj2b fu_INIT_PRIORITY(1015) { "\n        let arr = [1, 2];\n        fn eq(a: i32[], b: i32[]) a == b;\n        fn main() eq(arr, arr) ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_Aog51GgZHcl
                                #define STR_Aog51GgZHcl
static const fu::str str_Aog51GgZHcl fu_INIT_PRIORITY(1015) { "\n        let arr = [1, 2];\n        fn eq(a: $T[], b: $T[]) a == b;\n        fn main() eq(arr, arr) ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_nNSkafvEjOd
                                #define STR_nNSkafvEjOd
static const fu::str str_nNSkafvEjOd fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut a = [ 1, 2, 3, 4 ];\n            mut b = a[1.. ];\n            mut c = a[ ..3];\n            mut d = a[1..3];\n\n            mut res = b ~ c ~ d;\n            return res <> [ 2, 3, 4,  1, 2, 3,  2, 3 ];\n        }\n    "_fu };
                                #endif

                                #ifndef STR_ZAiEYcZNVr6
                                #define STR_ZAiEYcZNVr6
static const fu::str str_ZAiEYcZNVr6 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            let str = \"hello world\";\n            let s10 = str[..5] ~ str[6..];\n            return s10.len - 10;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Y3uptv5OJJ0
                                #define STR_Y3uptv5OJJ0
static const fu::str str_Y3uptv5OJJ0 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut strs = [ \"hello\", \"world\" ];\n            let hello = strs[0];\n            strs.insert(1,          <alt>\n                hello[0..5]         <alt/>\n                hello.slice(0, 5)   </alt>\n            );\n            return strs.len - 3;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_XJy3qp0ohg3
                                #define STR_XJy3qp0ohg3
static const fu::str str_XJy3qp0ohg3 fu_INIT_PRIORITY(1015) { "\n        fn test(hey: i32[..])\n            hey[0] + hey[1];\n\n        fn main()\n            test([-1, +1]);\n\n        ;; EXPECT fu::view<int> {{ -1, +1 }}\n    "_fu };
                                #endif

                                #ifndef STR_OdmZ5grYJZf
                                #define STR_OdmZ5grYJZf
static const fu::str str_OdmZ5grYJZf fu_INIT_PRIORITY(1015) { "\n        fn test(ref hey: i32[..])\n            hey[0] += hey[1];\n\n        fn main() {\n            mut hey = [-1, +1];\n            return hey.test();\n        }\n    "_fu };
                                #endif

                                #ifndef STR_MsaQe4N4Izd
                                #define STR_MsaQe4N4Izd
static const fu::str str_MsaQe4N4Izd fu_INIT_PRIORITY(1015) { "\n        fn test(i: i32) [ i, i + 1 ];\n        fn main() test(0)[1] - 1;\n    "_fu };
                                #endif

                                #ifndef STR_NgaY8OOH6a3
                                #define STR_NgaY8OOH6a3
static const fu::str str_NgaY8OOH6a3 fu_INIT_PRIORITY(1015) { "\n        fn test(hey: byte[])\n            hey.view(u32)[0];\n\n        fn main() {\n            mut hey: byte[] = [ byte(1), byte(1), byte(1), byte(1) ];\n            return (hey.test - 0x1010101).i32;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_o2Sdu5DfgCe
                                #define STR_o2Sdu5DfgCe
static const fu::str str_o2Sdu5DfgCe fu_INIT_PRIORITY(1015) { "\n        fn test(hey: i32[..])\n            hey[0] + hey[1];\n\n        fn main() {\n            let hey = [7, -1, +1];\n            return test(hey[1 .. 3]);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_F8siDzXia2l
                                #define STR_F8siDzXia2l
static const fu::str str_F8siDzXia2l fu_INIT_PRIORITY(1015) { "\n        fn test(ref hey: i32[..])\n            hey[0] += hey[1];\n\n        fn main() {\n            mut hey = [7, -1, +1];\n            return hey[1 .. 3].test();\n        }\n    "_fu };
                                #endif

                                #ifndef STR_u3pTf61Rlog
                                #define STR_u3pTf61Rlog
static const fu::str str_u3pTf61Rlog fu_INIT_PRIORITY(1015) { "\n        fn test(ref hey: i32[..])\n            hey.= [2, -3];\n\n        fn main() {\n            mut hey = [1, 0, 0];\n            test(hey[1 .. 3]);\n            return hey[0] + hey[1] + hey[2];\n        }\n    "_fu };
                                #endif

                                #ifndef STR_xDcCfHalr0j
                                #define STR_xDcCfHalr0j
static const fu::str str_xDcCfHalr0j fu_INIT_PRIORITY(1015) { "\n        struct Hey {\n            i: i32;\n        };\n\n        fn test(ref out: Hey[]) {\n            out.view(u8) .= [ 1.u8, 1.u8, 1.u8, 1.u8 ];\n        }\n\n        fn main() {\n            mut a = [ Hey ];\n            a.test();\n            return a[0].i - 16843009;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_IZHyaIOmasj
                                #define STR_IZHyaIOmasj
static const fu::str str_IZHyaIOmasj fu_INIT_PRIORITY(1015) { "\n        struct Hey {\n            i: i32;\n        };\n\n        fn test(ref x: i32[], y: Hey[])\n            x .= y.view(i32);\n\n        fn main() {\n            mut a = [ 0 ];\n            test(a, [ Hey(13) ]);\n            return a[0] - 13;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Az2yy9aj2k2
                                #define STR_Az2yy9aj2k2
static const fu::str str_Az2yy9aj2k2 fu_INIT_PRIORITY(1015) { "\n        struct Hey {\n            i: i32;\n        };\n\n        fn main() {\n            mut a = [ 0 ];\n            a .= [ Hey(13) ].view(i32);\n            return a[0] - 13;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_StrTNIIl3we
                                #define STR_StrTNIIl3we
static const fu::str str_StrTNIIl3we fu_INIT_PRIORITY(1015) { "\n        fn test(a: byte[..], b?: byte[..]) a == b;\n        fn main() test(\"\") ? 0 : 1;\n\n        ;; EXPECT (fu::view<char>{}, fu::view<char>{})\n    "_fu };
                                #endif

                                #ifndef STR_PiXPI8lGafd
                                #define STR_PiXPI8lGafd
static const fu::str str_PiXPI8lGafd fu_INIT_PRIORITY(1015) { "\n        // The slice() should relax to a get_view, which doesnt need annot to be a string.\n        //  We generally want to remove the distinction between slice(a,b) and [a:b] altogether.\n        //\n        let NOTES = [ \"AAA\", \"BBB\", \"CCC\" ];\n        novec fn what(annot: string) NOTES.find(annot.slice(1, annot.len));\n        fn main() what(\"!BBB\") - 1;\n    "_fu };
                                #endif

                                #ifndef STR_nLyiAoD8Z6b
                                #define STR_nLyiAoD8Z6b
static const fu::str str_nLyiAoD8Z6b fu_INIT_PRIORITY(1015) { "\n        fn Join(a: $T[][], lax sep = [])            // The sep is of type any-init.\n        {                                           //\n            if (a.len < 2)                          //\n                return a.len && a[0];               // NOT SURE WHAT'S 100% IDEAL, BUT:\n                                                    //\n            let N = typeof(sep) -> $T[..] ? sep.len // should either match here,\n                  : typeof(sep) -> $T     ? 1       //                                    but currently matches here, which is just wrong.\n                                 : 0;               //                           or here,\n\n            mut size = a[0].len;\n            for (mut i = 1; i < a.len; i++)\n                size += N + a[i].len;\n\n            mut res: $T[];\n            res.grow_junk(size);\n\n            let head = a[0];\n            size = head.len;\n            res[.. head.len] .= head;\n            for (mut i = 1; i < a.len; i++)\n            {\n                let range = a[i];\n                if (typeof(sep) -> $T[..])\n                    res[size .. size + N] .= sep;\n                else if (typeof(sep) -> $T)\n                    res[size] = sep;\n\n                size += N;\n                res[size .. size + range.len] .= range;\n                size += range.len;\n            }\n\n            return res;\n        }\n\n        fn main() {\n            let res = Join([ \"hello\", \"world\" ], []); // the [] fails the case above\n            return res == \"helloworld\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_AFAKQSWWtzb
                                #define STR_AFAKQSWWtzb
static const fu::str str_AFAKQSWWtzb fu_INIT_PRIORITY(1015) { "\n        // one of these things reported there's no $S in scope.\n        fn Join(a: $T, b: $T, lax sep: $S = [])\n            case ($S -> $T || $S -> $T[..] || $S -> [])\n        {\n            return typeof(sep) -> $T || typeof(sep) -> $T[..]\n                 ? a ~ sep ~ b\n                 : a ~ b;\n        }\n\n        fn main() {\n            let res = Join(\"hello\", \"world\");\n            return res == \"helloworld\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_RQfRt0XHw26
                                #define STR_RQfRt0XHw26
static const fu::str str_RQfRt0XHw26 fu_INIT_PRIORITY(1015) { "\n        // This is the initial type union concept\n        fn Join(a: $T, b: $T, lax sep?: $T or $T[..] or [])\n        {\n            return typeof(sep) -> $T || typeof(sep) -> $T[..]\n                 ? a ~ sep ~ b\n                 : a ~ b;\n        }\n\n        fn main() {\n            let res = Join(\"hello\", \"world\");\n            return res == \"helloworld\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_74QSBcmE1hb
                                #define STR_74QSBcmE1hb
static const fu::str str_74QSBcmE1hb fu_INIT_PRIORITY(1015) { "\n        fn Replace(str: $T[], all: $T or $T[..], with: $T or $T[..] or [])\n            str.len + (typeof(all)  -> $T ? 1 : all.len)\n                    + (typeof(with) -> [] ? 0 : typeof(with) -> $T ? 1 : with.len);\n\n        fn main()\n            \"Hello\".Replace(all: \"ll\", with: []) == 7 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_lQwMWHVPrP1
                                #define STR_lQwMWHVPrP1
static const fu::str str_lQwMWHVPrP1 fu_INIT_PRIORITY(1015) { "\n        noinline fn test(ref arr: i32[]) {\n            while (arr.len < 10) arr.unshift(arr.len);\n            while (arr.len < 20) arr.push(arr.len);\n        }\n\n        fn main() {\n            mut arr = [ 1000, 2000, 3000 ];     <alt>\n            test(arr[1 .. 2]);                  <alt/>\n            test(arr[1 ..][.. 1]);              </alt>\n            return arr == [ 1000, 9, 8, 7, 6, 5, 4, 3, 2, 1,\n                            2000, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n                            3000 ] ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_ZQ4md1AWmSl
                                #define STR_ZQ4md1AWmSl
static const fu::str str_ZQ4md1AWmSl fu_INIT_PRIORITY(1015) { "\n        noinline fn indirect_swap(ref a: i32[], ref b: i32[]) {\n            swap(a, b);\n        }\n\n        fn main() {\n            mut a = [ 0, 1, 2, 3, 4, 5 ];\n            mut b = [ 6, 7, 8, 9 ];\n    <alt>\n            indirect_swap(a[1 .. 5], b);\n            return (a ~ b) == [ 0, 6,7,8,9, 5, 1,2,3,4 ] ? 0 : 1;\n    <alt/>\n            indirect_swap(a[1 .. 5], b[1 .. 3]);\n            return (a ~ b) == [ 0, 7,8, 5, 6, 1,2,3,4, 9 ] ? 0 : 1;\n    </alt>\n        }\n    "_fu };
                                #endif

                                #ifndef STR_4xljR6e3n61
                                #define STR_4xljR6e3n61
static const fu::str str_4xljR6e3n61 fu_INIT_PRIORITY(1015) { "\n        noinline fn inject_via_empty_range(ref a: i32[]) {\n            a.push(10);\n            a.insert(a.len - 1, 20);\n            a ~= [ 30, 40 ];\n            a.splice(a.len - 2, 0, [ 50, 60 ]);\n        }\n\n        fn main() {\n            mut a = [ 1000, 2000, 3000 ];           <alt>\n            inject_via_empty_range(a[2 .. 2]);      <alt/>\n            inject_via_empty_range(a[2 ..][.. 0]);  </alt>\n            return a == [ 1000, 2000,\n                            20, 10, 50, 60, 30, 40,\n                          3000 ] ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_wiu6KPMm1v7
                                #define STR_wiu6KPMm1v7
static const fu::str str_wiu6KPMm1v7 fu_INIT_PRIORITY(1015) { "\n        struct Node { items: Node[] };\n        noinline fn make(items?: Node[]) Node(:items);\n        noinline fn items_len(n: Node) return n.items.len;\n    "_fu };
                                #endif

                                #ifndef STR_HxVIx1cxKqj
                                #define STR_HxVIx1cxKqj
static const fu::str str_HxVIx1cxKqj fu_INIT_PRIORITY(1015) { "\n        fn main() _0::make.items_len;\n    "_fu };
                                #endif

                                #ifndef STR_bYdqvkF3Nnk
                                #define STR_bYdqvkF3Nnk
static const fu::str str_bYdqvkF3Nnk fu_INIT_PRIORITY(1015) { "\n        noinline fn move_from_slice(a: string, b: string) {\n            mut c = a ~ b;\n            return c[(a.len >> 1) .. c.len - (b.len >> 1)];     ;; ConstCast\n        }\n\n        fn main() {\n            mut c = move_from_slice(\"HelloHelloHelloHelloHello\",\n                                    \"WorldWorldWorldWorldWorld\");\n\n            return c == \"lloHelloHelloWorldWorldWor\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_htLginyCH09
                                #define STR_htLginyCH09
static const fu::str str_htLginyCH09 fu_INIT_PRIORITY(1015) { "\n        noinline fn assign_via_vec_range(ref match: i32[], ref other: i32[], x: i32) {\n        <alt>\n            (match = other) ~= x;\n        <alt/>\n            match = (other ~= x);\n        </alt>\n        }\n\n        fn main() {\n            mut match = [ 1 ];\n        <alt>\n            mut other = [ 100, 2, 3 ];\n            assign_via_vec_range(:match, :other, 4);\n        <alt/>\n            mut other = [ 2, 3 ];\n            assign_via_vec_range(:match[1..], :other, 4);\n        <alt/>\n            mut other = [ 1000, 2, 3 ];\n            assign_via_vec_range(:match[1..], :other[1..], 4);\n        </alt>\n            return match.len - 4;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_tEoiYblGnZ7
                                #define STR_tEoiYblGnZ7
static const fu::str str_tEoiYblGnZ7 fu_INIT_PRIORITY(1015) { "\n        noinline fn test(ref arr: i32[]) {\n            mut right: i32[];\n            swap(right, arr[arr.len / 2 ..]);\n            return right;\n        }\n\n        fn main() {\n            mut left = [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ];\n            mut right = test(left);\n            return left.len + right.len * 10 - 54;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_DvYSfLZpzJj
                                #define STR_DvYSfLZpzJj
static const fu::str str_DvYSfLZpzJj fu_INIT_PRIORITY(1015) { "\n        noinline fn what(ref s: string, AoB: int)\n            s = AoB ? \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n                    : \"BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\"\n\n        fn main() {\n            inline fn what(AoB: int) {\n                mut s: string;\n                what(s, AoB)\n            }\n\n            let concat = what(0) ~ what(1)\n            return concat.len - 65\n        }\n    "_fu };
                                #endif

                                #ifndef STR_kio3cHsMoAc
                                #define STR_kio3cHsMoAc
static const fu::str str_kio3cHsMoAc fu_INIT_PRIORITY(1015) { "\n        enum Method { GET };\n        struct Request { method: Method; url: byte[] }\n        noinline fn moveFromVecRangeConst(mut buf: byte[]) {\n            let first_space = 3;\n            let last_space  = buf.len - 9;\n            if (last_space <= first_space) return [];\n            let method_str  = buf[0 .. first_space];\n            let url         = buf[first_space + 1 .. last_space];\n            let ver_str     = buf[last_space + 1 ..];\n            return ver_str == \"HTTP/1.1\" && method_str == \"GET\"\n                && Request(\"GET\", url);                         ;; ConstCast\n        }\n\n        fn main() {\n            mut hello = moveFromVecRangeConst(\"GET / HTTP/1.1\");\n            return hello.url == \"/\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_bDYUtsWBN9k
                                #define STR_bDYUtsWBN9k
static const fu::str str_bDYUtsWBN9k fu_INIT_PRIORITY(1015) { "\n        inline fn Stringlike(x: string): string = x;\n\n        inline fn Concat(mut parts.Stringlike[]: string[]) {\n            mut str = \"\";\n            for (mut i = 0; i < parts.len; i++) str ~= parts[i];\n            return str;\n        }\n\n        inline fn Konkat(mut parts.Stringlike[]: string[]) {\n            mut str = \"\";\n            for (mut i = 0; i < parts.len; i++) str = Concat(str, parts[i]);\n            return str;\n        }\n\n        fn main() {                                             ;; ConstCast\n            let hello = Konkat(\"Hello, \", \"World!\");            ;; GNUStmtExpr\n            return hello == \"Hello, World!\" ? 0 : 1;            ;; PointlessLocal\n        }\n    "_fu };
                                #endif

                                #ifndef STR_aJHe5OJMhDc
                                #define STR_aJHe5OJMhDc
static const fu::str str_aJHe5OJMhDc fu_INIT_PRIORITY(1015) { "\n        fn u64reduce(str: string) {\n            mut x: u64;\n            let u64s = str[0 .. str.len & ~7].view(of: u64);\n            for (mut i = 0; i < u64s.len; i++) {\n                x ^= u64s[i];\n                x ^= x << 13;\n                x ^= x >> 17;\n                x ^= x << 5;\n            }\n            return x;\n        }\n\n        fn main() {\n            let a = u64reduce(\"hello, world!\");\n            let b = u64reduce(\"Hello, world!\");\n            let c = u64reduce(\"Hello, World!\");\n            let sum = a + b + c;\n            let ret = (sum ^ sum >> 32).u32.i32;\n            return ret - 1184288320;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_QKt3CT26HX0
                                #define STR_QKt3CT26HX0
static const fu::str str_QKt3CT26HX0 fu_INIT_PRIORITY(1015) { "\n        <alt>\n        inline                                                  ;; GNUStmtExpr\n        <alt/>\n        noinline\n        </alt>\n        fn sillyDot(a: int[..], b: int[..]) {\n            mut res: int[];\n            let n = min(a.len, b.len);\n            for (mut i = 0; i < n; i++) res.push(a[i] * b[i]);\n            return res;\n        }\n\n        fn main() {\n            mut counter = 0;\n            fn c() counter++;\n            mut res = sillyDot(\n                [ c,c,c,c, c,c,c,c ],  // 0, 1, 2, 3,  4, 5, 6, 7\n                [ c,c,c,c, c,c,c,c ]); // 8, 9,10,11, 12,13,14,15\n\n            return counter == 16 && res == [ 0,9,20,33, 48,65,84,105 ] ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_GsoamMK21h6
                                #define STR_GsoamMK21h6
static const fu::str str_GsoamMK21h6 fu_INIT_PRIORITY(1015) { "\n        <alt>\n        inline      <alt/>\n        noinline    </alt>\n        fn invoke(ref str: int[..], what) {\n            what(str);\n        }\n\n        <alt>\n        inline      <alt/>\n        noinline    </alt>\n        fn Lifetime_op(ref lt: int[..], what) {\n            mut result: int[];\n            lt.invoke: |p| {\n                result ~= p;                                    ;; PointlessMustSeq\n                what(lt);\n            }\n            return result;\n        }\n\n        fn Lifetime_op_join(ref lt: int[..]) {\n            return lt.Lifetime_op(|c| {\n                mut sum = 0;\n                for (mut i = 0; i < c.len; i++) sum += c[i];\n                lt.each: |ref x| x += sum;\n            });\n        }\n\n        fn main() {\n            mut lt  = [ 1, 2, 3, 4 ];\n            let res = Lifetime_op_join(lt);\n            return res == [ 1, 2, 3, 4 ] && lt == [ 11, 12, 13, 14 ] ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_gBZB5o8yN1c
                                #define STR_gBZB5o8yN1c
static const fu::str str_gBZB5o8yN1c fu_INIT_PRIORITY(1015) { "at call to fn Lifetime_op 20:23+11 both alias ref arg lt 19:33+2"_fu };
                                #endif

                                #ifndef STR_JUDGNCyQ13i
                                #define STR_JUDGNCyQ13i
static const fu::str str_JUDGNCyQ13i fu_INIT_PRIORITY(1015) { "\n        <alt>\n        inline          <alt/>\n        noinline        </alt>\n        fn slicePromotion_inner(ref array: i32[], ref view: i32[..]) {\n            array ~= array.map(|x| x + view.len);\n            for (mut i = 0; i < view.len; i++) view[i] += array.len;\n        }\n\n        noinline fn slicePromotion_outer(ref array: i32[], ref view: i32[..]) {\n            return slicePromotion_inner(array, view);\n        }\n\n        fn main() {\n            mut array = [ 1, 2, 3, 4 ];\n            mut view  = [ 2, 3, 4, 5 ];\n            slicePromotion_outer(array, view);\n            return array == [ 1, 2, 3, 4, 5, 6, 7, 8 ]\n                && view  == [ 10, 11, 12, 13 ]\n                    ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_VvaqP9MAaXl
                                #define STR_VvaqP9MAaXl
static const fu::str str_VvaqP9MAaXl fu_INIT_PRIORITY(1015) { "\n        fn ifLetVecRangeMut(ref x: i32[]) {\n            if (ref items = x[.. x.len / 2]) {\n                mut hello = [ 1, 2 ];\n                swap(items, hello);\n            }\n\n            x ~= 5;\n        }\n\n        fn main() {\n            mut arr = [ 5, 6, 3, 4 ];\n            ifLetVecRangeMut(arr);\n            return arr == [ 1, 2, 3, 4, 5 ] ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_sP4ALCscbmc
                                #define STR_sP4ALCscbmc
static const fu::str str_sP4ALCscbmc fu_INIT_PRIORITY(1015) { "\n        let HOME = \"Hello\";\n        fn HOME_bang(lax n: int) <alt>n & 1 && </alt>HOME ~ <alt>\"!\"<alt/>'!'</alt>;\n\n        fn get_FU_ROOT(n: int) {\n            let FU_ROOT = HOME_bang(n);\n            return FU_ROOT || HOME ~ \"!!\";\n        }\n\n        fn main() get_FU_ROOT(1).len - 6;\n    "_fu };
                                #endif

                                #ifndef STR_HUUA4HTYrIk
                                #define STR_HUUA4HTYrIk
static const fu::str str_HUUA4HTYrIk fu_INIT_PRIORITY(1015) { "\n        fn slash(a: string)\n            a.if_last == '/' ? a : a ~ '/';\n\n        fn join(a: string, b: string)\n            b.starts  (with: '/') ?           b :\n            a.ends    (with: '/') ? a       ~ b :\n                                    a ~ '/' ~ b ;\n\n        let HOME = \"/hello/world\";\n\n        fn HOME_bang(n: int) {\n            mut res = HOME;\n            for (mut i = 0; i < n; i++) res ~= '!';\n            return res;\n        }\n\n        <split/>\n        fn get_FU_ROOT(n: int): string {\n            let FU_ROOT         = {                             ;; GNUStmtExpr\n                let exe         = HOME_bang(:n);\n\n                mut start       = -1;\n                for (;;) {\n                    let match   = exe.find(\"/world\", :start + 1);\n                    if (match   < 0) break;\n                    start       = match;\n                }\n\n                start > 0 && exe.slice(start: 0, end: start)\n            };\n\n            return slash(FU_ROOT || join(HOME, \"fu\"));          ;; ConstCast\n        }\n\n        fn main() get_FU_ROOT(1).len - 7;\n    "_fu };
                                #endif

                                #ifndef STR_QE81Ir4AFBl
                                #define STR_QE81Ir4AFBl
static const fu::str str_QE81Ir4AFBl fu_INIT_PRIORITY(1015) { "\n        struct Hey { i: i32; }\n\n        fn main() {\n            let a = 1;\n            let r: Hey = a && [ a ];\n            return r.i - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_yCPfS5dd1Zi
                                #define STR_yCPfS5dd1Zi
static const fu::str str_yCPfS5dd1Zi fu_INIT_PRIORITY(1015) { "\n        struct Hey { i: i32; }\n\n        fn main() {\n            let a: Hey[] = [ [ -1 ], [ +1 ] ];\n            return a[0].i + a[1].i;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_GaUyfz8VQWa
                                #define STR_GaUyfz8VQWa
static const fu::str str_GaUyfz8VQWa fu_INIT_PRIORITY(1015) { "\n        struct Hey { i: i32; }\n\n        fn test(): Hey {\n            return [ 0 ];\n        }\n\n        fn main() test.i;\n    "_fu };
                                #endif

                                #ifndef STR_jdCdJrMviyf
                                #define STR_jdCdJrMviyf
static const fu::str str_jdCdJrMviyf fu_INIT_PRIORITY(1015) { "\n        struct Test {\n        <fail bad call to Test expects 2 arg 11:16+4>\n            a: i32;  <pass/>\n            a?: i32; </fail>\n            b: i32;\n        };\n\n        return Test(b: 1).a;\n    "_fu };
                                #endif

                                #ifndef STR_30wuhCTFta7
                                #define STR_30wuhCTFta7
static const fu::str str_30wuhCTFta7 fu_INIT_PRIORITY(1015) { "\n        struct Test {\n            b: i32;\n        <fail bad call to Test expects 2 arg 11:16+4>\n            a: i32;  <pass/>\n            a?: i32; </fail>\n        };\n\n        return Test(1).a;\n    "_fu };
                                #endif

                                #ifndef STR_uZjq3kidXob
                                #define STR_uZjq3kidXob
static const fu::str str_uZjq3kidXob fu_INIT_PRIORITY(1015) { "\n        struct Node {\n            items?: Node[];\n            stuff?: Node[];\n        };\n\n        fn rec_copy(ref a: Node) {\n            // If implemented naively,\n            //  by the time you copy stuff it's no longer there.\n            a = a.items[0];\n        }\n\n        fn main() {\n            mut a = Node(items: [ Node(stuff: [ Node ]) ]);\n            rec_copy(a);\n            return a.stuff.len - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_GEHjzInm7Zg
                                #define STR_GEHjzInm7Zg
static const fu::str str_GEHjzInm7Zg fu_INIT_PRIORITY(1015) { "\n        fn test(a: i32, b!: i32 = 1) a + b;\n        return test(-1);\n    "_fu };
                                #endif

                                #ifndef STR_RDOUB2vsOeg
                                #define STR_RDOUB2vsOeg
static const fu::str str_RDOUB2vsOeg fu_INIT_PRIORITY(1015) { "\n        fn test(hey!: i32) hey * 2;\n        <fail arg hey explicit name 4:25+4>\n        fn main() = (0).test;       <pass/>\n        fn main() = test(hey: 0);   </fail>\n    "_fu };
                                #endif

                                #ifndef STR_8uxVys2Ru1l
                                #define STR_8uxVys2Ru1l
static const fu::str str_8uxVys2Ru1l fu_INIT_PRIORITY(1015) { "\n        fn test(a: i32, b!: i32 = 1) a + b;\n        <fail bad call to test arg b explicit name 7:16+4>\n        return test(-2, +2);    <pass/>\n        return test(-2, b: +2); </fail>\n    "_fu };
                                #endif

                                #ifndef STR_NPkxhs8H2v9
                                #define STR_NPkxhs8H2v9
static const fu::str str_NPkxhs8H2v9 fu_INIT_PRIORITY(1015) { "\n        struct Test { a: i32; b!: i32; };\n        fn test(t: Test) t.a + t.b;\n        <fail bad call to Test arg b explicit name 8:16+4>\n        return Test(-2, +2).test;    <pass/>\n        return Test(-2, b: +2).test; </fail>\n    "_fu };
                                #endif

                                #ifndef STR_kquArAoBrld
                                #define STR_kquArAoBrld
static const fu::str str_kquArAoBrld fu_INIT_PRIORITY(1015) { "\n        struct Test { a?: i32; b!?: i32; };\n        fn test(t: Test) t.a + t.b;\n        <fail bad call to Test arg b explicit name 8:16+4>\n        return Test(-2, +2).test;    <pass/>\n        return Test(b: +2).test - 2; </fail>\n    "_fu };
                                #endif

                                #ifndef STR_ETZpXdWqHVh
                                #define STR_ETZpXdWqHVh
static const fu::str str_ETZpXdWqHVh fu_INIT_PRIORITY(1015) { "\n        let _precedence = 0;\n        fn parseExpression(p1 = _precedence, mode! = 0) p1 + mode;\n        fn main() parseExpression();\n    "_fu };
                                #endif

                                #ifndef STR_irKqdRGeiLh
                                #define STR_irKqdRGeiLh
static const fu::str str_irKqdRGeiLh fu_INIT_PRIORITY(1015) { "\n        fn A(x!: i32 = 0) x;\n        fn B(x: i32 = 0) A(:x);\n        fn main() A + B;\n    "_fu };
                                #endif

                                #ifndef STR_jy3EDTzRJdf
                                #define STR_jy3EDTzRJdf
static const fu::str str_jy3EDTzRJdf fu_INIT_PRIORITY(1015) { "\n        fn A(x!?: i32) x;\n        fn B(x?: i32) A(:x);\n        fn main() A + B;\n    "_fu };
                                #endif

                                #ifndef STR_KJkEfSAPDdd
                                #define STR_KJkEfSAPDdd
static const fu::str str_KJkEfSAPDdd fu_INIT_PRIORITY(1015) { "\n        fn A(x! = 0) x;\n        fn B(x = 0) A(:x);\n        fn main() A + B;\n    "_fu };
                                #endif

                                #ifndef STR_qSX16EtbwId
                                #define STR_qSX16EtbwId
static const fu::str str_qSX16EtbwId fu_INIT_PRIORITY(1015) { "\n        fn what(a = -1, b!: i32) a + b; // Trailing explicit args.\n        fn main() what(b: +1);\n    "_fu };
                                #endif

                                #ifndef STR_oS3VXW5w4Jh
                                #define STR_oS3VXW5w4Jh
static const fu::str str_oS3VXW5w4Jh fu_INIT_PRIORITY(1015) { "\n        fn greet(with!greeting: string)     greeting.len;\n        fn main()                           greet(with: \"Hello!\") - 6;\n    "_fu };
                                #endif

                                #ifndef STR_MJOk5pv6rqc
                                #define STR_MJOk5pv6rqc
static const fu::str str_MJOk5pv6rqc fu_INIT_PRIORITY(1015) { "\n        fn Each(arr: $T[], visit)\n            for (mut i = 0; i < arr.len; i++)\n                visit(arr[i], i?: i);\n\n        fn main() {\n            mut muls = 0;\n            mut arr = [ 1, 2, 3 ];\n\n            arr.Each: |v, i!index|\n                muls += v * index; // complained no index in scope\n\n            return muls - 8;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_mDXIjAM2H7c
                                #define STR_mDXIjAM2H7c
static const fu::str str_mDXIjAM2H7c fu_INIT_PRIORITY(1015) { "\n        struct Lifetime { using regions: i32[] };\n        fn isInvalidatedBy(write: i32[]) write.len * write[0];\n\n        // This blew up with a TODO: bck_node(non-empty argid).\n        fn main() isInvalidatedBy(write: Lifetime([ 3, 5 ])) - 6;\n    "_fu };
                                #endif

                                #ifndef STR_Uy0gNzg9gD8
                                #define STR_Uy0gNzg9gD8
static const fu::str str_Uy0gNzg9gD8 fu_INIT_PRIORITY(1015) { "\n        struct Node { a: i32; b: i32; c: i32; d: i32 };\n\n        fn make(a: i32, b?: i32, c?: i32)\n            Node(a, :b, :c, d: 10);\n\n        fn make(a: i32, b?: i32, c?: i32, d!: i32)\n            Node(a, :b, :c, :d);\n\n        fn res(using n: Node)\n            return a + 10 * b + 100 * c + 1000 * d;\n\n        fn main()\n            make(4, 5).res      == 10054 &&\n            make(3, b: 4).res   == 10043 &&\n            make(2, c: 3).res   == 10302 &&\n            make(1, d: 2).res   == 2001 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_IXKm30Q2kYb
                                #define STR_IXKm30Q2kYb
static const fu::str str_IXKm30Q2kYb fu_INIT_PRIORITY(1015) { "\n        struct Type { canon: string }\n        struct LocidMap(type T) { _values: T[] };\n\n        fn each(ref map: LocidMap(_), each) // <- This each arg confusingly matches ...\n            map._values.each( // ... at this .each callsite, and then fails to compile.\n                |ref type, i| // Needs a BETTER ERROR message, doesn't need to work.\n                    each(type, i?: map._values.len - 1 - i));\n\n        fn test(var_usage0: LocidMap(Type), ref sum: int)\n        {\n            mut result: string;\n            fn trackVarUsage(i: int, slot: Type) {\n                sum     += i;\n                result  ~= slot.canon;\n            }\n                                                    <alt>\n            var_usage0.each: |slot: Type, i: int|   <alt/>\n            var_usage0.each: |slot,       i: int|   <alt/>\n            var_usage0.each: |slot: Type, i     |   <alt/>\n            var_usage0.each: |slot,       i     |   <alt/>\n            var_usage0.each: |i: int, slot: Type|   <alt/>\n            var_usage0.each: |i: int, slot      |   <alt/>\n            var_usage0.each: |i,      slot: Type|   <alt/>\n            var_usage0.each: |i,      slot      |   </alt>\n                if (slot)\n                    trackVarUsage(i, slot);\n        }\n\n        fn main() {\n            mut sum = 0;\n            let res = test(:sum, LocidMap([ Type(\", World!\"), Type(\"Hello\") ]));\n            return res == \"Hello, World!\" && sum == 1 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_HGbFUc8Tvs6
                                #define STR_HGbFUc8Tvs6
static const fu::str str_HGbFUc8Tvs6 fu_INIT_PRIORITY(1015) { "Bad call to slot 19:21+4 wrong number of arguments expects 2 got 0"_fu };
                                #endif

                                #ifndef STR_YdoB2Bqkls0
                                #define STR_YdoB2Bqkls0
static const fu::str str_YdoB2Bqkls0 fu_INIT_PRIORITY(1015) { "\n        fn a0o0() 0;\n        fn a1o0(a : i32) a;\n        fn a2o1(a : i32, b?: i32) a + b;\n        fn a2o2(a?: i32, b?: i32) a + b;\n        fn main() a0o0(a?: 1, b?: 2) *      1   //      .\n                + a1o0(a?: 1, b?: 2) *     10   //     10\n                + a2o1(a?: 1, b?: 2) *    100   //    300\n                + a2o2(a?: 1, b?: 2) *   1000   //   3000\n                + a2o1(a : 1, <fail bad call a2o1 10:19+4 b not provided c mismatch>\n                              c       <pass/>\n                              b       </fail>\n                               ?: 2) *  10000   //  30000\n                + a2o1(a : 1)        * 100000   // 100000\n                                // ----------------------\n                                     - 133310;\n    "_fu };
                                #endif

                                #ifndef STR_Kw5cFVZQnH8
                                #define STR_Kw5cFVZQnH8
static const fu::str str_Kw5cFVZQnH8 fu_INIT_PRIORITY(1015) { "\n        pub fn reveach(items: $T[..], fn)\n            for (mut i = items.len; i --> 0; )\n                fn(items[i], i?: i);\n\n        pub fn main() {\n            mut sum = 0;\n            [1, 2, 3].reveach(|x   | sum += x          );\n            [1, 2, 3].reveach(|x, i| sum += x * i * 100);\n            return sum - 806;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_5C7pItJEAL2
                                #define STR_5C7pItJEAL2
static const fu::str str_5C7pItJEAL2 fu_INIT_PRIORITY(1015) { "\n        pub lax fn noop() 0;\n        pub fn woot(ref i: i32, fn) i += fn(i?: i += 1); // Will not add 1.\n\n        fn main() {\n            mut sum = 0;\n            woot(sum, fn noop);\n            return sum;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_C3mMFVEhYMd
                                #define STR_C3mMFVEhYMd
static const fu::str str_C3mMFVEhYMd fu_INIT_PRIORITY(1015) { "\n        fn takesFns(x, f)\n            f(x * 2, optAndUnused?: x * 3);\n\n        fn hasUnusedOptArg(x: int, alt = 7, lax optAndUnused?: int)\n            x + alt;\n\n        fn main()\n            takesFns(2, fn hasUnusedOptArg) - 11;\n    "_fu };
                                #endif

                                #ifndef STR_suFsZHAF0Ci
                                #define STR_suFsZHAF0Ci
static const fu::str str_suFsZHAF0Ci fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            let ret: i8 = <fail annot match>\n                128 <pass/>\n                127 </fail>;\n\n            return (ret - 100).i32 - 27;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_QzPHV96Ss5e
                                #define STR_QzPHV96Ss5e
static const fu::str str_QzPHV96Ss5e fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            let ret: i16 = <fail annot match>\n                32768 <pass/>\n                32767 </fail>;\n\n            return (ret - 32700).i32 - 67;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_bPv7EcnvEze
                                #define STR_bPv7EcnvEze
static const fu::str str_bPv7EcnvEze fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            let ret: i32 = <fail annot match>\n                2147483648 <pass/>\n                2147483647 </fail>;\n\n            return (ret - 2147483600).i32 - 47;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_r07zzFEWZji
                                #define STR_r07zzFEWZji
static const fu::str str_r07zzFEWZji fu_INIT_PRIORITY(1015) { "\n        fn main() { // weird error, see the other two below\n            let ret: i64 = <fail bad int literal>\n                9223372036854775808 <pass/>\n                9223372036854775807 </fail>;\n\n            return (ret - 9223372036854775800).i32 - 7;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_SsUMPANCEXc
                                #define STR_SsUMPANCEXc
static const fu::str str_SsUMPANCEXc fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            let ret: i8 = <fail annot match>\n                -129 <pass/>\n                -128 </fail>;\n\n            return (ret + 100).i32 + 28;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_AtDAHKifEt4
                                #define STR_AtDAHKifEt4
static const fu::str str_AtDAHKifEt4 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            let ret: i16 = <fail annot match>\n                -32769 <pass/>\n                -32768 </fail>;\n\n            return (ret + 32700).i32 + 68;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_rHJq9GelhP2
                                #define STR_rHJq9GelhP2
static const fu::str str_rHJq9GelhP2 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            let ret: i32 = <fail annot match>\n                -2147483649 <pass/>\n                -2147483648 </fail>;\n\n            return (ret + 2147483600).i32 + 48;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_XkyPrhR2W93
                                #define STR_XkyPrhR2W93
static const fu::str str_XkyPrhR2W93 fu_INIT_PRIORITY(1015) { "\n        fn main() { // wording different from the ones above and below\n            let ret: i64 = <fail oversized signed int literal>\n                -9223372036854775809 <pass/>\n                -9223372036854775808 </fail>;\n\n            return (ret + 9223372036854775800).i32 + 8;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_M5QJcXTnuc9
                                #define STR_M5QJcXTnuc9
static const fu::str str_M5QJcXTnuc9 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            let ret: u8 = <fail annot match>\n                256 <pass/>\n                255 </fail>;\n\n            return (ret - 0xff).i32;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_6S7EjVKUIda
                                #define STR_6S7EjVKUIda
static const fu::str str_6S7EjVKUIda fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            let ret: u16 = <fail annot match>\n                65536 <pass/>\n                65535 </fail>;\n\n            return (ret - 0xffff).i32;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_sYLQo93eUzh
                                #define STR_sYLQo93eUzh
static const fu::str str_sYLQo93eUzh fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            let ret: u32 = <fail annot match>\n                4294967296 <pass/>\n                4294967295 </fail>;\n\n            return (ret - 0xffffffff).i32;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_JtO3SNjaEVf
                                #define STR_JtO3SNjaEVf
static const fu::str str_JtO3SNjaEVf fu_INIT_PRIORITY(1015) { "\n        fn main() { // this is the best of the weird ones\n            let ret: u64 = <fail integer overflows u64>\n                18446744073709551616 <pass/>\n                18446744073709551615 </fail>;\n\n            return (ret - 0xffffffffffffffff).i32;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Iqo9mznxu78
                                #define STR_Iqo9mznxu78
static const fu::str str_Iqo9mznxu78 fu_INIT_PRIORITY(1015) { "\n        pub fn set_once(ref entry, bit: i32): bool\n        {\n            let mask = 1 << bit.u64;    // cg'd into '1u << uint64_t(bit)'\n            if (entry & mask)           //  which doesnt work for some reason\n                return false;\n\n            entry |= mask;\n            return true;\n        }\n\n        fn main() {\n            mut entry: u64;\n            let a = set_once(entry, 32);\n            let b = set_once(entry, 32);\n            return a && !b ? 0 : 101;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_L9ob3cXaEx3
                                #define STR_L9ob3cXaEx3
static const fu::str str_L9ob3cXaEx3 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            let hey: u128 = 0x8000000000000000.u128;\n            let res = hey + hey;\n            return res > hey ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_mxd0QSPcyLa
                                #define STR_mxd0QSPcyLa
static const fu::str str_mxd0QSPcyLa fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            let v = <alt>u8<alt/>byte</alt>(128);\n            return v.i32 == 128 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_15isfz81rGe
                                #define STR_15isfz81rGe
static const fu::str str_15isfz81rGe fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            let v = <alt>i32<alt/>u32</alt>(128);\n            return byte(v) == byte(128) ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_du7fyzKiYZ8
                                #define STR_du7fyzKiYZ8
static const fu::str str_du7fyzKiYZ8 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            let v = <alt>i32<alt/>u32</alt>(2147483648);\n            return byte(v) == byte(0) ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_6OCoGZxQCFi
                                #define STR_6OCoGZxQCFi
static const fu::str str_6OCoGZxQCFi fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            let v = <alt>i32<alt/>u32</alt>(-1);\n            return byte(v) == byte(255) ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_XgBOG66B0ub
                                #define STR_XgBOG66B0ub
static const fu::str str_XgBOG66B0ub fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            return i32(byte(i32(128))) == 128 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_fpkEWqq8Kg6
                                #define STR_fpkEWqq8Kg6
static const fu::str str_fpkEWqq8Kg6 fu_INIT_PRIORITY(1015) { "\n        fn hello(a?: i32, b?: i32) = 10 * a + 100 * b;\n\n        <alt>\n        inline                  </alt>\n        fn test(f) {\n            let a = 1; // none of these should need 'lax',\n            let b = 2; //  they're all SS_MATCHED below,\n            let c = 3; //   and their use is explicitly discard-ok.\n            return f(?:a, ?:b, ?:c);\n        }\n\n        fn main() test(fn hello) - 210;\n    "_fu };
                                #endif

                                #ifndef STR_NCDDYdNotGa
                                #define STR_NCDDYdNotGa
static const fu::str str_NCDDYdNotGa fu_INIT_PRIORITY(1015) { "\n        pub lax fn noop() {} // AUTOPUB\n        <fail hello is not defined><pass/>\n        pub\n        </fail>\n        fn hello() 3;\n    "_fu };
                                #endif

                                #ifndef STR_bDKxvI6K5we
                                #define STR_bDKxvI6K5we
static const fu::str str_bDKxvI6K5we fu_INIT_PRIORITY(1015) { "\n        import _0;\n        fn main() 6 - hello * 2;\n    "_fu };
                                #endif

                                #ifndef STR_k35PMrzH9ya
                                #define STR_k35PMrzH9ya
static const fu::str str_k35PMrzH9ya fu_INIT_PRIORITY(1015) { "\n        pub struct Hey { i: i32; };\n    "_fu };
                                #endif

                                #ifndef STR_CG0xDNYh6n1
                                #define STR_CG0xDNYh6n1
static const fu::str str_CG0xDNYh6n1 fu_INIT_PRIORITY(1015) { "\n        fn main() 1._0::Hey.i - 1;\n    "_fu };
                                #endif

                                #ifndef STR_Dopo8R9DDNf
                                #define STR_Dopo8R9DDNf
static const fu::str str_Dopo8R9DDNf fu_INIT_PRIORITY(1015) { "\n        import _0;\n        pub inline fn test(h: Hey) h.i + 2;\n    "_fu };
                                #endif

                                #ifndef STR_47JovCWR8qd
                                #define STR_47JovCWR8qd
static const fu::str str_47JovCWR8qd fu_INIT_PRIORITY(1015) { "\n        import _1;\n        fn main() 1._0::Hey.test - 3;\n    "_fu };
                                #endif

                                #ifndef STR_5TtobiIiVCl
                                #define STR_5TtobiIiVCl
static const fu::str str_5TtobiIiVCl fu_INIT_PRIORITY(1015) { "\n        pub inline fn test(h: _0::Hey) h.i + 2;\n    "_fu };
                                #endif

                                #ifndef STR_KlAaBQjRqd4
                                #define STR_KlAaBQjRqd4
static const fu::str str_KlAaBQjRqd4 fu_INIT_PRIORITY(1015) { "\n        fn main() 1._0::Hey._1::test - 3;\n    "_fu };
                                #endif

                                #ifndef STR_kKa9CP7GU62
                                #define STR_kKa9CP7GU62
static const fu::str str_kKa9CP7GU62 fu_INIT_PRIORITY(1015) { "\n        pub struct You { i: i32; };\n    "_fu };
                                #endif

                                #ifndef STR_jn4Zwjk56Lh
                                #define STR_jn4Zwjk56Lh
static const fu::str str_jn4Zwjk56Lh fu_INIT_PRIORITY(1015) { "\n        pub struct Hey { using you: _0::You; };\n        pub fn init3(): Hey = [ _0::You(3) ];\n    "_fu };
                                #endif

                                #ifndef STR_fcyvbEwYWc7
                                #define STR_fcyvbEwYWc7
static const fu::str str_fcyvbEwYWc7 fu_INIT_PRIORITY(1015) { "\n        pub inline fn test(using h = _1::init3) i + 7;\n    "_fu };
                                #endif

                                #ifndef STR_GqPRG1QJoj4
                                #define STR_GqPRG1QJoj4
static const fu::str str_GqPRG1QJoj4 fu_INIT_PRIORITY(1015) { "\n        fn main() _2::test - 10;\n    "_fu };
                                #endif

                                #ifndef STR_LXOEJE0w5Wb
                                #define STR_LXOEJE0w5Wb
static const fu::str str_LXOEJE0w5Wb fu_INIT_PRIORITY(1015) { "\n        pub struct vec3 {\n            x?: f32;\n            y?: f32;\n            z?: f32;\n        };\n    "_fu };
                                #endif

                                #ifndef STR_yWN6vXeiDI6
                                #define STR_yWN6vXeiDI6
static const fu::str str_yWN6vXeiDI6 fu_INIT_PRIORITY(1015) { "\n        import _0;\n\n        pub struct mat34 {\n            mx: vec3;\n            my: vec3;\n            mz: vec3;\n            mo: vec3;\n        };\n\n        pub inline fn mat34_identity()\n            mat34(\n                vec3(x: 1),\n                vec3(y: 1),\n                vec3(z: 1), vec3 /*point3*/);\n    "_fu };
                                #endif

                                #ifndef STR_IxOcTPRGNil
                                #define STR_IxOcTPRGNil
static const fu::str str_IxOcTPRGNil fu_INIT_PRIORITY(1015) { "\n        pub struct mat4 {\n            m0: f32; m1: f32; m2: f32; m3: f32;\n            m4: f32; m5: f32; m6: f32; m7: f32;\n            m8: f32; m9: f32; mA: f32; mB: f32;\n            mC: f32; mD: f32; mE: f32; mF: f32;\n        };\n\n        pub inline fn mat4(using m: _1::mat34)\n            mat4(\n                mx.x, mx.y, mx.z, 0,\n                my.x, my.y, my.z, 0,\n                mz.x, mz.y, mz.z, 0,\n                mo.x, mo.y, mo.z, 1);\n\n        pub fn determinant(using _: mat4)\n            + mC * m9 * m6 * m3 - m8 * mD * m6 * m3 - mC * m5 * mA * m3\n            + m4 * mD * mA * m3 + m8 * m5 * mE * m3 - m4 * m9 * mE * m3\n            - mC * m9 * m2 * m7 + m8 * mD * m2 * m7 + mC * m1 * mA * m7\n            - m0 * mD * mA * m7 - m8 * m1 * mE * m7 + m0 * m9 * mE * m7\n            + mC * m5 * m2 * mB - m4 * mD * m2 * mB - mC * m1 * m6 * mB\n            + m0 * mD * m6 * mB + m4 * m1 * mE * mB - m0 * m5 * mE * mB\n            - m8 * m5 * m2 * mF + m4 * m9 * m2 * mF + m8 * m1 * m6 * mF\n            - m0 * m9 * m6 * mF - m4 * m1 * mA * mF + m0 * m5 * mA * mF;\n    "_fu };
                                #endif

                                #ifndef STR_YGguMkCbI0k
                                #define STR_YGguMkCbI0k
static const fu::str str_YGguMkCbI0k fu_INIT_PRIORITY(1015) { "\n        pub fn main()\n        {\n            let m34 = _1::mat34_identity;\n            let m44 = _2::mat4(m34);\n\n            return m44.determinant.i32 - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_LSTam6ibS72
                                #define STR_LSTam6ibS72
static const fu::str str_LSTam6ibS72 fu_INIT_PRIORITY(1015) { "\n        struct _0 { x?: f32; y?: f32 };\n        fn maxc(using vec: _0) x > y ? x : y;\n    "_fu };
                                #endif

                                #ifndef STR_C74NcrTvF0g
                                #define STR_C74NcrTvF0g
static const fu::str str_C74NcrTvF0g fu_INIT_PRIORITY(1015) { "\n        <alt>\n        import _0;\n        fn main() _0.maxc.i32;\n        <alt/>\n        fn main() ::_0.maxc.i32;\n        </alt>\n    "_fu };
                                #endif

                                #ifndef STR_kNCr1t0n6Mk
                                #define STR_kNCr1t0n6Mk
static const fu::str str_kNCr1t0n6Mk fu_INIT_PRIORITY(1015) { "\n        pub fn _0(i: i32) i + 1;\n    "_fu };
                                #endif

                                #ifndef STR_laDF3oSGVSi
                                #define STR_laDF3oSGVSi
static const fu::str str_laDF3oSGVSi fu_INIT_PRIORITY(1015) { "\n        fn main() (-1).::_0;\n    "_fu };
                                #endif

                                #ifndef STR_j8AKNds8bb4
                                #define STR_j8AKNds8bb4
static const fu::str str_j8AKNds8bb4 fu_INIT_PRIORITY(1015) { "\n        pub fn add(ref to: $T[], item: $T) {\n            for (mut i = 0; i < to.len; i++) {\n                if (to[i] >= item) {\n                    if (to[i] != item)\n                        to.insert(i, item);\n\n                    return;\n                }\n            }\n\n            to.push(item);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_rrfXAsM0nzd
                                #define STR_rrfXAsM0nzd
static const fu::str str_rrfXAsM0nzd fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut x = [1, 2, 3];\n            x._0::add(3); if (x.len != 3) return 33;\n            x._0::add(4); return x.len - x[3];\n        }\n    "_fu };
                                #endif

                                #ifndef STR_uzmtSFwwtvg
                                #define STR_uzmtSFwwtvg
static const fu::str str_uzmtSFwwtvg fu_INIT_PRIORITY(1015) { "\n        pub let pad0 = 0; pub let pad1 = 1; pub let pad2 = 2; pub let pad3 = 3; pub let pad4 = 4; pub let pad5 = 5; pub let pad6 = 6; pub let pad7 = 7; pub let pad8 = 8; pub let pad9 = 9;\n        pub let PAD0 = 0; pub let PAD1 = 1; pub let PAD2 = 2; pub let PAD3 = 3; pub let PAD4 = 4; pub let PAD5 = 5; pub let PAD6 = 6; pub let PAD7 = 7; pub let PAD8 = 8; pub let PAD9 = 9;\n\n        pub let A = \"hello\";\n        pub let B = \"world\";\n    "_fu };
                                #endif

                                #ifndef STR_rP1IUyzDPIi
                                #define STR_rP1IUyzDPIi
static const fu::str str_rP1IUyzDPIi fu_INIT_PRIORITY(1015) { "\n        import _0;\n        fn test(i: i32) {\n            let v = i & 1 ? A : B;\n            return v.len;\n        }\n\n        fn main() 0.test - 1.test;\n    "_fu };
                                #endif

                                #ifndef STR_HtYfmqhayZ7
                                #define STR_HtYfmqhayZ7
static const fu::str str_HtYfmqhayZ7 fu_INIT_PRIORITY(1015) { "\n        pub fn clone(a: $T)\n        case ($T.is::copy) a;\n        case ($T -> $T) {\n            mut res: $T;\n            for (fieldname i: $T) res.i = a.i.clone();\n            return res;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Gc7BcAL4x60
                                #define STR_Gc7BcAL4x60
static const fu::str str_Gc7BcAL4x60 fu_INIT_PRIORITY(1015) { "\n        pub nocopy struct Scope { x: i32; };\n\n        pub struct ModuleOutputs {\n            deps: i32[];\n            scope: Scope;\n        };\n\n        pub fn test(a: ModuleOutputs) {\n            let b = a._0::clone();\n            return a.deps.len - b.deps.len;\n        }\n\n        pub fn main() test(ModuleOutputs);\n    "_fu };
                                #endif

                                #ifndef STR_PrkBHpkj5T6
                                #define STR_PrkBHpkj5T6
static const fu::str str_PrkBHpkj5T6 fu_INIT_PRIORITY(1015) { "\n        // a private fn\n        fn createShader(src: string) = src;\n\n        // inits a public let\n        pub let GEOMETRY_PASS_TEST = createShader(\"src\");\n    "_fu };
                                #endif

                                #ifndef STR_uaTCnpZ4At0
                                #define STR_uaTCnpZ4At0
static const fu::str str_uaTCnpZ4At0 fu_INIT_PRIORITY(1015) { "\n        pub fn main() _0::GEOMETRY_PASS_TEST.len - 3;\n    "_fu };
                                #endif

                                #ifndef STR_dwwkyKqyuN0
                                #define STR_dwwkyKqyuN0
static const fu::str str_dwwkyKqyuN0 fu_INIT_PRIORITY(1015) { "\n        struct List {\n            vals: string[];\n        };\n\n        fn add(using ref _: List, val: string)\n            vals ~= val;\n\n        fn [](using _: List, val: string) {\n            mut count = 0;\n            for (mut i = 0; i < vals.len; i++)\n                if (vals[i] == val)\n                    count++;\n\n            return count;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_9AX1ZTniVb5
                                #define STR_9AX1ZTniVb5
static const fu::str str_9AX1ZTniVb5 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut list: _0::List;\n            for (mut i = 0; i < 3; i++)\n                list.add(i & 1 ? \"a\" : \"b\");\n\n            return list[\"b\"] - 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_McVhNeOqqI7
                                #define STR_McVhNeOqqI7
static const fu::str str_McVhNeOqqI7 fu_INIT_PRIORITY(1015) { "\n        struct Int { i: i32; };\n        fn -(a: Int) Int(-a.i);\n        fn +(a: Int, b: Int) Int(a.i + b.i);\n        fn +=(ref a: Int, b: Int) { a.i += b.i; return a; };\n        postfix fn ++(ref a: Int) { a.i++; };\n    "_fu };
                                #endif

                                #ifndef STR_V3VaBSYlxTg
                                #define STR_V3VaBSYlxTg
static const fu::str str_V3VaBSYlxTg fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut x: _0::Int = [ 1 ];\n            x += -(x + x);\n            x++;\n            return x.i;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_6zLJlVY63a2
                                #define STR_6zLJlVY63a2
static const fu::str str_6zLJlVY63a2 fu_INIT_PRIORITY(1015) { "\n        fn private(x)           x * 3;              // Scope_import is broken,\n        pub fn public(y)        private(y) * 2;     //  doesnt always import privates.\n        <split/>\n        fn main()               1.public - 6;\n    "_fu };
                                #endif

                                #ifndef STR_2s3qzorYYT1
                                #define STR_2s3qzorYYT1
static const fu::str str_2s3qzorYYT1 fu_INIT_PRIORITY(1015) { "\n        fn private(x: i32)      x * 3;              // cg fail:\n        pub fn public(y)        private(y) * 2;     //  fn private hidden in first translation unit.\n    "_fu };
                                #endif

                                #ifndef STR_YE1dlqShbO0
                                #define STR_YE1dlqShbO0
static const fu::str str_YE1dlqShbO0 fu_INIT_PRIORITY(1015) { "\n        fn main()               1._0::public - 6;\n    "_fu };
                                #endif

                                #ifndef STR_8KnCKfUVQI3
                                #define STR_8KnCKfUVQI3
static const fu::str str_8KnCKfUVQI3 fu_INIT_PRIORITY(1015) { "\n        let OPTOKENS = \"{}[]()!?~@#$%^&*/-+<=>,.;:|\";   // nowadays problem is OPTOKENS cgs to static in first translation unit\n\n        pub fn lex(src) // <- template\n        {\n            let end = src.len;\n            mut idx = 0;\n\n            while (idx < end) {\n                let c = src[idx++];\n                if (OPTOKENS.has(c)) // <- originally, no OPTOKENS in scope ...\n                    return idx - 1;\n            }\n\n            return src.len;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_D5BgtB9atkc
                                #define STR_D5BgtB9atkc
static const fu::str str_D5BgtB9atkc fu_INIT_PRIORITY(1015) { "\n        fn main() _0::lex(\"3 - 3\") - 2; // <- from here\n    "_fu };
                                #endif

                                #ifndef STR_WsrP1RubjL3
                                #define STR_WsrP1RubjL3
static const fu::str str_WsrP1RubjL3 fu_INIT_PRIORITY(1015) { "\n        pub fn pubbed(a: i32) a * 2;\n        <fail not_pubbed not defined><pass/>\n        pub                          </fail>\n        fn not_pubbed(b: i32) b * 3;\n    "_fu };
                                #endif

                                #ifndef STR_aBzbuqatg98
                                #define STR_aBzbuqatg98
static const fu::str str_aBzbuqatg98 fu_INIT_PRIORITY(1015) { "\n        fn main() 1._0::pubbed._0::not_pubbed - 6;\n    "_fu };
                                #endif

                                #ifndef STR_X59k84irB65
                                #define STR_X59k84irB65
static const fu::str str_X59k84irB65 fu_INIT_PRIORITY(1015) { "\n        let SELF_TEST           = true;\n        let NODEIDX_signbits    = SELF_TEST && 4;\n        let NODEIDX_signmask    = (1 << NODEIDX_signbits) - 1;\n    "_fu };
                                #endif

                                #ifndef STR_Ng15uG1a245
                                #define STR_Ng15uG1a245
static const fu::str str_Ng15uG1a245 fu_INIT_PRIORITY(1015) { "\n        fn main() _0::NODEIDX_signmask - 15;\n    "_fu };
                                #endif

                                #ifndef STR_pfiQr2EQLD8
                                #define STR_pfiQr2EQLD8
static const fu::str str_pfiQr2EQLD8 fu_INIT_PRIORITY(1015) { "\n        struct Helpers { index: i32; }\n        fn +(a: Helpers, b: Helpers) a.index - b.index;\n    "_fu };
                                #endif

                                #ifndef STR_lDV2yrsa83i
                                #define STR_lDV2yrsa83i
static const fu::str str_lDV2yrsa83i fu_INIT_PRIORITY(1015) { "\n        import _0;\n        fn main() {\n            <fail ambig><pass/> // autoshadowing surprised me here\n            shadow      </fail> //  feels like this override should be explicit\n            infix fn +(a: Helpers, b: Helpers) a.index + b.index;\n            return Helpers(+1) + Helpers(-1);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_LTU8rQ2Cun8
                                #define STR_LTU8rQ2Cun8
static const fu::str str_LTU8rQ2Cun8 fu_INIT_PRIORITY(1015) { "\n        struct Options { v: i32; };\n    "_fu };
                                #endif

                                #ifndef STR_P0wc9EiKQh7
                                #define STR_P0wc9EiKQh7
static const fu::str str_P0wc9EiKQh7 fu_INIT_PRIORITY(1015) { "\n        fn compile(o: _0::Options) = o.v;\n    "_fu };
                                #endif

                                #ifndef STR_WqNfxGIAnIe
                                #define STR_WqNfxGIAnIe
static const fu::str str_WqNfxGIAnIe fu_INIT_PRIORITY(1015) { "\n        // Won't find Options if solving in reverse modid order.\n        fn compile_snippets(o: _0::Options) = o.v;\n    "_fu };
                                #endif

                                #ifndef STR_FhDbff6AUw3
                                #define STR_FhDbff6AUw3
static const fu::str str_FhDbff6AUw3 fu_INIT_PRIORITY(1015) { "\n        import _1;\n        import _2;\n\n        fn main() {\n            let o = _0::Options(0);\n            return compile(o) + compile_snippets(o);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_GZc3qjFNYD6
                                #define STR_GZc3qjFNYD6
static const fu::str str_GZc3qjFNYD6 fu_INIT_PRIORITY(1015) { "\n        let x: i32 = 2;\n    "_fu };
                                #endif

                                #ifndef STR_fCINv3VVv42
                                #define STR_fCINv3VVv42
static const fu::str str_fCINv3VVv42 fu_INIT_PRIORITY(1015) { "\n        pub import _0;\n        let y: i32 = 3;\n    "_fu };
                                #endif

                                #ifndef STR_BzzzJQKuP50
                                #define STR_BzzzJQKuP50
static const fu::str str_BzzzJQKuP50 fu_INIT_PRIORITY(1015) { "\n        import _1;\n        fn main() x + y - 5;\n    "_fu };
                                #endif

                                #ifndef STR_0N0KGMJ9Rt7
                                #define STR_0N0KGMJ9Rt7
static const fu::str str_0N0KGMJ9Rt7 fu_INIT_PRIORITY(1015) { "\n        struct Profile {\n            a: i32;\n            b: i32;\n            c: i32;\n        };\n\n        fn incr(implicit ref p: Profile, which) {\n            p.which++;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_nPLwfXgApZh
                                #define STR_nPLwfXgApZh
static const fu::str str_nPLwfXgApZh fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            implicit mut p: _0::Profile;\n\n            _0::incr(fn _0::a);\n            _0::incr(|ref i| i._0::b);\n            _0::incr(|ref i| i.b);                              ;; DuplicateFunctions\n            _0::incr(._0::c);\n            _0::incr(.c);\n\n            return p._0::a + p.b * 10 + p.c * 100 == 221 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_zA2C53D7QFb
                                #define STR_zA2C53D7QFb
static const fu::str str_zA2C53D7QFb fu_INIT_PRIORITY(1015) { "\n        struct Sample { x: int; y: int };\n\n        fn main() {\n            mut res: Sample;\n            mut now_x = 1;\n            mut now_y = 2;\n            inline fn Now() = Sample(++now_x, now_y++);\n\n            fn PROFILE() unwrap {\n                defer {\n                    for (mut i = 0; i < 10; i++) now_x++;\n                    res = Now();\n                }\n            }\n\n            {\n                PROFILE();\n                now_y += 100;\n            }\n            return res.x == 12 && res.y == 102 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_52ePUZZHGKh
                                #define STR_52ePUZZHGKh
static const fu::str str_52ePUZZHGKh fu_INIT_PRIORITY(1015) { "\n        inline fn isStruct(type: string) =\n            type.starts(with: '/');\n\n        inline fn isStructOrUnion(type: string) =\n            type.isStruct;\n    "_fu };
                                #endif

                                #ifndef STR_8NRkIhBtwrh
                                #define STR_8NRkIhBtwrh
static const fu::str str_8NRkIhBtwrh fu_INIT_PRIORITY(1015) { "\n        fn lookupUserType(type: string) =\n            \"<\" ~ type.len ~ \">\";\n\n        fn tryLookupUserType(type: string) =\n            type._0::isStruct && lookupUserType(type);\n    "_fu };
                                #endif

                                #ifndef STR_jvhZD8ySNpc
                                #define STR_jvhZD8ySNpc
static const fu::str str_jvhZD8ySNpc fu_INIT_PRIORITY(1015) { "\n        fn getFlatCount(type: string) =\n            type._0::isStructOrUnion\n                ? _1::tryLookupUserType(type).len\n                : 1;\n    "_fu };
                                #endif

                                #ifndef STR_WscpQeEYbD4
                                #define STR_WscpQeEYbD4
static const fu::str str_WscpQeEYbD4 fu_INIT_PRIORITY(1015) { "\n        fn main() = \"/a\"._2::getFlatCount() == 3 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_FWSsifKePf5
                                #define STR_FWSsifKePf5
static const fu::str str_FWSsifKePf5 fu_INIT_PRIORITY(1015) { "\n        noinline fn recA(x) x & 1 ? recB(x) : x;\n        noinline fn recB(x) recA(x + 1);\n\n        pub inline fn fun(x: i32) recB(x);\n    "_fu };
                                #endif

                                #ifndef STR_lPcg1EFC8A8
                                #define STR_lPcg1EFC8A8
static const fu::str str_lPcg1EFC8A8 fu_INIT_PRIORITY(1015) { "\n        fn main() _0::fun(0) == 2 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_rnlJRY1cKB8
                                #define STR_rnlJRY1cKB8
static const fu::str str_rnlJRY1cKB8 fu_INIT_PRIORITY(1015) { "\n        fn add2(x: i32) x + 2;\n        fn times10(x: i32)\n            <fail import circ 2:9+6 5:23+2>\n                x * _1::add5(5)     <pass/>\n                x * 10              </fail>;\n    "_fu };
                                #endif

                                #ifndef STR_oW9tjyA2m17
                                #define STR_oW9tjyA2m17
static const fu::str str_oW9tjyA2m17 fu_INIT_PRIORITY(1015) { "\n        import _0;\n        fn add5(x: i32) add2(x) + 3;\n    "_fu };
                                #endif

                                #ifndef STR_xX4G8D7HBO6
                                #define STR_xX4G8D7HBO6
static const fu::str str_xX4G8D7HBO6 fu_INIT_PRIORITY(1015) { "\n        fn main() _0::times10(_1::add5(8)) - 130;\n    "_fu };
                                #endif

                                #ifndef STR_RsdBBPzPGE1
                                #define STR_RsdBBPzPGE1
static const fu::str str_RsdBBPzPGE1 fu_INIT_PRIORITY(1015) { "\n        fn hello(x: i32) x * 3;\n    "_fu };
                                #endif

                                #ifndef STR_1M3VYfdJaBl
                                #define STR_1M3VYfdJaBl
static const fu::str str_1M3VYfdJaBl fu_INIT_PRIORITY(1015) { "\n        <fail could not resolve import _2 3:9+6>\n        import _2;                       <pass/>\n        import _0;                       </fail>\n        fn main() hello(4) - 12;\n    "_fu };
                                #endif

                                #ifndef STR_JeMkjaogCzf
                                #define STR_JeMkjaogCzf
static const fu::str str_JeMkjaogCzf fu_INIT_PRIORITY(1015) { "\n        pub struct What { thing: i32 };\n\n        <fail must_be_public not defined 2:33+14><pass/>\n        pub </fail>\n        fn must_be_public(x: What) = x.thing * 11;\n    "_fu };
                                #endif

                                #ifndef STR_Ej6IuxKGVp8
                                #define STR_Ej6IuxKGVp8
static const fu::str str_Ej6IuxKGVp8 fu_INIT_PRIORITY(1015) { "\n        fn main() = _0::What(3).must_be_public - 33;\n    "_fu };
                                #endif

                                #ifndef STR_kGn8pi1n0I3
                                #define STR_kGn8pi1n0I3
static const fu::str str_kGn8pi1n0I3 fu_INIT_PRIORITY(1015) { "\n        struct Module { modid: i32; target: Target }\n        struct Target { _packed: u64 }\n\n        let modid = 2;\n        inline fn modid(t: Target) i32(t._packed);\n        inline fn index(t: Target) i32(t._packed >> 32);\n\n        fn Target(shadow modid: i32, index: i32) {\n            return Target(modid.u64 | index.u64 << 32);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_DTwmwWnUfWj
                                #define STR_DTwmwWnUfWj
static const fu::str str_DTwmwWnUfWj fu_INIT_PRIORITY(1015) { "\n        import _0;\n        fn inspect(m: Module) {\n            return modid + m.modid + m.target.modid;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_m946sXHGlgh
                                #define STR_m946sXHGlgh
static const fu::str str_m946sXHGlgh fu_INIT_PRIORITY(1015) { "\n        import _0;\n        fn main() {\n            let m = Module(3, Target(5, 7));\n            return m._1::inspect() - 10;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_jd68xUK1eE7
                                #define STR_jd68xUK1eE7
static const fu::str str_jd68xUK1eE7 fu_INIT_PRIORITY(1015) { "\n        struct Module { modid: i32; };\n        struct Target { _packed: u64; };\n\n        fn modid(t: Target) i32(t._packed & 0xffffff);\n\n        fn Target(modid: i32, index: i32, local: i32) {\n            return Target(modid.u64\n                        | index.u64 << 24\n                        | local.u64 << 44);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Gupk7SVzVxa
                                #define STR_Gupk7SVzVxa
static const fu::str str_Gupk7SVzVxa fu_INIT_PRIORITY(1015) { "\n        import _0;\n        fn inspect(module: Module) = module.modid;\n    "_fu };
                                #endif

                                #ifndef STR_PrbrWNHV2A9
                                #define STR_PrbrWNHV2A9
static const fu::str str_PrbrWNHV2A9 fu_INIT_PRIORITY(1015) { "\n        fn main() _1::inspect([]);\n    "_fu };
                                #endif

                                #ifndef STR_IrF0SyC7erj
                                #define STR_IrF0SyC7erj
static const fu::str str_IrF0SyC7erj fu_INIT_PRIORITY(1015) { "\n        struct Opts { b: i32 };\n    "_fu };
                                #endif

                                #ifndef STR_2fT2n4ENPte
                                #define STR_2fT2n4ENPte
static const fu::str str_2fT2n4ENPte fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            fn muteRest(a, opts?: _0::Opts) a + opts.b;\n            return 0.muteRest;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_WhhVxfJq9L6
                                #define STR_WhhVxfJq9L6
static const fu::str str_WhhVxfJq9L6 fu_INIT_PRIORITY(1015) { "\n        noinline fn ifArray(type: string, hit) {\n            if (type.starts(with: \"[]\"))\n                hit(type.slice(2));\n        }\n\n        noinline fn tryClearArray(type: string, else!?) {\n            ifArray(type): |item|\n                return item;\n\n            return else();\n        }\n\n        inline fn clearArray(type: string) {\n            return tryClearArray(type, else: ||\n                throw(\"Not an array: \" ~ type));\n        }\n    "_fu };
                                #endif

                                #ifndef STR_pY55c27MPXl
                                #define STR_pY55c27MPXl
static const fu::str str_pY55c27MPXl fu_INIT_PRIORITY(1015) { "\n        fn main() = _0::clearArray(\"[]int\").len - 3;\n    "_fu };
                                #endif

                                #ifndef STR_9EjaCjlFse6
                                #define STR_9EjaCjlFse6
static const fu::str str_9EjaCjlFse6 fu_INIT_PRIORITY(1015) { "\n        fn Arr(type V) struct { items: V[] };\n        fn append !V(\n            using ref _:    <fail ARR is not defined 5:17+3>\n                ARR(V),     <pass/>\n                Arr(V),     </fail>\n            item: V) items ~= item;\n    "_fu };
                                #endif

                                #ifndef STR_m3hvBHEwNh5
                                #define STR_m3hvBHEwNh5
static const fu::str str_m3hvBHEwNh5 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut arr: _0::Arr(i32);\n            return arr.append(0).len - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_yHH7hwIrBr7
                                #define STR_yHH7hwIrBr7
static const fu::str str_yHH7hwIrBr7 fu_INIT_PRIORITY(1015) { "\n        <fail not defined 3:34+10><pass/>\n        pub</fail>\n        fn not_public(x: i32) x * 2;\n        pub fn public(x: i32) x * 3;\n    "_fu };
                                #endif

                                #ifndef STR_9kRCAYXn2X7
                                #define STR_9kRCAYXn2X7
static const fu::str str_9kRCAYXn2X7 fu_INIT_PRIORITY(1015) { "\n        fn test(x, apply) apply(x);\n        fn main() test(5, fn _0::not_public) - 10;\n    "_fu };
                                #endif

                                #ifndef STR_BQIscLichHf
                                #define STR_BQIscLichHf
static const fu::str str_BQIscLichHf fu_INIT_PRIORITY(1015) { "\n        nocopy struct Target    { x: i32 }\n        nocopy struct Overload  { x: i32 };\n        nocopy struct Scope     { overloads: Overload[]; implicits: ScopeItem[] };\n\n        nocopy struct ScopeItem {\n            <fail Bad call globid expects Target got ScopeItem :50+6><pass/>\n            using </fail>\n            target: Target;\n        };\n\n        inline fn globid(.x: i32) x;\n\n        <split/>\n        fn Scope_exports(using implicit scope: Scope) {\n            for (mut i = 0; i < implicits.len; i++) {\n                let item        = implicits[i];\n                let overload    = overloads[item.globid - 1];   ;; PointlessLocal\n                if (overload) return overload.x;\n            }\n\n            return 0;\n        }\n\n        <split/>\n        fn main() {\n            implicit mut scope = Scope(overloads: [ Overload(3) ], implicits: [ ScopeItem(Target(1)) ]);\n            return Scope_exports() - 3;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_NEwm7SyHQc2
                                #define STR_NEwm7SyHQc2
static const fu::str str_NEwm7SyHQc2 fu_INIT_PRIORITY(1015) { "\n        struct List(type T) { data: T[] }\n    "_fu };
                                #endif

                                #ifndef STR_1zJQMKRdeOj
                                #define STR_1zJQMKRdeOj
static const fu::str str_1zJQMKRdeOj fu_INIT_PRIORITY(1015) { "\n        pub import _0;\n    "_fu };
                                #endif

                                #ifndef STR_NxN8rdNPZVf
                                #define STR_NxN8rdNPZVf
static const fu::str str_NxN8rdNPZVf fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut list: _1::List(i32);\n            return list.data.len;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_aUyJC6QlRV0
                                #define STR_aUyJC6QlRV0
static const fu::str str_aUyJC6QlRV0 fu_INIT_PRIORITY(1015) { "List is not defined 3:27+4"_fu };
                                #endif

                                #ifndef STR_orGAHn2iVe7
                                #define STR_orGAHn2iVe7
static const fu::str str_orGAHn2iVe7 fu_INIT_PRIORITY(1015) { "//file flat/List.fu\n        struct List(type T) { data: T[] }\n    "_fu };
                                #endif

                                #ifndef STR_utlV5PYCIh9
                                #define STR_utlV5PYCIh9
static const fu::str str_utlV5PYCIh9 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut list: flat::List(i32);\n            return list.data.len;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_ry5n7dmgD78
                                #define STR_ry5n7dmgD78
static const fu::str str_ry5n7dmgD78 fu_INIT_PRIORITY(1015) { "//file markdown/markdown.fu\n        struct Document { value: int };\n    "_fu };
                                #endif

                                #ifndef STR_ssMHfG1JwYe
                                #define STR_ssMHfG1JwYe
static const fu::str str_ssMHfG1JwYe fu_INIT_PRIORITY(1015) { "\n        fn main() markdown::Document().value;\n    "_fu };
                                #endif

                                #ifndef STR_TiUjQBn72C9
                                #define STR_TiUjQBn72C9
static const fu::str str_TiUjQBn72C9 fu_INIT_PRIORITY(1015) { "\n        struct Batch { x: i32[]; y: i32[] };\n        <split/>\n        type ViewQuads = Batch;\n        <split/>\n        let VIEW_QUADS: ViewQuads = [];\n        <split/>\n        fn main() VIEW_QUADS.x.len + VIEW_QUADS.y.len;\n    "_fu };
                                #endif

                                #ifndef STR_6cQGu65vWT8
                                #define STR_6cQGu65vWT8
static const fu::str str_6cQGu65vWT8 fu_INIT_PRIORITY(1015) { "\n        primitive MyPrim: int;\n        fn addback !T(ref a: T, ref b: MyPrim, which = .a) {\n            a.which += b;\n            b += a.which;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_qOzsKukbJ81
                                #define STR_qOzsKukbJ81
static const fu::str str_qOzsKukbJ81 fu_INIT_PRIORITY(1015) { "\n        <alt>\n        struct TwoMyPrims { a: _0::MyPrim; b: _0::MyPrim };\n        <alt/>\n        import _0;\n        struct TwoMyPrims { a: MyPrim; b: MyPrim };\n        </alt>\n        fn main() {\n            mut a = TwoMyPrims(1, 3);\n            a.b.addback(:a);\n            return i32(a.a + a.b) - 11;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Po0tEhVEwac
                                #define STR_Po0tEhVEwac
static const fu::str str_Po0tEhVEwac fu_INIT_PRIORITY(1015) { "\n        primitive A: int;\n        primitive B: int;\n        fn process(v: A or B, what) what(v);\n    "_fu };
                                #endif

                                #ifndef STR_xrxY9LuW8gi
                                #define STR_xrxY9LuW8gi
static const fu::str str_xrxY9LuW8gi fu_INIT_PRIORITY(1015) { "\n        <alt>\n        fn three() _0::A(3);\n        <alt/>\n        import _0;\n        fn three() A(3);\n        </alt>\n\n        fn main() three.process(|v| v * 2).int - 6;\n    "_fu };
                                #endif

                                #ifndef STR_nJn4P6sZVJc
                                #define STR_nJn4P6sZVJc
static const fu::str str_nJn4P6sZVJc fu_INIT_PRIORITY(1015) { "\n        let HELLO = 0;\n    "_fu };
                                #endif

                                #ifndef STR_g5EjgNlm809
                                #define STR_g5EjgNlm809
static const fu::str str_g5EjgNlm809 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            <fail HELO 4:24+4 not defined>\n            return _0::HELO;                <pass/>\n            return _0::HELLO;               </fail>\n        }\n    "_fu };
                                #endif

                                #ifndef STR_iw1o0gTr0Ec
                                #define STR_iw1o0gTr0Ec
static const fu::str str_iw1o0gTr0Ec fu_INIT_PRIORITY(1015) { "//file a.fu\n        let v = 7;\n    "_fu };
                                #endif

                                #ifndef STR_qUxrdhFEqF9
                                #define STR_qUxrdhFEqF9
static const fu::str str_qUxrdhFEqF9 fu_INIT_PRIORITY(1015) { "//file <fail creates confusion case insensitive file systems>A.fu<pass/>B.fu</fail>\n        let v = 19;\n    "_fu };
                                #endif

                                #ifndef STR_qeyoTT0Q744
                                #define STR_qeyoTT0Q744
static const fu::str str_qeyoTT0Q744 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            let c = a::v + B::v;\n            return c - 26;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_tcIWyRRBH5k
                                #define STR_tcIWyRRBH5k
static const fu::str str_tcIWyRRBH5k fu_INIT_PRIORITY(1015) { "\n        struct Hey(type T) { world: T };\n    "_fu };
                                #endif

                                #ifndef STR_Rhq9oSD2JP5
                                #define STR_Rhq9oSD2JP5
static const fu::str str_Rhq9oSD2JP5 fu_INIT_PRIORITY(1015) { "\n        type Hello = _0::Hey(int);\n    "_fu };
                                #endif

                                #ifndef STR_Gz4pyGnEVah
                                #define STR_Gz4pyGnEVah
static const fu::str str_Gz4pyGnEVah fu_INIT_PRIORITY(1015) { "\n        fn main() _1::Hello.world;\n    "_fu };
                                #endif

                                #ifndef STR_NYKq3KTyI31
                                #define STR_NYKq3KTyI31
static const fu::str str_NYKq3KTyI31 fu_INIT_PRIORITY(1015) { "\n        let a = 1;\n        shadow let a = a + 1;\n        return a - 2;\n    "_fu };
                                #endif

                                #ifndef STR_MxkaOnPFMJ9
                                #define STR_MxkaOnPFMJ9
static const fu::str str_MxkaOnPFMJ9 fu_INIT_PRIORITY(1015) { "\n        inline fn outer() inner(); // <- this reset root-scope\n        inline fn inner() {\n            // <- so main::i was visible here\n            for (mut i = 0; i < 10; i++) return i;\n            return 1;\n        }\n        fn main() {\n            for (mut i = 0; i < 10; i++) return outer();\n            return 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_51pRuFwLg23
                                #define STR_51pRuFwLg23
static const fu::str str_51pRuFwLg23 fu_INIT_PRIORITY(1015) { "\n        pub struct Target { modid: i32; packed: u32; };\n\n        pub fn index(t: Target) i32(t.packed & 0x7fffffff);\n\n        pub fn local_eq(t: Target, index: i32, implicit modid: i32)\n            modid - t.modid || index - t.index;\n\n        fn main() {\n            let implicit modid = 1;\n            return local_eq(Target(1, 0x80000002), 7) - 5;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_rdTjuqBCcIk
                                #define STR_rdTjuqBCcIk
static const fu::str str_rdTjuqBCcIk fu_INIT_PRIORITY(1015) { "\n        nocopy struct P { secs: P[] };\n\n        fn matchImplicitArgByName_closuresAndShadowing(prims: P[]) {\n            struct Helper { idx: i32; };\n\n            using fn GET(using _: Helper) prims[idx];\n\n            shadow mut prims = {\n                mut res: Helper[];\n                for (mut i = 0; i < prims.len; i++)\n                    res ~= Helper(i);                           ;; ConstCast\n                res                                             ;; GNUStmtExpr\n            };\n\n            prims.sort(|a, b| a.secs.len < b.secs.len);\n\n            mut res = 101;\n            for (mut i = 0; i < prims.len; i++) {\n                let m = prims[i];\n                res += m.secs.len;\n                res *= m.secs.len;\n            }\n\n            return res;\n        }\n\n        fn main() {\n            let prims = [ P([ P, P, P ]), P, P([ P ]), P([ P, P ]) ];\n            let res = matchImplicitArgByName_closuresAndShadowing(prims);\n            return res == 27 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_7H5lmgRZG68
                                #define STR_7H5lmgRZG68
static const fu::str str_7H5lmgRZG68 fu_INIT_PRIORITY(1015) { "\n        fn hello(x: int) = x * 10;\n        fn originalHello(x: int) = x.hello;\n\n        shadow fn hello(x: int) = x * 100;\n        fn shadowedHello(x: int) = x.hello;\n\n        <fail shadowing only supported inside functions 5:16+2>\n        fn main() = <pass/>\n        return      </fail> 1.originalHello + 2.shadowedHello == 210 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_59LsNTlTOmd
                                #define STR_59LsNTlTOmd
static const fu::str str_59LsNTlTOmd fu_INIT_PRIORITY(1015) { "\n        struct Hello { hello: int };\n        fn what(using ref <fail ambig hello hello using 5:16+5 4:27+5 2:24+5>\n                          hello     <pass/>\n                          _         </fail><alt>: Hello</alt>, fn)\n            fn(hello);\n\n        fn main() {\n            mut hello: Hello;\n            return hello.what(|v| v);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_DsRh5yawTT0
                                #define STR_DsRh5yawTT0
static const fu::str str_DsRh5yawTT0 fu_INIT_PRIORITY(1015) { "main: return type i32, got Hello 9:13+6"_fu };
                                #endif

                                #ifndef STR_xOzAypluxK1
                                #define STR_xOzAypluxK1
static const fu::str str_xOzAypluxK1 fu_INIT_PRIORITY(1015) { "\n        struct RawSet { ints: int[] };\n        fn each(using ref _: RawSet, fn) ints.each: fn fn;\n\n        struct LocidSet { raw_set: RawSet };\n        fn each(using ref <fail ambig call raw_set field using 9:13+7 7:27+7 5:27+7>\n                          raw_set       <pass/>\n                                _       </fail> : LocidSet, offset: int, fn)\n        {\n            raw_set.each: |item| fn(item + offset);\n        }\n\n        fn sum(using ref ls: LocidSet, offset: int) {\n            mut sum = 0;\n            ls.each(:offset): |item| sum += item;\n            return sum;\n        }\n\n        fn main() {\n            mut ls = LocidSet(RawSet([ 1, 2, 3 ]));\n            mut sum = ls.sum(10);\n            return sum - 36;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_0IANEn52Qjj
                                #define STR_0IANEn52Qjj
static const fu::str str_0IANEn52Qjj fu_INIT_PRIORITY(1015) { "Bad call to each LocidSet 9:21+4"_fu };
                                #endif

                                #ifndef STR_8TdSZ3fFMX5
                                #define STR_8TdSZ3fFMX5
static const fu::str str_8TdSZ3fFMX5 fu_INIT_PRIORITY(1015) { "\n        struct HasInt { i: i32; };\n\n        fn test(s: HasInt): &i32 {\n            let i = s.i;\n            return i;\n        }\n\n        fn main() HasInt(-1).test + 1;\n    "_fu };
                                #endif

                                #ifndef STR_aEVb6C1NyT6
                                #define STR_aEVb6C1NyT6
static const fu::str str_aEVb6C1NyT6 fu_INIT_PRIORITY(1015) { "\n        fn test(x: i32): &i32 = x;\n        fn main() test(3) - 3;\n    "_fu };
                                #endif

                                #ifndef STR_r6QEXSFdC1b
                                #define STR_r6QEXSFdC1b
static const fu::str str_r6QEXSFdC1b fu_INIT_PRIORITY(1015) { "\n        fn test(x: i32): &i32 {\n            fn inner() x;\n            return inner;\n        }\n\n        fn main() test(3) - 3;\n    "_fu };
                                #endif

                                #ifndef STR_LpPry8a1bCi
                                #define STR_LpPry8a1bCi
static const fu::str str_LpPry8a1bCi fu_INIT_PRIORITY(1015) { "\n        struct I { v: i32; };\n\n        fn test(x: I): &i32 {\n            fn inner() x.v;\n            return inner;\n        }\n\n        fn main() test(I(3)) - 3;\n    "_fu };
                                #endif

                                #ifndef STR_UGJbvoA1DMb
                                #define STR_UGJbvoA1DMb
static const fu::str str_UGJbvoA1DMb fu_INIT_PRIORITY(1015) { "\n        struct I { v: i32[]; };\n\n        fn test(x: I): &i32 {\n            fn inner() x.v[0];\n            return inner;\n        }\n\n        fn main() test(I([3])) - 3;\n    "_fu };
                                #endif

                                #ifndef STR_6bcH6aDI6Qb
                                #define STR_6bcH6aDI6Qb
static const fu::str str_6bcH6aDI6Qb fu_INIT_PRIORITY(1015) { "\n        struct I { v: i32[]; };\n\n        fn test(x: I): &i32 {\n            fn inner() {\n                let v = x.v;\n                return v[0];\n            }\n\n            return inner;\n        }\n\n        fn main() test(I([3])) - 3;\n    "_fu };
                                #endif

                                #ifndef STR_KZnKlHz7uNa
                                #define STR_KZnKlHz7uNa
static const fu::str str_KZnKlHz7uNa fu_INIT_PRIORITY(1015) { "\n        fn noReturn() throw (\"ex\");\n\n        fn doesReturn(a: i32) {\n            if (a > 0) return noReturn();\n            return a;\n        }\n\n        fn main() doesReturn(-3) + 3;\n    "_fu };
                                #endif

                                #ifndef STR_J1e7WB3z7S2
                                #define STR_J1e7WB3z7S2
static const fu::str str_J1e7WB3z7S2 fu_INIT_PRIORITY(1015) { "\n        struct Context { modules: Module[]; };\n        struct Module  { fname: i32; };\n\n        fn test(implicit ctx: Context) {\n            fn findModule(fname: i32): &Module {\n                let modules = ctx.modules;\n                for (mut i = 0; i < modules.len; i++) {\n                    let module = modules[i];\n                    if (module.fname == fname)\n                        return module;\n                }\n\n                throw(\"Cannot locate: \" ~ fname);\n            }\n\n            return findModule(0);\n        }\n\n        fn main() {\n            let implicit ctx = Context([ Module ]);\n            return test.fname;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_OqTRFg5CCu1
                                #define STR_OqTRFg5CCu1
static const fu::str str_OqTRFg5CCu1 fu_INIT_PRIORITY(1015) { "\n        fn noReturn() throw (\"ex\");\n\n        fn returnVoid(a: i32): void {\n            if (a > 0) return noReturn();\n        }\n\n        fn main() {\n            returnVoid(0);\n            return 0;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_wjcjLstruQ6
                                #define STR_wjcjLstruQ6
static const fu::str str_wjcjLstruQ6 fu_INIT_PRIORITY(1015) { "\n        fn parseQualifierChain(mut i: i32): i32 {\n            for (;;) {\n                if !(i & 15) return i;\n                i--;\n            }\n        }\n\n        fn main() parseQualifierChain(15);\n    "_fu };
                                #endif

                                #ifndef STR_965Djp2jmze
                                #define STR_965Djp2jmze
static const fu::str str_965Djp2jmze fu_INIT_PRIORITY(1015) { "\n        fn main()\n        {\n            mut sum = 0;\n            fn compile(x: i32)\n            {\n                // 1. this throw contributed a 'never' ret_count.\n                x || throw (\"x=0\");\n                if (x & 1) compile(x + 1); // 2. then this recursion did something.\n                sum += x; // <- also this must be a closure.\n                // 3. finally no ret_actual but non-zero ret_count.\n            }\n\n            compile(2);\n            return sum - 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_kAvUwpx3VZ3
                                #define STR_kAvUwpx3VZ3
static const fu::str str_kAvUwpx3VZ3 fu_INIT_PRIORITY(1015) { "\n        fn main()\n        {\n            mut sum = 0;\n            fn getModule(fname: string) fname.len;\n            fn compile(fname: string, via: string = \"\")\n            {\n                let module = getModule(fname) || throw (\"import circle: '\" ~ via ~ fname ~ \"'.\");\n                if (module & 1) {\n                    let fuzimports = fname.split(\"a\");\n                    for (mut i = 0; i < fuzimports.len; i++)\n                        compile(\n                            fname: fuzimports[i],\n                              via: fname ~ \" <- \" ~ via);\n                }\n\n                sum += module;\n            }\n\n            compile(\"ab\");\n            return sum - 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_7zBz5AuSUD1
                                #define STR_7zBz5AuSUD1
static const fu::str str_7zBz5AuSUD1 fu_INIT_PRIORITY(1015) { "\n        fn A(implicit _A: i32[]) _A;\n        fn B(implicit _B:  u8[]) _B;\n\n        fn AB(x: i32) A[x] - B[x].i32;\n        fn BA(x: i32) B[x].i32 - A[x];\n\n        fn cycleA_inner(x: i32)\n            x & 1   ? either(x + 1) + AB(x)\n                    : BA(x);\n\n        fn cycleA_outer(x: i32)\n            x & 1   ? cycleA_inner(x + 1) + AB(x)\n                    : BA(x);\n\n        fn cycleB_inner(x: i32)\n            x & 2   ? either(x + 1) + BA(x)\n                    : AB(x);\n\n        fn cycleB_outer(x: i32)\n            x & 2   ? cycleB_inner(x + 1) + BA(x)\n                    : AB(x);\n\n        fn either(x: i32)\n            x & 4   ? cycleA_outer(x)\n                    : cycleB_outer(x);\n\n        fn main() {\n            let implicit _A = [ 0,    1,    2    ];\n            let implicit _B = [ 0.u8, 1.u8, 2.u8 ];\n\n            return either(0);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_N9NiLXXujp2
                                #define STR_N9NiLXXujp2
static const fu::str str_N9NiLXXujp2 fu_INIT_PRIORITY(1015) { "\n        fn if0_ret101(x: i32) {\n            if      (x > 2) return x * 2;\n            else if (x > 1) return x + 1; // <- left branch seeded right with never\n            return x + 101;\n        }\n\n        fn main() 0.if0_ret101 - 101;\n    "_fu };
                                #endif

                                #ifndef STR_hgepVrB6JQ7
                                #define STR_hgepVrB6JQ7
static const fu::str str_hgepVrB6JQ7 fu_INIT_PRIORITY(1015) { "\n        fn hello(x: i32) {\n            if (x & 1)\n                return x * 2;\n\n            <fail hello is missing a final return statement 7:13+1>\n            x;            <pass/>\n            return x;     </fail>\n        }\n\n        fn main() 0.hello;\n    "_fu };
                                #endif

                                #ifndef STR_Bbtsr3VOFce
                                #define STR_Bbtsr3VOFce
static const fu::str str_Bbtsr3VOFce fu_INIT_PRIORITY(1015) { "\n        fn throws()         { throw(\"WHAT!\");   }\n        fn myfn(a = throws) { return a;         } // never in default argument position!\n        fn main() {\n            try             { return myfn();                }\n            catch (e)       { return e == \"WHAT!\" ? 0 : 1;  }\n        }\n    "_fu };
                                #endif

                                #ifndef STR_zGI50AXK3m1
                                #define STR_zGI50AXK3m1
static const fu::str str_zGI50AXK3m1 fu_INIT_PRIORITY(1015) { "\n        fn printus(parts: string[], implicit ref out: i32)\n            parts.each(|part| part.each(|c| out += c.i32 ));\n\n        <alt>\n        inline  <alt/>\n        lax     </alt>\n        fn silent(lax parts) {}\n\n        fn main() {\n            implicit mut out: i32;\n\n            printus([ \"Hel\",\"lo\" ]);\n            if (out != 500)\n                return 1;\n\n            // Tries to test dead array literals.\n            shadow let printus = fn silent;\n\n            printus([ \"Hel\",\"lo\" ]);\n            return out == 500 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_0Lg3nCAFG53
                                #define STR_0Lg3nCAFG53
static const fu::str str_0Lg3nCAFG53 fu_INIT_PRIORITY(1015) { "\n        fn test() [] => i32;\n        fn main() test;\n    "_fu };
                                #endif

                                #ifndef STR_kXSKYvoo7o9
                                #define STR_kXSKYvoo7o9
static const fu::str str_kXSKYvoo7o9 fu_INIT_PRIORITY(1015) { "\n        fn main() {                                             ;; !DEV_DontFoldLiterals\n            <alt>\n            if (true) return 0;     <alt/>\n            if (!false) return 0;   <alt/>\n            if !(false) return 0;   </alt>\n            DOESNT_EXIST();\n        }\n    "_fu };
                                #endif

                                #ifndef STR_LeHODRpX4ik
                                #define STR_LeHODRpX4ik
static const fu::str str_LeHODRpX4ik fu_INIT_PRIORITY(1015) { "\n        fn test(a) {\n            if (typeof(a) -> _[..])\n                return a.len;\n\n            return a * 10;\n        }\n\n        fn main() {\n            let A = [ 0, 1 ].test;\n            let B = 4.test;\n            return A + B == 42 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_YD0dq3TXXfe
                                #define STR_YD0dq3TXXfe
static const fu::str str_YD0dq3TXXfe fu_INIT_PRIORITY(1015) { "\n        fn staticIfSymmetry(\n            <fail $T is not defined>\n            ref a: $U[], b)  <pass/>\n            ref a: $T[], b)  </fail>\n        {\n            let N = typeof(b) ->  $T   ? 1 : 2;\n            let M = typeof(b) -> $T[..] ? 2 : 1;\n            a ~= b;\n            return N == M ? 0 : 1;\n        }\n\n        fn main() {\n            mut arr = [ 0 ];\n            return staticIfSymmetry(arr, 0)\n                 + staticIfSymmetry(arr, [ 0, 0 ])\n                 + arr.len * 10 - 40;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_2LETc9YWv3e
                                #define STR_2LETc9YWv3e
static const fu::str str_2LETc9YWv3e fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            let a: <fail bad call unsigned 4:23+8>f32<pass/>i32</fail> = 1;\n            let b = a.unsigned;\n            let c = a.signed;\n            if (typeof(a) -> u32) return 1;\n            if (typeof(a) -> i32) {\n                if (typeof(b) -> i32) return 2;\n                if (typeof(b) -> u32) {\n                    if (typeof(c) -> i32) {\n                        if (typeof(0.i8.unsigned)   -> u8  &&\n                            typeof(0.i16.unsigned)  -> u16 &&\n                            typeof(0.i32.unsigned)  -> u32 &&\n                            typeof(0.i64.unsigned)  -> u64 &&\n                            typeof(0.i128.unsigned) -> u128)\n                        {\n                            return 0;\n                        }\n                        return 3;\n                    }\n                    return 4;\n                }\n            }\n            return 5;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_KqnyGOzrvi5
                                #define STR_KqnyGOzrvi5
static const fu::str str_KqnyGOzrvi5 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            let a: <fail bad call signed 4:23+6>f64<pass/>u64</fail> = 1;\n            let b = a.signed;\n            let c = a.unsigned;\n            if (typeof(a) -> i64) return 1;\n            if (typeof(a) -> u64) {\n                if (typeof(b) -> u64) return 2;\n                if (typeof(b) -> i64) {\n                    if (typeof(c) -> u64) {\n                        if (typeof(0.u8.signed)   -> i8  &&\n                            typeof(0.u16.signed)  -> i16 &&\n                            typeof(0.u32.signed)  -> i32 &&\n                            typeof(0.u64.signed)  -> i64 &&\n                            typeof(0.u128.signed) -> i128)\n                        {\n                            return 0;\n                        }\n                        return 3;\n                    }\n                    return 4;\n                }\n            }\n            return 5;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_lOOoVF4iBFa
                                #define STR_lOOoVF4iBFa
static const fu::str str_lOOoVF4iBFa fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut a = 1;\n            mut b = 0;\n            {\n                defer a++;\n                b = a;\n            }\n            return (b+1) - a;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_HxpoQbU6JVf
                                #define STR_HxpoQbU6JVf
static const fu::str str_HxpoQbU6JVf fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut a = 1;\n            mut b = 0;\n            mut c = 0;\n            {\n                defer a++;\n                defer c = a;\n                b = a;\n            }\n            return (b*27) - (a*11 + c*5);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_HpBDbktYVC7
                                #define STR_HpBDbktYVC7
static const fu::str str_HpBDbktYVC7 fu_INIT_PRIORITY(1015) { "\n        fn test_defer_if_errok(throw_err: bool) {\n            mut x      = 1;\n            mut if_err = 0;\n            mut if_ok  = 0;\n            try {\n                defer x++;\n                defer:err if_err += x;\n                defer:ok  if_ok  += x;\n\n                if (throw_err)\n                    throw(\"len=5\");\n\n                x += 8; // 9 defer++ = 10\n            }\n            catch (e) {\n                x += e.len; // 6 defer++ = 7\n            }\n\n            return x * 3 + if_err * 5 + if_ok * 7;\n        }\n\n        fn main()   (test_defer_if_errok(true)  - 7 *3 - 1*5 - 0*7)\n            + 100 * (test_defer_if_errok(false) - 10*3 - 0*5 - 9*7);\n    "_fu };
                                #endif

                                #ifndef STR_fIdYTyYre6l
                                #define STR_fIdYTyYre6l
static const fu::str str_fIdYTyYre6l fu_INIT_PRIORITY(1015) { "\n        fn test(ref x: i32) {\n            x++;\n            <alt>\n            defer x++;      <alt/>\n            defer:ok x++;   </alt>\n        }\n\n        fn main() {\n            mut x = 0;\n            test(x);\n            return x == 2 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_eQZohJM4zYh
                                #define STR_eQZohJM4zYh
static const fu::str str_eQZohJM4zYh fu_INIT_PRIORITY(1015) { "\n        fn test(ref x: i32) {\n            <fail missing final return 8:13+5>\n            if (x & 1)              // ------ currently highlights the defer\n                return x;           //         probably should highlight the semicollon\n            <pass/></fail>\n            x++;\n            defer:err x++;\n        }\n\n        fn main() {\n            mut x = 0;\n            test(x);\n            return x == 1 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_PxneohOK78c
                                #define STR_PxneohOK78c
static const fu::str str_PxneohOK78c fu_INIT_PRIORITY(1015) { "\n        fn sum_amulb(a: i32[], b: i32[], ref sum: i32)\n            for (mut i = 0; i < a.len; i++)\n                sum += a[i] * b[i];\n\n        fn incrarr_by1(ref a: i32[])\n            for (mut i = 0; i < a.len; i++)\n                a[i] += 1;\n\n        fn test(ref a: i32[], ref sum: i32) {\n            let b = a;\n            defer sum_amulb(:a, :b, :sum);\n\n            <alt>\n            for (mut i = 0; i < a.len; i++) a[i] += 1;\n            return a[0] - 2;\n            <alt/>\n            defer for (mut i = 0; i < a.len; i++) a[i] += 1;\n            return a[0] - 1;\n            <alt/>\n            incrarr_by1(:a);\n            return a[0] - 2;\n            <alt/>\n            defer incrarr_by1(:a);\n            return a[0] - 1;\n            </alt>\n        }\n\n        fn main() {\n            mut a = [ 1 ];\n            mut sum = 0;\n            let ret = 100 * test(:a, :sum);\n            return sum - 2 + ret;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_glrSoAjAQTh
                                #define STR_glrSoAjAQTh
static const fu::str str_glrSoAjAQTh fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut res = 1;            // single statement blocks unwrap\n            { defer res--; }        //  fix by unwraping tailing defers\n            return res;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Uj6PtU4Lr9f
                                #define STR_Uj6PtU4Lr9f
static const fu::str str_Uj6PtU4Lr9f fu_INIT_PRIORITY(1015) { "\n        fn unwraps_defer(ref x: i32) unwrap {\n            defer x++;\n        }\n\n        fn main() {\n            mut y = 0;\n            { unwraps_defer(y); }\n            mut x = 0;\n            unwraps_defer(x);\n            return y == 1 && x == 0 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_SCvgbUC1dj4
                                #define STR_SCvgbUC1dj4
static const fu::str str_SCvgbUC1dj4 fu_INIT_PRIORITY(1015) { "\n        type Test = i8;\n        fn main() 256.Test.i32;\n    "_fu };
                                #endif

                                #ifndef STR_rZ4VFfeFKz9
                                #define STR_rZ4VFfeFKz9
static const fu::str str_rZ4VFfeFKz9 fu_INIT_PRIORITY(1015) { "\n        fn test(a: $A, b: $B) b +   <fail bad call + i32 i8 2:33+1>\n            a;                      <pass/>\n            $B(a);                  </fail>\n\n        fn main() i8(-1).test(+1);\n    "_fu };
                                #endif

                                #ifndef STR_bRzLoN1XF33
                                #define STR_bRzLoN1XF33
static const fu::str str_bRzLoN1XF33 fu_INIT_PRIORITY(1015) { "\n        struct Test { v: u32 };\n        fn test(v   <fail bad call type Test expect u32 got i32 5:23+1 2:9+6>\n                        <pass/>\n                 : u32  </fail>\n            ): Test = [ v ];\n\n        fn main() test(2).v == 2 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_5z2hl7J3wo4
                                #define STR_5z2hl7J3wo4
static const fu::str str_5z2hl7J3wo4 fu_INIT_PRIORITY(1015) { "\n        let x = { mut z = 0; z++; z };\n        return x - 1;\n    "_fu };
                                #endif

                                #ifndef STR_wF6g1ZBJw63
                                #define STR_wF6g1ZBJw63
static const fu::str str_wF6g1ZBJw63 fu_INIT_PRIORITY(1015) { "\n        fn mul2(a) a*2;\n        fn test(b, fn) fn(1 + fn(b));\n        fn main() 14 - test(3, fn mul2);\n    "_fu };
                                #endif

                                #ifndef STR_6yPJFahwrK8
                                #define STR_6yPJFahwrK8
static const fu::str str_6yPJFahwrK8 fu_INIT_PRIORITY(1015) { "\n        let overloaded = 1;\n        fn overloaded(a) a*2;\n        fn test(b, fn) fn(fn + fn(b));\n        fn main() 14 - test(3, fn overloaded);\n    "_fu };
                                #endif

                                #ifndef STR_ui5zqCRSoFd
                                #define STR_ui5zqCRSoFd
static const fu::str str_ui5zqCRSoFd fu_INIT_PRIORITY(1015) { "\n        fn overloaded(a) a*2;\n        fn test(b, fn) fn(fn + fn(b));\n        fn main() {\n            let overloaded = 1;\n            return 14 - test(3, fn overloaded);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_YUTmqvzQpQl
                                #define STR_YUTmqvzQpQl
static const fu::str str_YUTmqvzQpQl fu_INIT_PRIORITY(1015) { "\n        fn MAP(items: $T[], fn) {\n            mut result: typeof( fn(items[0]) )[];\n            for (mut i = 0; i < items.len; i++)\n                result.push(fn(items[i]));\n\n            return result;\n        }\n\n        fn sqr(x) x*x;\n\n        fn main() [2].MAP(fn sqr)[0] - 4;\n\n        ;; EXPECT fu::view<int> {{ 2 }}\n        //  During the propagateType rework\n        //   the 'mut result: fn(items[0])[]' type annot\n        //    was found listed as a callsite for items,\n        //     but wasn't reachable for relax.\n    "_fu };
                                #endif

                                #ifndef STR_BvvXIxYUvAe
                                #define STR_BvvXIxYUvAe
static const fu::str str_BvvXIxYUvAe fu_INIT_PRIORITY(1015) { "\n        fn reduce(items: $T[], fn, init?: $T) {\n            mut result = init;\n            for (mut i = 0; i < items.len; i++)\n                result = fn(result, items[i]);\n\n            return result;\n        }\n\n        fn main() [1, 2].reduce(|a, b| a + b) - 3;\n    "_fu };
                                #endif

                                #ifndef STR_8qqoyU6hP7l
                                #define STR_8qqoyU6hP7l
static const fu::str str_8qqoyU6hP7l fu_INIT_PRIORITY(1015) { "\n        fn Each(items: $T[], fn) {\n            for (mut i = 0; i < items.len; i++) // <- one i\n                fn(items[i]);\n        }\n\n        fn main() {\n            mut i = 0;                  // <- another i, i got them to shadow each other\n            [1, 2].Each: |x| i += x;    //      in the everything-a-free-function\n            return i - 3;               //      impl of closures\n        }\n    "_fu };
                                #endif

                                #ifndef STR_9xKp5y8oyr0
                                #define STR_9xKp5y8oyr0
static const fu::str str_9xKp5y8oyr0 fu_INIT_PRIORITY(1015) { "\n        mut sum = 2;\n\n        fn FnDecl_update(parent_idx: i32) {\n            fn Each(fn) fn();\n            Each(|| makeDirty(:parent_idx));\n        }\n\n        fn makeDirty(parent_idx: i32): void {\n            sum += parent_idx;\n        }\n\n        FnDecl_update(1);\n\n        return sum - 3;\n    "_fu };
                                #endif

                                #ifndef STR_pXROE67H9lj
                                #define STR_pXROE67H9lj
static const fu::str str_pXROE67H9lj fu_INIT_PRIORITY(1015) { "\n        // something complains about no final return\n        fn main() {\n            let addret = |a: i32, b: i32| {\n                return a + b;\n            };\n\n            let hey = |x: i32| {\n                if !(x & 1)\n                    return x;\n\n                // this complains about indentation\n                <alt>\n                continue \"\".len                                 ;; GNUStmtExpr\n                <alt/>\n                \"\".len                                          ;; GNUStmtExpr\n                <alt/>\n                \"\".len.addret(x)\n                </alt>\n            };\n\n            // and this complains about no match for *(void, void)\n            return hey(0) * hey(1);\n        }\n\n        // misfired during the removal of maybeCopyOrMove(isReturn)\n        ;; !*MustSeq\n    "_fu };
                                #endif

                                #ifndef STR_cBHRC4wQWka
                                #define STR_cBHRC4wQWka
static const fu::str str_cBHRC4wQWka fu_INIT_PRIORITY(1015) { "\n        // something complains about no final return\n        fn main() {\n            let hey = |x: i32| {\n                if !(x & 1)\n                    return x;                                   ;; GNUStmtExpr\n\n                \"\".len + x\n            };\n\n            // and this complains about no match for *(void, void)\n            return hey(1) * hey(0);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_3fRZV7hf9Qh
                                #define STR_3fRZV7hf9Qh
static const fu::str str_3fRZV7hf9Qh fu_INIT_PRIORITY(1015) { "\n        fn check(a, b, compare! = infix fn <>)\n            compare(a, b);\n\n        fn main() check(0, 0);\n    "_fu };
                                #endif

                                #ifndef STR_Q5DJe6XL7zc
                                #define STR_Q5DJe6XL7zc
static const fu::str str_Q5DJe6XL7zc fu_INIT_PRIORITY(1015) { "\n        fn check(a, b, compare! = |aa, bb| aa <> bb)\n            compare(a, b);\n\n        fn main() check(0, 0);\n    "_fu };
                                #endif

                                #ifndef STR_PLEGjIwX4Vl
                                #define STR_PLEGjIwX4Vl
static const fu::str str_PLEGjIwX4Vl fu_INIT_PRIORITY(1015) { "\n        fn Find !<T>(ref arr: T[], needle: T, visit) {\n            for (mut i = 0; i < arr.len; i++) {\n                ref item = arr[i];\n                if (item == needle) {\n                    visit(i?: i, remove?: |ret = true| {\n                        arr.splice(i, 1);\n                        return ret;\n                    });\n                    return true;\n                }\n            }\n            return [];\n        }\n\n        fn main() {\n            mut arr = [1, 2, 3, 4];\n            let x = arr.Find(2, |i, remove!| remove(i));\n            return x - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_OVU2LMEFkhh
                                #define STR_OVU2LMEFkhh
static const fu::str str_OVU2LMEFkhh fu_INIT_PRIORITY(1015) { "\n        fn Hello(ref str) str ~= \"Hello, \";\n        fn World(ref str) str ~= \"World!\";\n\n        struct addrofns {\n            hello: typeof(fn Hello);\n            world: typeof(fn World);\n        };\n\n        fn main() {\n            mut str = \"\";\n            mut fns = addrofns();\n            for (fieldname i: addrofns) (fns.i)(str);\n            return str == \"Hello, World!\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_s2j1ZcjYdfd
                                #define STR_s2j1ZcjYdfd
static const fu::str str_s2j1ZcjYdfd fu_INIT_PRIORITY(1015) { "\n        fn non_void_ret(fn) {\n            return fn();\n        }\n\n        fn void_ret(fn): void {\n            non_void_ret: || fn();  // statement-mode semi should discard retval\n        }\n\n        fn main() {\n            mut v = 3;\n            void_ret(|| v -= 3);\n            return v;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_ZwlsW2TCjSb
                                #define STR_ZwlsW2TCjSb
static const fu::str str_ZwlsW2TCjSb fu_INIT_PRIORITY(1015) { "\n        fn main() {\n\n            // Previously we considered making the : shorthand available in expression position -\n            //  now we're backing off and making it solely available for void-returning lambdas in stmt position,\n            //   and making the continue/break rewrites more cautious for regular lambdas.\n            //\n            // Brief - we're equating the : shorthand with custom control flow.\n            //\n            mut sum = 0;\n            each([ 1, 2, 3 ]        <fail missing comma 12:21+1>\n                .map: |x| x * x     <pass/>\n                .map(|x| x * x)     </fail>\n                    ): |x| sum += x;\n\n            return sum - 14;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_p7vT6CwmEW8
                                #define STR_p7vT6CwmEW8
static const fu::str str_p7vT6CwmEW8 fu_INIT_PRIORITY(1015) { "\n        struct A { a: i32; };\n        struct B { b: i32; };\n\n        <alt>\n        using fn bananas(a: A)  B(a.a * 2); <alt/>\n        using fn bananas(a: _)  // conv-cache: adding the case to salvage this alt\n        case(typeof(a) -> A)    B(a.a * 2); <alt/>\n        using fn bananas(a.a)   B(  a * 2); <alt/>\n        using fn bananas( .a)   B(  a * 2); </alt>\n\n        <split/>\n        fn main() 1.A.b - 2;\n    "_fu };
                                #endif

                                #ifndef STR_D3xbc9TnSMi
                                #define STR_D3xbc9TnSMi
static const fu::str str_D3xbc9TnSMi fu_INIT_PRIORITY(1015) { "\n        fn sqr(a: i32) a * a;\n        fn woot(a.sqr) a + 1;\n        fn main() 2.woot - 5;\n    "_fu };
                                #endif

                                #ifndef STR_6JDUtpJdBI3
                                #define STR_6JDUtpJdBI3
static const fu::str str_6JDUtpJdBI3 fu_INIT_PRIORITY(1015) { "\n        struct A0 { a0: i32; };\n        struct A1 { a1: i32; };\n        struct B  { b:  i32; };\n\n        fn a0(a1: A1) a1.a1 * 100;\n        fn bananas(a) B(a.a0 * 2); // <- template\n        fn woot(a.bananas: B) a.b; // <- check\n\n        fn main() 1.A0.woot + 1.A1.woot - 202;\n    "_fu };
                                #endif

                                #ifndef STR_fvo0sJVjkcj
                                #define STR_fvo0sJVjkcj
static const fu::str str_fvo0sJVjkcj fu_INIT_PRIORITY(1015) { "\n        struct A0 { a0: i32; };\n        struct A1 { a1: i32; };\n        struct B0 { b0: i32; };\n        struct B1 { b1: i32; };\n        struct C  { c:  i32; };\n\n        fn bananas(using _: A0) B0(a0 * 2);\n        fn bananas(using _: A1) B1(a1 * 3);\n        using fn c0(using _: B0) C(c: b0 * 5);\n        using fn c1(using _: B1) C(c: b1 * 7);\n        fn woot(using a.bananas: C) c; // extra conversion\n\n        fn main() 1.A0.woot + 1.A1.woot - 31;\n    "_fu };
                                #endif

                                #ifndef STR_V9j5JgBRWIc
                                #define STR_V9j5JgBRWIc
static const fu::str str_V9j5JgBRWIc fu_INIT_PRIORITY(1015) { "\n        struct A0 { a0: i32; };\n        struct A1 { a1: i32; };\n        struct B0 { b:  i32; };\n        struct B1 { b:  i32; };\n\n        fn bananas(a0: A0) B0(a0.a0 * 2);\n        fn bananas(a1: A1) B1(a1.a1 * 3);\n        fn woot(a.bananas) a.b; // <- template\n\n        fn main() 1.A0.woot + 1.A1.woot - 5;\n    "_fu };
                                #endif

                                #ifndef STR_rDVkdXBRPu5
                                #define STR_rDVkdXBRPu5
static const fu::str str_rDVkdXBRPu5 fu_INIT_PRIORITY(1015) { "\n        fn times_implicit(x: i32, implicit y: i32) x * y;\n        fn times7(x: i32) x * 7;\n\n        fn woot(a.times_implicit, b: u32) a * b.i32;\n        fn woot(a: i32, b.times7: i32) a * b;\n\n        fn test0() 3.woot(2.i32);\n\n        fn test1() {\n            let implicit y = 7;\n            return 3.woot(2.u32);\n        }\n\n        fn main() test0 + test1 * 1000 - 42042;\n    "_fu };
                                #endif

                                #ifndef STR_Fx7h8uUWPN5
                                #define STR_Fx7h8uUWPN5
static const fu::str str_Fx7h8uUWPN5 fu_INIT_PRIORITY(1015) { "\n        struct X { str: string; };\n        fn ~(a: X, b: X) X(a.str ~ b.str);          // currently: invalid operator~ cg\n        inline fn ~(a: X, b.to_debug_str) a ~ b;    // currently: pointless blocks\n\n        fn to_debug_str(a: i32) X(\"i\" ~ a);\n\n        fn main() {\n            let hey = X(\"Hey! \") ~ 5;\n            return hey.str == \"Hey! i5\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_p3M1TLekYH5
                                #define STR_p3M1TLekYH5
static const fu::str str_p3M1TLekYH5 fu_INIT_PRIORITY(1015) { "\n        struct vec32  { x: f32; };\n        struct conv32 { v: f32; };\n\n        <alt>\n        using inline fn convert(v: i32): conv32 = [ v.f32 ]; // no litfix\n        <alt/>\n        using inline fn convert(v: f32): conv32 = [ v ]; // litfix in a conv: i32 -> f32\n        </alt>\n\n        inline fn /(a: conv32, b: vec32) vec32(a.v / b.x);\n        fn main() i32 <| (1/vec32(1)).x - 1;\n    "_fu };
                                #endif

                                #ifndef STR_Q3MBtJ5DKPh
                                #define STR_Q3MBtJ5DKPh
static const fu::str str_Q3MBtJ5DKPh fu_INIT_PRIORITY(1015) { "expects conv32 got i32 10:28+1"_fu };
                                #endif

                                #ifndef STR_RZEt4Dc6DGj
                                #define STR_RZEt4Dc6DGj
static const fu::str str_RZEt4Dc6DGj fu_INIT_PRIORITY(1015) { "\n        struct vec_u  { x: u32; };\n        struct vec32  { x: f32; };\n        struct vec64  { x: f64; };\n\n        struct conv_u { v: u32; };\n        struct conv32 { v: f32; };\n        struct conv64 { v: f64; };\n\n        using inline fn convert(v: u32): conv_u = [ v ]; // matchfail before\n        using inline fn convert(v: f32): conv32 = [ v ];\n        using inline fn convert(v: f64): conv64 = [ v ]; // matchfail after\n\n        inline fn /(a: conv_u, b: vec_u) vec_u(a.v / b.x);\n        inline fn /(a: conv32, b: vec32) vec32(a.v / b.x);\n        inline fn /(a: conv64, b: vec64) vec64(a.v / b.x);\n\n        fn main() i32 <| (1/vec32(1)).x - 1;\n    "_fu };
                                #endif

                                #ifndef STR_BKaTNV2iPb1
                                #define STR_BKaTNV2iPb1
static const fu::str str_BKaTNV2iPb1 fu_INIT_PRIORITY(1015) { "expects conv32 got i32 18:28+1"_fu };
                                #endif

                                #ifndef STR_OH7dtXLbyo1
                                #define STR_OH7dtXLbyo1
static const fu::str str_OH7dtXLbyo1 fu_INIT_PRIORITY(1015) { "\n        pub struct Module       { modid: i32; };\n        pub struct Target       { modid: i32; index: i32; };\n        pub struct Type         { using vtype: ValueType; };\n        pub struct ValueType    { modid: i32; canon: string; };\n        pub struct Overload     { kind: string; locals?: Overload[]; };\n\n        fn main() {\n            using fn GET(target: Target, implicit overloads: Overload[]) {\n                target.index > 0 || throw(\"Assertion failed.\");\n                if (target.modid < 0)\n                    return overloads[-target.modid - 1].locals[target.index - 1];\n                else\n                    return overloads[target.index - 1];\n            }\n\n            fn try_GET(target: Target)\n                target && GET(target);\n\n            implicit mut overloads: Overload[];\n            overloads ~= Overload(\"What\");\n            return try_GET(Target(0, 1)).kind.len - 4;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_rusVXp1cWGk
                                #define STR_rusVXp1cWGk
static const fu::str str_rusVXp1cWGk fu_INIT_PRIORITY(1015) { "\n        struct RWEvent { rw_target!: i32 };\n        struct ReadID  { id: i32 };\n\n        fn main()\n        {\n            <fail ambig rw_target>\n            using   <pass/></fail>\n            fn RWEvent(read: ReadID)    RWEvent(rw_target: read.id);\n\n            fn rw_target(read: ReadID)  read.id;\n\n            return ReadID(0).rw_target;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_JraZ5CRliw1
                                #define STR_JraZ5CRliw1
static const fu::str str_JraZ5CRliw1 fu_INIT_PRIORITY(1015) { "\n        fn a_len(a: $T[..]) a.len; // a conversion could navigate this here\n        struct Test { using a: i32[]; };\n        fn main() Test.a_len;\n    "_fu };
                                #endif

                                #ifndef STR_4Nkn2qZDXS4
                                #define STR_4Nkn2qZDXS4
static const fu::str str_4Nkn2qZDXS4 fu_INIT_PRIORITY(1015) { "\n        struct CodegenOutput { using src: string; };\n\n        fn test(ref str: string, out: CodegenOutput) {\n            str ~= out && \"b\";\n            return str ~ out;\n        }\n\n        fn main() {\n            mut str = \"a\";\n            return str.test(CodegenOutput(\"what\")).len - 6; // \"abwhat\".len;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_RpX2M3QLoo9
                                #define STR_RpX2M3QLoo9
static const fu::str str_RpX2M3QLoo9 fu_INIT_PRIORITY(1015) { "\n        struct linearRGB    { r: i32; };\n        struct sRGB         { r: i32; };\n\n        <fail ambig conversion 14:18+1 lin2srgb 6:9+5 srgb2lin 9:9+5>\n        using    <pass/></fail>\n        fn lin2srgb(c: linearRGB): sRGB = [ c.r / 3 ];\n\n        using\n        fn srgb2lin(c: sRGB): linearRGB = [ c.r * 3 ];\n\n        fn RGB(linear: bool, r: i32) {\n            return linear\n                 ? linearRGB(r)\n                 :      sRGB(r);\n        }\n\n        fn main() {\n            mut c = RGB(linear: false, 7);\n            return c.r - 21;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_PxQV4htUajj
                                #define STR_PxQV4htUajj
static const fu::str str_PxQV4htUajj fu_INIT_PRIORITY(1015) { "\n        struct linearRGB    { r: i32; };\n        struct sRGB         { r: i32; };\n\n        <fail cannot convert><pass/>\n        using                </fail>\n        fn srgb2lin(c: sRGB): linearRGB = [ c.r * 7 ];\n\n        fn main() = (sRGB(r: 3) => linearRGB).r - 21;\n    "_fu };
                                #endif

                                #ifndef STR_bkCaQjDgfNc
                                #define STR_bkCaQjDgfNc
static const fu::str str_bkCaQjDgfNc fu_INIT_PRIORITY(1015) { "\n        struct Overload     { name: string; };\n        struct Target       { o_index: i32; };\n\n        struct Helpers      { hd_index: i32; };\n        struct HelpersData  { target: Target; };\n\n        fn solve(ref overloads: Overload[], ref helpers: HelpersData[])\n        {\n            using fn GET(h: Helpers)\n                helpers[h.hd_index];\n\n            fn qWHAT(o: Overload)\n                o.name;\n\n            using fn GET(t: Target) {\n                ref o = overloads[t.o_index];\n\n                // The qWHAT here tried to (pointlessly) solve qWHAT below,\n                //  but GET hadn't solved yet so it wasn't available.\n                return o.qWHAT ? o : GET(Target(t.o_index + 1));\n            }\n\n            fn qWHAT(hd: HelpersData)\n                hd.target.qWHAT;\n\n            return Helpers(0).qWHAT;\n        }\n\n        fn main() {\n            mut overloads: Overload[];\n            mut helpers: HelpersData[];\n\n            for (mut i = 0; i < 2; i++) {\n                overloads ~= Overload(i && \"o=\" ~ i);\n                helpers ~= HelpersData(Target(i));\n            }\n\n            return solve(overloads, helpers) == \"o=1\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_6USD34CDPT8
                                #define STR_6USD34CDPT8
static const fu::str str_6USD34CDPT8 fu_INIT_PRIORITY(1015) { "\n        struct Overload     { name: string; };\n        struct Target       { o_index: i32; };\n\n        struct Helpers      { hd_index: i32; };\n        struct HelpersData  { target: Target; };\n\n        fn overloads(implicit ref o: Overload[]) o;\n        fn helpers(implicit ref h: HelpersData[]) h;\n\n        using fn GET(h: Helpers)\n            helpers[h.hd_index];\n\n        fn qWHAT(o: Overload)\n            o.name;\n\n        using fn GET(t: Target) {\n            ref o = overloads[t.o_index];\n\n            // The qWHAT here tried to (pointlessly) solve qWHAT below,\n            //  but GET hadn't solved yet so it wasn't available.\n            return o.qWHAT ? o : GET(Target(t.o_index + 1));\n        }\n\n        fn qWHAT(hd: HelpersData)\n            hd.target.qWHAT;\n\n        fn solve() = Helpers(0).qWHAT;\n\n        fn main() {\n            implicit mut o: Overload[];\n            implicit mut h: HelpersData[];\n\n            for (mut i = 0; i < 2; i++) {\n                o ~= Overload(i && \"o=\" ~ i);\n                h ~= HelpersData(Target(i));\n            }\n\n            return solve() == \"o=1\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_veoPuhVvnF2
                                #define STR_veoPuhVvnF2
static const fu::str str_veoPuhVvnF2 fu_INIT_PRIORITY(1015) { "\n        struct Target       { index: int };\n        struct Overload     { name: string; };\n\n        fn solve(_overloads: Overload[], _targets: Target[]) {\n            fn fail(mut reason: string): never {\n                for (mut i = _targets.len; i --> 0; ) {\n                    let t = _targets[i];\n                    if (t)\n                        reason ~= GET(t).qWHAT;\n                }\n\n                return throw(reason);\n            }\n\n            fn qWHAT(o: Overload)\n                o.name;\n\n            using fn GET(target: Target) {\n                _overloads.len >= target.index || fail(\n                    GET(Target(_overloads.len - 1)).qWHAT);\n\n                return _overloads[target.index];\n            }\n\n            fn qWHAT(n: Target[]) {\n            <alt>\n                mut res = \"\";\n                for (mut i = 0; i < n.len; i++)\n                    res ~= n[i].qWHAT;\n\n                return res;\n            <alt/>\n                return n.map(|t| t.qWHAT).join();\n            </alt>\n            }\n\n            return _targets.qWHAT;\n        }\n\n        fn main() {\n            mut res = solve(\n                [ Overload(\"Hello\"), Overload(\", \"), Overload(\"! \"), Overload(\"World!\") ],\n                [ Target(0), Target(1), Target(3) ]);\n\n            return res == \"Hello, World!\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_9cU5mqsF1w7
                                #define STR_9cU5mqsF1w7
static const fu::str str_9cU5mqsF1w7 fu_INIT_PRIORITY(1015) { "\n        struct Target       { index: int };\n        struct Overload     { name: string; };\n\n        fn _overloads(implicit overloads: Overload[]) overloads;\n        fn _targets(implicit targets: Target[]) targets;\n\n        fn fail(mut reason: string): never {\n            for (mut i = _targets.len; i --> 0; ) {\n                let t = _targets[i];\n                if (t)\n                    reason ~= GET(t).qWHAT;\n            }\n\n            return throw(reason);\n        }\n\n        fn qWHAT(o: Overload)\n            o.name;\n\n        using fn GET(target: Target) {\n            _overloads.len >= target.index || fail(\n                GET(Target(_overloads.len - 1)).qWHAT);\n\n            return _overloads[target.index];\n        }\n\n        fn qWHAT(n: Target[]) {\n        <alt>\n            mut res = \"\";\n            for (mut i = 0; i < n.len; i++)\n                res ~= n[i].qWHAT;\n\n            return res;\n        <alt/>\n            return n.map(|t| t.qWHAT).join();\n        </alt>\n        }\n\n        fn solve(implicit overloads: Overload[], implicit targets: Target[])\n            targets.qWHAT;\n\n        fn main() {\n            mut res = solve(\n                [ Overload(\"Hello\"), Overload(\", \"), Overload(\"! \"), Overload(\"World!\") ],\n                [ Target(0), Target(1), Target(3) ]);\n\n            return res == \"Hello, World!\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_46Qs1uMN960
                                #define STR_46Qs1uMN960
static const fu::str str_46Qs1uMN960 fu_INIT_PRIORITY(1015) { "\n        fn a_slash_b(a: f32, b: f32) {\n            return a ~ \"/\" ~ b;                                 ;; DuplicateFunctions\n        }\n\n        fn main() {\n            return a_slash_b(1, 2) == \"1.000000/2.000000\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_VruuYP1yqQd
                                #define STR_VruuYP1yqQd
static const fu::str str_VruuYP1yqQd fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            let s: i32 = -3;\n            let u: u32 =  3;\n            <fail 6:22+1 9:10+1 T: incompatible types i32 u32>\n            return s + u;             <pass/>\n            return s + u.i32;         </fail>\n        }\n    "_fu };
                                #endif

                                #ifndef STR_ZCm7zwSWUUk
                                #define STR_ZCm7zwSWUUk
static const fu::str str_ZCm7zwSWUUk fu_INIT_PRIORITY(1015) { "\n        struct Start { s: i32 };\n        struct MidA { a: i32 };\n        struct MidB { b: i32 };\n        struct End { e: i32 };\n\n        using fn toMidA(start: Start) MidA(start.s * 2);\n        using fn toMidB(start: Start) MidB(start.s * 3);\n        using fn toEnd(mida: MidA) End(mida.a * 5);\n\n        <fail (5:26+1|18:26+1) multiple ways to conv Start into End toMidA 7:9+5 toEnd 9:9+5 toMidB 8:9+5 toEnd 12:9+5>\n        using <pass/></fail>\n        fn toEnd(midb: MidB) End(midb.b * 7);\n        <split/>\n\n        fn main() {\n            let start = Start(1);\n            return start.e - 2*5;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_CtxlJzDzcU1
                                #define STR_CtxlJzDzcU1
static const fu::str str_CtxlJzDzcU1 fu_INIT_PRIORITY(1015) { "\n        struct vec3 { x: i32 };\n        fn woot(\n            using a: vec3,\n            <fail ambig using multiple ways to obtain vec3 9:20+1 4:13+5 6:13+5>\n            using <pass/></fail>\n            b: vec3)\n        {\n            return x + b.x;\n        }\n\n        fn main() vec3(1).woot(vec3(-1));\n    "_fu };
                                #endif

                                #ifndef STR_4LgHe883CBi
                                #define STR_4LgHe883CBi
static const fu::str str_4LgHe883CBi fu_INIT_PRIORITY(1015) { "\n        struct B { v: i32 };\n        struct C { v: i32 };\n\n        <fail ambig (7:31+1|8:31+1) 6:20+1 (2:20+1|3:20+1) using fn AC (7:9+5|8:9+5)>\n        struct A { v: i32 };\n        using fn AB(a: A) B(a.v * 2);\n        using fn AC(a: A) C(a.v * 3);\n        <pass/>\n        struct A { a: i32 };\n        using fn AB(a: A) B(a.a * 2);\n        using fn AC(a: A) C(a.a * 3);\n        </fail>\n\n        fn main() {\n            let a = A(1);\n            let b: B = a;\n            let c: C = a;\n            return b.v * c.v - 6;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_6oFINV2DHY3
                                #define STR_6oFINV2DHY3
static const fu::str str_6oFINV2DHY3 fu_INIT_PRIORITY(1015) { "\n        struct A1 { v: i32 };\n        struct A2 { v: i32 };\n        struct B { v: i32 };\n\n        using fn A1B(a: A1) B(a.v * 2);\n        using fn A2B(a: A2) B(a.v * 3);\n\n        fn test(a): B = a;\n\n        fn main() A1(1).test.v * A2(1).test.v - 6;\n    "_fu };
                                #endif

                                #ifndef STR_Bi7j5a2PHZ9
                                #define STR_Bi7j5a2PHZ9
static const fu::str str_Bi7j5a2PHZ9 fu_INIT_PRIORITY(1015) { "\n        struct A { a: i32 };\n        struct B { b: i32 };\n\n        // Currently this would have to be named fn A -\n        //  because we match by type *name*, instead of\n        //   attempting conversions to type A.\n        //\n        // We want to replace match-by-name by tryConvert.\n        //\n        using fn A2B(a: A): B = [ a.a + 3 ];\n\n        fn main() A(2)<alt>.B</alt>.b - 5;\n    "_fu };
                                #endif

                                #ifndef STR_vYzCQpQvfGl
                                #define STR_vYzCQpQvfGl
static const fu::str str_vYzCQpQvfGl fu_INIT_PRIORITY(1015) { "Bad call to T A 13:24+1"_fu };
                                #endif

                                #ifndef STR_GspYM69Ovsa
                                #define STR_GspYM69Ovsa
static const fu::str str_GspYM69Ovsa fu_INIT_PRIORITY(1015) { "\n        fn Wrap(type T) =\n            struct { value!: T };\n\n        infix fn => !<A, B>\n            (from: Wrap(A), lax _: Wrap(B)): Into =\n                [ Into(from.value) + 4 ];\n    <alt>\n        fn main() =\n            (7.u32 => Wrap(int)).value - 14;\n    <alt/>\n        fn main() {\n            type T = Wrap(int);\n            return T(7.u32).value - 14;\n        }\n    </alt>\n    "_fu };
                                #endif

                                #ifndef STR_m6dz1Bjxkia
                                #define STR_m6dz1Bjxkia
static const fu::str str_m6dz1Bjxkia fu_INIT_PRIORITY(1015) { "Bad call to T u32 11:20+1"_fu };
                                #endif

                                #ifndef STR_FvzpTwttKef
                                #define STR_FvzpTwttKef
static const fu::str str_FvzpTwttKef fu_INIT_PRIORITY(1015) { "\n        struct A { target: i32; };\n        struct B { target: u32; };\n\n        fn definit()    <fail ambig call [] A:target B:target><pass/>\n            : A         </fail>\n                = [];\n\n        fn main() = definit.target;\n    "_fu };
                                #endif

                                #ifndef STR_CtISJ19EsIf
                                #define STR_CtISJ19EsIf
static const fu::str str_CtISJ19EsIf fu_INIT_PRIORITY(1015) { "\n        struct A { x: i32 };\n        struct C { a: A };\n                                    <fail conv func arg need type annot 5:26+1>\n        using fn C2A(ref a) a.a;    <pass/>\n        using fn C2A(ref a.a) a;    </fail>\n\n        using fn getX(ref x.x) x;\n        fn main(): i32 {\n            let c: C;\n            return c;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_jLiP2ZGDm6l
                                #define STR_jLiP2ZGDm6l
static const fu::str str_jLiP2ZGDm6l fu_INIT_PRIORITY(1015) { "\n        struct A { x: i32 };\n        struct C { a: A };\n                                    <fail conv func arg need type annot 5:26+1>\n        using fn C2A(ref a) a.a;    <pass/>\n        using fn C2A(ref .a)  a;    </fail>\n\n        using fn getX(ref .x) x;\n        fn main(): i32 {\n            let c: C;\n            return c;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_CftzlWzfnl5
                                #define STR_CftzlWzfnl5
static const fu::str str_CftzlWzfnl5 fu_INIT_PRIORITY(1015) { "\n        struct A { x: i32 };\n        struct B { using a: A };\n        struct C { b: B };\n<alt>\n        using fn C2B(ref .b) b;                             <alt/>\n        using fn C2B(using ref c: C or C) b;                <alt/>\n        using fn C2B(using ref c: <T>) case (T -> C) b;     <alt/>\n        using fn C2B(using ref c: C, lax unused?: $T) b;    </alt>\n\n        <split/>\n<alt>\n        using fn generic_ref_x(using ref a: A or A) x;              <alt/>\n        using fn generic_ref_x(using ref a: <T>) case (T -> A) x;   <alt/>\n        using fn generic_ref_x(using ref a: A, lax unused?: $T) x;  </alt>\n<alt>\n        using fn val_x(using c: C) generic_ref_x;           <alt/>\n        using fn val_x(c: C)     c.generic_ref_x;           <alt/>\n        using fn val_x(ref c: C) c.generic_ref_x;           </alt>\n\n        <split/>\n        fn main() {\n            using mut c: C;\n            generic_ref_x++;\n            return val_x - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_j5m0YmSwph8
                                #define STR_j5m0YmSwph8
static const fu::str str_j5m0YmSwph8 fu_INIT_PRIORITY(1015) { "bad call generic_ref_x cannot infer ref arg a 17:13+13"_fu };
                                #endif

                                #ifndef STR_cFtmvRUGNjl
                                #define STR_cFtmvRUGNjl
static const fu::str str_cFtmvRUGNjl fu_INIT_PRIORITY(1015) { "\n        fn Each !T(ref a: T[..], fn)\n            for (mut i = 0; i < a.len; i++)\n                fn(a[i], i?: i);\n\n        <split/>\n        fn main() {\n            fn sqr(v) v * v;\n            let list = [ 1, 2, 3 ];\n            mut sum_of_squares = 0;\n            list.Each: |.sqr| sum_of_squares += sqr;\n            return sum_of_squares - 14;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_rMLsaE8lD1i
                                #define STR_rMLsaE8lD1i
static const fu::str str_rMLsaE8lD1i fu_INIT_PRIORITY(1015) { "sqr is not defined here 11:24+1"_fu };
                                #endif

                                #ifndef STR_eEoBDapraPj
                                #define STR_eEoBDapraPj
static const fu::str str_eEoBDapraPj fu_INIT_PRIORITY(1015) { "\n        fn Each !T(ref a: T[..], fn)\n            for (mut i = 0; i < a.len; i++)\n                fn(a[i], i?: i);\n\n        <split/>\n        struct List(type T) { sorted!: T[] }\n        fn Each !T(l: List(T), visit)\n            l.sorted.Each: fn visit;\n\n        <split/>\n        fn main() {\n            fn sqr(v) v * v;\n            let list: List(int) = [ sorted: [ 1, 2, 3 ] ];\n            mut sum_of_squares = 0;\n            list.Each: |.sqr| sum_of_squares += sqr;\n            return sum_of_squares - 14;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_TSWhkUkEf4d
                                #define STR_TSWhkUkEf4d
static const fu::str str_TSWhkUkEf4d fu_INIT_PRIORITY(1015) { "sqr is not defined here 4:17+2"_fu };
                                #endif

                                #ifndef STR_6nVxW3v0AUd
                                #define STR_6nVxW3v0AUd
static const fu::str str_6nVxW3v0AUd fu_INIT_PRIORITY(1015) { "\n        struct Set(type T) { using array: T[] }\n    "_fu };
                                #endif

                                #ifndef STR_NGT82x8ekfl
                                #define STR_NGT82x8ekfl
static const fu::str str_NGT82x8ekfl fu_INIT_PRIORITY(1015) { "\n        struct CountedSet(type T) { using set: _0::Set(T) }\n    "_fu };
                                #endif

                                #ifndef STR_SQIp3UY2Ydf
                                #define STR_SQIp3UY2Ydf
static const fu::str str_SQIp3UY2Ydf fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut cs: _1::CountedSet(i32);\n            mut count = 0;\n            cs.each: |_| count++;\n            return count;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_uPUQPEqUdAa
                                #define STR_uPUQPEqUdAa
static const fu::str str_uPUQPEqUdAa fu_INIT_PRIORITY(1015) { "\n        struct Set(type T) {    <fail ambig each 5:16+4 :4+4 7:12+4>\n            using               <pass/></fail>\n            array: T[];\n        }\n\n        fn each !T(ref set: Set(T), visit) set.array.each(fn visit);\n    "_fu };
                                #endif

                                #ifndef STR_Mc0n6yWdit0
                                #define STR_Mc0n6yWdit0
static const fu::str str_Mc0n6yWdit0 fu_INIT_PRIORITY(1015) { "\n        pub struct SillyHash { int: int }\n        pub fn SillyHash(str: string) = SillyHash(str.len)\n\n        struct SetItem(type <Key>, type <Hash>) { hash: Hash; key: Key }\n        pub struct Set(type <Key>, type <Hash> = SillyHash) { items: SetItem(:Hash, :Key)[] }\n\n        fn if_ref <Hash, Key>(ref set: Set(:Hash, :Key), hash!: Hash, key: Key, visit, else?) {\n            for (mut i = 0; i < set.items.len; i++) {\n                ref item = set.items[i]\n                if (item.hash == hash && item.key == key)\n                    return visit(?: item)\n            }\n\n            return else()\n        }\n\n        pub inline fn get(ref set: Set(:<Hash>, :<Key>), key: Key) {\n            return set.if_ref(:key, hash: Hash(key), visit: |item| item) || []\n        }\n\n        pub fn add <Hash>(ref set: Set(:Hash, :<Key>), key: Key) {\n            let hash = Hash(key)\n            set.if_ref(:key, :hash, visit: false): || {\n                type Item = SetItem(:Key, :Hash)\n                set.items ~= Item(:key, :hash)\n                return true\n            }\n        }\n    "_fu };
                                #endif

                                #ifndef STR_VTvjSDJy1E9
                                #define STR_VTvjSDJy1E9
static const fu::str str_VTvjSDJy1E9 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut set = _0::Set(string)\n            if (!set.add(\"Hello!\")) return 1\n            return set.get(\"Hello!\").hash.int - 6               ;; LocalConstBool\n        }\n    "_fu };
                                #endif

                                #ifndef STR_wX6j4Mx8Blg
                                #define STR_wX6j4Mx8Blg
static const fu::str str_wX6j4Mx8Blg fu_INIT_PRIORITY(1015) { "\n        fn main() {                                             ;; GNUStmtExpr\n            mut hello: hash::Map(string, string);               ;; Goto\n            hello.set(\"hello\", \"world!\");\n            let a = hello.get(\"hello\").len - 6;\n            hello.remove(\"hello\");\n            let b = hello.get(\"hello\").len;\n            hello.set(\"world\", \"world!!\");\n            let c = hello.get(\"world\").len - 7;\n            return a + b * 10 + c * 100;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_VjRGHnOJqe0
                                #define STR_VjRGHnOJqe0
static const fu::str str_VjRGHnOJqe0 fu_INIT_PRIORITY(1015) { "//file hlprs.fu\n        fn grow_if_oob(ref a: $T[], i: i32): &mut $T {\n            if (a.len <= i) a.grow(i + 1);\n            return a[i];\n        }\n    "_fu };
                                #endif

                                #ifndef STR_JvVJwt6EcW9
                                #define STR_JvVJwt6EcW9
static const fu::str str_JvVJwt6EcW9 fu_INIT_PRIORITY(1015) { "//file bs.fu\n        struct BitSet { _data: u8[] }\n\n        fn rem(using ref _: BitSet, idx: int) {\n            let bucket  = idx >> 3;\n            let mask    = 1 << u8(idx & 7);\n            if (_data.len > bucket) {\n                let item = _data[bucket];\n                if (item & mask) {\n                    _data[bucket] &= ~mask;\n                    if (item == mask && _data.len == bucket + 1)\n                        _shrink_to_fit();\n                }\n            }\n        }\n\n        fn add(using ref _: BitSet, idx: int) {\n            _data.hlprs::grow_if_oob(idx >> 3) |= 1 << u8(idx & 7);\n        }\n\n        fn _shrink_to_fit(using ref _: BitSet) {\n            mut end = _data.len;\n            while (end --> 0) if (_data[end]) break;\n            _data.shrink(end + 1);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_eM5E5Hcy0Oa
                                #define STR_eM5E5Hcy0Oa
static const fu::str str_eM5E5Hcy0Oa fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut bs: bs::BitSet;\n            bs.add(100);    let len0 = bs._data.len;\n            bs.rem(100);    let len1 = bs._data.len;\n            return len0 == 13 && len1 == 0 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_umbLUEsnAF5
                                #define STR_umbLUEsnAF5
static const fu::str str_umbLUEsnAF5 fu_INIT_PRIORITY(1015) { "\n        struct Key   { ki: int };\n        struct Value { vi: int };\n        struct Data  { values: Value[] };\n\n        noinline fn test(using ref _: Data) {\n            fn push(v: Value) values ~= v;\n            using fn EXT(k: Key) values[k.ki];\n            push(Value(101));\n            return Key(0).vi;\n        }\n\n        fn main() {\n            mut data: Data;\n            return data.test() - 101;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_IDykhjq4Tpj
                                #define STR_IDykhjq4Tpj
static const fu::str str_IDykhjq4Tpj fu_INIT_PRIORITY(1015) { "\n        struct Helpers      { index: int };\n        struct HelpersData  { target: Target };\n        struct Target       { globid: int };\n        struct Overload     { name: string };\n\n        noinline fn test(_overloads: Overload[], _helpers: Helpers[], _data: HelpersData[], t: Target)\n        {\n            using fn H(h: Helpers): HelpersData {\n                h.index >= 0 && h.index < _data.len || throw(\"A\");\n                return _data[h.index];\n            }\n\n            fn fail_appendStack(mut r: string) {\n                for (mut i = _helpers.len; i --> 0; ) r ~= O(_helpers[i].target);\n                return r;\n            }\n\n            fn fail(r: string) {\n                r || fail(\"B\");\n                return throw(r.fail_appendStack());\n            }\n\n            fn str(o: Overload) = o.name;\n\n            using fn O(target: Target) {\n                let globid = target.globid;\n                globid > 0 && _overloads.len >= globid || fail(\"C\");\n                return _overloads[target.globid - 1];\n            }\n\n            return t.name;\n        }\n\n        fn main() = test([ Overload(\"Hello\") ], [], [], Target(1)) == \"Hello\" ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_f25p7v1DgP9
                                #define STR_f25p7v1DgP9
static const fu::str str_f25p7v1DgP9 fu_INIT_PRIORITY(1015) { "\n        struct ConvCacheEntry   { types: int[] }\n        struct Set(type T)      { keys_asc!: T[] };\n\n        fn append(using ref _: Set($T), v: int) keys_asc ~= v;\n\n        struct SolverState {    <flip>\n            _input?: int[];     <flip/>\n            _output?: Set(int); </flip>\n        }\n\n        fn ConvCache_fieldItemsOrder_glitch(using ref ss: SolverState) {\n            fn append(v: int) _output.append(v);\n            _input.each: |v| append(v);\n        }\n\n        fn main() {\n            mut ss = SolverState(_input: [ 1, 2, 3 ]);\n            ss.ConvCache_fieldItemsOrder_glitch();\n            return ss._output.keys_asc.len - 3;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_02CGk6meQS6
                                #define STR_02CGk6meQS6
static const fu::str str_02CGk6meQS6 fu_INIT_PRIORITY(1015) { "\n        struct A { x: int };\n        struct B { using a: A };\n        struct C { using a: A };\n\n        fn main() {\n            using mut b = B(A(1));\n            <fail using ambig mut a 7:13+5 field B:a 3:20+5 mut b 9:13+5 field C:a 4:20+5>\n            using <pass/></fail>\n            mut c = C(A(2));\n\n            x *= 10;\n            return b.x == 10 && c.x == 2 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_zDF46rHaov5
                                #define STR_zDF46rHaov5
static const fu::str str_zDF46rHaov5 fu_INIT_PRIORITY(1015) { "\n        struct Target { id: string }\n        struct ScopeItem { name: string }\n        fn zeroes() = [];\n    "_fu };
                                #endif

                                #ifndef STR_yb0ft1pca48
                                #define STR_yb0ft1pca48
static const fu::str str_yb0ft1pca48 fu_INIT_PRIORITY(1015) { "\n        import _0;\n        fn throwIfEmpty_else_returnEmptyStr(what: string) {\n            using inline fn GET(lax h: Target): ScopeItem = <alt>[]<alt/>zeroes()</alt>;\n\n            fn throwIfEmpty(id: string) {\n                let t = Target(:id);\n                return t.AlwaysTrue.name;\n            }\n\n            fn AlwaysTrue(target) target || throw(target.id);\n            return throwIfEmpty(what);\n        }\n\n        fn main() {\n            try         return throwIfEmpty_else_returnEmptyStr(\"Not empty!\").len;\n            catch (e)   return 1000 + e.len;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_umRd7qZVp52
                                #define STR_umRd7qZVp52
static const fu::str str_umRd7qZVp52 fu_INIT_PRIORITY(1015) { "\n        struct ValueType { canon: string };\n        struct Type { using vtype: ValueType };\n        <split/>\n        fn ternary_mutrefExact_vs_constUsingField(left: Type, ref right: ValueType[])\n            !right ? left : right[0];\n\n        fn main() {\n            mut right: ValueType[];\n            let a = ternary_mutrefExact_vs_constUsingField(Type(ValueType(\"Hello, \")), :right);\n            right ~= ValueType(\"World!\");\n            let b = ternary_mutrefExact_vs_constUsingField(Type(), :right);\n            return a.canon ~ b.canon == \"Hello, World!\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_cfHO2eU0Gl8
                                #define STR_cfHO2eU0Gl8
static const fu::str str_cfHO2eU0Gl8 fu_INIT_PRIORITY(1015) { "\n        struct A { a: int };\n        struct B { b: int };\n\n        fn conversionToZeroesOrNever(what: A) {\n            using fn intoB(a: A)    <fail ambiguous conversion assigns to anything 6:13+5>\n                [];                 <pass/>\n                B(a.a * 2);         </fail>\n\n            return what && what.b;\n        }\n\n        fn main() conversionToZeroesOrNever(A(3)) == 6 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_3dlmMXWun0e
                                #define STR_3dlmMXWun0e
static const fu::str str_3dlmMXWun0e fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut hello = 0;\n            using fn what() ++hello;\n            fn add(x: int, y: int) x + y;\n            return add(-1);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_feLuEjPcbGl
                                #define STR_feLuEjPcbGl
static const fu::str str_feLuEjPcbGl fu_INIT_PRIORITY(1015) { "\n        using fn what(implicit ref hello: int) ++hello;\n        fn main() {\n            implicit mut hello = 0;\n            fn add(x: int, y: int) x + y;\n            return add(-1);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_WPdFjqYDGQ8
                                #define STR_WPdFjqYDGQ8
static const fu::str str_WPdFjqYDGQ8 fu_INIT_PRIORITY(1015) { "\n        using fn what(implicit ref a: i32) ++a;\n        using fn woot(implicit ref b: u32) ++b;\n        fn main() {\n            implicit mut a: i32 = 10;\n            implicit mut b: u32 = 201;\n            fn add(x: i32, y: i32) x + y;\n            fn add(x: u32, y: u32) x + y;\n            return add(1<fail ambig 8:16+3 using 3:9+5 7:16+3 using 2:9+5><pass/>.i32</fail>)\n                 + add(1.u32).i32 - 215;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_cOLbOLhi6U5
                                #define STR_cOLbOLhi6U5
static const fu::str str_cOLbOLhi6U5 fu_INIT_PRIORITY(1015) { "\n        struct Node         { value: int; items: Node[] };\n        struct OpenBlock    { using node: Node };\n\n        fn closeOpenBlocks(ref open_blocks: OpenBlock[]) {\n            for (mut i = open_blocks.len; i --> 1; )\n                open_blocks[i - 1].items ~= open_blocks[i];\n\n            open_blocks.shrink(1);\n            return open_blocks.only;\n        }\n\n        fn main() {\n            mut open_blocks = [\n                OpenBlock(Node(10)),\n                OpenBlock(Node(20)),\n                OpenBlock(Node(30)),\n            ];\n\n            let n = closeOpenBlocks(open_blocks);\n\n            fn sum(n: Node) {\n                mut sum = n.value;\n                n.items.each(|item| sum += item.sum());\n                return sum;\n            }\n\n            return n.sum() == 60 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_ujmEX47lP27
                                #define STR_ujmEX47lP27
static const fu::str str_ujmEX47lP27 fu_INIT_PRIORITY(1015) { "Incompatible types T for Node <-> OpenBlock 7:42+2"_fu };
                                #endif

                                #ifndef STR_UTpHhxZPP9k
                                #define STR_UTpHhxZPP9k
static const fu::str str_UTpHhxZPP9k fu_INIT_PRIORITY(1015) { "\n        enum Color { Red = 0; Green; Blue; Yellow; Cyan; Magenta };\n        enum ColorFam { Primary = 0; Secondary = 3 };\n        fn woot(c: Color or ColorFam) c.int;\n        fn main() woot(\"Yellow\") - woot(\"Secondary\");\n    "_fu };
                                #endif

                                #ifndef STR_D165vHqY9mc
                                #define STR_D165vHqY9mc
static const fu::str str_D165vHqY9mc fu_INIT_PRIORITY(1015) { "Color, ColorFam, got string 5:19+4"_fu };
                                #endif

                                #ifndef STR_xIwQfIXYUR0
                                #define STR_xIwQfIXYUR0
static const fu::str str_xIwQfIXYUR0 fu_INIT_PRIORITY(1015) { "\n        struct V { v: int };\n        fn main() {\n            using V();\n            return v;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_8bwbkqoO426
                                #define STR_8bwbkqoO426
static const fu::str str_8bwbkqoO426 fu_INIT_PRIORITY(1015) { "\n        struct vec2     { x: f32; y: f32 };\n        struct Player   { position: vec2 };\n\n        fn move(ref player: Player, dist: vec2) {\n            using player.position;\n            x += dist.x;\n            y += dist.y;\n        }\n\n        fn main() {\n            mut p: Player;\n            p.move(vec2(10, 10));\n            assert(p.position.x * p.position.y == 100);\n            return 0;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_455SDML51xk
                                #define STR_455SDML51xk
static const fu::str str_455SDML51xk fu_INIT_PRIORITY(1015) { "\n        fn segfault_tryRetypingEmptyBlock(a: int)\n            = a & 1 ? a         <fail no common supertype i32 void 3:21+1>\n                    : {};       <pass/>\n                    : [];       </fail>\n        fn main() 0.segfault_tryRetypingEmptyBlock;\n    "_fu };
                                #endif

                                #ifndef STR_pZqYc6emId0
                                #define STR_pZqYc6emId0
static const fu::str str_pZqYc6emId0 fu_INIT_PRIORITY(1015) { "\n        fn varargs(a[]) a[0] + a[1];\n        fn main() varargs(1, 2) - 3;\n    "_fu };
                                #endif

                                #ifndef STR_QsKkCBM3X90
                                #define STR_QsKkCBM3X90
static const fu::str str_QsKkCBM3X90 fu_INIT_PRIORITY(1015) { "\n        fn to_debug_str(a: i32) a     * 2;\n        fn to_debug_str(b: u32) b.i32 * 3;\n\n        <alt>\n        inline                                                  ;; GNUStmtExpr\n        </alt>\n        fn inspect(.to_debug_str[] items) // <- varargs!\n        {\n            mut a = 0;\n            for (mut i = 0; i < items.len; i++)\n                a += items[i];\n\n            return a;\n        }\n\n        fn main() inspect(5.i32, 7.u32) - 31;\n    "_fu };
                                #endif

                                #ifndef STR_Sv2N8r9evO9
                                #define STR_Sv2N8r9evO9
static const fu::str str_Sv2N8r9evO9 fu_INIT_PRIORITY(1015) { "\n        fn va(args[]: i32[]) {\n            mut sum = 0;\n            for (mut i = 0; i < args.len; i++) sum += args[i];\n            return sum;\n        }\n\n        fn main() va(1, 2) - 3;\n    "_fu };
                                #endif

                                #ifndef STR_1LZrc3S45Kb
                                #define STR_1LZrc3S45Kb
static const fu::str str_1LZrc3S45Kb fu_INIT_PRIORITY(1015) { "\n        fn Stringy(i: i32) \"i:\" ~ i;\n\n        inline fn Printy(x: string): string = x;                ;; ConstCast\n        inline fn Printy(x.Stringy): string = x;                ;; PointlessLocal\n\n        fn Println(parts.Printy[]<alt>: string[..]</alt>) {\n            mut total = 0;\n            for (mut i = 0; i < parts.len; i++) total += parts[i].len;\n            return total;\n        }\n\n        fn main() Println(\"str\", 10) - 7; // 'stri:10'.len\n    "_fu };
                                #endif

                                #ifndef STR_paXAREW61Te
                                #define STR_paXAREW61Te
static const fu::str str_paXAREW61Te fu_INIT_PRIORITY(1015) { " // inline fn empty retval on autocall\n        inline fn concatable(a: bool)               a ? \"yes\" : \"no\";\n        inline fn concat(a.concatable, b: string)   a ~ b;\n        fn main()                                   concat(true, \"!\") == \"yes!\" ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_hmzfMLvHUy2
                                #define STR_hmzfMLvHUy2
static const fu::str str_hmzfMLvHUy2 fu_INIT_PRIORITY(1015) { " // inline fn empty retval on autocall\n        inline fn inl_print(a: byte)                a;          ;; PointlessLocal\n        fn inl_println(a.inl_print[]: string)       a.len;\n        fn main()                                   inl_println('a', 'b') == 2 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_j5DhuV12M25
                                #define STR_j5DhuV12M25
static const fu::str str_j5DhuV12M25 fu_INIT_PRIORITY(1015) { "\n        struct My { i: i32 };\n\n        fn test(oh: My)\n        {\n            // autocall(): never\n            let str = |my: My|: never {             ;; N_DeadConv\n                return my.i; // exits test() here\n            };\n\n            <alt>\n            let hello = \"Hello, \" ~ oh;     <alt/> // both mess up, this one emits a pointless overload,\n            let hello = oh ~ \"!\";           </alt> //  this one messes up earlier in the solver\n\n            return hello.len;\n        }\n\n        fn main() {\n            return test(My(3)) - 3;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_TK5MMVWFk2l
                                #define STR_TK5MMVWFk2l
static const fu::str str_TK5MMVWFk2l fu_INIT_PRIORITY(1015) { "\n        fn printlike(topic: string, stuff.print[]: string[..], implicit ref out: string) {\n            out ~= topic ~ \": \" ~ stuff.join() ~ '\\n';\n        }\n\n        fn main() {\n            let topic = \"A\";\n            implicit mut out: string;\n            printlike(:topic, \"Hello, \", \"World\", \"!\");\n            return out == \"A: Hello, World!\\n\" ? 0 : 1         ;; PointlessLocal\n        }\n    "_fu };
                                #endif

                                #ifndef STR_X3hO7kdDKai
                                #define STR_X3hO7kdDKai
static const fu::str str_X3hO7kdDKai fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut out: string;                                    ;; PointlessLocal\n            fn lazywarn(prefix: string, inline stuff.print[]: string[..]) {\n                out ||= prefix ~ stuff.join();\n            }\n\n            mut once = 0;\n            fn once(str: string) {\n                once++;\n                return str;\n            }\n\n            lazywarn(once(\"Hello\"), \", \", \"World\", \"!\", prefix: \"X: \");\n            lazywarn(prefix: \"Y: \", once(\"Hello\"), \"!\");\n\n            return out == \"X: Hello, World!\" && once == 1 ? 0 : 1\n        }\n    "_fu };
                                #endif

                                #ifndef STR_oEXTexNjPU2
                                #define STR_oEXTexNjPU2
static const fu::str str_oEXTexNjPU2 fu_INIT_PRIORITY(1015) { "\n        fn ifThenElse(inline cond, inline cons, inline alt)\n            cond ? cons : alt;\n\n        fn main() {\n            mut cond = 0;\n            ifThenElse(cond++,\n                { return 10; },\n                { return cond == 1 ? 0 : 100; });\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Yfc6HoSAQXa
                                #define STR_Yfc6HoSAQXa
static const fu::str str_Yfc6HoSAQXa fu_INIT_PRIORITY(1015) { "\n        fn not_ambig !T(ref sum!: i32,\n            <alt>\n            inline                                              ;; GNUStmtExpr\n            </alt>\n            v[]: T[])\n        {\n            fn acc(inline x: string)    sum += x.len;\n            fn acc(inline x: i32)       sum += x;\n\n            shadow let v = v; for (mut i = 0; i < v.len; i++) acc(v[i]);\n            return sum;\n        }\n\n        fn not_ambig !T(ref sum: i32, a: i32, b: string) sum += (a + b.len);\n        fn not_ambig !T(ref sum: i32, a: string, b: i32) sum += (a.len + b);\n\n        fn main() {\n            mut sum = 0;\n\n            let a = not_ambig(:sum, 1, \"ab\");\n            let b = not_ambig(:sum, \"bc\", 2);\n            let c = not_ambig(:sum, \"abc\", \"de\");\n            let d = not_ambig(:sum, 3, 3);\n            let e = not_ambig(:sum, \"abcdef\",\n                <fail bad call to not_ambig (23:21+9|25:21+9)>\n                                     'g'); <pass/>\n                                     \"g\"); </fail>\n\n            return a == 3 && b == 7 && c == 12 && d == 18 && e == 25 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_CzkBvOQW0e1
                                #define STR_CzkBvOQW0e1
static const fu::str str_CzkBvOQW0e1 fu_INIT_PRIORITY(1015) { "\n        fn count_args!T (\n            <alt>\n            inline\n            </alt>\n            v[]: T[]) = v.len;\n\n        fn main() = count_args(\n            hello?: \"ignore me\",\n            1, 2, 3,\n            world?: \"ignore me too\")\n                == 3 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_4UKyyw3dWM1
                                #define STR_4UKyyw3dWM1
static const fu::str str_4UKyyw3dWM1 fu_INIT_PRIORITY(1015) { "optional argument ambiguity 6:21+10"_fu };
                                #endif

                                #ifndef STR_TXa97AP04yf
                                #define STR_TXa97AP04yf
static const fu::str str_TXa97AP04yf fu_INIT_PRIORITY(1015) { "\n        inline fn descend_a(ref data: i32[], offset: i32, implicit ref TWO: i32) {\n            return TWO * will_relax_args_a(data, offset + 1);\n        }\n\n        noinline fn will_relax_args_a(ref data: i32[], offset: i32, implicit ref THREE: i32) {\n            if (offset < data.len) {\n                if (offset & 1)\n                    return descend_b(data, offset);\n        <alt>\n                if (offset & 2)\n                    return 2 * will_relax_args_a(data, offset + 1);\n        </alt>\n                return descend_a(:data, :offset);\n            }\n\n            return THREE * offset;\n        }\n\n        noinline fn will_relax_args_b(ref data: i32[], offset: i32, implicit ref FOUR: i32) {\n            if (offset < data.len) {\n                if (offset & 1)\n                    return descend_a(data, offset);\n        <alt>\n                if (offset & 2)\n                    return 5 * will_relax_args_b(data, offset + 1);\n        </alt>\n                return descend_b(:data, :offset);\n            }\n\n            return FOUR * offset;\n        }\n\n        inline fn descend_b(ref data: i32[], offset: i32, implicit ref FIVE: i32) {\n            return FIVE * will_relax_args_b(data, offset + 1);\n        }\n\n        fn main() {\n            implicit mut TWO    = 2;\n            implicit mut THREE  = 3;\n            implicit mut FOUR   = 4;\n            implicit mut FIVE   = 5;\n\n            mut data = [ 0, 0, 0, 0, 0 ];\n            let res = descend_b(data, 0);\n            return res == 10000 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_PbyaJDIM27e
                                #define STR_PbyaJDIM27e
static const fu::str str_PbyaJDIM27e fu_INIT_PRIORITY(1015) { "\n        struct Token { index: i32 };\n        struct Node  { token: Token };\n        <split/>\n        fn HERE(t.token<alt>: Token</alt>) t.index * 11;\n        <split/>\n        fn main = HERE(Node(Token(3))) - 33;\n    "_fu };
                                #endif

                                #ifndef STR_3xsNUg8LFod
                                #define STR_3xsNUg8LFod
static const fu::str str_3xsNUg8LFod fu_INIT_PRIORITY(1015) { "\n        struct Token { index: i32 };\n        struct Node  { token: Token };\n    "_fu };
                                #endif

                                #ifndef STR_PQlTFCtv5Qk
                                #define STR_PQlTFCtv5Qk
static const fu::str str_PQlTFCtv5Qk fu_INIT_PRIORITY(1015) { "\n        fn HERE(t.token<alt>: _0::Token</alt>) t.index * 11;\n    "_fu };
                                #endif

                                #ifndef STR_I2x6OzYltAf
                                #define STR_I2x6OzYltAf
static const fu::str str_I2x6OzYltAf fu_INIT_PRIORITY(1015) { "\n        fn main = _1::HERE(_0::Node(_0::Token(3))) - 33;\n    "_fu };
                                #endif

                                #ifndef STR_2hj4R7Qde66
                                #define STR_2hj4R7Qde66
static const fu::str str_2hj4R7Qde66 fu_INIT_PRIORITY(1015) { "\n        struct A { a: i32 };\n        fn hello(.a: i32) a;\n        fn world(a.a: i32) a;\n        fn main() A(0).hello + A(0).world;\n    "_fu };
                                #endif

                                #ifndef STR_sRf1NjrYJw3
                                #define STR_sRf1NjrYJw3
static const fu::str str_sRf1NjrYJw3 fu_INIT_PRIORITY(1015) { "\n        fn fn_v(fn, v) fn(v);\n        struct XY { x: i32; y: i32; };  // fields weren't visible to addroffns\n        fn main() {\n            let v = XY(11, 13);\n            return fn_v(.x, v) + fn_v(.y, v) - 24;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_CPk75RdQt8i
                                #define STR_CPk75RdQt8i
static const fu::str str_CPk75RdQt8i fu_INIT_PRIORITY(1015) { "\n        fn fn_v(x, v) x(v);             // same but name conflict - x arg and .x field\n        struct XY { x: i32; y: i32; };\n        fn main() {\n            let v = XY(11, 13);\n            return fn_v(.x, v) + fn_v(.y, v) - 24;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_X9dvS4NfKil
                                #define STR_X9dvS4NfKil
static const fu::str str_X9dvS4NfKil fu_INIT_PRIORITY(1015) { "\n        fn fn_w(x, y) x(y);             // same thing but\n        fn fn_v(y, x) fn_w(fn y, x);    // extra nasty\n        struct XY { x: i32; y: i32; };\n        fn main() {\n            let v = XY(11, 13);\n            return fn_v(.x, v) + fn_v(.y, v) - 24;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_n3LHxHnLmGi
                                #define STR_n3LHxHnLmGi
static const fu::str str_n3LHxHnLmGi fu_INIT_PRIORITY(1015) { "\n        fn woot(x: int) x + 5;\n    <alt>\n        let what = .woot;   <alt/>\n        let what = fn woot; </alt>\n        fn main() (-5).what;\n    "_fu };
                                #endif

                                #ifndef STR_gyRCVMTxbz4
                                #define STR_gyRCVMTxbz4
static const fu::str str_gyRCVMTxbz4 fu_INIT_PRIORITY(1015) { "\n        fn identity(x) x;\n        fn main() {\n            fn outer(depth1) {\n                let sum = depth1; return identity(|| sum);\n            }\n            let sum = 0; return outer(sum);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_bNJsPndhUC5
                                #define STR_bNJsPndhUC5
static const fu::str str_bNJsPndhUC5 fu_INIT_PRIORITY(1015) { "\n        fn identity(x) x;\n        fn test(depth0) {\n            fn outer(depth1) {\n                let sum = depth1; inline fn lambda1() sum; return identity(fn lambda1);\n            }\n            let sum = depth0; inline fn lambda0() sum; return outer(fn lambda0);\n        }\n        fn main() test(0);\n    "_fu };
                                #endif

                                #ifndef STR_KRst2x4rU82
                                #define STR_KRst2x4rU82
static const fu::str str_KRst2x4rU82 fu_INIT_PRIORITY(1015) { "\n        fn test(depth0) {\n            fn identity(x) x;\n            fn outer(depth1) {\n                fn inner(depth2) {\n                    let sum = depth2; inline fn lambda2() sum; return identity(fn lambda2);\n                }\n                let sum = depth1; inline fn lambda1() sum; return inner(fn lambda1);\n            }\n            let sum = depth0; inline fn lambda0() sum; return outer(fn lambda0);\n        }\n        fn main() test(0);\n    "_fu };
                                #endif

                                #ifndef STR_C0tPiZpvzJ5
                                #define STR_C0tPiZpvzJ5
static const fu::str str_C0tPiZpvzJ5 fu_INIT_PRIORITY(1015) { "\n        fn test(depth0)\n        {\n            fn first(depth1) {\n                fn first_inner(depth2) {\n                    let sum = depth0 + depth1 + depth2;\n                    return sum;\n                }\n\n                let sum = depth0 + depth1;\n                return first_inner(|| sum);                     ;; DuplicateFunctions\n            }\n\n            fn second(depth1) {\n                fn second_inner(depth2) {\n                    let sum = depth0 + depth1 + depth2;\n                    return sum + first(|| sum);\n                }\n\n                let sum = depth0 + depth1;\n                return second_inner(|| sum);\n            }\n\n            let sum = depth0 + depth0;\n            return second(|| sum);\n        }\n\n        fn main() test(0);\n    "_fu };
                                #endif

                                #ifndef STR_F1SYSKtXa4h
                                #define STR_F1SYSKtXa4h
static const fu::str str_F1SYSKtXa4h fu_INIT_PRIORITY(1015) { "\n        inline fn parseStuff(x: i32) descend(x);                ;; GNUStmtExpr\n\n        inline fn descend(x: i32) {\n            fn inner() x & 1 ? parseStuff(x / 2) : x;\n            return inner();\n        }\n\n        fn main() parseStuff(5) == 2 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_H9Ej1K3v8xc
                                #define STR_H9Ej1K3v8xc
static const fu::str str_H9Ej1K3v8xc fu_INIT_PRIORITY(1015) { "COMPILER BUG host_args.len != args.len"_fu };
                                #endif

                                #ifndef STR_gMoCsPy5gYf
                                #define STR_gMoCsPy5gYf
static const fu::str str_gMoCsPy5gYf fu_INIT_PRIORITY(1015) { "\n        fn use_a(implicit a: i32) a * a;\n        fn use_b(implicit b: i32) b * b;\n        fn use_c(implicit c: i32) c * c;\n\n        <alt>\n        inline </alt>\n        fn parseStuff(x: i32) {\n            fn doStuff(y: i32) doSomething(y * y);\n            return doStuff(x * x);\n        }\n\n        <alt>\n        inline </alt>\n        fn doSomething(x: i32) {\n            fn doSomething_inner(y: i32) y * use_a * descend(y * y);\n            return doSomething_inner(x * x);\n        }\n\n        <alt>\n        inline </alt>\n        fn descend(x: i32) { // <- x here\n            fn descend_inner(y: i32)\n                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?\n                      : doSomethingElse(y * y) * use_c;\n\n            return descend_inner(x * x);\n        }\n\n        <alt>\n        inline </alt>\n        fn doSomethingElse(x: i32) {\n            fn doSomethingElse_inner(y: i32) y * use_b;\n            return doSomethingElse_inner(x * x);\n        }\n\n        fn main() {\n            let implicit a = 0;\n            let implicit b = 0;\n            let implicit c = 0;\n            return parseStuff(0);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_KKalcDl25ri
                                #define STR_KKalcDl25ri
static const fu::str str_KKalcDl25ri fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut stuff = \"\";\n            fn doThing(thing)\n                try         stuff = \"continue \" ~ thing();\n                catch (e)   stuff = \"throw \" ~ e;\n\n            :DO_THING doThing: ||\n            {\n                fn cannotDoThing(inline reason: string)\n                    continue :DO_THING reason;\n            <alt>\n                cannotDoThing(throw(\"Reason\"));\n            };\n            return stuff.len - 12; // \"throw Reason\"\n            <alt/>\n                cannotDoThing(\"Reason\");\n            };\n            return stuff.len - 15; // \"continue Reason\"\n            </alt>\n        }\n    "_fu };
                                #endif

                                #ifndef STR_LCl7QVCmrxl
                                #define STR_LCl7QVCmrxl
static const fu::str str_LCl7QVCmrxl fu_INIT_PRIORITY(1015) { "\n        fn nested(ref index: i32)\n            return index++ && [];\n\n        fn Lifetime_each(ref lifetime: i32[], visit)\n            for (mut i = lifetime.len; i --> 0; )\n                visit(nested(lifetime[i]));\n\n        fn Lifetime_allowsMutrefReturn(ref lifetime: i32[])\n            Lifetime_each(:lifetime): |t|\n                return t;\n\n        fn main() {\n            mut arr: i32[] = [ 5, -2 ];\n            Lifetime_allowsMutrefReturn(arr);\n\n            mut sum = 0;\n            for (mut i = 0; i < arr.len; i++) sum += arr[i];\n            return sum - 4;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_NpS9n79rVog
                                #define STR_NpS9n79rVog
static const fu::str str_NpS9n79rVog fu_INIT_PRIORITY(1015) { "\n        fn Incr(ref x: i32) ++x;\n\n        struct N { v: i32 };\n\n        <alt>\n        inline\n        </alt>\n        fn +=(ref a: N, b: i32) {\n            a.v = a.v * 10 + b;\n            return a;\n        }\n\n        fn main() {\n            mut c: i32;\n            mut a: N;\n            (a = N(c.Incr)) += c.Incr;\n            return a.v - 21;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_KpiqFI4OUp4
                                #define STR_KpiqFI4OUp4
static const fu::str str_KpiqFI4OUp4 fu_INIT_PRIORITY(1015) { "\n        struct Lifetime { regions: i32[] };\n\n        let Region_STATIC = 0;\n\n        fn Region_asLocal(r: i32) r > 1000 ? r - 1000 : 0;\n\n        fn Lifetime_each !<S, A, L, E>(lt.regions,\n            static: S = [], argidx: A = [],\n            local:  L = [], else:   E = [])\n        {\n            for (mut i = 0; i < lt.len; i++)\n            {\n                let r = lt[i];\n\n                :ELSE {                                         ;; Goto\n                    if (r == Region_STATIC)\n                        S -> [] ? { break :ELSE; }\n                                : static(i?: i);\n                    else if (let locid = Region_asLocal(r))\n                        L -> [] ? { break :ELSE; }\n                                : local(:locid, i?: i);\n                    else\n                        A -> [] ? { break :ELSE; }\n                                : argidx(r, i?: i);\n\n                    continue;\n                }\n\n                else(i?: i);\n            }\n        }\n\n        fn isMovedFrom(locid: i32) locid & 1;\n\n    <alt>\n        fn main() {\n    <alt/>\n        fn main() = test();\n        fn test() {\n    </alt>\n            mut lt = Lifetime([ 1001, <alt>1002<alt/>1</alt>, 1003 ]);\n            mut locids = 0;\n            mut force_mut = true;\n\n            Lifetime_each(lt,\n                local: |locid| {\n                    if (!locid.isMovedFrom) {\n                        force_mut = false;\n                        break;\n                    }\n\n                    locids += locid;\n                },\n                else: || {\n                    force_mut = false;\n                    break;\n                });\n\n            return force_mut == false && locids == 1 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_B2muxAIeNCa
                                #define STR_B2muxAIeNCa
static const fu::str str_B2muxAIeNCa fu_INIT_PRIORITY(1015) { "\n        struct Overload { name: string };\n        struct Target { globid: i32 };\n\n        fn solve(overloads: Overload[], target: Target, BUG)\n        {\n            using fn GET(t: Target)\n                overloads[t.globid];\n\n            fn BUG2(<alt>inline </alt>topic: string)\n                BUG(topic);\n\n            fn relaxBlockVar(t: Target)\n                BUG2(t.name.BUG2);\n\n            return target.relaxBlockVar();\n        }\n\n        fn main() {\n            try\n                solve([ Overload(\"hello\") ], Target(0), fn throw);\n            catch (e)\n                return e == \"hello\" ? 0 : 1;\n\n            return 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_WHC3oHq5Mf2
                                #define STR_WHC3oHq5Mf2
static const fu::str str_WHC3oHq5Mf2 fu_INIT_PRIORITY(1015) { "\n        let SELF_TEST = <alt>true<alt/>false</alt>;\n\n        inline fn LT_each(lt: i32[..], each)\n            for (mut i = 0; i < lt.len; i++)\n                each(lt[i]);\n\n        lax fn assertPathsValid(lax lt: i32[..], lax minPathDepth)\n            if (SELF_TEST)\n                lt.LT_each: |value: i32|\n                    if (value < minPathDepth)\n                        throw(\"BAD: \" ~ value);\n\n        inline fn LT_op(lt: i32[], each, minPathDepth! = 1) {\n            mut result: i32[];\n\n            lt.LT_each: |value: i32| {\n                let result0 = result.len;\n                each(:result, :value);\n                assertPathsValid(result[result0 ..], :minPathDepth);\n            }\n\n            return result;\n        }\n\n        fn LT_double(lt: i32[])\n            lt.LT_op(minPathDepth: 2): |value, ref result|  <alt>\n                result ~= value * 2;                        <alt/>\n              { result ~= value * 2; }                      </alt>\n\n        fn main() = [ 1, 2, 3 ].LT_double == [ 2, 4, 6 ] ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_yY9XgygFmdj
                                #define STR_yY9XgygFmdj
static const fu::str str_yY9XgygFmdj fu_INIT_PRIORITY(1015) { "\n        fn solve(ref TRACE_out: string, ref effect: int) {\n            fn doTrySpecialize(what) {\n                defer TRACE_out ~= \"<\" ~ effect++ ~ \">\";\n                what();\n            }\n\n            doTrySpecialize(|| {});\n        }\n\n        fn main() {\n            mut TRACE_out = \"\";\n            mut effect = 10;\n            solve(:TRACE_out, :effect);\n            return TRACE_out == \"<10>\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_CVgFWE9Jtj0
                                #define STR_CVgFWE9Jtj0
static const fu::str str_CVgFWE9Jtj0 fu_INIT_PRIORITY(1015) { "\n        fn TRACE_BRACKET(x: bool, inline msg: string)\n            x && { shadow let msg = msg; msg };                 ;; PointlessLocal\n\n        fn main() TRACE_BRACKET(true, \"hello\" ~ 0) == \"hello0\" ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_V6ekLRJvGDi
                                #define STR_V6ekLRJvGDi
static const fu::str str_V6ekLRJvGDi fu_INIT_PRIORITY(1015) { "\n        fn TRACE_BRACKET(x: bool, inline msg: string)\n            x && { shadow let msg = msg; msg ~ msg };\n\n        fn main() {\n            mut count = 0;      <alt>\n            inline              <alt/>\n            noinline            </alt>\n            fn woot() \"hello\" ~ (count++);\n            let a = TRACE_BRACKET(false, woot);\n            let b = TRACE_BRACKET(true, woot);\n            return a ~ b == \"hello0hello0\" && count == 1 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_8SDD2V9Ii4l
                                #define STR_8SDD2V9Ii4l
static const fu::str str_8SDD2V9Ii4l fu_INIT_PRIORITY(1015) { "\n        struct Target { _packed: u32 }\n        inline fn globid(t: Target) i32(t._packed);\n\n        fn solve(ref TRACE_out: string, a: Target, b: Target)\n        {\n            fn TRACE_BRACKET(inline msg: string) unwrap {\n                mut len0: int;\n                defer if (TRACE_out.len > len0) {\n                    shadow let msg = msg;\n                    TRACE_out.splice(len0, 0, \"<\" ~ msg ~ \">\");\n                    TRACE_out ~= \"</\" ~ msg ~ \">\";\n                }\n            }\n\n            fn TRACE(msg: string) TRACE_out ~= msg;\n\n            fn doTrySpecialize(mut target: Target, what) {\n                mut mul = 10;\n                TRACE_BRACKET(\"Hello \" ~ (target.globid * mul++));\n                what();\n            }\n\n            doTrySpecialize(a, || {});\n            doTrySpecialize(b, || TRACE(\"World!\"));\n        }\n\n        fn main() {\n            mut TRACE_out = \"\";\n            solve(:TRACE_out, Target(1), Target(2));\n            return TRACE_out == \"<Hello 20>World!</Hello 20>\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_BABAZ1KQkse
                                #define STR_BABAZ1KQkse
static const fu::str str_BABAZ1KQkse fu_INIT_PRIORITY(1015) { "\n        struct Target { _packed: u32 }\n        inline fn globid(t: Target) i32(t._packed);\n\n        fn TRACE_BRACKET(implicit ref TRACE_out: string, inline msg: string) unwrap {\n            mut len0: int;\n            defer if (TRACE_out.len > len0) {\n                // unlike the test above, we'll inline msg twice\n                TRACE_out.splice(len0, 0, \"<\" ~ msg ~ \">\");\n                TRACE_out ~= \"</\" ~ msg ~ \">\";\n            }\n        }\n\n        fn TRACE(implicit ref TRACE_out: string, msg: string) TRACE_out ~= msg;\n\n        fn doTrySpecialize(mut target: Target, what) {\n            mut mul = 10;\n            TRACE_BRACKET(\"Hello \" ~ (target.globid * mul++));\n            what();\n        }\n\n        fn solve(a: Target, b: Target) {\n            doTrySpecialize(a, || {});\n            doTrySpecialize(b, || TRACE(\"World!\"));\n        }\n\n        fn main() {\n            implicit mut TRACE_out = \"\";\n            solve(          <fail wrong number of arguments 29:13+5>\n                :TRACE_out, <pass/></fail>\n                Target(1), Target(2));\n            return TRACE_out == \"<Hello 20>World!</Hello 22>\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_klfQNVlvksd
                                #define STR_klfQNVlvksd
static const fu::str str_klfQNVlvksd fu_INIT_PRIORITY(1015) { "Inline arguments can only be inlined once 10:37+3"_fu };
                                #endif

                                #ifndef STR_z7l1sNrBGf7
                                #define STR_z7l1sNrBGf7
static const fu::str str_z7l1sNrBGf7 fu_INIT_PRIORITY(1015) { "\n        fn incr_do_incr(ref count: i32, inline do) {\n            count++;\n            count += do;\n            count++;\n        }\n\n        fn main() {\n            mut count = 0;\n            try         incr_do_incr(count, throw(\"what\"));\n            catch (e)   count += 10 * e.len;\n            return count - 41;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_uRem5Bd2aBh
                                #define STR_uRem5Bd2aBh
static const fu::str str_uRem5Bd2aBh fu_INIT_PRIORITY(1015) { "\n        struct Struct { items: Target[] };\n        struct Target { index: i32 };\n        struct Scope { type: Type };\n        struct Type { canon: i32 };\n\n        noinline fn doNothingCreatively(_types: Struct[], _out: string, _type: Type)\n        {\n            fn zeroInit(lax target: Target)\n                return [];\n\n            noinline fn noInline(type, ref out): string =\n                return type && inlineOuter(type, :out);\n\n            fn inlineOuter(inline type, ref out): string = {\n                inlineInner(_types[type.canon], :out);\n                return [];\n            }\n\n            fn inlineInner(inline s, ref out) {\n                let fields = s.items;\n                for (mut i = 0; i < fields.len; i++) {\n                    lax let field = zeroInit(fields[i]);\n                    lax let annot = noInline(field.type, :out);\n                }\n            }\n\n            fn cgCopyOrMove(type: Type, ref out: string)\n                inlineOuter(type, :out);\n\n            return cgCopyOrMove(_type, _out);\n        }\n\n        fn main() {\n            mut structs = [ Struct() ];\n            mut out: string;\n            doNothingCreatively(structs, out, []);\n            return out.len;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_QAPUsKIWW8g
                                #define STR_QAPUsKIWW8g
static const fu::str str_QAPUsKIWW8g fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut error = \"Hello\";\n            fn matchFail(inline reason: string)\n                if (error) error ~= reason || throw(\"-\");\n\n            matchFail(\", w\" ~ 0 ~ \"rld!\");\n            return error == \"Hello, w0rld!\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_jFzZNxoLfJ4
                                #define STR_jFzZNxoLfJ4
static const fu::str str_jFzZNxoLfJ4 fu_INIT_PRIORITY(1015) { "\n        noinline fn orNodeTypeExpectsRefGotValue(ref error!: string, args?: int[]) {\n            fn matchFail(inline reason: string)\n                if (error) error ~= reason || throw(\"-\");\n\n            for (mut i = 0; i < args.len; i++) {\n                mut arg = args[i];\n                if (!arg) matchFail(\", w\" ~ i ~ \"rld!\");\n            }\n\n            return [];\n        }\n\n        fn main() {\n            mut error = \"Hello\";\n            orNodeTypeExpectsRefGotValue(:error, [ 0 ]);\n            return error == \"Hello, w0rld!\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_njVzGXd7jhe
                                #define STR_njVzGXd7jhe
static const fu::str str_njVzGXd7jhe fu_INIT_PRIORITY(1015) { "\n        fn letdefUnwrapsDuringMCOM(\n            ref error: string, ref effect: int,\n            a: string, b: string, c: string) {\n    <alt>\n            fn inl4(inline err: string) if (error) error ~= err;\n            fn inl3(inline err: string) inl4(:err);\n            fn inl2(inline err: string) inl3(:err);\n            fn inl1(inline err: string) inl2(:err);\n    <alt/>\n            fn inl4(inline err) if (error) error ~= err;\n            fn inl3(inline err) inl4(:err);\n            fn inl2(inline err) inl3(:err);\n            fn inl1(inline err) inl2(:err);\n    </alt>\n            inl1(\"ello\");\n            inl2({ effect++; a ~ b });\n            inl3(\"World\");\n            inl4(c);\n        }\n\n        fn main() {\n            mut error: string;\n            mut effect: int;\n            letdefUnwrapsDuringMCOM(:error, :effect, \",\", \" \", \"!\");\n            if (effect || error) return 101;\n\n            error = \"H\";\n            letdefUnwrapsDuringMCOM(:error, :effect, \",\", \" \", \"!\");\n            return effect == 1 && error == \"Hello, World!\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_MGF6lI4iMWh
                                #define STR_MGF6lI4iMWh
static const fu::str str_MGF6lI4iMWh fu_INIT_PRIORITY(1015) { "\n        inline fn test(inline hey: int) hey;\n        fn main() 1.test && 0;\n    "_fu };
                                #endif

                                #ifndef STR_Wwp9jmgCiN4
                                #define STR_Wwp9jmgCiN4
static const fu::str str_Wwp9jmgCiN4 fu_INIT_PRIORITY(1015) { "\n        fn ALWAYS_TRUE(inline assertion) assertion;\n\n        fn solve(ref overloads: int[]) {\n            fn GET(t: int)\n                t >= 0 && t < overloads.len && overloads[t];\n\n            fn _current_fn_eachArg(visit) {\n                for (mut i = 0; i < overloads.len; i++) {\n                    let t = overloads[i];\n                    if (t.GET.ALWAYS_TRUE)\n                        visit(i?: i);\n                }\n            }\n\n            mut mask = u32();\n            _current_fn_eachArg: |i| mask |= (1 << (i.u32 & 31));\n            return mask;\n        }\n\n        fn main() solve([ 1, 2 ]) == 1 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_WENk3Xxqsm7
                                #define STR_WENk3Xxqsm7
static const fu::str str_WENk3Xxqsm7 fu_INIT_PRIORITY(1015) { "\n        fn unwrapCall(what) unwrap { defer what() }\n\n        fn main() {\n            mut res = 0;\n            unwrapCall(|| res++);\n            return res;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_H5nImr7Wxsi
                                #define STR_H5nImr7Wxsi
static const fu::str str_H5nImr7Wxsi fu_INIT_PRIORITY(1015) { "\n        fn unwrapCall(what) unwrap { defer what() }\n\n        fn main() {\n            mut res = -1;\n            { unwrapCall(|| res++); }\n            return res;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_l7z989jS39c
                                #define STR_l7z989jS39c
static const fu::str str_l7z989jS39c fu_INIT_PRIORITY(1015) { "\n        fn unwrapCall(what) unwrap { defer what() }\n\n        fn main() {\n            mut res = -1; <fail unwrapCall as a value 6:36+10 wrap in block>\n            fn trackVarUsage(what) unwrapCall(fn what);             <pass/>\n            fn trackVarUsage(what) { unwrapCall(fn what); }         </fail>\n            trackVarUsage(|| res++);\n            return res;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_YpPNUYLFQr7
                                #define STR_YpPNUYLFQr7
static const fu::str str_YpPNUYLFQr7 fu_INIT_PRIORITY(1015) { "                                  <alt>\n        fn sA(_: $T) struct { hey: $T; };   <alt/>\n        fn sA(type T) struct { hey: T; };   <alt/>\n        struct sA(_: $T) { hey: $T; };      <alt/>\n        struct sA(type T) { hey: T; };      </alt>\n\n        fn fA(a: $T): sA($T) = [ a + 2 ];\n        fn main() 1.fA.hey - 3;\n    "_fu };
                                #endif

                                #ifndef STR_ZzYxTZGCLJ0
                                #define STR_ZzYxTZGCLJ0
static const fu::str str_ZzYxTZGCLJ0 fu_INIT_PRIORITY(1015) { "\n        fn sB(_: $T) struct { hey: $T; };\n\n        fn fB(a: $T): sB($T) = [ a + 2 ];\n        fn main() 1.fB.hey - 1.u32.fB.hey   <fail bad call - i32 u32 5:28+1><pass/>\n                              .i32          </fail>;\n    "_fu };
                                #endif

                                #ifndef STR_zbL9jkccOaf
                                #define STR_zbL9jkccOaf
static const fu::str str_zbL9jkccOaf fu_INIT_PRIORITY(1015) { "\n        fn sB(_: $T) struct { hey: $T; };\n\n        // Prep for the thing below.\n        fn test(x) x.hey - 1;\n\n        // 'a' must be callable.\n        type a = sB(i32);\n        fn main() a(1).test;\n    "_fu };
                                #endif

                                #ifndef STR_upaoR4AKh07
                                #define STR_upaoR4AKh07
static const fu::str str_upaoR4AKh07 fu_INIT_PRIORITY(1015) { "\n        fn setupOperators(i: i32) {\n            struct BINOP { i: i32; };\n            return BINOP(:i);\n        }\n\n        fn main() setupOperators(0).i;\n    "_fu };
                                #endif

                                #ifndef STR_WhI1dfS53Jk
                                #define STR_WhI1dfS53Jk
static const fu::str str_WhI1dfS53Jk fu_INIT_PRIORITY(1015) { "\n        fn sB(_: $T) struct { hey: $T; };\n\n        fn setupOperators(i: i32) {\n            struct BINOP { i: sB(i32); };\n            mut s: sB(i32) = [ i ];\n            return BINOP(s);\n        }\n\n        fn main() setupOperators(0).i.hey;\n    "_fu };
                                #endif

                                #ifndef STR_Y01Swsdnopf
                                #define STR_Y01Swsdnopf
static const fu::str str_Y01Swsdnopf fu_INIT_PRIORITY(1015) { "\n        fn Hey = struct { i: i32 }; // fn Hey generated nonsense code\n        fn get(s: Hey) s.i;\n    "_fu };
                                #endif

                                #ifndef STR_1kyksorLMu8
                                #define STR_1kyksorLMu8
static const fu::str str_1kyksorLMu8 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut s: _0::Hey;\n            return s.get();\n        }\n    "_fu };
                                #endif

                                #ifndef STR_O4MlfWNmNUg
                                #define STR_O4MlfWNmNUg
static const fu::str str_O4MlfWNmNUg fu_INIT_PRIORITY(1015) { "\n        fn Hey(_: $T) = struct { i: $T };\n        fn get(s) s.i;\n    "_fu };
                                #endif

                                #ifndef STR_qavnxcj2Sh3
                                #define STR_qavnxcj2Sh3
static const fu::str str_qavnxcj2Sh3 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut s: _0::Hey(i32);\n            return s.get(); // get(): wasn't visible, the struct didnt remember its template origin module.\n        }\n    "_fu };
                                #endif

                                #ifndef STR_nCYEnU0rgM6
                                #define STR_nCYEnU0rgM6
static const fu::str str_nCYEnU0rgM6 fu_INIT_PRIORITY(1015) { "\n        fn Hey(_: $T) = struct { v: $T };\n    "_fu };
                                #endif

                                #ifndef STR_WEyM5y8zG87
                                #define STR_WEyM5y8zG87
static const fu::str str_WEyM5y8zG87 fu_INIT_PRIORITY(1015) { "\n        fn unwrap(h: _0::Hey(i32)) = h.v * 10;\n    "_fu };
                                #endif

                                #ifndef STR_IbGrSLMPJph
                                #define STR_IbGrSLMPJph
static const fu::str str_IbGrSLMPJph fu_INIT_PRIORITY(1015) { "\n        fn wrap(v: i32): _0::Hey(i32) = [ v + 3 ];\n    "_fu };
                                #endif

                                #ifndef STR_usDEG4ebjd0
                                #define STR_usDEG4ebjd0
static const fu::str str_usDEG4ebjd0 fu_INIT_PRIORITY(1015) { "\n        fn main() = _1::unwrap(_2::wrap(4)) - 70;\n    "_fu };
                                #endif

                                #ifndef STR_crCciuTsJB9
                                #define STR_crCciuTsJB9
static const fu::str str_crCciuTsJB9 fu_INIT_PRIORITY(1015) { "\n        fn Hello(_: $T) struct { world: $T };\n    "_fu };
                                #endif

                                #ifndef STR_39HKALOxQj3
                                #define STR_39HKALOxQj3
static const fu::str str_39HKALOxQj3 fu_INIT_PRIORITY(1015) { "\n        fn getHello(x: i32): _0::Hello(i32) = [ x * x ];\n    "_fu };
                                #endif

                                #ifndef STR_GQ9I53Gj8Ng
                                #define STR_GQ9I53Gj8Ng
static const fu::str str_GQ9I53Gj8Ng fu_INIT_PRIORITY(1015) { "\n        fn hello(x: i32) _1::getHello(x + 3);\n    "_fu };
                                #endif

                                #ifndef STR_0wNrsWbvFgk
                                #define STR_0wNrsWbvFgk
static const fu::str str_0wNrsWbvFgk fu_INIT_PRIORITY(1015) { "\n        fn main() _2::hello(2).world - 25;\n    "_fu };
                                #endif

                                #ifndef STR_Onxhzl01ASb
                                #define STR_Onxhzl01ASb
static const fu::str str_Onxhzl01ASb fu_INIT_PRIORITY(1015) { "\n        fn sB(_: $T) struct { hey: $T; };\n\n        // Pattern & partial spec, how?\n        fn test(x: sB($T)): $T = x.hey - 1;\n\n        <alt>\n        type a = sB(i32);\n        fn main() a(1).test;\n        <alt/>\n        fn main() sB(i32)(1).test;\n        </alt>\n    "_fu };
                                #endif

                                #ifndef STR_AHJUfbLvUrh
                                #define STR_AHJUfbLvUrh
static const fu::str str_AHJUfbLvUrh fu_INIT_PRIORITY(1015) { "\n        fn M(lax k: $K, lax v: $V) =\n            struct { k: $K; v: $V };\n        <split/>\n\n        <alt>\n        fn add(a: M($K, $V), b: M($K, $V)): M($K, $V) = <alt/>\n        type Mu32 = M(u32, u32);\n        fn add(a: Mu32, b: Mu32): Mu32 =                </alt>\n            [ a.k + b.k, a.v + b.v ];\n\n        fn incr_by(ref a: $T, b: $T) =\n            a = add(a, b);\n\n        fn K(_: $K) = M($K, u32);\n        fn KK(k: $K, v: u32): K($K) = [ k, v ];\n        <split/>\n        fn V(_: $V) = M(u32, $V);\n        fn VV(k: u32, v: $V): V($V) = [ k, v ];\n        <split/>\n\n        fn main() {\n            mut a = KK(0x1, 2);\n            mut b = VV(3, 0x4);\n\n            a.incr_by(b);\n            b.incr_by(a);\n            return b.k * 100 + b.v == 710 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_2kr5mKkGXgg
                                #define STR_2kr5mKkGXgg
static const fu::str str_2kr5mKkGXgg fu_INIT_PRIORITY(1015) { "\n        fn Hey(_: $T) struct { hey: $T; };\n\n        fn hello(x: i32) x * 10;\n        fn hello(x: Hey(i32)) x.hey * 100;\n        fn hello(x: Hey($T)) case ($T.is::unsigned) x.hey * 1000;\n\n        fn main() hello(1)\n                + hello([ 1 ]   => Hey(i32))\n                + hello([ 0x1 ] => Hey(u32)).i32\n                    - 1110;\n    "_fu };
                                #endif

                                #ifndef STR_p061OjMME72
                                #define STR_p061OjMME72
static const fu::str str_p061OjMME72 fu_INIT_PRIORITY(1015) { "\n        fn Hey(_: $T) struct { hey: $T };\n\n        fn main() {\n            using let _ = Hey(i32[]);\n            return hey.len;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_sZHT5tWLvie
                                #define STR_sZHT5tWLvie
static const fu::str str_sZHT5tWLvie fu_INIT_PRIORITY(1015) { "\n        fn Hey(type T) struct { hey: T };\n\n        fn main() {\n            using let _ = Hey(i32[]);\n            return hey.len;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_DMs69K9lwB6
                                #define STR_DMs69K9lwB6
static const fu::str str_DMs69K9lwB6 fu_INIT_PRIORITY(1015) { "\n        fn Hey !T(<alt>lax _: T<alt/>type T</alt>)\n            case (T.is::arithmetic) = struct { hello: T };\n            default                 = struct { world: T };\n\n        fn main() {\n            using let _a = Hey(i32);\n            using let _b = Hey(i32[]);\n            return hello + world.len;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_8sVW4PtPpLg
                                #define STR_8sVW4PtPpLg
static const fu::str str_8sVW4PtPpLg fu_INIT_PRIORITY(1015) { "\n        fn new(type T): T = [];\n        fn main() =\n            <fail arg T expects a type, got a value 2:12+3>\n            new(0)   <pass/>\n            new(i32) </fail>;\n    "_fu };
                                #endif

                                #ifndef STR_GnM25CXn0h6
                                #define STR_GnM25CXn0h6
static const fu::str str_GnM25CXn0h6 fu_INIT_PRIORITY(1015) { "\n        type A = struct { x: i32 };\n        type B = struct { y: i32 };\n        fn main() {\n            mut a: A;\n            mut b: B;\n            return a.x + b.y;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_tzNe27nPuTg
                                #define STR_tzNe27nPuTg
static const fu::str str_tzNe27nPuTg fu_INIT_PRIORITY(1015) { "\n        fn Hey(type T) {\n            <alt>\n            struct A { a: T };\n            struct B { b: T };\n            <alt/>\n            type A = struct { a: T };\n            type B = struct { b: T };\n            </alt>\n            return struct { a: A; b: B };\n        }\n\n        <alt>\n        fn fill(ref s, ref v: i32)\n            for (fieldname i: typeof(s))\n                if (typeof(s.i) -> i32)     s.i = v++;\n                else                        fill(s.i, v);\n        <alt/>\n        fn fill(ref s, ref v: i32) {\n            if (typeof(s) -> Hey(_)) {\n                fill(s.a, v);\n                fill(s.b, v);\n            }\n            else for (fieldname i: typeof(s)) {\n                s.i = v++;\n            }\n        }\n        <alt/>\n        fn fill(ref s, ref v: i32)\n        case (typeof(s) -> Hey(_)) {\n            fill(s.a, v);\n            fill(s.b, v);\n        }\n        default {\n            for (fieldname i: typeof(s))\n                s.i = v++;\n        }\n        </alt>\n\n        fn main() {\n            mut ab = Hey(i32);\n            mut v = 11;\n            fill(ab, v);\n            return ab.a.a + ab.b.b - 23;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_6ZkixeVeFZ5
                                #define STR_6ZkixeVeFZ5
static const fu::str str_6ZkixeVeFZ5 fu_INIT_PRIORITY(1015) { "\n        <fail not a type 4:23+1>\n        let  X = i32; <pass/>\n        type X = i32; </fail>\n        struct Y { x: X };\n\n        fn main() {\n            mut y = Y(1 + 2);\n            return y.x - 3;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_NYPfCtJ5tz9
                                #define STR_NYPfCtJ5tz9
static const fu::str str_NYPfCtJ5tz9 fu_INIT_PRIORITY(1015) { "\n        struct Hello { a: i32; b: i32 };\n\n        fn Wrap(type T) = struct { using v: T };\n        fn incr_a1_b2 !T(using w: Wrap(T)) =\n            T(:a + 1, :b + 2);\n\n        fn main() {\n            mut zeroes: Wrap(Hello);\n            let ones = incr_a1_b2(zeroes);\n            return ones.a * 10 + ones.b * 100 - 210;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_3p1wMhemCA0
                                #define STR_3p1wMhemCA0
static const fu::str str_3p1wMhemCA0 fu_INIT_PRIORITY(1015) { "\n        fn typeArgRename(type Outer!<Inner>)\n            case (Inner.is::primitive)\n                = Inner;\n\n        fn main() {\n            mut x: typeArgRename(\n                <fail explicitly named 7:20+13><pass/>Outer: </fail>\n                    i32);\n\n            return x;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_zIbrQJ45pa6
                                #define STR_zIbrQJ45pa6
static const fu::str str_zIbrQJ45pa6 fu_INIT_PRIORITY(1015) { "\n        struct HasData(type T) { data: T[] };\n\n        fn obfuscate !T(l.data: T[..], r.data: T[..], with_left, with_right) {\n            with_left (l0?: 0, l1?: l.len);\n            with_right(right: r[.. r.len]);\n        }\n\n        fn concatAndFlatten !T(l: HasData(T), r: HasData(T)) {\n            mut result: T[];\n            obfuscate(l, r,\n                with_left:  |l0, l1| result ~= l.data[l0 .. l1],\n                with_right: |right|  result ~= right);\n\n            return result.join(\"\");\n        }\n\n        fn main() {\n            let a: HasData(string) = [ [ \"Hello\", \", \" ] ];\n            let b: HasData(string) = [ [ \"World\", \"!\" ] ];\n\n            return concatAndFlatten(a, b).len - 13;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_wjqa1nQUglh
                                #define STR_wjqa1nQUglh
static const fu::str str_wjqa1nQUglh fu_INIT_PRIORITY(1015) { "\n        struct Sockets(type RequestHandler) {\n            req_handler: RequestHandler\n        }\n\n        fn handle_request !RH(ref sockets: Sockets(RH)) {\n            let req_handler = sockets.req_handler;\n            req_handler();\n        }\n\n        fn HTTP(request?) {\n            <fail ambig call type Sockets 2:9+6 fn HTTP 11:12+4><pass/>\n            shadow\n            </fail>\n            type HTTP = Sockets(typeof(fn request));\n            return HTTP(<alt>fn request</alt>);\n        }\n\n        fn main() {\n            mut res = -1;\n            fn handler() res++;\n            let http = HTTP(fn handler);\n            handle_request(http);\n            return res;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_cBxT6Bxdr5g
                                #define STR_cBxT6Bxdr5g
static const fu::str str_cBxT6Bxdr5g fu_INIT_PRIORITY(1015) { "\n        struct CollideEverything {}\n        noinline fn set_hash !T(ref slot: T, value: T) slot = value;\n        using fn int(_: CollideEverything) 0;\n        fn main() {\n            mut hash: CollideEverything;\n            set_hash(hash, hash);\n            return hash;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_pX5zbPjirgl
                                #define STR_pX5zbPjirgl
static const fu::str str_pX5zbPjirgl fu_INIT_PRIORITY(1015) { "\n        struct Collide {}\n        struct HK(type Hash, type Key) { hash: Hash; key: Key }\n\n        noinline fn set_hk <Hash, Key>(\n            ref a: HK(:Hash, :Key), ref b: HK(:Hash, :Key), hash: Hash, key: Key)\n        {\n            a.hash = hash;\n            b.key  = key;\n        }\n\n        using fn int(_: Collide) 2;\n        fn main() {\n            shadow type HK = HK(Hash: Collide, Key: int);\n            mut hk = HK(Collide(), 3);\n            set_hk(hk, hk, hk.hash, hk.key);\n            return hk.hash.int + hk.key - 5;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_qkXou8bcCbb
                                #define STR_qkXou8bcCbb
static const fu::str str_qkXou8bcCbb fu_INIT_PRIORITY(1015) { "\n        struct Map(type Key, type Value, type Hash) {\n            k: Key; v: Value; h: Hash\n        }\n\n        fn key !<Key>(ref map: Map(:Key, _, _)) map.k;\n\n        fn main() {\n            mut map: Map(int, u32, u64);\n            return map.key;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_yMqtjv7yE87
                                #define STR_yMqtjv7yE87
static const fu::str str_yMqtjv7yE87 fu_INIT_PRIORITY(1015) { "\n        struct SillyHash {}\n        struct Map(type Key, <fail missing type arg Value for template Map 9:21+3>\n                 type Value, <pass/></fail>type Hash = SillyHash) {}\n        inline fn set !<Key, Hash>(ref map: Map(:Key, :Hash), key: Key) return []\n\n        lax fn test(ref map)\n            for (mut i = 0; i < 10; i++)\n                map.set(i)\n\n        fn main() {\n            mut map: Map(int, int)\n            test(map)\n            return 0\n        }\n    "_fu };
                                #endif

                                #ifndef STR_z9vfpAgDiO0
                                #define STR_z9vfpAgDiO0
static const fu::str str_z9vfpAgDiO0 fu_INIT_PRIORITY(1015) { "\n        struct Hello(type T = uint) {} // missing F_TEMPLATE because of the default\n        fn zero !T(ref h: Hello(T)) T();\n        fn main() {\n            mut h_i32: Hello(i32);\n            mut h_i64: Hello(i64);\n\n            mut v_i32: i32 = h_i32.zero;\n            mut v_i64: i64 = h_i64.zero;\n            <fail incompatible T 11:23+2>\n            if (v_i64 += v_i32) <pass/>\n            if (v_i32 || v_i64) </fail> return 1;\n\n            mut hello: Hello(int);\n            return hello.zero;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_AS8Ul9ljZLg
                                #define STR_AS8Ul9ljZLg
static const fu::str str_AS8Ul9ljZLg fu_INIT_PRIORITY(1015) { "\n        struct DefaultHasher {}\n        fn hash(_: DefaultHasher, value: int) value * 10;\n        pub struct Map(type Hasher = DefaultHasher) { hasher: Hasher; data: int[] }\n        inline fn hash(ref map: Map(_), value: int) map.hasher.hash(value);\n        pub fn add(ref map: Map(_), value: int) map.data ~= map.hash(value);\n    "_fu };
                                #endif

                                #ifndef STR_CHyUsYS8m5f
                                #define STR_CHyUsYS8m5f
static const fu::str str_CHyUsYS8m5f fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut map: _0::Map();\n            map.add(10);\n            return map.data.len == 1 && map.data[0] == 100 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_fG762V2Zjkc
                                #define STR_fG762V2Zjkc
static const fu::str str_fG762V2Zjkc fu_INIT_PRIORITY(1015) { "\n        struct Map(type Key, type Hasher) { hasher: Hasher }\n        fn hash !Key(map: Map(:Key, _), key: Key) = map.hasher.hash(key)\n        fn add !Key(ref map: Map(:Key, _), key: Key) = map.hash(key)\n    <flip>\n        struct Noop {}\n        fn hash(hasher: Noop, _) = 0\n    <flip/>\n        struct Constant(c) { c: typeof(fn c) }\n        fn hash(h: Constant(_), _) {\n            let c = h.c\n            return c\n        }\n    </flip>\n        fn main() {\n            mut map: Map(u8, Constant(|| 1))\n            return map.add(2) - 1\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Tt0PZvVZrM6
                                #define STR_Tt0PZvVZrM6
static const fu::str str_Tt0PZvVZrM6 fu_INIT_PRIORITY(1015) { "\n        pub struct Map(type Key, type Hasher) { hasher: Hasher }\n        fn hash !Key(map: Map(:Key, _), key: Key) = map.hasher.hash(key)\n        pub fn add !Key(ref map: Map(:Key, _), key: Key) = map.hash(key)\n\n        pub struct Noop {}\n        fn hash(hasher: Noop, _) = 0\n\n        struct Constant(c) { c: typeof(fn c) }\n        fn hash(h: Constant(_), _) {\n            let c = h.c\n            return c\n        }\n\n        pub fn visibility_a(mut map?: Map(u8, Constant(|| 1))) = map.add(2) - 1\n    "_fu };
                                #endif

                                #ifndef STR_iq9rebitw38
                                #define STR_iq9rebitw38
static const fu::str str_iq9rebitw38 fu_INIT_PRIORITY(1015) { "\n        <alt>\n        import _0\n        fn visibility_b(mut map?: Map(u8, Noop)) = map.add(2)\n        fn main() = visibility_a() || visibility_b()\n        <alt/>\n        fn visibility_b(mut map?: _0::Map(u8, _0::Noop)) = map.add(2)\n        fn main() = _0::visibility_a() || visibility_b()\n        </alt>\n    "_fu };
                                #endif

                                #ifndef STR_QVwlv7K2xe6
                                #define STR_QVwlv7K2xe6
static const fu::str str_QVwlv7K2xe6 fu_INIT_PRIORITY(1015) { "\n        <fail List not defined 3:25+4><pass/>\n        pub </fail>\n        struct List(type X) { f: X };\n        pub fn make_list(v: int) = List(int)(v);\n    "_fu };
                                #endif

                                #ifndef STR_IwrSF5i4ILd
                                #define STR_IwrSF5i4ILd
static const fu::str str_IwrSF5i4ILd fu_INIT_PRIORITY(1015) { "\n        import _0;\n        pub fn get_f(l: List(_)) l.f;\n    "_fu };
                                #endif

                                #ifndef STR_Vwmi4MBZNQi
                                #define STR_Vwmi4MBZNQi
static const fu::str str_Vwmi4MBZNQi fu_INIT_PRIORITY(1015) { "\n        fn main() _0::make_list(0)._1::get_f();\n    "_fu };
                                #endif

                                #ifndef STR_oLE84j43Ec2
                                #define STR_oLE84j43Ec2
static const fu::str str_oLE84j43Ec2 fu_INIT_PRIORITY(1015) { "\n        struct Two(type T) { a: T; b: T };\n    "_fu };
                                #endif

                                #ifndef STR_DJsNMRKLJT5
                                #define STR_DJsNMRKLJT5
static const fu::str str_DJsNMRKLJT5 fu_INIT_PRIORITY(1015) { "\n        fn arr_of_two(x: int)               <alt>\n            : _0::Two(int)[] = [[ x, x ]];  <alt/>\n            [ _0::Two(int)(x, x) ];         </alt>\n    "_fu };
                                #endif

                                #ifndef STR_97U6ng39drg
                                #define STR_97U6ng39drg
static const fu::str str_97U6ng39drg fu_INIT_PRIORITY(1015) { "\n        import _0;\n        fn arr_of_2(x: int)                 <alt>\n            : Two(int)[] = [[ x, x ]];      <alt/>\n            [ Two(int)(x, x) ];             </alt>\n    "_fu };
                                #endif

                                #ifndef STR_rq2beZaL6J4
                                #define STR_rq2beZaL6J4
static const fu::str str_rq2beZaL6J4 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut sum = 0;\n            fn sum !T(what: T)\n                case (T -> _[])     what.each(.sum);\n                default             sum += what.a + what.b;\n\n            sum(_1::arr_of_two(2) ~ _2::arr_of_2(3));\n            return sum == 10 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_ulfuzkUO3y4
                                #define STR_ulfuzkUO3y4
static const fu::str str_ulfuzkUO3y4 fu_INIT_PRIORITY(1015) { "\n        struct Some(type T) { some: T }\n        fn wrap !T(v: T) Some(T)(v);\n\n        fn map !T(v: Some(T), fn) {\n            shadow let v =      <fail got Some(Some(string)) 16:23+4>\n                fn(v);          <pass/>\n                fn(v.some);     </fail>\n\n            return Some(typeof(v))(v);\n        }\n\n        fn Zero(sources: Some(string))\n            sources;\n\n        fn ZeroSame(alts: Some(Some(string)))\n            alts.map(.Zero);\n\n        fn ZeroSame(alts: Some(string))\n            ZeroSame(alts.map(|x| wrap(x)));\n\n        fn main() {\n            let result = ZeroSame(wrap(\"Hello, World!\"));\n            return result.some.some.len - 13;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_X3723xJC1pc
                                #define STR_X3723xJC1pc
static const fu::str str_X3723xJC1pc fu_INIT_PRIORITY(1015) { "\n        struct Some(type T) { some: T }\n        fn wrap !T(v: T) Some(T)(v);\n\n        fn map !T(v: Some(T), fn) {\n            shadow let v =      <fail got Some(Some(Some(string))) 16:23+4>\n                fn(v);          <pass/>\n                fn(v.some);     </fail>\n\n            return Some(typeof(v))(v);\n        }\n\n        fn Zero(sources: Some(Some(string)))\n            sources;\n\n        fn ZeroSame(alts: Some(Some(Some(string))))\n            alts.map(.Zero);\n\n        fn ZeroSame(alts: Some(Some(string)))\n            ZeroSame(alts.map(|x| wrap(x)));\n\n        fn main() {\n            let result = ZeroSame(wrap(wrap(\"Hello, World!\")));\n            return result.some.some.some.len - 13;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_YMumZy69Bl3
                                #define STR_YMumZy69Bl3
static const fu::str str_YMumZy69Bl3 fu_INIT_PRIORITY(1015) { "\n        struct Thing(type <Value>) { value: Value }\n\n        fn woot(ref t: Thing(int) or Thing(uint), what)\n            what(t.value);\n    "_fu };
                                #endif

                                #ifndef STR_kxAhvMgu0gf
                                #define STR_kxAhvMgu0gf
static const fu::str str_kxAhvMgu0gf fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut t = _0::Thing(int)(11);\n            t.woot(|ref v| v += v);\n            return t.value - 22;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_cCUEkbSSCRl
                                #define STR_cCUEkbSSCRl
static const fu::str str_cCUEkbSSCRl fu_INIT_PRIORITY(1015) { "\n        struct Tuple(type <Left>, type <Right>) { left: Left; right: Right }\n\n        fn woot(ref t: Tuple(<T>, Tuple(int, int)))\n            t.right.left += t.right.right;\n    "_fu };
                                #endif

                                #ifndef STR_zghXR5FT6C9
                                #define STR_zghXR5FT6C9
static const fu::str str_zghXR5FT6C9 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut t = _0::Tuple(int, _0::Tuple(int, int))(0, _0::Tuple(int, int)(2, 3));\n            t.woot();\n            return t.right.left - 5;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_r2dOk01XFK2
                                #define STR_r2dOk01XFK2
static const fu::str str_r2dOk01XFK2 fu_INIT_PRIORITY(1015) { "\n        nocopy struct NoCopy {};\n        struct Generic(type V) { vals: V[] }\n\n        struct SelfRecursive {\n            _scope:             NoCopy;\n            _conv_cache:        Generic(SelfRecursive);\n        };\n\n        fn main() {\n            mut v: SelfRecursive;\n            v._conv_cache.vals ~= v; // fail\n            return v._conv_cache.vals.len;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_riqFeS7SRy2
                                #define STR_riqFeS7SRy2
static const fu::str str_riqFeS7SRy2 fu_INIT_PRIORITY(1015) { "BUG detectRecursion no _helpers entry for SelfRecursive 3:40+1"_fu };
                                #endif

                                #ifndef STR_buGjTxntDx9
                                #define STR_buGjTxntDx9
static const fu::str str_buGjTxntDx9 fu_INIT_PRIORITY(1015) { "\n        struct List {\n            struct Item { value: int };\n            fn newItem(v: int)  Item(value);\n\n            items: Item[];\n            fn push(v: int)     items ~= newItem(v);\n            fn each(fn)         items.each: fn fn;\n        }\n\n        fn main() {\n            mut list: List;\n            list.push(3);\n            list.items ~= List.Item(5);\n            mut check = 0;\n            list.each: |item: List.Item| check += 11 * item.value;\n            return check - 88;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_VcJiiFjlogj
                                #define STR_VcJiiFjlogj
static const fu::str str_VcJiiFjlogj fu_INIT_PRIORITY(1015) { "Missing semicollon before Item 3:20+4"_fu };
                                #endif

                                #ifndef STR_QJdbu43L1kb
                                #define STR_QJdbu43L1kb
static const fu::str str_QJdbu43L1kb fu_INIT_PRIORITY(1015) { "\n        fn test(x: i32) {\n            :OUTER {\n                :INNER {\n                    if (x > 1) break :OUTER;                    ;; Goto\n                    if (x > 0) break :INNER;\n                    return 2;\n                }\n                return 1;\n            }\n            return 0;\n        }\n\n        fn main() 2.test * 11 + (1.test - 1) * 13 + (0.test - 2) * 17;\n    "_fu };
                                #endif

                                #ifndef STR_fyjAutaCroh
                                #define STR_fyjAutaCroh
static const fu::str str_fyjAutaCroh fu_INIT_PRIORITY(1015) { "\n        fn test(x: i32) {\n            return {\n                :BLOCK {\n                    if (x & 1) break :BLOCK 1;\n                    if (x & 2) return 2;\n                    3\n                }\n            };\n        }\n\n        fn main() 4.test - 5.test - 6.test; // 3-1-2\n    "_fu };
                                #endif

                                #ifndef STR_LXDfBhH4mBb
                                #define STR_LXDfBhH4mBb
static const fu::str str_LXDfBhH4mBb fu_INIT_PRIORITY(1015) { "\n        fn brkif(mut x: i32)\n        {\n            :WOOT\n            if (x & 1) {\n                if (x & 2) x++;\n                if (x & 4) break :WOOT;                         ;; Goto\n                x *= x;\n            }\n\n            return x;\n        }\n\n        fn main()\n            brkif(1) + brkif(3) * 10 + brkif(5) * 100 + brkif(9) * 1000\n                == 81541 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_B5NSNz1UKjj
                                #define STR_B5NSNz1UKjj
static const fu::str str_B5NSNz1UKjj fu_INIT_PRIORITY(1015) { "\n        fn test(a: i32) {\n            mut w = 3;\n            :OUTER w += {                                       ;; GNUStmtExpr\n                :INNER {\n                    if (a & 1)  break :INNER;\n                    else        break :OUTER;                   ;; Goto\n                };\n                5\n            };\n            return w;\n        }\n        fn main() 0.test + 1.test - 11;\n    "_fu };
                                #endif

                                #ifndef STR_AMjv7GnB8u8
                                #define STR_AMjv7GnB8u8
static const fu::str str_AMjv7GnB8u8 fu_INIT_PRIORITY(1015) { "\n        fn ifbrk(a: i32) {\n            mut x = 0;\n            if (a & 3) {\n                x += a;\n\n                :IF_LABEL\n                if (a & 1) {\n                    mut incr    = a & 4 ? a * 2\n                                : a & 2 ? { break :IF_LABEL; }  ;; Goto\n                                        : a;                    ;; GNUStmtExpr\n                    x += incr;\n                }\n            }\n\n            return x;\n        }\n\n        fn main() 1.ifbrk + 3.ifbrk * 10 + 5.ifbrk * 100 - 1532;\n    "_fu };
                                #endif

                                #ifndef STR_xgsNFF9kPQj
                                #define STR_xgsNFF9kPQj
static const fu::str str_xgsNFF9kPQj fu_INIT_PRIORITY(1015) { "\n        fn test(x: i32) {\n            return {\n                :BLOCK 2 * {\n                    if (x) break :BLOCK 3;                      ;; GNUStmtExpr\n                    1\n                }\n            };\n        }\n\n        fn main() = test(0) == 2 && test(1) == 3 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_rzXVwAoZ3Ia
                                #define STR_rzXVwAoZ3Ia
static const fu::str str_rzXVwAoZ3Ia fu_INIT_PRIORITY(1015) { "\n        fn v(x: i32) {                                          ;; GNUStmtExpr\n            return {\n                :BLOCK                          5000 + { // *2:\n                    if (x == 9) continue :BLOCK 2000;    //   - here\n                    if (x == 8) return           300;\n                    if (x == 7) break :BLOCK      40;\n\n                    5                                    //   - and here!\n                }\n            }  // -----------------------------------\n        }\n        fn main() 9.v + 8.v + 7.v + 6.v      - 12345;\n    "_fu };
                                #endif

                                #ifndef STR_1BUKALBd2e3
                                #define STR_1BUKALBd2e3
static const fu::str str_1BUKALBd2e3 fu_INIT_PRIORITY(1015) { "\n        pub fn test(x: i32[], y: i32[]) {\n            let z = {\n                :BLOCK {\n                    mut w: i32[] = x;\n                    if (y[0]) w ~= y;\n                    if (w[0] != 17)\n                        break :BLOCK w;\n                    x\n                }\n            };\n\n            return z[0] + z[z.len - 1];\n        }\n\n        fn main() test([ 1 ], [ 2 ]) - 3;\n    "_fu };
                                #endif

                                #ifndef STR_PKkx26mHOde
                                #define STR_PKkx26mHOde
static const fu::str str_PKkx26mHOde fu_INIT_PRIORITY(1015) { "\n        fn test(mut x: i32) {\n            {\n                x++;\n                :CANT_FLATTEN { // naive block flattening\n                                //  can damage this label\n                    if (x & 1) break :CANT_FLATTEN;\n                    return x;\n                }\n            }\n            return x * 2;\n        }\n\n        fn main() test(1) + test(2) - 8;\n    "_fu };
                                #endif

                                #ifndef STR_tWZ2s8dX0Kb
                                #define STR_tWZ2s8dX0Kb
static const fu::str str_tWZ2s8dX0Kb fu_INIT_PRIORITY(1015) { "\n        fn Each(arr, fn)\n            for (mut i = 0; i < arr.len; i++)\n                fn(arr[i]);\n\n        fn Some(arr, fn) {\n            arr.Each: |x| if (fn(x)) return x;\n            return 0;\n        }\n\n        fn main() [ 1, 2, 3 ].Some(|v| v & 1 == 0) - 2;\n\n        ;; EXPECT fu::view<int> {{ 1, 2, 3 }}\n    "_fu };
                                #endif

                                #ifndef STR_1CR17tSKo7g
                                #define STR_1CR17tSKo7g
static const fu::str str_1CR17tSKo7g fu_INIT_PRIORITY(1015) { "\n        fn outer() {\n            mut sum = 0;\n\n            inline fn inner(v: i32) {                           ;; GNUStmtExpr\n                for (mut i = 0; i < 10; i++) {\n                    sum += v;\n                    if (sum > 40)\n                        return :outer sum;\n                }\n\n                return v * 2;\n            }\n\n            mut x = 1;\n            for (;;) x = inner(x);\n        }\n\n        fn main() outer - 42; // extra points for style\n    "_fu };
                                #endif

                                #ifndef STR_Nch3v8fr1xi
                                #define STR_Nch3v8fr1xi
static const fu::str str_Nch3v8fr1xi fu_INIT_PRIORITY(1015) { "\n        inline fn Each(arr, fn)\n            for (mut i = 0; i < arr.len; i++)\n                fn(arr[i]);\n\n        fn main() {\n            mut sum = 0;\n            :OUTER [1, 2, 3, 4].Each(|x| {\n                sum += x;\n                for (mut i = 1; i--; ) // once\n                    if (sum == 6) break :OUTER;                 ;; Goto\n            });\n            return sum - 6;\n        }\n\n        ;; !N_NonTrivAutoCopy\n    "_fu };
                                #endif

                                #ifndef STR_KOHayIWDEyg
                                #define STR_KOHayIWDEyg
static const fu::str str_KOHayIWDEyg fu_INIT_PRIORITY(1015) { "\n        inline fn hello(ref sum) {  //     when inlined into woot\n            if (sum > 2) return;    //      the hello block now looks like an expr\n            sum += 2;               // <-    with a diverging tail return here\n        }\n\n        fn woot(ref sum) hello(sum);\n\n        fn main() {\n            mut sum = -2;\n            sum.woot();\n            return sum;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_y3aRWLXT7t7
                                #define STR_y3aRWLXT7t7
static const fu::str str_y3aRWLXT7t7 fu_INIT_PRIORITY(1015) { "\n        fn loop1d(i0, i1, fn)\n            for (mut i = i0; i < i1; i++)\n                fn(i);\n\n        fn main() {\n            mut x = 0;\n            loop1d(0, 10, |i| { if (x += i) break; });\n            return x - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_6hz98eM1Tch
                                #define STR_6hz98eM1Tch
static const fu::str str_6hz98eM1Tch fu_INIT_PRIORITY(1015) { "\n        fn loop1d(i0, i1, fn)\n            for (mut i = i0; i < i1; i++)\n                fn(i);\n\n        fn main() {\n            mut x = 0;\n            loop1d(0, 10, |i| { if (x += i) return x - 1; });\n            return 101;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_71VeIhloiC2
                                #define STR_71VeIhloiC2
static const fu::str str_71VeIhloiC2 fu_INIT_PRIORITY(1015) { "\n        fn loop2d(x0, x1, y0, y1, fn) {\n            for (mut y = y0; y < y1; y++)\n            for (mut x = x0; x < x1; x++) fn(x, y);\n        }\n\n        fn main() {\n            mut sum = 0;\n            loop2d( x0:  0, x1: 10,\n                    y0: 10, y1: 12, |x, y|\n            {\n                if (y < 11) {\n                    sum++;          // for (x: 0, 10) so 10 times\n                    continue;       // <- inner loop\n                }\n\n                if (x == 1) break;  // <- outer loop\n                sum += (x + 1) * y; // once: (0+1)*(y=11)\n            });\n\n            return sum - 21;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_8TpQX1bw9ei
                                #define STR_8TpQX1bw9ei
static const fu::str str_8TpQX1bw9ei fu_INIT_PRIORITY(1015) { "\n        fn loop1d(i0, i1, fn)\n            for (mut i = i0; i < i1; i++)\n                fn(i);\n\n        fn loop2d(x0, x1, y0, y1, fn)\n            loop1d(y0, y1, |y|\n                loop1d(x0, x1, |x|\n                    fn (x, y)));\n\n        fn main() {\n            mut sum = 0;\n            loop2d( x0:  0, x1: 10,\n                    y0: 10, y1: 12, |x, y|\n            {\n                if (y < 11) {\n                    sum++;          // for (x: 0, 10) so 10 times\n                    continue;       // <- inner loop\n                }\n\n                if (x == 1) break;  // <- outer loop\n                sum += (x + 1) * y; // once: (0+1)*(y=11)\n            });\n\n            return sum - 21;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_g7Q13veCZHa
                                #define STR_g7Q13veCZHa
static const fu::str str_g7Q13veCZHa fu_INIT_PRIORITY(1015) { "\n        fn next(implicit ref sum: i32, lifetime: i32[..], locals_start: i32) {\n            sum += lifetime.len;\n            return lifetime[locals_start .. lifetime.len];\n        }\n\n        fn Lifetime_each(lifetime: i32[..], visit) {\n            for (mut i = 0; i < lifetime.len; i++)\n                visit(lifetime[i .. <alt>lifetime.len</alt>]);\n        }\n\n        fn Lifetime_F_TODO_FIX_RRET(lifetime: i32[..], locals_start: i32) {\n            Lifetime_each(:lifetime, visit: |l| {\n                if (l)\n                    Lifetime_F_TODO_FIX_RRET(l.next(locals_start), locals_start);\n            });\n        }\n\n        fn main() {\n            let lifetime = [ 1, 2 ];\n            implicit mut sum = 0;\n            Lifetime_F_TODO_FIX_RRET(lifetime, locals_start: 1);\n            return sum - 4;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_GZlwPSwgfz9
                                #define STR_GZlwPSwgfz9
static const fu::str str_GZlwPSwgfz9 fu_INIT_PRIORITY(1015) { "\n        fn test(x: i32, ref odds: i32) {\n            return x & 1 ? { odds++; x } : x + 1;\n        }\n\n        fn main() {\n            let nums = [ 1, 2, 3 ];\n            mut odds = 0;\n            mut sum  = 0;\n            for (mut i = 0; i < nums.len; i++)\n                sum += test(nums[i], :odds);\n\n            return odds != 2 ? 100\n                 : sum  != 7 ? 200\n                 : 0;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_zd5nxhng9fc
                                #define STR_zd5nxhng9fc
static const fu::str str_zd5nxhng9fc fu_INIT_PRIORITY(1015) { "\n        fn test(ref x: i32) {\n            return {\n                :BLOCK {\n                    if (x & 1)  break :BLOCK x++;\n                    else        break :BLOCK x * 2;\n                }\n            };\n        }\n\n        fn main() {\n            mut x = 1;\n            return test(x) == 1 && test(x) == 4 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Rq4VXGrQw12
                                #define STR_Rq4VXGrQw12
static const fu::str str_Rq4VXGrQw12 fu_INIT_PRIORITY(1015) { "\n        fn PASS_borrowCheck(ref x: i32[]) {\n            fn bck_node(add: i32) {\n                for (mut i = 0; i < x.len; i++) {\n                    x[i] *= x[i];\n                    x[i] += add;\n                }\n            }\n\n            bck_node(1);\n\n            :SOLVE_AAR {\n                if (x.len & 2)\n                    bck_node(2);\n\n                if (x.len & 1)\n                    break :SOLVE_AAR;\n\n                bck_node(3);\n            }\n        }\n\n        fn main() {\n            mut a = [ 1, 2, 3 ];\n            mut b = [ 1, 2 ];\n            PASS_borrowCheck(a);\n            PASS_borrowCheck(b);\n            return a[2] == 102 && b[1] == 732 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_NsINuz9EYCh
                                #define STR_NsINuz9EYCh
static const fu::str str_NsINuz9EYCh fu_INIT_PRIORITY(1015) { "\n        fn rev(arr, fn) {\n            for (mut i = arr.len; i --> 0; ) {\n                if (!arr[i])\n                    break;\n                <alt>\n                else\n                    fn(arr[i], i?: i);\n                <alt/>\n                fn(arr[i], i?: i);\n                </alt>\n            }\n        }\n\n        fn test(arr) {\n            mut sum = 0;\n            arr.rev: |x| {\n                if (x & 1) continue;\n                sum += x;\n            }\n            return sum;\n        }\n\n        fn main() {\n            return test([2, 4, 6, 8]) == 20\n                && test([2, 4, 7, 8]) == 14\n                && test([2, 4, 0, 8]) ==  8 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_pUFG7VmvKI4
                                #define STR_pUFG7VmvKI4
static const fu::str str_pUFG7VmvKI4 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            fn exit(code: i32) { return :main code; }\n            fn exitViaArgdef(what: i32 = exit(0)) = what;\n            exitViaArgdef();\n        }\n    "_fu };
                                #endif

                                #ifndef STR_tKIKW0dRjn0
                                #define STR_tKIKW0dRjn0
static const fu::str str_tKIKW0dRjn0 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            fn exit(code: i32) { return :main code; }\n            fn exitViaArgdef(a: i32 = exit(0), b?) = a + b;\n            exitViaArgdef()\n        }\n    "_fu };
                                #endif

                                #ifndef STR_hVEKQMU7uP2
                                #define STR_hVEKQMU7uP2
static const fu::str str_hVEKQMU7uP2 fu_INIT_PRIORITY(1015) { "\n        fn test(x: i32)\n        {\n            fn mayExitTest() {\n                return x & 1 ? { return :test x * x; }          ;; GNUStmtExpr\n                             : x * 2;\n            }\n\n            fn mayExitTestFromDefarg(y: i32 = mayExitTest) {\n                return y * x;\n            }\n\n            return x & 2 ? mayExitTestFromDefarg()\n                         : mayExitTestFromDefarg(x * 2);\n        }\n\n        fn main() {\n            return test(3) == 9 && test(4) == 32 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_1wBW4oBl8N5
                                #define STR_1wBW4oBl8N5
static const fu::str str_1wBW4oBl8N5 fu_INIT_PRIORITY(1015) { "\n        fn test(x: i32)\n        {\n            fn mayExitTest()\n                x & 1   ? { return :test x * x; }\n                        : x * 2;\n\n            fn mayExitTestFromDefarg(y: i32 = mayExitTest)\n                y * x;\n\n            return x & 2 ? mayExitTestFromDefarg()\n                         : mayExitTestFromDefarg(x * 2);\n        }\n\n        fn main()\n            test(3) == 9 && test(4) == 32 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_hE1rd7gfVRi
                                #define STR_hE1rd7gfVRi
static const fu::str str_hE1rd7gfVRi fu_INIT_PRIORITY(1015) { "\n        <alt>\n        inline                                                  ;; Goto\n        </alt>\n        fn test(mut x: i32) {\n            fn loopInsideInlineArg(inline theLoop = {\n                while (x) {\n                    if (x & 1)  return x;\n                    if (x & 2)  break;\n                    if (x & 8)  return :test x * 100;\n                    x /= 2;\n                }\n            }) {\n                theLoop();\n                return x * 10;\n            }\n\n            return loopInsideInlineArg() * 3;                   ;; GNUStmtExpr\n        }\n\n        fn main() {\n            let a = test(5);\n            let b = test(4);\n            let c = test(16);\n            return a == 5 && b == 60 && c == 800 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Q2EZ5iWaPS2
                                #define STR_Q2EZ5iWaPS2
static const fu::str str_Q2EZ5iWaPS2 fu_INIT_PRIORITY(1015) { "\n        fn UnusedArgError(arr: i32[], fn)\n            for (mut i = 0; i < arr.len; i++)\n                fn(hello: arr[i], i?: i);\n\n        fn main() {\n            mut sum = 0;\n            let arr = [ 1, 2, -3 ];\n            arr.UnusedArgError: |lax i, hello|\n                <fail unused arg hello 9:41+5>\n                sum += arr[i];         <pass/>\n                sum += hello;          </fail>\n\n            return sum;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_yeHGUlPAbV7
                                #define STR_yeHGUlPAbV7
static const fu::str str_yeHGUlPAbV7 fu_INIT_PRIORITY(1015) { "\n        fn test() {     <fail nothing to break from here 3:13+5>\n            break;      <pass/>\n            return 0;   </fail>\n        }\n        fn main() = test();\n    "_fu };
                                #endif

                                #ifndef STR_72kqrO937Sa
                                #define STR_72kqrO937Sa
static const fu::str str_72kqrO937Sa fu_INIT_PRIORITY(1015) { "\n        fn test() {\n            let hello = || {    <fail nothing to break from here 4:17+5>\n                break;          <pass/>\n                return 0;       </fail>\n            };\n\n            return hello;\n        }\n        fn main() = test();\n    "_fu };
                                #endif

                                #ifndef STR_o7FUT2yV1tc
                                #define STR_o7FUT2yV1tc
static const fu::str str_o7FUT2yV1tc fu_INIT_PRIORITY(1015) { "\n        fn run(action) action();\n        fn test() {\n            run: || {\n                let hello = || {    <fail nothing to break from here 6:21+5>\n                    break;          <pass/>\n                    return 0;       </fail>\n                };\n\n                return hello;\n            };\n        }\n        fn main() = test();\n    "_fu };
                                #endif

                                #ifndef STR_ahP49fH49S3
                                #define STR_ahP49fH49S3
static const fu::str str_ahP49fH49S3 fu_INIT_PRIORITY(1015) { "\n        fn test() {     <fail nothing to continue from here 3:13+8>\n            continue;   <pass/>\n            return 0;   </fail>\n        }\n        fn main() = test();\n    "_fu };
                                #endif

                                #ifndef STR_tEchOBEkvBk
                                #define STR_tEchOBEkvBk
static const fu::str str_tEchOBEkvBk fu_INIT_PRIORITY(1015) { "\n        fn main() {\n    <alt>\n            let lambda = || { return 0; }       <alt/>\n            let lambda = |nil?| { return nil; } </alt>\n    <alt>\n            let test = || lambda + 11;          <alt/>\n            fn test() lambda + 11;              <alt/>\n            fn test() return lambda + 11;       </alt>\n\n            return test + 13;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_vbRvXts1fuc
                                #define STR_vbRvXts1fuc
static const fu::str str_vbRvXts1fuc fu_INIT_PRIORITY(1015) { "\n        fn each(ref arr: i32[], even, odd)\n            for (mut i = 0; i < arr.len; i++)\n                if (!i) odd(i?: i, it?: arr[i]);\n                else   even(i?: i, it?: arr[i]);\n\n        fn main() {\n            mut arr = [ 1, 2, 3 ];\n            arr.each(odd: |ref it| it++, even: || { break; });\n\n            mut sum = 0;\n            for (mut i = 0; i < arr.len; i++) sum += arr[i];\n            return sum - 7;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_afhS3zDV5m1
                                #define STR_afhS3zDV5m1
static const fu::str str_afhS3zDV5m1 fu_INIT_PRIORITY(1015) { "\n        struct BitSet { _data: u8 };\n\n        fn each(ref ._data, visit)\n            if (_data) for (mut b = 0; b < 8; b++) {\n                let mask = 1 << b.u8;\n                let remove = || _data &= ~mask;\n                if (_data & mask)\n                    visit(b.int, ?:fn remove);\n            }\n\n        fn Lifetime_process(ref set: BitSet, fn)\n            set.each: |locid, remove| {\n                fn continue_keep() { continue; }\n                fn(:locid, ?:fn continue_keep);\n                remove();\n            }\n\n        fn main() {\n            mut ls = BitSet(255.u8);\n            ls.Lifetime_process: |locid, continue_keep|\n                if (locid & 1)\n                    continue_keep();\n\n            return ls._data == 170 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_bwKWWQ00mjj
                                #define STR_bwKWWQ00mjj
static const fu::str str_bwKWWQ00mjj fu_INIT_PRIORITY(1015) { "\n        fn hello(a) a * a;          ;; EXPECT (const int a)\n        fn main() {\n            mut a = 3;\n            let b = hello(a);\n            return b - 9;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_jtCluGQLEWh
                                #define STR_jtCluGQLEWh
static const fu::str str_jtCluGQLEWh fu_INIT_PRIORITY(1015) { "\n        struct AB { a: i32; b: i32; };\n        fn sqr   (ref x: i32) x * x;\n        fn outer (ref ab: AB) sqr(ab.a) + sqr(ab.b);        ;; EXPECT const AB_kiW0&\n        fn main() {\n            mut ab = AB(3, 5);\n            return ab.outer - 34;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_vBf6Mspu4Nc
                                #define STR_vBf6Mspu4Nc
static const fu::str str_vBf6Mspu4Nc fu_INIT_PRIORITY(1015) { "\n        fn ascii_lower(a: string): string\n        {\n            let offset = 'a'.i32 - 'A'.i32;\n\n            mut res = a;\n            for (mut i = 0; i < res.len; i++)\n            {\n                let c = res[i];\n                if (c >= 'A' && c <= 'Z')\n                    res[i] = byte(c.i32 + offset);\n            }\n\n            return res;\n        }\n\n        <split/>\n\n        fn main() \"WORLD!\".ascii_lower[2].i32 - 'r'.i32;\n    "_fu };
                                #endif

                                #ifndef STR_Ck8EPKw8be5
                                #define STR_Ck8EPKw8be5
static const fu::str str_Ck8EPKw8be5 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut a = [[ 7 ]];\n            return a[0][0] - 7;        ;; EXPECT a[0][0]\n        }\n    "_fu };
                                #endif

                                #ifndef STR_ffCwTiyHpue
                                #define STR_ffCwTiyHpue
static const fu::str str_ffCwTiyHpue fu_INIT_PRIORITY(1015) { "\n        lax fn doNothing(pointlessArg: i32) {\n            if (pointlessArg == 1)\n                return;\n        }\n\n        fn main() {\n            doNothing(1);\n            return 0;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_9P335zaTRd4
                                #define STR_9P335zaTRd4
static const fu::str str_9P335zaTRd4 fu_INIT_PRIORITY(1015) { "\n        struct Target   { index: i32 };\n        struct Overload { uni0n: i32[] };\n\n        fn solve(all: Overload[], check: Target) {\n            fn GET(t: Target) {\n                if (t.index < 1 || t.index > all.len) throw(\"nope\");\n                return all[t.index - 1];\n            }\n\n            fn propagateType(t: Target) {\n                if (t.GET.uni0n.has(t.index)) {}\n                return t.index;\n            }\n\n            return propagateType(check);\n        }\n\n        fn main() solve([ Overload([ 1, 2, 3 ])], Target(1)) - 1;\n    "_fu };
                                #endif

                                #ifndef STR_6rKK4AqCQH8
                                #define STR_6rKK4AqCQH8
static const fu::str str_6rKK4AqCQH8 fu_INIT_PRIORITY(1015) { "\n        struct Overload     { args: Argument[]; };\n        struct SolvedNode   { x: i32; };\n        struct Argument     { default: SolvedNode; };\n\n        pub fn test(overload: Overload, ref args: SolvedNode[])\n        {\n            let host_args = overload.args;          ;; EXPECT fu::view<Argument_5Ucf> /*overload*/ host_args\n\n            args.resize(host_args.len);             // .len didnt relax its arg\n            for (mut i = 0; i < args.len; i++)\n            {\n                if (!args[i])\n                {\n                    let host_arg = host_args[i];\n                    args[i] = host_arg.default;\n                }\n            }\n        }\n\n        fn main() {\n            mut o: Overload;\n            for (mut i = 0; i < 3; i++)\n                o.args ~= Argument(default: SolvedNode(x: i));\n\n            mut args: SolvedNode[];\n            test(o, args);\n            return args.len - args[args.len - 1].x - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_92Qn6CnB6f0
                                #define STR_92Qn6CnB6f0
static const fu::str str_92Qn6CnB6f0 fu_INIT_PRIORITY(1015) { "\n        struct S { hey: i32[]; };\n\n        fn m_and_c_cant_alias_001(ref m!: S, c!: S) {\n            m.hey.clear();\n            return c.hey; // noalias\n        }\n\n        fn test(ref mc: S) {\n            return m_and_c_cant_alias_001(m:mc, c:mc);  // Can't return a ref into c!\n        }                                               //  But can be made to work by creating an intermediate copyvar\n                                                        //   and move-returning from there.\n        fn main() {\n            mut mc  = S([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]);\n            let hey = test(mc);\n            return hey.len - 10;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_vL8HEb1sPLj
                                #define STR_vL8HEb1sPLj
static const fu::str str_vL8HEb1sPLj fu_INIT_PRIORITY(1015) { "Both alias mc 10:51+2 m_and_c_cant_alias_001:c is ref-returned"_fu };
                                #endif

                                #ifndef STR_vvCgpKaEFBa
                                #define STR_vvCgpKaEFBa
static const fu::str str_vvCgpKaEFBa fu_INIT_PRIORITY(1015) { "\n        // !!!! The m_and_c_cant_alias_001 test obsoletes this,\n        // !!!!  this is just detects what we definitely don't want to see -\n        // !!!!   returning a reference into a temporary copy.\n        //\n        struct S { hey: i32[]; };\n\n        fn m_and_c_cant_alias_002(ref m: S, c: S) {\n            m.hey.clear();\n            return c.hey; // noalias\n        }\n\n        fn main() {\n            mut mc  = S([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]);\n            <fail alias>\n            let hey = m_and_c_cant_alias_002(mc, mc);\n            <pass/>\n            mut bc  = mc;\n            let hey = m_and_c_cant_alias_002(mc, bc);\n            </fail>\n            return hey.len - 10;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_ARlgBKtA413
                                #define STR_ARlgBKtA413
static const fu::str str_ARlgBKtA413 fu_INIT_PRIORITY(1015) { "\n        fn grow_if_oob(ref a: $T[], i: i32): &mut $T {\n            if (a.len <= i)\n                a.grow(i + 1);\n\n            return a[i];\n        }\n\n        struct BitSet { _data: u8[]; }\n\n        fn add_once(using ref _: BitSet, idx: i32): bool {\n            let no_neg = idx < 0 ? -1 : 0;\n            let bucket = idx / 8 | no_neg;\n            let bit    = idx % 8;\n            let mask   = 1 << bit.u8;\n\n            ref entry = _data.grow_if_oob(bucket);\n            if !(entry & mask) {\n                entry |= mask;\n                return true;\n            }\n\n            // Already there.\n            return false;\n        }\n\n        type BitSet2D = BitSet[];\n\n        fn add_once(ref bs: BitSet2D, i: i32, j: i32): bool {\n            return bs\n                .grow_if_oob(i)\n                .add_once(j);                                   ;; !*MustSeq\n        }\n\n        fn main() {\n            mut bs: BitSet2D;\n            bs.add_once(9, 9);\n            return bs.len + 1000 * bs[9]._data.len - 2010;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_qYgaVkrLR7j
                                #define STR_qYgaVkrLR7j
static const fu::str str_qYgaVkrLR7j fu_INIT_PRIORITY(1015) { "\n        fn test(mut _precedence = 0)\n        {\n            fn parseExpression(p1?: i32): i32 {\n                if !((_precedence = p1))\n                    return parseExpressionHead();\n\n                return _precedence;\n            }\n\n            fn parseExpressionHead()\n                parseExpression(_precedence * 101 + 1);\n\n            return parseExpression();\n        }\n\n        fn main() = test() - 1;\n    "_fu };
                                #endif

                                #ifndef STR_OJfoSC7duY6
                                #define STR_OJfoSC7duY6
static const fu::str str_OJfoSC7duY6 fu_INIT_PRIORITY(1015) { "\n        struct Overload {\n            is_var?: bool;\n            lifetime?: i32[];\n        }\n\n        fn GET(implicit overloads: Overload[], idx: i32) {\n            return overloads[idx];\n        }\n\n        <alt>\n        inline </alt>\n        fn Lifetime_each(mut lifetime: i32[], visit) {\n            for (mut i = 0; i < lifetime.len; i++) {\n                let r = lifetime[i];\n                let o = GET(r);\n                visit(:o, i?: i, lifetime?: lifetime);\n            }\n        }\n\n        fn Lifetime_ascend(mut lifetime: i32[], visit) {\n            Lifetime_each(:lifetime, visit: |o, shadow ref lifetime| {\n                visit(o);\n                lifetime ~= o.lifetime; // set::add\n            });\n        }\n\n        fn Lifetime_allowsMutrefReturn(lifetime: i32[]): bool {\n            Lifetime_ascend(:lifetime, visit: |o| {\n                if (o.is_var)\n                    return false; // ERR: propagateType(jump): h.ret_actual not available.\n            });\n\n            return true;\n        }\n\n        fn main() {\n            let implicit overloads = [\n                Overload,\n                Overload(lifetime: [ 0 ]),\n                Overload(lifetime: [ 1 ], is_var: true),\n                Overload(lifetime: [ 1 ]),\n                Overload(lifetime: [ 2 ]), /* the isvar */\n                Overload(lifetime: [ 3 ]), /* the non-isvar */\n            ];\n\n            let expect_false = Lifetime_allowsMutrefReturn([ 4 ]);\n            let expect_true  = Lifetime_allowsMutrefReturn([ 5 ]);\n\n            if (expect_false) return 20;\n            if (!expect_true) return 10;\n            return 0;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_KNfmjI7Oy5d
                                #define STR_KNfmjI7Oy5d
static const fu::str str_KNfmjI7Oy5d fu_INIT_PRIORITY(1015) { "\n        struct Overload { items: string[]; };\n\n        fn Last(a: $T[])                    a[a.len - 1];\n        fn arg_lets(overload: Overload)     overload.items[.. overload.items.len - 2];\n        fn test(overload: Overload)         overload.arg_lets.Last.len;\n        fn main()                           Overload([ \"hello\", \"cruel\", \"world!\" ]).test - 5;\n    "_fu };
                                #endif

                                #ifndef STR_r0IImUoY8th
                                #define STR_r0IImUoY8th
static const fu::str str_r0IImUoY8th fu_INIT_PRIORITY(1015) { "\n        struct Helpers      { index: i32; };\n        struct HelpersData  { mask!: i16; };\n\n        let HM_Function     = 1.i16 << 3;\n        let HM_Struct       = 1.i16 << 5;\n\n        using inline fn GET(h: Helpers, implicit ref _helpers_data: HelpersData[]): HelpersData\n            _helpers_data[h.index];\n                                                            //////////////////\n        fn isFnOrType(h: Helpers): bool                     ;; EXPECT fu::view\n            !!(h.mask & (HM_Function | HM_Struct));         //////////////////\n\n        fn main() {\n            implicit mut _helpers_data = [ HelpersData(mask: 0) ];\n            return Helpers(0).isFnOrType.i32;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_uKl51cREbK9
                                #define STR_uKl51cREbK9
static const fu::str str_uKl51cREbK9 fu_INIT_PRIORITY(1015) { "\n        struct Helpers      { index: i32; };\n        struct HelpersData  { mask!: i16; };\n\n        let HM_Function     = 1.i16 << 3;\n        let HM_Struct       = 1.i16 << 5;\n\n        fn main() {\n            implicit mut _helpers_data = [ HelpersData(mask: 0) ];\n\n            using inline fn GET(h: Helpers): HelpersData\n                _helpers_data[h.index];\n                                                            //////////////////\n            fn isFnOrType(h: Helpers): bool                 ;; EXPECT fu::view\n                !!(h.mask & (HM_Function | HM_Struct));     //////////////////\n\n            return Helpers(0).isFnOrType.i32;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_tlfBarDXTJc
                                #define STR_tlfBarDXTJc
static const fu::str str_tlfBarDXTJc fu_INIT_PRIORITY(1015) { "\n        pub fn ref(dest, item: $T, extras) {\n            for (mut i = 0; i < dest.len; i++) {\n                if (dest[i] >= item) {\n                    if (dest[i] != item) {\n                        dest.insert(i, item);\n                        extras.insert(i, []);\n                    }\n                    return extras[i];\n                }\n            }\n\n            dest.push(item);\n            extras.push([]);\n            return extras[extras.len - 1];\n        }\n    "_fu };
                                #endif

                                #ifndef STR_fKxR1nSBWzi
                                #define STR_fKxR1nSBWzi
static const fu::str str_fKxR1nSBWzi fu_INIT_PRIORITY(1015) { "\n        fn Map(lax k: $K, lax v: $V) struct {\n            keys: $K[];\n            vals: $V[];\n        };\n\n        fn ref(using ref _, key)\n            _0::ref(\n                || keys, key,\n                || vals);\n    "_fu };
                                #endif

                                #ifndef STR_vWzUeiHEVFc
                                #define STR_vWzUeiHEVFc
static const fu::str str_vWzUeiHEVFc fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut _map: _1::Map(string, string);\n\n            fn upsert(k: string, v: string) _map._1::ref(k) = v;\n            upsert(\"hello\", \"world\");\n\n            // Relaxer failed here while I was trying to get rid of F_REFs from specTypes.\n            fn check(k: string) _map._1::ref(k) == \"world\" ? 0 : 1;\n            return check(\"hello\");\n        }\n    "_fu };
                                #endif

                                #ifndef STR_BYKzGroabBj
                                #define STR_BYKzGroabBj
static const fu::str str_BYKzGroabBj fu_INIT_PRIORITY(1015) { "\n        fn useless_ref_lambda(ref sources: string[]) {\n            fn src = sources[sources.len / 2]; // didn't relax the ref, failed bck\n            return src[1 .. src.len] ~ src[.. 1];\n        }\n        fn main() {\n            mut sources = [ \"ab\" ];\n            return useless_ref_lambda(sources) == \"ba\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Qo08aBJiZi8
                                #define STR_Qo08aBJiZi8
static const fu::str str_Qo08aBJiZi8 fu_INIT_PRIORITY(1015) { "\n        struct Node { items: Node[] };\n\n        pure fn rec_useless_ref_simple(ref n: Node, offset: i32)\n            offset < n.items.len\n                ? rec_useless_ref_simple(:n, offset + 1)\n                : offset;\n\n        fn main() {\n            mut n = Node([ Node(), Node() ]);\n            return rec_useless_ref_simple(:n, 0) - 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_r4emsqkokEa
                                #define STR_r4emsqkokEa
static const fu::str str_r4emsqkokEa fu_INIT_PRIORITY(1015) { "\n        struct Node { items: Node[]; };\n\n        pure fn rec_useless_ref(ref n: Node) {\n            mut ret = n.items.len;\n            for (mut i = 0; i < n.items.len; i++)\n                ret += rec_useless_ref(n.items[i]);\n\n            return ret;\n        }\n\n        fn main() {\n            mut tree = Node([ Node(), Node() ]);\n            return rec_useless_ref(tree) - 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_IQxtphh6EJk
                                #define STR_IQxtphh6EJk
static const fu::str str_IQxtphh6EJk fu_INIT_PRIORITY(1015) { "\n        struct Node { items: Node[]; };\n\n        fn mrec_useless_ref_A(ref n: Node) {\n            mut ret = n.items.len;\n            for (mut i = 0; i < n.items.len; i++)\n                ret += i & 1\n                    ?      mrec_useless_ref_A(n.items[i])\n                    : 50 * mrec_useless_ref_B(n.items[i]);\n\n            return ret;\n        }\n\n        pure fn mrec_useless_ref_B(ref n: Node) {\n            mut ret = n.items.len;\n            for (mut i = 0; i < n.items.len; i++)\n                ret += i & 1\n                    ? 10 * mrec_useless_ref_A(n.items[i])\n                    :      mrec_useless_ref_B(n.items[i]);\n\n            return ret;\n        }\n\n        fn main() {\n            mut tree = Node([ Node([ Node, Node ]), Node([ Node ]) ]);\n            return mrec_useless_ref_A(tree) - 103;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_SBSqlDR5yxg
                                #define STR_SBSqlDR5yxg
static const fu::str str_SBSqlDR5yxg fu_INIT_PRIORITY(1015) { "\n        fn Last(s: $T[])\n            s.len ? s[s.len - 1] : throw(\"len == 0\");\n\n        struct Node { kind: string; items: Node[] }\n\n        pure fn check(ref node: Node)\n            node.kind != \"block\" ||\n            node.items.Last.kind == \"return\";\n\n        fn main() {\n            mut node: Node;\n            return node.check ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_0f9ZKNXuYcc
                                #define STR_0f9ZKNXuYcc
static const fu::str str_0f9ZKNXuYcc fu_INIT_PRIORITY(1015) { "\n        fn relaxes_arr_to_slice_and_fails(ref arr) {\n            arr.pop();\n            return arr;\n        }\n\n        fn main() {\n            mut arr = [ 1 ];\n            relaxes_arr_to_slice_and_fails(arr);\n            return arr.len;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_4z6JwwnbgGe
                                #define STR_4z6JwwnbgGe
static const fu::str str_4z6JwwnbgGe fu_INIT_PRIORITY(1015) { "\n        type Context = string[];\n\n        fn compile_snippets(sources: string[], fnames?: string[]): Context {\n            return sources ~ fnames;\n        }\n\n        fn ZERO(implicit ref output: string, mut sources: string[]): Context {\n            for (mut i = 0; i < sources.len; i++) {\n                ref src = sources[i];\n                let idx = src.find('X');\n                if (idx >= 0) {\n                    let moduleA = src.slice(0, idx);\n                    let moduleB = src[idx .. idx] ~ src[idx + 1 .. src.len];\n                    let without = src[0   .. idx] ~ src[idx + 1 .. src.len];\n\n                    sources[i]  = without;\n                    ZERO(:sources);\n\n                    sources[i]  = moduleA;\n                    sources.insert(i + 1, moduleB);\n                    i--;\n                }\n            }\n\n            let ctx = compile_snippets(:sources);\n            output ~= sources.join(',') ~ \";\";\n            return ctx;\n        }\n\n        fn ZERO(src: string) ZERO(sources: [ src ]);\n\n        fn main() {\n            implicit mut output: string;\n            ZERO(\"aXbXc\");\n            return output == \"abc;ab,c;a,bc;a,b,c;\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_6Zwznygyhu3
                                #define STR_6Zwznygyhu3
static const fu::str str_6Zwznygyhu3 fu_INIT_PRIORITY(1015) { "\n        fn ZERO(mut sources: string[], implicit ref output: string) {\n            for (mut i = 0; i < sources.len; i++) {\n                ref src = sources[i];\n                mut idx = 0;\n                while ((idx = src.find(\"X\")) > 0) {\n                    let sources1 = sources[0 .. i]\n                        ~ src.slice(0, idx)\n                        ~ src.slice(idx + 1, src.len)\n                        ~ sources[i + 1 .. sources.len];\n\n                    ZERO(sources1);\n                    src = src[0 .. idx] ~ src[idx + 1 .. src.len];\n                }\n            }\n\n            output ~= sources.join(\",\") ~ \";\";\n        }\n\n        fn ZERO(src: string) {\n            return ZERO([ src ]);           ;; ALLOCS 5\n        }\n\n        fn main() {\n            implicit mut output: string;\n            ZERO(\"aXbXc\");\n            return output == \"a,b,c;a,bc;ab,c;abc;\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_KvHJLAxGyqb
                                #define STR_KvHJLAxGyqb
static const fu::str str_KvHJLAxGyqb fu_INIT_PRIORITY(1015) { "COW will break 10:34+1 4:21+3 2:21+7"_fu };
                                #endif

                                #ifndef STR_7aM0X46QwB9
                                #define STR_7aM0X46QwB9
static const fu::str str_7aM0X46QwB9 fu_INIT_PRIORITY(1015) { "\n        fn test(str: <alt>byte[..]<alt/>string</alt>) {\n            mut res = 1;\n            str.split('/'): |piece| res *= piece.len;\n            return res;\n        }\n\n        fn main() {\n            let res = test(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb/cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\");\n            if (mem::ALLOC_STAT_COUNT() != 0) return 101;\n            return res == 196608 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_1HI0EYiwYVj
                                #define STR_1HI0EYiwYVj
static const fu::str str_1HI0EYiwYVj fu_INIT_PRIORITY(1015) { "\n        novec fn doesnt_copy_arg(arg: string, suffix: byte) <alt>\n            arg     && arg ~ suffix;                        <alt/>\n            arg      ? arg ~ suffix : \"\";                   <alt/>\n            arg.len && arg ~ suffix;                        <alt/>\n            arg.len  ? arg ~ suffix : \"\";                   <alt/>\n            !!arg   && arg ~ suffix;                        <alt/>\n            !!arg    ? arg ~ suffix : \"\";                   </alt>\n\n        fn main() {\n            mut share = \"01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH\";\n            mut a = doesnt_copy_arg(share, '!');\n            mut b = doesnt_copy_arg(share, '?');\n            mut c = doesnt_copy_arg(\"\", '.');\n            return a.len == b.len && a.len == 49 && c.len == 0 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_7JSrnkGxH87
                                #define STR_7JSrnkGxH87
static const fu::str str_7JSrnkGxH87 fu_INIT_PRIORITY(1015) { "\n        fn loop(ref cond, body)     <alt>\n            while (cond) body();    <alt/>\n            do body();\n            while (cond);           </alt>\n\n        novec fn doesnt_copy_arg(ref nums: i32[]) {\n            loop(nums): || {\n                mut sum = 0;\n                for (mut i = 0; i < nums.len; i++)\n                    sum += nums[i]++;\n                if (sum >= 10)\n                    return sum;\n            }\n            return 0;\n        }\n\n        fn main() {\n            mut nums: i32[];\n            mut a = doesnt_copy_arg(nums);\n            nums ~= 1;\n            mut b = doesnt_copy_arg(nums);\n            nums ~= 2;\n            mut c = doesnt_copy_arg(nums);\n            return a == 0 && b == 10 && c == 13 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_u8G9tDUZ8ql
                                #define STR_u8G9tDUZ8ql
static const fu::str str_u8G9tDUZ8ql fu_INIT_PRIORITY(1015) { "\n        fn grow_if_oob !T(ref a: T[], i: i32) {\n            if (a.len <= i) a.grow(i + 1);\n            return a[i];\n        }\n\n        struct Target { modid: i32; index: i32 }\n        struct Scope { overloads: Overload[]; extended: Extended[] };\n        struct Overload { modid: i32 };\n        struct Extended { min: i32; locals: Overload[] };\n\n        fn create(ref scope: Scope, modid: i32): Target {\n            ref overloads = modid\n                ? scope.extended.grow_if_oob(modid).locals\n                : scope.overloads;\n\n            let target = Target(:modid, index: overloads.len + 1);\n            overloads.push(Overload(:modid));\n            return target;\n        }\n\n        fn main() {\n            mut scope: Scope;\n            scope.create(0);\n            scope.create(1);\n            return scope.overloads.len == 1\n                && scope.extended .len == 2 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_yQbsd8SCrg9
                                #define STR_yQbsd8SCrg9
static const fu::str str_yQbsd8SCrg9 fu_INIT_PRIORITY(1015) { "\n        using flags TPFlags { ArgSpec; Typename; NeedsConsumed };\n\n        struct TP { flags: TPFlags };\n\n        fn doTrySpec(ref typeParams: TP[]) {\n            fn useConsumedType(tp<alt>: TP</alt>)\n                tp.flags & (ArgSpec | Typename) == ArgSpec;\n\n            typeParams.each: |ref tp|\n                if (tp.useConsumedType)\n                    tp.flags |= NeedsConsumed;\n        }\n\n        fn main() {\n            mut typeParams: TP[] = [\n                [ ArgSpec ],\n                [ ArgSpec | Typename ],\n                [ Typename ],\n            ];\n\n            doTrySpec(typeParams);\n\n            mut count = 0;\n            typeParams.each: |tp|\n                if (tp.flags & NeedsConsumed)\n                    count++;\n\n            return count - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_ZxTVDKLSuzf
                                #define STR_ZxTVDKLSuzf
static const fu::str str_ZxTVDKLSuzf fu_INIT_PRIORITY(1015) { "\n        struct Empty {};\n\n        fn main() {\n            mut e = [ Empty(), Empty() ];\n            fn GET(idx: i32) e.len > idx && e[idx];\n            return GET(0) == GET(1) ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_IjxpyOqnzta
                                #define STR_IjxpyOqnzta
static const fu::str str_IjxpyOqnzta fu_INIT_PRIORITY(1015) { "BUG invalid c++ void[] 5:17+1"_fu };
                                #endif

                                #ifndef STR_kd0Z0HVe6V0
                                #define STR_kd0Z0HVe6V0
static const fu::str str_kd0Z0HVe6V0 fu_INIT_PRIORITY(1015) { "\n        struct Module { modid: i32 };\n        struct Ephemeral { <alt>broke_when_zst?: i32</alt> };\n        struct SolverState { _ephemeral: Ephemeral[] };\n        struct Target { modid: i32; globid: i32 };\n\n        fn test(implicit ref module: Module, using ref ss: SolverState, target: Target): Ephemeral {\n    <alt>\n            fn EPH(shadow target: Target)\n                return target.modid == module.modid\n                    && _ephemeral[target.globid];\n\n            return EPH(target);\n    <alt/>\n            using fn EPH(shadow target: Target)\n                return target.modid == module.modid\n                    && _ephemeral[target.globid];\n\n            return target;\n    </alt>\n        }\n\n        fn main() {\n            implicit mut module = Module(1);\n            mut ss = SolverState([ Ephemeral(), Ephemeral(), Ephemeral() ]);\n            return test(ss, Target(modid: 1, globid: 2)) == [] ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_h2TO1AAmzcf
                                #define STR_h2TO1AAmzcf
static const fu::str str_h2TO1AAmzcf fu_INIT_PRIORITY(1015) { "BUG invalid c++ void[] 19:17+2"_fu };
                                #endif

                                #ifndef STR_kHhhgx2cFol
                                #define STR_kHhhgx2cFol
static const fu::str str_kHhhgx2cFol fu_INIT_PRIORITY(1015) { "\n        fn Map(type K, type V) struct {\n            keys: K[];\n            vals: V[];\n        };\n\n        fn ref !<K, V>(using ref _: Map(K, V), key: K) {\n            for (mut i = 0; i < keys.len; i++)\n                if (keys[i] == key)\n                    return vals[i];\n\n            keys.push(key);\n            vals.push([]);\n            return vals[vals.len - 1];\n        }\n\n        struct Type { using vtype: i32 };\n\n        fn find_if_odd(ref map: Map(i32, Type), key: i32)\n            key & 1\n                ? map.ref(key)\n                : key & 2 && throw(\"never\");\n\n        fn main() {\n            mut map: Map(i32, Type);\n            map.keys ~= 1;\n            map.vals ~= Type(2);\n            return find_if_odd(map, 1) - 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_fEd1j1u4VY4
                                #define STR_fEd1j1u4VY4
static const fu::str str_fEd1j1u4VY4 fu_INIT_PRIORITY(1015) { "\n        lax                         <alt>\n        inline      ;; PointlessLocal   <alt/>\n        noinline                        </alt>\n        fn longer(                  <alt>\n            l: string, r: string,       <alt/>\n            l: $T[..], r: $T[..],       </alt>\n            pick!)\n        {\n            let longer = {                                      ;; GNUStmtExpr\n                :PICK {\n                    for (;;) {\n                        if (l.len > r.len)\n                            break :PICK l;                      ;; Goto\n\n                        break :PICK r;\n                    }\n                }\n            };\n\n            return pick(longer);\n        }\n\n        fn main() {\n            longer(\"does\", \"nothing\",\n                pick: |_| { break; });\n\n            let longer = longer(\"Hello\", \" World!\",\n                pick: |longer| { break longer; });\n\n            return longer.len - 7;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_pQrEbItTlAg
                                #define STR_pQrEbItTlAg
static const fu::str str_pQrEbItTlAg fu_INIT_PRIORITY(1015) { "\n        noinline fn longer(             <fail cannot move from a slice (8:20+6|15:20+6)>\n            l: byte[..], r: byte[..])   <pass/>\n            l: $T[..],   r: $T[..])     </fail>\n        {\n            return l.len > r.len ? l : r;\n        }\n\n        <split/>\n        noinline fn strsqr(mut str: string, n: i32) {\n            for (mut i = 1; i < n; i++) str ~= str;\n            return str;\n        }\n\n        noinline fn mightConstCast() {\n            return longer(\n                \"A---A\".strsqr(4),\n                \"B-BB-B\".strsqr(4));                            ;; ConstCast\n        }\n\n        fn main() {\n            let longer = mightConstCast();\n            shadow let longer = longer ~ longer;\n            return longer.split(\"BB\").len == 32 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_mRyIvB0tOoc
                                #define STR_mRyIvB0tOoc
static const fu::str str_mRyIvB0tOoc fu_INIT_PRIORITY(1015) { "\n        struct Target   { index: i32 }\n        struct Lifetime { uni0n!: byte[] };\n        type Type = Lifetime;\n\n        fn is_ref(type: Type) = !!type;\n\n        fn Lifetime_process(lifetime: Lifetime, each) {\n            fn visit(shadow lifetime) {\n                do {\n                    fn continue_climb(mut parent: Lifetime) {\n                        visit(parent);\n                        continue;\n                    }\n\n                    each(lifetime, fn continue_climb);\n                }\n                while (false);\n            }\n\n            return visit(lifetime);\n        }\n\n        fn main() {\n            fn Lifetime_climbType(lax lifetime: Lifetime) return [];\n\n            mut count = 0;\n            Lifetime_process([], each: |lifetime, continue_climb| {\n                count++;\n\n                lax let init = lifetime.Lifetime_climbType;\n                if (init.is_ref)\n                    continue_climb(init);\n            });\n\n            return count - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_lEiEin3TTae
                                #define STR_lEiEin3TTae
static const fu::str str_lEiEin3TTae fu_INIT_PRIORITY(1015) { "\n        using flags Flags { A; B }\n\n        fn parseExoticDecl(shadow mut flags: Flags) {\n            if (flags) {\n                fn add(flag) flags |= flag;\n                return add(B);\n            }\n\n            return flags;\n        }\n\n        fn main() = parseExoticDecl(A).i32 - 3;\n    "_fu };
                                #endif

                                #ifndef STR_E4QLKyAkugj
                                #define STR_E4QLKyAkugj
static const fu::str str_E4QLKyAkugj fu_INIT_PRIORITY(1015) { "\n        struct Node { items: string };\n\n        pub fn solve(using ref _current_fn: Node, root) {\n            fn solveNode(node) {\n                if (_current_fn) {\n                    fn outItems(back) items[items.len - back];\n                    _current_fn.items ~= \"! \";\n                    return outItems(2);\n                }\n\n                _current_fn.items ~= node.items;\n                return [];\n            }\n\n            return solveNode(root);\n        }\n\n        fn main() {\n            mut n = Node(\"hello\");\n            return solve(n, n).i32 - '!'.i32;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_6yBoL8VOMd1
                                #define STR_6yBoL8VOMd1
static const fu::str str_6yBoL8VOMd1 fu_INIT_PRIORITY(1015) { "\n        struct Node { items: string };\n\n        pure fn closure_of_explicit_ref_cant_relax(ref n) {\n            fn solveNode(ref items) {\n                fn outItems(back) items[items.len - back];\n                if (n) return outItems(1);\n                return [];\n            }\n\n            return solveNode(n.items);\n        }\n\n        fn main() {\n            mut n = Node(\"hello\");\n            return closure_of_explicit_ref_cant_relax(n).i32 - 'o'.i32;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_lm1ndvHwrO0
                                #define STR_lm1ndvHwrO0
static const fu::str str_lm1ndvHwrO0 fu_INIT_PRIORITY(1015) { "\n        struct Node { items: string };\n\n        pure fn injected_args_ignore_relaxed_types(using ref n) {\n            fn solveNode(lax _) {\n                fn outItems(back) items[items.len - back];\n                if (n) return outItems(1);\n                return [];\n            }\n\n            return solveNode(0);\n        }\n\n        fn main() {\n            mut n = Node(\"hello\");\n            return injected_args_ignore_relaxed_types(n).i32 - 'o'.i32;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_fLJhLzaH49a
                                #define STR_fLJhLzaH49a
static const fu::str str_fLJhLzaH49a fu_INIT_PRIORITY(1015) { "\n        fn blockTailHasLocals_but_blockTypeIsTemp_reduct(ref id: string) {\n            fn ooeWrap(src) src && [];\n            return id\n                 ? ooeWrap((id = \"\") ~ (id = \"\"))\n                 : \"\";\n        }\n\n        fn main() {\n            mut id: string = \"none of this does anything\";\n            return blockTailHasLocals_but_blockTypeIsTemp_reduct(:id).len;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_a0QjQQ65v1c
                                #define STR_a0QjQQ65v1c
static const fu::str str_a0QjQQ65v1c fu_INIT_PRIORITY(1015) { "\n        struct SolvedNode { value: string; items?: SolvedNode[] };\n\n        noinline fn blockTailHasLocals_but_blockTypeIsTemp(root: SolvedNode)\n        {\n            fn declareStruct(node: SolvedNode) {\n                mut def = \"\";\n                node.items.each: |item|\n                    def ~= item.value ~ cgCall(item);\n\n                return def;\n            }\n\n            fn cgCall(node: SolvedNode) {\n                mut item_src: string[] = [ \"\", \"\" ];\n                fn ooeWrap(src) src && [];\n                fn ARG(i) item_src[i];\n\n                let id = node.value;\n                if (id.len & 1)\n                    return ooeWrap((ARG(0)<alt> = \"\"</alt>) ~ \"\" ~ (ARG(1)<alt> = \"\"</alt>));\n                else if (!id)\n                    return \"\" ~ id;\n                else\n                    return [];\n            }\n\n            return declareStruct(root);\n        }\n\n        fn main() {\n            return blockTailHasLocals_but_blockTypeIsTemp(\n                SolvedNode(\"none of this does anything\")).len;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_wdUzEEKF3Bl
                                #define STR_wdUzEEKF3Bl
static const fu::str str_wdUzEEKF3Bl fu_INIT_PRIORITY(1015) { "\n        struct Target { id: int };\n        fn isLocal(t: Target) t.id & 1;\n        fn parent(t: Target) Target(t.id & ~1);\n\n        fn main() {\n            struct SolverState { _scope: string };\n            using mut ss: SolverState = [ \"Hello\" ];\n            fn GETLocal(t: Target) = GET(t.parent) ~ \", world!\";\n            using fn GET(t: Target) = t.isLocal ? GETLocal(t) : _scope;\n            let res: string = Target(1);\n            return res == \"Hello, world!\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_eIx4DST6EQi
                                #define STR_eIx4DST6EQi
static const fu::str str_eIx4DST6EQi fu_INIT_PRIORITY(1015) { "\n        struct Target { id: int }\n        struct Overload { name: string };\n        struct ClosureID { target: Target };\n        inline fn globid(lax t) i32();\n\n        fn parse(id!: string) {\n            if (!id) throw(\"throw!\");\n            shadow let id = id[0].int;\n            return ClosureID(Target(id));\n        }\n\n        fn zstHostArgsCanEndUpWithMismatchedArgVals(ref overloads: Overload[]) {\n            fn strGET(id: string) GET(parse(:id).target);\n            fn GET(t: Target) overloads[t.globid].name;\n            return \"0\".strGET;\n        }\n\n        fn main() {\n            mut overloads = [ Overload(\"Hello, world!\") ];\n            return overloads.zstHostArgsCanEndUpWithMismatchedArgVals().len - 13;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_4rh8LdLmbne
                                #define STR_4rh8LdLmbne
static const fu::str str_4rh8LdLmbne fu_INIT_PRIORITY(1015) { "\n        fn FAIL(implicit side: string)\n            throw(side);\n\n        fn ensureArgSeq_argsLenMismatch(\n            ref data: string, index: int)\n        {\n            fn strGET(id: string)\n                id && intGET(id.len || FAIL());\n\n            fn intGET(target: int)\n                target > data.len\n                    ? intGET(0).strGET\n                    : data[target ..];\n\n            return intGET(index);\n        }\n\n        fn main() {\n            let implicit side = \"Hello!\";\n            mut data = \"Hello, World!\";\n            return ensureArgSeq_argsLenMismatch(data, 5).len - 8;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_aodirEasCmj
                                #define STR_aodirEasCmj
static const fu::str str_aodirEasCmj fu_INIT_PRIORITY(1015) { "\n        fn FAIL(implicit fnames: string[], implicit _here: int)\n            throw(fnames[_here]);\n\n        fn ensureArgSeq_argsLenMismatch(\n            ref overloads: string[], which: int)\n        {\n            fn strGET(id: string)                   <alt>\n                intGET(int(id && id[0]) || FAIL()); <alt/>\n                id && intGET(int(id[0]) || FAIL()); </alt>\n\n            fn intGET(target: int) {\n                if (target >= overloads.len)\n                    throw(overloads ? intGET(0).strGET : \"\");\n\n                return overloads[target];\n            }\n\n            return intGET(which);\n        }\n\n        fn main() {\n            let implicit _here = 0;\n            let implicit fnames = [ \"Hello!\" ];\n            mut overloads = [ \"Hello, World!\" ];\n            return ensureArgSeq_argsLenMismatch(overloads, 0).len - 13;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_GAdGEvCiLVd
                                #define STR_GAdGEvCiLVd
static const fu::str str_GAdGEvCiLVd fu_INIT_PRIORITY(1015) { "BUG relaxed spec.args.len(2) != original.args.len(4)"_fu };
                                #endif

                                #ifndef STR_MwxJd6Y0wGh
                                #define STR_MwxJd6Y0wGh
static const fu::str str_MwxJd6Y0wGh fu_INIT_PRIORITY(1015) { "\n        struct Unit { a: string; b: string };\n\n        fn brokenAssignmentWantsStringGetsSlice(ref u: Unit) {\n            <alt>\n            ref a = u.b && u.a;         <alt/>\n            fn  a = u.b && u.a;         <alt/>\n            ref a = u.a;                <alt/>\n            fn  a = u.a;                </alt>\n            return a && a[0 .. a.len];\n        }\n\n        fn main() {\n            mut u = Unit(\"Hello\", \"world!\");\n            <alt>\n            mut ;; ConstCast    <alt/>\n            ref                 </alt>\n                res = brokenAssignmentWantsStringGetsSlice(:u);\n            res ~= \"!!\";\n            return res.len == 7 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_fGfJCzCisxi
                                #define STR_fGfJCzCisxi
static const fu::str str_fGfJCzCisxi fu_INIT_PRIORITY(1015) { "\n        struct Unit { a: string; b: string };\n\n        fn brokenAssignmentWantsStringGetsSlice(u: Unit, ref res: string) {\n            <alt>\n            let a = u.b && u.a;         <alt/>\n            fn  a = u.b && u.a;         <alt/>\n            let a = u.a;                <alt/>\n            fn  a = u.a;                </alt>\n            res   = a && a[0 .. a.len];\n        }\n\n        fn main() {\n            let u = Unit(\"Hello\", \"world!\");\n            mut res: string;\n            brokenAssignmentWantsStringGetsSlice(:u, :res);\n            return res.len == 5 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_NZsZKnKFcEb
                                #define STR_NZsZKnKFcEb
static const fu::str str_NZsZKnKFcEb fu_INIT_PRIORITY(1015) { "\n        struct Unit { a: string; b: string };\n\n        fn brokenAssignmentWantsStringGetsSlice(ref u: Unit, ref res: string) {\n            <alt>\n            ref a = u.b && u.a;         <alt/>\n            fn  a = u.b && u.a;         <alt/>\n            ref a = u.a;                <alt/>\n            fn  a = u.a;                </alt>\n            res   = a && a[0 .. a.len];\n            if (u.b)\n                return a;\n\n            return res;\n        }\n\n        fn main() {\n            mut u = Unit(\"Hello\", \"world!\");\n            mut res: string;\n            brokenAssignmentWantsStringGetsSlice(:u, :res).clear();\n            return res.len == 5 && !u.a.len ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_rFnJkVE5l84
                                #define STR_rFnJkVE5l84
static const fu::str str_rFnJkVE5l84 fu_INIT_PRIORITY(1015) { "\n        struct Unit { a: string; b: string };\n\n        fn brokenAssignmentWantsStringGetsSlice(units: Unit[], ref res: string) {\n            for (mut i = 0; i < units.len; i++) {\n                let u = units[i];           <alt>\n                let a = u.b && u.a;         <alt/>\n                fn  a = u.b && u.a;         <alt/>\n                let a = u.a;                <alt/>\n                fn  a = u.a;                </alt>\n                res   = a && a[0 .. a.len];\n            }\n        }\n\n        fn main() {\n            let units = [ Unit(\"Hello\", \"world!\") ];\n            mut res: string;\n            brokenAssignmentWantsStringGetsSlice(:units, :res);\n            return res.len == 5 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_XIUg3aIBkP4
                                #define STR_XIUg3aIBkP4
static const fu::str str_XIUg3aIBkP4 fu_INIT_PRIORITY(1015) { "\n        struct Unit { a: string; b: string };\n\n        fn brokenAssignmentWantsStringGetsSlice(ref units: Unit[], ref res: string) {\n            for (mut i = 0; i < units.len; i++) {\n                ref u = units[i];           <alt>\n                ref a = u.b && u.a;         <alt/>\n                fn  a = u.b && u.a;         <alt/>\n                ref a = u.a;                <alt/>\n                fn  a = u.a;                </alt>\n                res   = a && a[0 .. a.len];\n                if (u.b)\n                    return a;\n            }\n\n            return res;\n        }\n\n        fn main() {\n            mut units = [ Unit(\"Hello\", \"world!\") ];\n            mut res: string;\n            brokenAssignmentWantsStringGetsSlice(:units, :res).clear();\n            return res.len == 5 && units.all(|x| !x.a.len) ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_1ilaqwMePjh
                                #define STR_1ilaqwMePjh
static const fu::str str_1ilaqwMePjh fu_INIT_PRIORITY(1015) { "\n        struct Unit { a: string; b: string };\n<alt>\n        fn bang(str: string)\n            str[0 .. str.len] ~ (str.starts(with: \"H\") ? \", \" : \"!\");\n<alt/>\n        fn bang(mut str: string)\n            str[0 .. str.len] ~= (str.starts(with: \"H\") ? \", \" : \"!\");\n</alt>\n        fn brokenAssignmentWantsStringGetsSlice(units: Unit[], ref aa: string[], ref bb: string[]) {\n            for (mut i = 0; i < units.len; i++) {\n                let u = units[i];\n        <alt>\n                let a = u.a;        <alt/>\n                fn  a = u.a;        </alt>\n        <alt>\n                let b = a && u.b;   <alt/>\n                fn  b = a && u.b;   </alt>\n\n                aa.push(a && bang(a));\n                bb.push(b && bang(b));\n            }\n        }\n\n        fn main() {\n            let units = [ Unit(\"Hello\", \"world\") ];\n            mut aa: string[];\n            mut bb: string[];\n            brokenAssignmentWantsStringGetsSlice(:units, :aa, :bb);\n            return aa.join() ~ bb.join() == \"Hello, world!\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_boCxSefF295
                                #define STR_boCxSefF295
static const fu::str str_boCxSefF295 fu_INIT_PRIORITY(1015) { "\n        struct Unit { a: string; b: string };\n\n        fn bang(ref str: string)\n            str[0 .. str.len] ~= str.starts(with: \"H\") ? \", \" : \"!\";\n\n        fn brokenAssignmentWantsStringGetsSlice(ref units: Unit[], ref aa: string[], ref bb: string[]) {\n            for (mut i = 0; i < units.len; i++) {\n                ref u = units[i];\n        <alt>\n                ref a = u.a;        <alt/>\n                fn  a = u.a;        </alt>\n        <alt>\n                ref b = a && u.b;   <alt/>\n                fn  b = a && u.b;   </alt>\n\n                aa.push(a && bang(a));\n                bb.push(b && bang(b));\n            }\n        }\n\n        fn main() {\n            mut units = [ Unit(\"Hello\", \"world\") ];\n            mut aa: string[];\n            mut bb: string[];\n            brokenAssignmentWantsStringGetsSlice(:units, :aa, :bb);\n            return aa.join() ~ bb.join() == \"Hello, world!\"\n                && units.map(|u| u.a ~ u.b).join() == \"Hello, world!\" ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_iic78EGpxAb
                                #define STR_iic78EGpxAb
static const fu::str str_iic78EGpxAb fu_INIT_PRIORITY(1015) { "Cannot access ref b 16:25+1 inval write u 15:30+4 via 5:31+2"_fu };
                                #endif

                                #ifndef STR_ErGgRIaBMw9
                                #define STR_ErGgRIaBMw9
static const fu::str str_ErGgRIaBMw9 fu_INIT_PRIORITY(1015) { "\n        struct Type { vfacts: int };\n\n        fn TEST_FunctionNarrowing(host: Type)\n            TEST_Assignable(host, false);\n\n        fn TEST_Assignable(mut host: Type, inline reason) {\n            if (reason) host.vfacts = [];   <fail does nothing 4:12+22><pass/>\n            return host;                    </fail>\n        }\n\n        fn main() {\n            let host = Type(1);\n            TEST_FunctionNarrowing(host);\n            return host.vfacts - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_2XnPUzzis01
                                #define STR_2XnPUzzis01
static const fu::str str_2XnPUzzis01 fu_INIT_PRIORITY(1015) { "\n        struct Type { vfacts: int };\n\n        fn TEST_FunctionNarrowing(host: Type, inline reason) {\n            shadow mut host = host;\n            if (reason) host.vfacts = [];\n            return host;\n        }\n\n        fn main() {\n            let host = Type(1);\n            TEST_FunctionNarrowing(host, false);\n            return host.vfacts - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_gP83QiNxEP9
                                #define STR_gP83QiNxEP9
static const fu::str str_gP83QiNxEP9 fu_INIT_PRIORITY(1015) { "\n        struct Type { canon: string; vfacts: int }\n\n        fn TEST_FunctionNarrowing(host: Type, guest: Type) {\n            TEST_Assignable(host, guest, false)\n        }\n\n        fn TEST_Assignable(mut host: Type, guest: Type, inline reason: bool) {\n            if (reason) host.vfacts = [];\n            isAssignable(:host, :guest)\n        }\n\n        fn isAssignable(host: Type, guest: Type) {\n            host == guest\n        }\n\n        fn main() TEST_FunctionNarrowing(Type(), Type()) ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_s5To0Jewevh
                                #define STR_s5To0Jewevh
static const fu::str str_s5To0Jewevh fu_INIT_PRIORITY(1015) { "\n        fn what(arg: int) {\n            lax mut prefix = arg & 1        <fail does nothing X:X><pass/>\n            return prefix;                  </fail>\n        }\n\n        fn main() 0.what;\n    "_fu };
                                #endif

                                #ifndef STR_NLide8oHp42
                                #define STR_NLide8oHp42
static const fu::str str_NLide8oHp42 fu_INIT_PRIORITY(1015) { "<fail> does not throw"_fu };
                                #endif

                                #ifndef STR_vxllbTQfC2i
                                #define STR_vxllbTQfC2i
static const fu::str str_vxllbTQfC2i fu_INIT_PRIORITY(1015) { "\n        fn no_fx() {\n            mut res = 0;\n            pragma clock(`\n                static int counter;\n                `res`  = counter++;\n            `);\n            return res;\n        }\n\n        struct X { a: i32[]; b: i32[] };\n        fn test(x: X, ref y: i32[])\n            y ~= x.a;\n\n        fn main() {\n            mut x = X(\n                [ no_fx(), 2, 3, 4, 5, 6, 7, 8 ],\n                [ no_fx(), 3, 4, 5, 6, 7, 8, 9 ]);\n\n            test(x, x.a);\n            return x.a.len + no_fx * 1000 - 1016;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_g1eL60Zvh4i
                                #define STR_g1eL60Zvh4i
static const fu::str str_g1eL60Zvh4i fu_INIT_PRIORITY(1015) { "\n        struct A { a: X[] };\n        struct B { b: X[] };\n        struct C { c: X[] };\n        struct X { a: A[]; b: B[]; c?: C[]; };\n\n        fn GET(implicit ref x: X[], idx: int) {\n            return x[idx];\n        }\n\n        fn DUPE(implicit ref x: X[], idx: int) {\n            let src = GET(idx);\n            let idx1 = x.len;\n\n            x.grow(idx1 + 1)\n            ref dest = x[idx1];\n            dest.a = src.a;\n            dest.b = src.b;\n        }\n\n        fn main() {\n            implicit mut x = [ X([ A(), A() ], [ B(), B(), B() ], [ C(), C(), C(), C(), C() ]) ];\n            DUPE(0);\n            mut sum = 0;\n            for (mut i = 0; i < x.len; i++) {\n                shadow let x = x[i];\n                sum *= x.a.len || 1; sum += x.a.len;\n                sum *= x.b.len || 1; sum += x.b.len;\n                sum *= x.c.len || 1; sum += x.c.len;\n            }\n            return sum - 309;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_KY93l4iJQEg
                                #define STR_KY93l4iJQEg
static const fu::str str_KY93l4iJQEg fu_INIT_PRIORITY(1015) { "\n        noinline fn hello(x: i32) x;\n    "_fu };
                                #endif

                                #ifndef STR_HNMLY6Vnqwg
                                #define STR_HNMLY6Vnqwg
static const fu::str str_HNMLY6Vnqwg fu_INIT_PRIORITY(1015) { "\n        fn main() 0._0::hello + 0._1::hello;\n    "_fu };
                                #endif

                                #ifndef STR_AGr2q1Piub4
                                #define STR_AGr2q1Piub4
static const fu::str str_AGr2q1Piub4 fu_INIT_PRIORITY(1015) { "\n        noinline fn hello(x) x;\n    "_fu };
                                #endif

                                #ifndef STR_UX3HpCNPB46
                                #define STR_UX3HpCNPB46
static const fu::str str_UX3HpCNPB46 fu_INIT_PRIORITY(1015) { "\n        fn main() 0._0::hello + 0._1::hello;                    ;; DuplicateFunctions\n    "_fu };
                                #endif

                                #ifndef STR_QfKbKJREPx9
                                #define STR_QfKbKJREPx9
static const fu::str str_QfKbKJREPx9 fu_INIT_PRIORITY(1015) { "\n        fn Each(y<alt>: i32</alt>)\n            y & 1   ? y\n                    : y / 2 + Each(y / 2);\n    "_fu };
                                #endif

                                #ifndef STR_SorTR4aXN4e
                                #define STR_SorTR4aXN4e
static const fu::str str_SorTR4aXN4e fu_INIT_PRIORITY(1015) { "\n        fn Each(y<alt>: i32</alt>)\n            y & 1   ? y / 2\n                    : y / 2 + Each(y / 2);\n    "_fu };
                                #endif

                                #ifndef STR_QSVLBrqODx7
                                #define STR_QSVLBrqODx7
static const fu::str str_QSVLBrqODx7 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            let a = _0::Each(100);\n            let b = _1::Each(8);\n\n            return a+b - 107;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_ICiheY0Ami4
                                #define STR_ICiheY0Ami4
static const fu::str str_ICiheY0Ami4 fu_INIT_PRIORITY(1015) { "\n        fn find(keys: $T[], item: $T) {\n            for (mut i = 0; i < keys.len; i++) {\n                if (keys[i] >= item) {\n                    if (keys[i] != item)\n                        return -1;\n\n                    return i;\n                }\n            }\n\n            return -1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_oYzIVJbj7Sk
                                #define STR_oYzIVJbj7Sk
static const fu::str str_oYzIVJbj7Sk fu_INIT_PRIORITY(1015) { "\n        fn Set(_: $K) struct { keys: $K[]; };\n\n        fn has(using _, key)\n            _0::find(keys, key) >= 0;\n    "_fu };
                                #endif

                                #ifndef STR_9cwexZI9T1j
                                #define STR_9cwexZI9T1j
static const fu::str str_9cwexZI9T1j fu_INIT_PRIORITY(1015) { "\n        fn use_Set(a: string) {\n            mut set: _1::Set(string);\n            set.keys ~= a;\n            return set._1::has(a);\n        }\n\n        fn dont_use_Set(a: string, b: string) {\n            mut keys: string[];\n            keys ~= b;\n            keys ~= a;\n            return keys.find(a);\n        }\n\n        fn main() {\n            if (!use_Set(\"a\"))\n                return -1;\n\n            return dont_use_Set(\"a\", \"b\") - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_hYgX5gHQ5r8
                                #define STR_hYgX5gHQ5r8
static const fu::str str_hYgX5gHQ5r8 fu_INIT_PRIORITY(1015) { "\n        fn test(tokens: i32[]) {\n            mut lidx = 0;\n            mut sum  = 0;\n\n            fn token(idx: i32, col!: i32)       = sum += idx * col;\n            fn token(idx: i32)                  = token(:idx, col: lidx - idx);\n\n            for (mut i = 0; i < tokens.len; i++)\n                token(tokens[i]);\n\n            return sum;\n        }\n\n        fn main() [ 1 ].test + 1;\n    "_fu };
                                #endif

                                #ifndef STR_tTSX8KnSmGa
                                #define STR_tTSX8KnSmGa
static const fu::str str_tTSX8KnSmGa fu_INIT_PRIORITY(1015) { "\n        fn sum_each(a, b, Each)     a.Each + b.Each;\n\n        fn hello(x) {\n            if (x & 1) {\n                fn Each(y) y    ? y * Each(y - 1)\n                                : 100;\n\n                return sum_each(x, x, fn Each);\n            }\n            else {\n                fn Each(y) y    ? y * Each(y - 1)\n                                : 10000;\n\n                return sum_each(x, x, fn Each);\n            }\n        }\n    "_fu };
                                #endif

                                #ifndef STR_k2eQ2PJueV4
                                #define STR_k2eQ2PJueV4
static const fu::str str_k2eQ2PJueV4 fu_INIT_PRIORITY(1015) { "\n        fn Each(y) y & 1    ? y\n                            : y / 2 + Each(y / 2);\n\n        fn main() _0::hello(1) - 2 * Each(100)\n                + _0::hello(2) - 2 * Each(20000);\n    "_fu };
                                #endif

                                #ifndef STR_Db37nsTFWMc
                                #define STR_Db37nsTFWMc
static const fu::str str_Db37nsTFWMc fu_INIT_PRIORITY(1015) { "\n        fn sum_each(a, b)       // Same as above,\n            a.Each + b.Each;    //  but we don't explicitly pass the fn Each in.\n\n        fn hello(x) {\n            if (x & 1) {\n                fn Each(a) a    ? a * Each(a - 1)   // These get ignored?\n                                : 100;              //  sum_each goes and selects the one from _1.\n\n                return sum_each(x, x);\n            }\n            else {\n                fn Each(b) b    ? b * Each(b - 1)\n                                : 10000;\n\n                return sum_each(x, x);\n            }\n        }\n    "_fu };
                                #endif

                                #ifndef STR_pwjEGqbB95j
                                #define STR_pwjEGqbB95j
static const fu::str str_pwjEGqbB95j fu_INIT_PRIORITY(1015) { "\n        fn Each(c) c & 1    ? c\n                            : c / 2 + Each(c / 2);\n\n        fn main() _0::hello(1) - 2 * Each(100)\n                + _0::hello(2) - 2 * Each(20000);\n    "_fu };
                                #endif

                                #ifndef STR_2sHnIvnH4Yc
                                #define STR_2sHnIvnH4Yc
static const fu::str str_2sHnIvnH4Yc fu_INIT_PRIORITY(1015) { "\n        fn a        = \"aaa\";\n        fn shorter  = \"bb\";\n        fn greater  = \"aac\";\n\n        return a <> shorter == +1\n            && a <> greater == -1 ? 0 : 101;\n    "_fu };
                                #endif

                                #ifndef STR_ARbVH7j5eUk
                                #define STR_ARbVH7j5eUk
static const fu::str str_ARbVH7j5eUk fu_INIT_PRIORITY(1015) { "\n        fn &(a, b) {\n            mut res = a;\n            for (fieldname i: typeof(a)) res.i &= b.i;\n            return res;\n        }\n\n        struct XY  { x: i32; y: i32 };\n        struct UVW { u: i32; v: i32; w: i32 };\n    "_fu };
                                #endif

                                #ifndef STR_kcROpYwSf68
                                #define STR_kcROpYwSf68
static const fu::str str_kcROpYwSf68 fu_INIT_PRIORITY(1015) { "\n        import _0;\n\n        fn main() {\n            mut xy  =  XY(1, 2)    &  XY(2, 3);\n            mut uvw = UVW(1, 2, 3) & UVW(2, 3, 4);\n            return xy.y - uvw.v;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_HV0X1MEq5b1
                                #define STR_HV0X1MEq5b1
static const fu::str str_HV0X1MEq5b1 fu_INIT_PRIORITY(1015) { "\n        struct Projection { x: i32; y: i32 };\n        fn Projection(a: i32, b: i32) = Projection(x: a*a, y: b*b);\n        fn Projection(c: i32, d: i32) = Projection(x: c+c, y: d+d);\n    "_fu };
                                #endif

                                #ifndef STR_KoAhlTjsyo7
                                #define STR_KoAhlTjsyo7
static const fu::str str_KoAhlTjsyo7 fu_INIT_PRIORITY(1015) { "\n        import _0;\n\n        fn main() {\n            let p0 = Projection(a: 3,  4);\n            let p1 = Projection(c: 20, 30);\n            return p0.x + p1.x - 49;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_ELitno4wlw5
                                #define STR_ELitno4wlw5
static const fu::str str_ELitno4wlw5 fu_INIT_PRIORITY(1015) { "\n        struct Woot { i: i32 };\n        fn sqr(v) = mul(v, v);\n    "_fu };
                                #endif

                                #ifndef STR_1e3a4VG4OM7
                                #define STR_1e3a4VG4OM7
static const fu::str str_1e3a4VG4OM7 fu_INIT_PRIORITY(1015) { "\n        import _0;\n        noinline fn mul(x: Woot, y: Woot) = x.i * y.i;\n        inline fn use_sqr(a: Woot) = sqr(a);\n    "_fu };
                                #endif

                                #ifndef STR_ltWPaZGiJXe
                                #define STR_ltWPaZGiJXe
static const fu::str str_ltWPaZGiJXe fu_INIT_PRIORITY(1015) { "\n        import _0;\n        noinline fn mul(x: Woot, y: Woot) = 2 * x.i * y.i;\n        inline fn use_sqr(a: Woot) = sqr(a);\n    "_fu };
                                #endif

                                #ifndef STR_XD8NLOYIbT4
                                #define STR_XD8NLOYIbT4
static const fu::str str_XD8NLOYIbT4 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            let x = _0::Woot(2);\n            let a = _1::use_sqr(x);\n            let b = _2::use_sqr(x);\n            return a == 4 && b == 8 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Fq4ogPA9pc2
                                #define STR_Fq4ogPA9pc2
static const fu::str str_Fq4ogPA9pc2 fu_INIT_PRIORITY(1015) { "\n        noinline fn hey(a: int) a + 2;\n        pub fn add2(a) a.hey;\n    "_fu };
                                #endif

                                #ifndef STR_6PRTAxiBaOl
                                #define STR_6PRTAxiBaOl
static const fu::str str_6PRTAxiBaOl fu_INIT_PRIORITY(1015) { "\n        noinline fn hey(a: int) a + 3;\n        pub fn add3(a) a.hey;\n    "_fu };
                                #endif

                                #ifndef STR_AJsADX9c9Y1
                                #define STR_AJsADX9c9Y1
static const fu::str str_AJsADX9c9Y1 fu_INIT_PRIORITY(1015) { "\n        fn main() (-5)._0::add2._1::add3;\n    "_fu };
                                #endif

                                #ifndef STR_pvTxycb2KF0
                                #define STR_pvTxycb2KF0
static const fu::str str_pvTxycb2KF0 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            type A = { struct Node { value?: int; items: Node[] }; Node };\n            type B = { struct Node { items: Node[]; value?: uint }; Node };\n            fn sum(a: A, b: B) a.items.len + b.items.len;\n            return sum(A(items: [ A, A ]), B(items: [ B, B, B ])) - 5;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_qY3mizywEBe
                                #define STR_qY3mizywEBe
static const fu::str str_qY3mizywEBe fu_INIT_PRIORITY(1015) { "\n        struct Node { value: int; items: Node[] }\n        fn sum_a(n: Node) n.value + n.items.len;\n    "_fu };
                                #endif

                                #ifndef STR_YF4S7RdfVvg
                                #define STR_YF4S7RdfVvg
static const fu::str str_YF4S7RdfVvg fu_INIT_PRIORITY(1015) { "\n        struct Node { items: Node[]; value: uint }\n        fn sum_b(n: Node) n.value.int + n.items.len;\n    "_fu };
                                #endif

                                #ifndef STR_750jaIhoMzf
                                #define STR_750jaIhoMzf
static const fu::str str_750jaIhoMzf fu_INIT_PRIORITY(1015) { "\n        fn main() _0::sum_a(_0::Node(value: -11, [ _0::Node(), _0::Node() ]))\n                + _1::sum_b(_1::Node(value: 0x6, [ _1::Node(), _1::Node(), _1::Node() ]));\n    "_fu };
                                #endif

                                #ifndef STR_nzEDLcvaHPk
                                #define STR_nzEDLcvaHPk
static const fu::str str_nzEDLcvaHPk fu_INIT_PRIORITY(1015) { "\n        pragma emit(`\n            void ccIncrX2(int& a, int b) {\n                a += b * 2;\n            }\n        `);\n\n        fn main() {\n            mut a = 0;\n            pragma emit(\"ccIncrX2(\", a, \", 5);\");\n            return a - 10;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_xtBLPESrVai
                                #define STR_xtBLPESrVai
static const fu::str str_xtBLPESrVai fu_INIT_PRIORITY(1015) { "\n        pragma emit(\"// needs newline\");\n        pragma emit(`\n            namespace {\n            }\n        `);\n        fn main() 0;\n    "_fu };
                                #endif

                                #ifndef STR_Acu77WIZEre
                                #define STR_Acu77WIZEre
static const fu::str str_Acu77WIZEre fu_INIT_PRIORITY(1015) { "\n        fn hello(with_ints) {\n            mut a = 0;\n            mut b = 0;\n            pragma emit(`\n                for (;;) {\n                    `b` += `a`++;\n                    `with_ints(:a, :b)`;\n                }\n            `);                                                ;; GNUStmtExpr\n        }\n\n        fn main() {\n            mut sum = 0;\n            hello: |a, b| if (a + b > 3) return (sum = a + b) - 6;\n            return 101;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_eQeZkl1J0K1
                                #define STR_eQeZkl1J0K1
static const fu::str str_eQeZkl1J0K1 fu_INIT_PRIORITY(1015) { "\n        fn hello(with_ints) {\n            mut a = 0;\n            mut b = 0;\n            pragma emit(`\n                for (;;) {\n                    `b` += `a`++;\n                    `with_ints(:a, :b)`;\n                }\n            `);                                                ;; GNUStmtExpr\n        }\n\n        fn main() {\n            mut sum = 0;\n            hello: |a, b| if ((sum = a + b) > 3) break;\n            return sum - 6;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_pUalFXizeeg
                                #define STR_pUalFXizeeg
static const fu::str str_pUalFXizeeg fu_INIT_PRIORITY(1015) { "\n        fn hello(with_ints) {\n            mut a = 0;\n            mut b = 0;\n            pragma emit(`\n                for (;;) {\n                    `b` += `a`++;\n                    bool brk = `with_ints(:a, :b)`;\n                    if (brk) break;\n                }\n            `);\n        }\n\n        fn main() {\n            mut sum = 0;\n            hello: |a, b| (sum = a + b) > 3;\n            return sum - 6;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Y2Q52pisvCk
                                #define STR_Y2Q52pisvCk
static const fu::str str_Y2Q52pisvCk fu_INIT_PRIORITY(1015) { "\n        fn apply(num: i32, func: fn (i32): i32) = func(num);\n        fn main()                               = apply([1], |i| i - 1);\n    "_fu };
                                #endif

                                #ifndef STR_U7BlLIMQO8i
                                #define STR_U7BlLIMQO8i
static const fu::str str_U7BlLIMQO8i fu_INIT_PRIORITY(1015) { "expected , got . 2:42+1"_fu };
                                #endif

                                #ifndef STR_3xVeAd7xPS1
                                #define STR_3xVeAd7xPS1
static const fu::str str_3xVeAd7xPS1 fu_INIT_PRIORITY(1015) { "\n        fn desc(a: i32, b: i32) b < a;\n\n        fn main() {\n            mut vals = [ 1, 2 ];\n            vals.sort(fn desc);\n            return vals[0] - 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_ZxywGOfYBcg
                                #define STR_ZxywGOfYBcg
static const fu::str str_ZxywGOfYBcg fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut vals = [ 1, 2 ];\n            vals.sort(|a: i32, b: i32| b < a);\n            return vals[0] - 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_TKereznYXb4
                                #define STR_TKereznYXb4
static const fu::str str_TKereznYXb4 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut vals = [ 1, 2 ];\n            vals.sort(|a, b| b < a);\n            return vals[0] - 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_0uqKdCPVVo2
                                #define STR_0uqKdCPVVo2
static const fu::str str_0uqKdCPVVo2 fu_INIT_PRIORITY(1015) { "\n        fn test(ref vals: i32[], xor: i32)\n            vals.sort(\n                |a: i32, b: i32|\n                    a^xor < b^xor);\n\n        fn main() {\n            mut vals = [ 1, 2 ];\n            vals.test(xor: 3); // xor:3 descs 1 and 2.\n            return vals[0] - 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_4HV1ElLoVS9
                                #define STR_4HV1ElLoVS9
static const fu::str str_4HV1ElLoVS9 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut arr = [ 1, 2, 3, 4 ];\n\n            arr.par::each: |ref it| it *= 2;\n\n            mut sum = 0;\n            for (mut i = 0; i < arr.len; i++)\n                sum += arr[i];\n\n            return sum - 2 - 4 - 6 - 8;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Q9dZtLEVsB7
                                #define STR_Q9dZtLEVsB7
static const fu::str str_Q9dZtLEVsB7 fu_INIT_PRIORITY(1015) { "\n        fn seq__each(ref a: $T[..], fn)\n            for (mut i = 0; i < a.len; i++)\n                fn(a[i]);\n\n        fn main() {\n            mut arr = [ 1, 2, 3, 4 ];\n            mut sum = 0;\n\n            <fail purectx writes to implicit sum>\n            arr.par::each: |ref it| <pass/>\n            arr.seq__each: |ref it| </fail>\n                sum += it *= 2;                                 ;; PointlessMustSeq\n\n            return sum - 2 - 4 - 6 - 8;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Lf3JMmMbil7
                                #define STR_Lf3JMmMbil7
static const fu::str str_Lf3JMmMbil7 fu_INIT_PRIORITY(1015) { "\n        fn seq__each(ref a: $T[..], fn)\n            for (mut i = 0; i < a.len; i++)\n                fn(a[i]);\n\n        fn main() {\n            mut arr = [ 1, 2, 3, 4 ];\n\n            <fail noflow non local control flow>\n            arr.par::each: |ref it| <pass/>\n            arr.seq__each: |ref it| </fail>\n                if ((it *= 2) > 4)\n                    break;\n\n            mut sum = 0;\n            for (mut i = 0; i < arr.len; i++)\n                sum += arr[i];\n\n            return sum - 2 - 4 - 6 - 4/*unchanged after break*/;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_ENftHR8bqH0
                                #define STR_ENftHR8bqH0
static const fu::str str_ENftHR8bqH0 fu_INIT_PRIORITY(1015) { "\n        fn test(ref arr: i32[])\n            arr.par::each: |ref v, i| v += i;\n\n        fn main() {\n            let N = 1087 * 1091;\n\n            mut orig: i32[];\n            orig.resize(N);\n\n            mut arr = orig;\n            arr.test();\n\n            if (arr.len != N || arr.len != orig.len)\n                return 1;\n\n            for (mut i = 0; i < N; i++)\n                if (orig[i] != 0)\n                    return 2;\n\n            for (mut i = 0; i < N; i++)\n                if (arr[i] != i)\n                    return 3;\n\n            return 0;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_jzHRoXhPvu7
                                #define STR_jzHRoXhPvu7
static const fu::str str_jzHRoXhPvu7 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            let i: i8 = 0;\n            <fail return type does not match annot i32, got i8 5:13+6>\n            return i;        <pass/>\n            return i.i32;    </fail>\n        }\n    "_fu };
                                #endif

                                #ifndef STR_SzjjlrtvTeh
                                #define STR_SzjjlrtvTeh
static const fu::str str_SzjjlrtvTeh fu_INIT_PRIORITY(1015) { "\n        primitive s32: i32;\n\n        fn main() {\n            let i: s32 = 0;\n            <fail return type does not match annot expects i32, got prim s32 7:13+6>\n            return i;        <pass/>\n            return i.i32;    </fail>\n        }\n    "_fu };
                                #endif

                                #ifndef STR_mNKQFe92yT2
                                #define STR_mNKQFe92yT2
static const fu::str str_mNKQFe92yT2 fu_INIT_PRIORITY(1015) { "\n        enum Enum { None = 0 };\n\n        fn main() {\n            let e = Enum.None;\n            <fail return type does not match annot expects i32, got Enum 7:13+6>\n            return e;        <pass/>\n            return e.i32;    </fail>\n        }\n    "_fu };
                                #endif

                                #ifndef STR_fF6DgpL8p0f
                                #define STR_fF6DgpL8p0f
static const fu::str str_fF6DgpL8p0f fu_INIT_PRIORITY(1015) { "\n        using enum Test { A = 5; B; C };\n        fn main()\n            <fail - bad call>\n            C - 7;      <pass/>\n            C.i32 - 7;  </fail>\n    "_fu };
                                #endif

                                #ifndef STR_GNVUcbPTqvb
                                #define STR_GNVUcbPTqvb
static const fu::str str_GNVUcbPTqvb fu_INIT_PRIORITY(1015) { "\n        using\n        <alt>\n        primitive <alt/>\n        enum      </alt> Test: i32 { A1; A2; M5 = 5; A6 };\n\n        fn main()\n            A1.i32 + A2.i32 * 10 + M5.i32 * 100 + A6.i32 * 1000\n                == 6521 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_2ooe0u2YVQj
                                #define STR_2ooe0u2YVQj
static const fu::str str_2ooe0u2YVQj fu_INIT_PRIORITY(1015) { "\n        using\n        <fail bad call to ->\n        enum         <pass/>\n        primitive    </fail> Test: i32 { A; B };\n        fn main() (B - A).i32 - 1;\n    "_fu };
                                #endif

                                #ifndef STR_xDh7khfJPig
                                #define STR_xDh7khfJPig
static const fu::str str_xDh7khfJPig fu_INIT_PRIORITY(1015) { "\n        enum EnumA: i32;\n        enum EnumB: EnumA { Zero = 0 };\n        fn main() EnumB.Zero.i32;\n    "_fu };
                                #endif

                                #ifndef STR_bMASOltDVVl
                                #define STR_bMASOltDVVl
static const fu::str str_bMASOltDVVl fu_INIT_PRIORITY(1015) { "\n        primitive PrimA: i32;\n        using primitive PrimB: PrimA { Zero = 0; One };\n        fn main() (One - 1).i32;\n    "_fu };
                                #endif

                                #ifndef STR_XuinLIhnv2k
                                #define STR_XuinLIhnv2k
static const fu::str str_XuinLIhnv2k fu_INIT_PRIORITY(1015) { "\n        primitive PrimA: i32;\n        primitive PrimB: PrimA { Zero = 0; One };\n\n    <alt>\n        fn and_decr(ref prim: PrimB)\n            prim &&= prim - 1;\n    <alt/>\n        fn and_decr(ref prim: PrimB)\n        {\n            mut res = prim - 1;\n            prim &&= res;\n            return prim;\n        }\n    </alt>\n\n        fn main() {\n            mut r = PrimB.One;\n            return r.and_decr.i32;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_x853FIwFRH1
                                #define STR_x853FIwFRH1
static const fu::str str_x853FIwFRH1 fu_INIT_PRIORITY(1015) { "\n        enum Hey { foo; };\n        fn test(hey: Hey) hey.i32;\n        fn main() test(\"foo\") - 1;\n    "_fu };
                                #endif

                                #ifndef STR_FX1WbvOQsP9
                                #define STR_FX1WbvOQsP9
static const fu::str str_FX1WbvOQsP9 fu_INIT_PRIORITY(1015) { "\n        using enum Greet { hello; world };\n        fn main()\n            hello ~ \" \" ~ world == \"hello world\"                ;; DuplicateFunctions\n                ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_mgxNCoXenSl
                                #define STR_mgxNCoXenSl
static const fu::str str_mgxNCoXenSl fu_INIT_PRIORITY(1015) { "\n        enum Greet { hello; world };\n        fn woot(hi: Greet) hi == \"hello\";\n        fn main() Greet.hello.woot ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_1PU1HAOK0P4
                                #define STR_1PU1HAOK0P4
static const fu::str str_1PU1HAOK0P4 fu_INIT_PRIORITY(1015) { "\n        using enum Greet { hello; world };\n        fn h() Greet.hello;\n        fn w() Greet.world;\n    "_fu };
                                #endif

                                #ifndef STR_BLkvlzN2nRk
                                #define STR_BLkvlzN2nRk
static const fu::str str_BLkvlzN2nRk fu_INIT_PRIORITY(1015) { "\n        fn main()\n            _0::h() ~ \" \" ~ _0::w() == \"hello world\"            ;; DuplicateFunctions\n                ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_UhZPzvlyXid
                                #define STR_UhZPzvlyXid
static const fu::str str_UhZPzvlyXid fu_INIT_PRIORITY(1015) { "\n        using enum _0 { A; B };\n    "_fu };
                                #endif

                                #ifndef STR_8krJ9vKI0Ci
                                #define STR_8krJ9vKI0Ci
static const fu::str str_8krJ9vKI0Ci fu_INIT_PRIORITY(1015) { "\n        fn test(x: ::_0) x.i32;\n        fn main() \"A\".test - _0::A.i32;\n    "_fu };
                                #endif

                                #ifndef STR_5n1lru9tNYe
                                #define STR_5n1lru9tNYe
static const fu::str str_5n1lru9tNYe fu_INIT_PRIORITY(1015) { "\n        enum _0 { A; B };\n    "_fu };
                                #endif

                                #ifndef STR_nh4koosfWz3
                                #define STR_nh4koosfWz3
static const fu::str str_nh4koosfWz3 fu_INIT_PRIORITY(1015) { "\n        fn test(x: ::_0 = \"B\") x.i32;\n        fn main() test - ::_0.B.i32;\n    "_fu };
                                #endif

                                #ifndef STR_HukZVc94OZ2
                                #define STR_HukZVc94OZ2
static const fu::str str_HukZVc94OZ2 fu_INIT_PRIORITY(1015) { "\n        enum Enum { A = 0; B };\n        fn inner(x: Enum) x.i32;\n        fn outer(x: i32) inner(x & 1 ? \"B\" : \"A\");\n        fn main() outer(0);\n    "_fu };
                                #endif

                                #ifndef STR_MYdZDZPRl4j
                                #define STR_MYdZDZPRl4j
static const fu::str str_MYdZDZPRl4j fu_INIT_PRIORITY(1015) { "\n        enum Test { A; B = A; C; };\n        fn main() Test.C.i32 - 1;\n    "_fu };
                                #endif

                                #ifndef STR_BHZehN7PC0h
                                #define STR_BHZehN7PC0h
static const fu::str str_BHZehN7PC0h fu_INIT_PRIORITY(1015) { "A is not defined here 2:28+1"_fu };
                                #endif

                                #ifndef STR_p4VpH2ZxlQ4
                                #define STR_p4VpH2ZxlQ4
static const fu::str str_p4VpH2ZxlQ4 fu_INIT_PRIORITY(1015) { "\n        using flags Flags { A; B; C; D };\n\n        fn main() {\n            mut flags = A | C;\n            return flags.i32 == 5 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_mYvSnmAq9W4
                                #define STR_mYvSnmAq9W4
static const fu::str str_mYvSnmAq9W4 fu_INIT_PRIORITY(1015) { "\n        flags Flags: i32 { A; B };\n\n        fn main() {\n            mut hello = 5;\n            mut world = hello.Flags;\n            return world.i32 - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_OK02hUaDTo6
                                #define STR_OK02hUaDTo6
static const fu::str str_OK02hUaDTo6 fu_INIT_PRIORITY(1015) { "\n        using flags Hey: u8 { A; B };\n        fn main() {\n            mut flags = A | B;\n            flags &= ~B;\n            return flags.i32 - 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_bc305rUCcd6
                                #define STR_bc305rUCcd6
static const fu::str str_bc305rUCcd6 fu_INIT_PRIORITY(1015) { "\n        enum thing { i32; int; bool }\n\n        // So the problem is the retval annotation for fn ==(template): bool\n        //  fails to resolve as it conflicts with enumv from thing here.\n        //\n        // I'm not terribly sure what we want to do about it,\n        //  it's the ambiguity thing again - template sees the enum on expansion,\n        //   so it does kinda make sense for thing not to compile,\n        //    otherwise imagine the original bool goes away,\n        //     it'd fallback to the enumv here, which is exactly not what we want.\n        //\n        // Perhaps the scoping rules for templates don't make so much sense,\n        //  if we didn't make everything from local scope visible\n        //   they'll also compile faster.\n        //\n        fn isInt (k: thing) k == \"i32\" || k == \"int\";\n        fn isBool(k: thing) k == \"bool\";\n        fn main() isInt(\"i32\") && isBool(\"bool\") ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_O2OokfNZuKa
                                #define STR_O2OokfNZuKa
static const fu::str str_O2OokfNZuKa fu_INIT_PRIORITY(1015) { "\n        enum ID: u64 {\n            // clang warned with -Wimplicitly-unsigned-literal\n            CustomIDs = 0x8000_0000_0000_0000;\n            BitmapFontAtlas;\n        };\n\n        fn main() {\n            mut id: u64 = ID.BitmapFontAtlas.u64;\n            // meawhile this outputted the underscores\n            return id == 0x8000_0000_0000_0001 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_KwcYIIvaRE5
                                #define STR_KwcYIIvaRE5
static const fu::str str_KwcYIIvaRE5 fu_INIT_PRIORITY(1015) { "\n        using enum ID: u32 {\n            SecondLast = 0xffff_fffe;\n            Last;\n            <fail exhaust range>\n            NoRoom; <pass/></fail>\n        };\n\n        fn main() {\n            return Last.u32 == 0xffff_ffff ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_7E053aQjj6b
                                #define STR_7E053aQjj6b
static const fu::str str_7E053aQjj6b fu_INIT_PRIORITY(1015) { "\n        enum ID: u64 {\n            SecondLast = 0xffff_ffff_ffff_fffe;\n            Last;\n            <fail exhaust range>\n            NoRoom; <pass/></fail>\n        };\n\n        fn main() {\n            return ID.Last.u64 == 0xffff_ffff_ffff_ffff ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_xdgD8N5OY03
                                #define STR_xdgD8N5OY03
static const fu::str str_xdgD8N5OY03 fu_INIT_PRIORITY(1015) { "\n        enum ID { A = 1 };\n        using enum IDOffset { B = 10 };\n        fn offset(a: ID, b: IDOffset) = a.i32 + b.i32;\n    "_fu };
                                #endif

                                #ifndef STR_zbqLAlJTv81
                                #define STR_zbqLAlJTv81
static const fu::str str_zbqLAlJTv81 fu_INIT_PRIORITY(1015) { "\n        fn main() = _0::ID.A.offset(\n            _0::<alt>B<alt/>IDOffset.B</alt>) - 11;\n    "_fu };
                                #endif

                                #ifndef STR_lhdS6fISOJ4
                                #define STR_lhdS6fISOJ4
static const fu::str str_lhdS6fISOJ4 fu_INIT_PRIORITY(1015) { "\n        enum ABC { A; B; C };\n\n        fn isAorB(x: ABC)\n            x == \"A\" ||     <fail 6:15+2 incompatible types for T>\n            x == \"b\";       <pass/>\n            x == \"B\";       </fail>\n\n        fn main() isAorB(\"A\") && isAorB(\"B\") && !isAorB(\"C\") ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_GoCO9rldWa5
                                #define STR_GoCO9rldWa5
static const fu::str str_GoCO9rldWa5 fu_INIT_PRIORITY(1015) { "\n        <alt>\n        using </alt>\n        enum Hello { str; b };\n\n        <split/>\n        fn main() {\n            mut out = \"str\";\n            return (out ~ \"b\").len - 4;\n        };\n    "_fu };
                                #endif

                                #ifndef STR_JzAwBv3xALh
                                #define STR_JzAwBv3xALh
static const fu::str str_JzAwBv3xALh fu_INIT_PRIORITY(1015) { "\n        enum world { world; };\n        fn type_vs_value(type X) = \"NO!\";\n        fn type_vs_value(str: string) = str ~ \"!\";\n        fn hello(.type_vs_value) = \"Hello \" ~ type_vs_value;\n        fn main() = hello(\"world\") == \"Hello world!\" ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_8Cvo1IMWO3k
                                #define STR_8Cvo1IMWO3k
static const fu::str str_8Cvo1IMWO3k fu_INIT_PRIORITY(1015) { "\n        enum world { world; };\n        fn world(str: string) = str ~ \"!\";\n        fn hello(.world) = \"Hello \" ~ world;\n        fn main() = hello(\"world\") == \"Hello world!\" ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_WlqTtHNNhM8
                                #define STR_WlqTtHNNhM8
static const fu::str str_WlqTtHNNhM8 fu_INIT_PRIORITY(1015) { "\n        enum Kind { None; A };\n    "_fu };
                                #endif

                                #ifndef STR_MvfsSVRQB05
                                #define STR_MvfsSVRQB05
static const fu::str str_MvfsSVRQB05 fu_INIT_PRIORITY(1015) { "\n        enum Kind { None; B };\n    "_fu };
                                #endif

                                #ifndef STR_NWCmQD4aCbl
                                #define STR_NWCmQD4aCbl
static const fu::str str_NWCmQD4aCbl fu_INIT_PRIORITY(1015) { "\n        fn main() _0::Kind.A.i32 - _1::Kind.B.i32;\n    "_fu };
                                #endif

                                #ifndef STR_PniEgXTrCXb
                                #define STR_PniEgXTrCXb
static const fu::str str_PniEgXTrCXb fu_INIT_PRIORITY(1015) { "\n        using primitive Distance: f32 {\n            Meter       = 1\n            Kilometer   = 1000\n        };\n\n        fn main() Kilometer / Meter == Kilometer ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_KmETJqDp3t9
                                #define STR_KmETJqDp3t9
static const fu::str str_KmETJqDp3t9 fu_INIT_PRIORITY(1015) { "\n        primitive LogicalIndent: u16 { Max = 0xffff };\n\n        noinline fn test(ref li: LogicalIndent) {\n            let prev = li;\n            li = \"Max\";\n            return prev < \"Max\";\n        }\n\n        fn main() {\n            mut li: LogicalIndent;\n            let a = test(li);\n            let b = test(li);\n            return a || !b ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_XO40EdCgGZ8
                                #define STR_XO40EdCgGZ8
static const fu::str str_XO40EdCgGZ8 fu_INIT_PRIORITY(1015) { "\n        enum FaceCull { Disabled = 0; CullCW; CullCCW }\n        pub fn updateFaceCull(v: FaceCull) v.int;\n    "_fu };
                                #endif

                                #ifndef STR_lA3gn4LRZFk
                                #define STR_lA3gn4LRZFk
static const fu::str str_lA3gn4LRZFk fu_INIT_PRIORITY(1015) { "\n        fn test(v: int) _0::updateFaceCull(\n            v == 1 ? \"CullCW\"   : v == 2    ? \"CullCCW\"\n                                            : \"Disable\"); //< should be \"Disabled\"\n        fn main() 0.test;                                 //   gotta suggest a fix\n    "_fu };
                                #endif

                                #ifndef STR_JZKkHEHMrPj
                                #define STR_JZKkHEHMrPj
static const fu::str str_JZKkHEHMrPj fu_INIT_PRIORITY(1015) { "FaceCull, got string 2:29+14"_fu };
                                #endif

                                #ifndef STR_mhIp5eCmxC1
                                #define STR_mhIp5eCmxC1
static const fu::str str_mhIp5eCmxC1 fu_INIT_PRIORITY(1015) { "\n        enum Token { KEY_X }\n\n        fn update(ref state: int, tokens: Token[])\n            if (tokens.has(\"KEY_X\"))\n                state++;\n\n        fn main() {\n            mut state = -1;\n            state.update([ Token.KEY_X ]);\n            return state;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_cstDX5OBfka
                                #define STR_cstDX5OBfka
static const fu::str str_cstDX5OBfka fu_INIT_PRIORITY(1015) { "Incompat types for T Token string byte 5:24+3"_fu };
                                #endif

                                #ifndef STR_dfA6MAtIeTh
                                #define STR_dfA6MAtIeTh
static const fu::str str_dfA6MAtIeTh fu_INIT_PRIORITY(1015) { "\n        enum RunMode { None = 0; Normally; EnsureExecutableButDontRun }\n\n        fn build(runmode: RunMode) runmode.i32;\n        fn build(runmode: RunMode, bootstrap: bool)\n            build(runmode: bootstrap\n                ? runmode\n                : runmode && \"EnsureExecutableButDontRun\");\n\n        fn main() build(\"Normally\", false) - 2;\n    "_fu };
                                #endif

                                #ifndef STR_dtCVR0EWJF2
                                #define STR_dtCVR0EWJF2
static const fu::str str_dtCVR0EWJF2 fu_INIT_PRIORITY(1015) { "\n        union union_ui {\n            i: i32;\n            u: u32;\n        }\n\n        fn main() {\n            mut ui = union_ui(i: -1);\n            return (ui.u - 0xffffffff).i32;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_mK8cHmIIEf1
                                #define STR_mK8cHmIIEf1
static const fu::str str_mK8cHmIIEf1 fu_INIT_PRIORITY(1015) { "\n        fn test(a: int, b: int) a +% b;\n        fn main() test(int.MIN, -1) - int.MAX;\n    "_fu };
                                #endif

                                #ifndef STR_LZTU8zhmhBa
                                #define STR_LZTU8zhmhBa
static const fu::str str_LZTU8zhmhBa fu_INIT_PRIORITY(1015) { "\n        fn does_throw(mut x: i32) {\n            if (x & 1)          return x;\n            mut str = \"\";\n            while (x--)         str ~= x;\n            throw(str);\n        }\n\n        nothrow fn does_catch(mut y: i32) {\n            try                 return does_throw(y);\n            catch (e)           return e.len;\n        }\n\n        <fail does_throw throws>\n        nothrow <pass/></fail>\n        fn doesnt_catch(mut z: i32) {\n            if (z & 2)          return does_throw(z);\n            else                return does_catch(z);\n        }\n\n        fn main() = doesnt_catch(1) - 1;\n    "_fu };
                                #endif

                                #ifndef STR_zWW85IiRHG8
                                #define STR_zWW85IiRHG8
static const fu::str str_zWW85IiRHG8 fu_INIT_PRIORITY(1015) { "\n        fn has_fx() {\n            mut res = 0;\n            pragma output(`\n                static int counter;\n                `res`  = counter++;\n            `);\n            return res;\n        }\n\n        fn not_dead_mutually_rec_a(x: i32) {\n            if (x > 0) {\n                not_dead_mutually_rec_b(x - 1);\n                has_fx();\n            }\n        }\n\n        fn not_dead_mutually_rec_b(x: i32) {\n            if (x > 0) {\n                not_dead_mutually_rec_a(x - 1);\n                has_fx();\n            }\n        }\n\n        fn main() {\n            <alt>\n            not_dead_mutually_rec_a(2); <alt/>\n            not_dead_mutually_rec_b(2); </alt>\n            return has_fx() - 2;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_g65ZuNHPj04
                                #define STR_g65ZuNHPj04
static const fu::str str_g65ZuNHPj04 fu_INIT_PRIORITY(1015) { "\n        fn no_fx() {\n            mut res = 0;\n            pragma clock(`\n                static int counter;\n                `res`  = counter++;\n            `);\n            return res;\n        }\n\n        fn test(lax x: i32) {\n            x & 1 && no_fx();\n            x & 2 || no_fx();\n            if (!no_fx) no_fx(); else no_fx();\n            for (mut i = 1; i--> 0; no_fx()) no_fx();\n\n            // the idea is that everything above should go,\n            //  and just this one call to no_fx will remain.\n            return no_fx();\n        }\n\n        fn main() = test(1);\n    "_fu };
                                #endif

                                #ifndef STR_4O0eDuFPMl5
                                #define STR_4O0eDuFPMl5
static const fu::str str_4O0eDuFPMl5 fu_INIT_PRIORITY(1015) { "\n        fn lex(src: string) {\n            mut idx = 0;\n            let end = src.len;\n            while (idx < end) {\n                let c = src[idx++]; // bug in discard(if) unused this var\n                if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z' || c == '_' || c >= '0' && c <= '9') {\n                    //\n                }\n                else {\n                    idx--;\n                    break;\n                }\n            }\n            return idx;\n        }\n\n        fn main() = \"hello!\".lex - 5;\n    "_fu };
                                #endif

                                #ifndef STR_RmgGZeNM6ch
                                #define STR_RmgGZeNM6ch
static const fu::str str_RmgGZeNM6ch fu_INIT_PRIORITY(1015) { "\n        let se_global_false = false;                            ;; !DEV_DontFoldLiterals\n        <split/>\n        fn main() {\n            if (se_global_false) return THIS_DOESNT_EXIST();\n            return 0;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_bYLORUJwv20
                                #define STR_bYLORUJwv20
static const fu::str str_bYLORUJwv20 fu_INIT_PRIORITY(1015) { "\n        let se_global_true = true;                              ;; !DEV_DontFoldLiterals\n        <split/>\n        fn main() {\n            if (!se_global_true) return THIS_DOESNT_EXIST();\n            return 0;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_tRWdBElJGRj
                                #define STR_tRWdBElJGRj
static const fu::str str_tRWdBElJGRj fu_INIT_PRIORITY(1015) { "\n        let se_global_let_from_closure = false;                 ;; !DEV_DontFoldLiterals\n        <split/>\n        fn main() {\n            fn test() {\n                if (se_global_let_from_closure) return THIS_DOESNT_EXIST();\n                return 0;\n            }\n            return test();\n        }\n    "_fu };
                                #endif

                                #ifndef STR_xvucwGYzNOk
                                #define STR_xvucwGYzNOk
static const fu::str str_xvucwGYzNOk fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            <fail THIS_DOESNT_EXIST not defined 5:38+17>\n            mut <pass/>\n            let </fail> se_local_let = false;                   ;; !DEV_DontFoldLiterals\n            if (se_local_let) return THIS_DOESNT_EXIST();\n            return 0;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_J3W0m9R6dVh
                                #define STR_J3W0m9R6dVh
static const fu::str str_J3W0m9R6dVh fu_INIT_PRIORITY(1015) { "\n        // 'v' got mistagged as VFacts.AlwaysFalse\n        struct Hello { v?: bool; }\n        fn main() = Hello(true).v ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_1dOcin5BCy2
                                #define STR_1dOcin5BCy2
static const fu::str str_1dOcin5BCy2 fu_INIT_PRIORITY(1015) { "\n        // 'v' got mistagged as VFacts.AlwaysFalse\n        struct Hello { v?: bool; }\n\n        fn main() {\n            let yes = Hello(true);\n            let no  = Hello(false);\n\n            let expect_true = yes.v;\n            let expect_false = no.v;\n\n            if (!expect_true) return 20;\n            if (expect_false) return 10;\n            return 0;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Vd6jAj1drW8
                                #define STR_Vd6jAj1drW8
static const fu::str str_Vd6jAj1drW8 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            <fail THIS_DOESNT_EXIST not defined 6:44+17>\n            mut <pass/>\n            let </fail> se_closure_let = false;                 ;; !DEV_DontFoldLiterals\n            fn test() {\n                if (se_closure_let) return THIS_DOESNT_EXIST();\n                return 0;\n            }\n            return test();\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Pi6xvQdFLeg
                                #define STR_Pi6xvQdFLeg
static const fu::str str_Pi6xvQdFLeg fu_INIT_PRIORITY(1015) { "\n        fn test(x: i32) {\n            let val =                                       <alt>\n                x & 1 ? { return 0 } : { return 1 };        <alt/>\n                x & 1 && { return 0 } || { return 1 };      <alt/>\n                (x & 1 || { return 1 }) && { return 0 };    </alt>\n\n            return UNREACHABLE(val);\n        }\n\n        fn main() test(1);\n    "_fu };
                                #endif

                                #ifndef STR_3fwinQ4O1qa
                                #define STR_3fwinQ4O1qa
static const fu::str str_3fwinQ4O1qa fu_INIT_PRIORITY(1015) { "\n        noinline fn alwaysFalse() false;\n        fn main() alwaysFalse.i32;\n    "_fu };
                                #endif

                                #ifndef STR_Ep8x7vZi8pk
                                #define STR_Ep8x7vZi8pk
static const fu::str str_Ep8x7vZi8pk fu_INIT_PRIORITY(1015) { "\n        fn typeParamsMusntPickUpVFacts(x: i32) {\n            let y = x || throw(\"x == 0\"); // Now y is always true.\n            if (y & 1) // & 1 is not always true though.\n                return y * 10;\n            else\n                return y * 100;\n        }\n\n        fn main() typeParamsMusntPickUpVFacts(3)\n                + typeParamsMusntPickUpVFacts(2) <fail weaker operator new line 11:17+1> == 230 ? 0 : 1 <pass/>\n                    == 230 ? 0 : 1;              </fail>\n    "_fu };
                                #endif

                                #ifndef STR_90YEa9KO3Kb
                                #define STR_90YEa9KO3Kb
static const fu::str str_90YEa9KO3Kb fu_INIT_PRIORITY(1015) { "\n        fn test() <fail return does not match annotation never 4:23+2>\n                : never <pass/></fail>\n                    = [];\n\n        fn main() {\n            mut x: i32 = test();\n            return x;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_7aGG30WswR9
                                #define STR_7aGG30WswR9
static const fu::str str_7aGG30WswR9 fu_INIT_PRIORITY(1015) { "\n        fn checkPalindrome(host: string, guest: string)\n            return host == guest || throw(\":(\");\n\n        fn palindrome(value: string) {\n            mut rev = value;\n            rev.reverse();\n            <alt>\n            checkPalindrome(value, rev);\n            return rev;\n            <alt/>\n            return checkPalindrome(value, rev)\n                && rev;\n            </alt>\n        }\n\n        fn main() {\n            mut n = \"opera-arepo\";\n            return n.palindrome.len - 11;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_ykKKvopL5S6
                                #define STR_ykKKvopL5S6
static const fu::str str_ykKKvopL5S6 fu_INIT_PRIORITY(1015) { "\n        struct Node         { value: string };\n        struct Target       { index: i32    };\n        struct SolvedNode   { value: string };\n\n        fn solve(n_root: Node)\n        {\n            fn solveNode(node: Node)\n                return CallerNode(node.value);\n\n            fn checkAssignable(host: string, guest: string)\n                return host == guest || throw(\":(\");\n\n            fn CallerNode(value: string) {\n                <alt>\n                checkAssignable(value, n_root.value);\n                return SolvedNode(:value);\n                <alt/>\n                return checkAssignable(value, n_root.value)\n                    && SolvedNode(:value);\n                </alt>\n            }\n\n            return solveNode(n_root);\n        }\n\n        fn main() {\n            mut n = Node(\"hello!\");\n            return n.solve.value.len - 6;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_KUNkWgFt0ea
                                #define STR_KUNkWgFt0ea
static const fu::str str_KUNkWgFt0ea fu_INIT_PRIORITY(1015) { "\n        struct Postdom { a: i32; b?: i32[] };\n\n        fn clear(ref p: Postdom)\n            for (fieldname i: Postdom)\n                if (typeof(p.i) -> i32[])\n                    p.i.clear();\n\n        fn main() {\n            mut a = Postdom(a: 3);\n            mut b = Postdom(a: 3, b: [ 1 ]);\n            if (a == b) return 1;\n            b.clear();\n            return a == b ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_UrDz18ae8G1
                                #define STR_UrDz18ae8G1
static const fu::str str_UrDz18ae8G1 fu_INIT_PRIORITY(1015) { "\n        novec fn build(ref a: string, b: string) {\n            let cmake       = false;                            ;; !DEV_DontFoldLiterals\n            <alt>\n            let CMakeLists  = cmake && (a ~= b);\n            <alt/>\n            let OPAQUE      = a.len + b.len;\n            let CMakeLists  = cmake && OPAQUE && (a ~= b);\n            </alt>\n            if (CMakeLists) DOESNT_EXIST();\n            return CMakeLists;\n        }\n\n        fn main() {\n            mut a = \"hello, \";\n            let b = \"world!\";\n            return build(a, b).len;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_2qU8mGLlvvk
                                #define STR_2qU8mGLlvvk
static const fu::str str_2qU8mGLlvvk fu_INIT_PRIORITY(1015) { "\n        fn doesntSkipIfWithTrailingFalse(x: i32) {\n            if (x && false)                                     ;; !DEV_DontFoldLiterals\n                return DOESNT_EXIST;\n            else\n                return x;\n        }\n\n        fn main() = doesntSkipIfWithTrailingFalse(0);\n    "_fu };
                                #endif

                                #ifndef STR_xQ97CujNlY3
                                #define STR_xQ97CujNlY3
static const fu::str str_xQ97CujNlY3 fu_INIT_PRIORITY(1015) { "\n        struct Hello { hello: int };\n        fn what(who) {\n            if (who.hello) DOESNT_EXIST;\n            return 0;\n        }\n\n        fn main() what([]);\n    "_fu };
                                #endif

                                #ifndef STR_QAAMBdIPAJf
                                #define STR_QAAMBdIPAJf
static const fu::str str_QAAMBdIPAJf fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut zero = 0; // zero++ must never happen\n            (zero++) = { return :main zero; };\n        }\n    "_fu };
                                #endif

                                #ifndef STR_AVyGElvuqNf
                                #define STR_AVyGElvuqNf
static const fu::str str_AVyGElvuqNf fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            mut zero = 0; // zero++ must never happen\n            fn no_return() { return :main zero; }\n            (zero++) = no_return();\n        }\n    "_fu };
                                #endif

                                #ifndef STR_anoIKxiIozh
                                #define STR_anoIKxiIozh
static const fu::str str_anoIKxiIozh fu_INIT_PRIORITY(1015) { "\n        fn takes_two_lambdas(inline a, inline b) a = b;\n\n        fn main() {\n            mut zero = 0; // zero++ must never happen\n            takes_two_lambdas(zero++, { return :main zero });\n        }\n    "_fu };
                                #endif

                                #ifndef STR_6h06MsfKt3h
                                #define STR_6h06MsfKt3h
static const fu::str str_6h06MsfKt3h fu_INIT_PRIORITY(1015) { "\n        fn takes_two_lambdas(a, b) a() = b();\n\n        fn main() {\n            mut zero = 0; // zero++ must never happen\n            takes_two_lambdas(|| zero++, || { return :main zero });\n        }\n    "_fu };
                                #endif

                                #ifndef STR_1dfayCbIQee
                                #define STR_1dfayCbIQee
static const fu::str str_1dfayCbIQee fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            if (<fail not defined 3:23+12>true<pass/>false</fail>) DOESNT_EXIST(); ;; !DEV_DontFoldLiterals\n            return 0;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_ZCWyxiDX2n7
                                #define STR_ZCWyxiDX2n7
static const fu::str str_ZCWyxiDX2n7 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            if (<fail not defined 3:20+12>1<pass/>0</fail>) DOESNT_EXIST(); ;; !DEV_DontFoldLiterals\n            return 0;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_zdGfbfw0jRa
                                #define STR_zdGfbfw0jRa
static const fu::str str_zdGfbfw0jRa fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            if (<fail not defined 3:22+12>'0'<pass/>'\\0'</fail>) DOESNT_EXIST(); ;; !DEV_DontFoldLiterals\n            return 0;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_JA3vdb8NkI4
                                #define STR_JA3vdb8NkI4
static const fu::str str_JA3vdb8NkI4 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            if (<fail not defined 3:23+12>\"\\0\"<pass/>\"\"</fail>) DOESNT_EXIST(); ;; !DEV_DontFoldLiterals\n            return 0;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_1mU848R2pR9
                                #define STR_1mU848R2pR9
static const fu::str str_1mU848R2pR9 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            if (int[]) DOESNT_EXIST();\n            return 0;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_WVCvJUWA9F9
                                #define STR_WVCvJUWA9F9
static const fu::str str_WVCvJUWA9F9 fu_INIT_PRIORITY(1015) { "\n        noinline fn add(ref a: i32, ref b: i32) a + b;\n        fn main() = add(1, 2) - 3;\n    "_fu };
                                #endif

                                #ifndef STR_RXoB0pjZPGj
                                #define STR_RXoB0pjZPGj
static const fu::str str_RXoB0pjZPGj fu_INIT_PRIORITY(1015) { "\n        inline fn add(ref a: i32, ref b: i32) a + b;\n        fn main() = add(1, 2) - 3;\n    "_fu };
                                #endif

                                #ifndef STR_TPVzubCI8O2
                                #define STR_TPVzubCI8O2
static const fu::str str_TPVzubCI8O2 fu_INIT_PRIORITY(1015) { "Bad call to add 3:21+3 expects mutref"_fu };
                                #endif

                                #ifndef STR_vWGnPrHQXjg
                                #define STR_vWGnPrHQXjg
static const fu::str str_vWGnPrHQXjg fu_INIT_PRIORITY(1015) { "\n        noinline fn add(ref a: i32, ref b: i32) a || b;\n        fn main() = add(1, 2) - 1;\n    "_fu };
                                #endif

                                #ifndef STR_ICJgNQd5AO6
                                #define STR_ICJgNQd5AO6
static const fu::str str_ICJgNQd5AO6 fu_INIT_PRIORITY(1015) { "\n        noinline fn at(ref a: i32[], i: i32) a[i];\n        fn main() = [ 1 ].at(0) - 1;\n    "_fu };
                                #endif

                                #ifndef STR_UiUqtBd2rC0
                                #define STR_UiUqtBd2rC0
static const fu::str str_UiUqtBd2rC0 fu_INIT_PRIORITY(1015) { "Bad call to at 3:27+2 expects mutref"_fu };
                                #endif

                                #ifndef STR_ShFXgoCGHyg
                                #define STR_ShFXgoCGHyg
static const fu::str str_ShFXgoCGHyg fu_INIT_PRIORITY(1015) { "\n        fn PreIncr( <fail bad call ++ mutref 3:20+2><pass/>\n            ref     </fail>\n                x) ++x;\n\n        fn main() {\n            mut res = -1;\n            return PreIncr(res);\n        }\n    "_fu };
                                #endif

                                #ifndef STR_qe1KOpsV4ve
                                #define STR_qe1KOpsV4ve
static const fu::str str_qe1KOpsV4ve fu_INIT_PRIORITY(1015) { "\n        fn val_keyword(val a, val b) {\n            val c = a + b;\n            return c;\n        }\n\n        fn main() val_keyword(2, 3) - 5;\n    "_fu };
                                #endif

                                #ifndef STR_v3dBqKDge08
                                #define STR_v3dBqKDge08
static const fu::str str_v3dBqKDge08 fu_INIT_PRIORITY(1015) { "\n        fn val_keyword(const ref a, const ref b) {\n            const ref c = a || b;\n            return c;\n        }\n\n        fn main() val_keyword(2, 3) - 2;\n    "_fu };
                                #endif

                                #ifndef STR_jyAI36yjM8j
                                #define STR_jyAI36yjM8j
static const fu::str str_jyAI36yjM8j fu_INIT_PRIORITY(1015) { "\n        <fail explicit_arg closure_arg both alias use val or ref 9:25+14>\n        fn foreach_modify(    explicit_arg: int[], foreach)     <pass/>\n        fn foreach_modify(ref explicit_arg: int[], foreach)     </fail>\n            for (mut i = explicit_arg.len; i --> 0; )\n                foreach(explicit_arg[i], i?: i);\n\n        fn main() {\n            mut closure_arg = [ 2 ];\n            closure_arg.foreach_modify: |item, ref i| {\n                while (item > i) {\n                    closure_arg.insert(i, i);\n                    i++;\n                }\n            }\n\n            return closure_arg == [ 0, 1, 2 ] ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_VGNCOU8hZx6
                                #define STR_VGNCOU8hZx6
static const fu::str str_VGNCOU8hZx6 fu_INIT_PRIORITY(1015) { "\n        fn main() {\n            lax let five = 5;\n            ref x = <fail init expr not ref 4:17+1>5<pass/>five</fail>;\n            return x - 5;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_azGiwegXxmd
                                #define STR_azGiwegXxmd
static const fu::str str_azGiwegXxmd fu_INIT_PRIORITY(1015) { "\n        fn main() {         <fail init expr not mut ref 4:21+1>\n            let five = 5;   <pass/>\n            mut five = 5;   </fail>\n            mut ref x = five;\n            return x - 5;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_O4MFxnV8cMe
                                #define STR_O4MFxnV8cMe
static const fu::str str_O4MFxnV8cMe fu_INIT_PRIORITY(1015) { "\n        fn test(ref x: int) {\n            if ((y := x *= 2) > 10)\n                return y * 2;\n            else\n                return y;\n        }\n\n        fn main() {\n            mut x = 6;\n            return test(x) == 24 && x == 12 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_NKUT9ZpjO9i
                                #define STR_NKUT9ZpjO9i
static const fu::str str_NKUT9ZpjO9i fu_INIT_PRIORITY(1015) { "\n        struct NonTriv { items: NonTriv[] };\n\n        fn pick(ref things: <alt>NonTriv<alt/>_</alt>[], id: int) {\n            for (mut i = 0; i < things.len; i++)\n                if ((thing := things[i]).items.len == id)\n                    return thing;\n\n            return [];\n        }\n\n        fn test(ref things: <alt>NonTriv<alt/>_</alt>[], id: int) {\n            if (let thing = pick(things, id))\n                return thing.items.len;\n\n            return -1;\n        }\n\n        fn main() {\n            mut things: NonTriv[];\n            for (mut i = 0; i < 10; i++) {\n                mut thing: NonTriv;\n                for (mut j = 0; j < i; j++) thing.items ~= <fail ambig ~= 23:57+2>[]<pass/>NonTriv()</fail>;\n                things ~= thing;\n            }\n\n            return test(things, 11) == -1\n                && test(things, 7)  ==  7 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_SV5PZT2QEib
                                #define STR_SV5PZT2QEib
static const fu::str str_SV5PZT2QEib fu_INIT_PRIORITY(1015) { "\n        struct Container { value: int };\n        fn visit(ref container: Container, fn) {\n            fn(container.value);\n        }\n\n        fn main() {\n            let c = Container(0);\n            c.visit: |v| return v;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_Qtdh48HQsAh
                                #define STR_Qtdh48HQsAh
static const fu::str str_Qtdh48HQsAh fu_INIT_PRIORITY(1015) { "\n        struct Container { value: int };\n        fn visit(ref container: Container, fn) {\n            fn update(v: int) container.value = v;\n            fn(container.value, ?:fn update);\n        }\n\n        fn init(mut c?: Container) {\n            c.visit: |v, update| { update(v - 10) };\n            return c;\n        }\n\n        fn main() {\n            let c = init(Container(10));\n            c.visit: |v| return v;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_D6f2hnR5ey9
                                #define STR_D6f2hnR5ey9
static const fu::str str_D6f2hnR5ey9 fu_INIT_PRIORITY(1015) { "\n        struct RawSet { ints: int[] };\n\n        fn each(using ref _: RawSet, fn) {\n            for (mut i = ints.len; i --> 0; ) {\n                fn remove() {\n                    ints.splice(i, 1);\n                    continue;\n                }\n\n                fn(ints[i], ?:fn remove);\n            }\n        }\n\n        <split/>\n        struct LocidSet { raw_set: RawSet };\n\n        fn each(using ref _: LocidSet, offset: int, fn)\n            raw_set.each: |item, remove|\n                fn(item + offset, ?:fn remove);\n\n        <split/>\n        fn sum(locids: LocidSet, offset: int) {\n            mut sum = 0;\n            locids.each(:offset): |item| sum += item;\n            return sum;\n        }\n\n        fn main() {\n            mut locids = LocidSet(RawSet([ 1, 2, 3 ]));\n            mut sum = locids.sum(offset: 10);\n\n            locids.each(offset: 10): |item, remove| {\n                if (item & 1) remove();\n                sum -= item;\n            }\n\n            return locids.raw_set.ints == [ 2 ] && sum == 11 + 13 ? 0 : 1;\n        }\n    "_fu };
                                #endif

                                #ifndef STR_X3GeE6wyzve
                                #define STR_X3GeE6wyzve
static const fu::str str_X3GeE6wyzve fu_INIT_PRIORITY(1015) { "\n        fn pretend_pure(mut res = 0) {\n            pragma emit(`\n                static int counter = 100;\n                `res` += counter++;\n            `);\n            return res;\n        }\n\n        fn validate_looks_pure() {\n            pretend_pure(1);\n            return pretend_pure(2);\n        }\n\n        fn main() validate_looks_pure() == 102 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_RTojzkPql6d
                                #define STR_RTojzkPql6d
static const fu::str str_RTojzkPql6d fu_INIT_PRIORITY(1015) { "\n        fn pretend_pure(mut res = 0) {\n            pragma emit(`\n                static int counter = 100;\n                `res` += counter++;\n            `);\n            return res;\n        }\n\n        fn licm_loop_preheader(n: i32) {\n            mut res = 0;\n            for (mut i = 0; i < n; i++)\n            on enter {\n                let must_hoist = pretend_pure(n);\n            }\n            then {\n                res += must_hoist;\n            }\n            return res;\n        }\n\n        fn main() licm_loop_preheader(2) == 204 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_FlefEpx4l0l
                                #define STR_FlefEpx4l0l
static const fu::str str_FlefEpx4l0l fu_INIT_PRIORITY(1015) { "\n        fn pretend_pure(mut res = 0) {\n            pragma emit(`\n                static int counter = 100;\n                `res` += counter++;\n            `);\n            return res;\n        }\n\n        fn licm_hoist_var(n: i32) {\n            mut res = 0;\n            for (mut i = 0; i < n; i++) {\n                let must_hoist = pretend_pure(n);\n                res += must_hoist;\n            }\n            return res;\n        }\n\n        fn main() licm_hoist_var(2) == 204 ? 0 : 1;\n    "_fu };
                                #endif

                                #ifndef STR_1I9IXsIp5s6
                                #define STR_1I9IXsIp5s6
static const fu::str str_1I9IXsIp5s6 fu_INIT_PRIORITY(1015) { "\n        struct Hello { v: i32 }\n        test a_simple_test() {\n            <fail assertion failed !!Hello>\n            assert(!!Hello().v)     <pass/>\n            assert(!Hello().v)      </fail>\n        }\n    "_fu };
                                #endif

                                #ifndef STR_xcC0x12Tp41
                                #define STR_xcC0x12Tp41
static const fu::str str_xcC0x12Tp41 fu_INIT_PRIORITY(1015) { "\n        fn main() _0::Hello().v;\n    "_fu };
                                #endif

#ifndef fu_NO_fdefs

extern const fu::str FU_ROOT;
                                #ifndef DEF___eDoEsSQbBaj
                                #define DEF___eDoEsSQbBaj
inline static TestResult_Ws87 _eDoE(fu::vec_range<fu::str> test)
{
    /*MOV*/ fu::str error {};
    /*MOV*/ TestDiffs_EVlo testdiffs {};
    const Options_TBgD options = Options_TBgD { Lint_Q9R1{}, SolverNotes_LSla{}, CGDefects_2L18{}, DevOptions_QEya_DEV_Parallel, {/*unused non-zst*/} };

    try
    {
    {
        ZERO_3QGL(fu::vec<fu::str>(test), Options_TBgD(options), (*(fu::str*)fu::NIL), 0, testdiffs);
    }
    }
    catch (const std::exception& o_0)
    {
        fu::str e = fu::to_str(o_0.what());

        error = static_cast<fu::str&&>(e);
    }
;
    return TestResult_Ws87 { static_cast<fu::str&&>(error), static_cast<TestDiffs_EVlo&&>(testdiffs) };
}
                                #endif

                                #ifndef DEF___NvZjti5PMtd
                                #define DEF___NvZjti5PMtd
inline static const TestResult_Ws87& _NvZj(const int i, fu::view<fu::vec<fu::str>> arr, fu::view_mut<TestResult_Ws87> result)
{
    return (result.mutref(i) = _eDoE(arr[i]));
}
                                #endif

                                #ifndef DEF_parallel_for_AWeBCNMM7je
                                #define DEF_parallel_for_AWeBCNMM7je
inline static void parallel_for_AWeB(const int min, int end, fu::view<fu::vec<fu::str>> arr, fu::view_mut<TestResult_Ws87> result)
{
    int start = (end & 0);
    (void) start;

    typedef decltype(start) start_t;
    typedef decltype(end) end_t;

    fu::parallel_for(size_t(end), size_t(min > 1 ? min : 1), [&](size_t Start, size_t End)
    {
        auto start = (start_t) Start;
        auto end   = (end_t  ) End;

    for (int i = start; i < end; i++)
        _NvZj(i, arr, result);

    });

}
                                #endif

                                #ifndef DEF_map_KpxiOlLHCp9
                                #define DEF_map_KpxiOlLHCp9
inline fu::vec<TestResult_Ws87> map_Kpxi(fu::view<fu::vec<fu::str>> arr, const int min)
{
    /*MOV*/ fu::vec<TestResult_Ws87> result {};
    result.grow<false>(arr.size());
    parallel_for_AWeB(min, arr.size(), arr, result);
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF_x7Ex3D_w1zac9Uldqj
                                #define DEF_x7Ex3D_w1zac9Uldqj
inline fu::view<char> x7Ex3D_w1za(fu::vec_range_mut<char> a, fu::view<char> b)
{
    return (a += b);
}
                                #endif

static fu::view<fu::vec<fu::str>> PARZERO_f83T(fu::vec_range<char> src, fu::vec<fu::vec<fu::str>>& PARZERO_queue)
{
    return (PARZERO_queue += fu::vec<fu::str> {{ fu::str(src) }});
}

static fu::view<fu::vec<fu::str>> PARZERO_WvpD(fu::vec_range<fu::str> src, fu::vec<fu::vec<fu::str>>& PARZERO_queue)
{
    return (PARZERO_queue += fu::vec<fu::str>(src));
}

                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_7SLcWgAQSl4
                                #define DEF_find_7SLcWgAQSl4
inline int find_7SLc(fu::view<char> haystack, fu::view<char> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_ZKsG(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const char needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_BNNwXhPzgU8
                                #define DEF_find_BNNwXhPzgU8
inline int find_BNNw(fu::view<char> haystack, fu::view<char> needle, const int start)
{
    fu::view<char> slice = fu::get_view(haystack, start);
    const int res = find_7SLc(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF_replace_4fXW2QLS6G4
                                #define DEF_replace_4fXW2QLS6G4
inline fu::str replace_4fXW(fu::vec_range<char> str, fu::view<char> all, fu::view<char> with)
{
    /*MOV*/ fu::str result {};

    {
        int last = 0;
        int next = 0;
        const int N = all.size();
        if (N)
        {
            while (((next = find_BNNw(str, all, last)) >= 0))
            {

                {
                    fu::view<char> substr = fu::get_view(str, last, next);
                    const bool first = !last;
                    if (!first)
                        result += with;

                    result += substr;
                };
                last = (next + N);
            };
        };
        if (last)
        {
            fu::view<char> substr = fu::get_view(str, last);
            result += with;
            result += substr;
        }
        else
            return fu::str(str);

    };
    return /*NRVO*/ result;
}
                                #endif

static fu::str EXPR_FnZ2(fu::view<char> varname, fu::vec_range<char> assertion)
{
    return replace_4fXW(assertion, "@"_view, varname);
}

static void ARROPS_FnZ2(fu::view<char> literal, fu::view<char> operation, fu::str&& assertion, fu::vec<fu::vec<fu::str>>& PARZERO_queue)
{
    assertion = (("("_view + assertion) + ")"_view);
    fu::str src {};
    src += "\n"_view;
    src += "\n    {"_view;
    src += (("\n        mut arr0 = ["_view + literal) + "];"_view);
    src += (("\n        arr0."_view + operation) + ";"_view);
    src += (("\n        if ("_view + EXPR_FnZ2("arr0"_view, assertion)) + " != 0) return 13;"_view);
    src += "\n    }"_view;
    src += "\n"_view;
    src += (("\n    mut orig = ["_view + literal) + "];"_view);
    src += "\n"_view;
    src += "\n    {"_view;
    src += "\n        mut arr1 = orig;"_view;
    src += (("\n        arr1."_view + operation) + ";"_view);
    src += (("\n        if ("_view + EXPR_FnZ2("arr1"_view, assertion)) + " != 0) return 17;"_view);
    src += "\n    }"_view;
    src += "\n"_view;
    src += "\n    {"_view;
    src += "\n        ref arr2 = orig;"_view;
    src += "\n        if (arr2.len != 5) return 38;"_view;
    src += (("\n        arr2."_view + operation) + ";"_view);
    src += (("\n        if ("_view + EXPR_FnZ2("arr2"_view, assertion)) + " != 0) return 23;"_view);
    src += "\n    }"_view;
    src += "\n"_view;
    src += "\n    return 0;"_view;
    src += "\n"_view;
    PARZERO_f83T(src, PARZERO_queue);
}

void runTests()
{
    /*MOV*/ fu::str TESTDIFFS_FILE = (FU_ROOT + "testdiff/now.td"_view);
    TestDiffs_EVlo testdiffs {};
    fu_DEFER_IF_OK(write_VWJw(TESTDIFFS_FILE.destructive_move(), serialize_pXri(testdiffs), RW_RW_RW));
    fu::vec<fu::vec<fu::str>> PARZERO_queue {};
    fu_DEFER_IF_OK(
    {
        fu::vec<TestResult_Ws87> results = map_Kpxi(PARZERO_queue, 0);
        /*MOV*/ fu::str error {};
        for (int i = 0; i < results.size(); i++)
        {
            const TestResult_Ws87& result = results[i];
            if (result.error)
                error += (result.error + "\n"_view);
            else
            {
                append_pXri(testdiffs, result.testdiffs);
            };
        };
        if (error)
        {
            const int l = error.size();
            if (l == 0x7fffffff)
                x7Ex3D_w1za(error, fu::i64dec(l));

            fu::fail(static_cast<fu::str&&>(error));
        };
    });
    PARZERO_f83T(str_VipjxbFj0Wb, PARZERO_queue);
    PARZERO_f83T(str_DFOuAasAaAb, PARZERO_queue);
    PARZERO_f83T(str_3sE2yOAoS6b, PARZERO_queue);
    PARZERO_f83T(str_zz5dICl64U1, PARZERO_queue);
    PARZERO_f83T(str_Y1AchFVVAe3, PARZERO_queue);
    PARZERO_f83T(str_VXdeCe0KFU3, PARZERO_queue);
    PARZERO_f83T(str_V9m6LFrfrSh, PARZERO_queue);
    PARZERO_f83T(str_3mf1WaH6287, PARZERO_queue);
    PARZERO_f83T(str_qySmxBISqli, PARZERO_queue);
    PARZERO_f83T(str_PH4axN3ofZ2, PARZERO_queue);
    PARZERO_f83T(str_ptOK4lUjXWb, PARZERO_queue);
    PARZERO_f83T(str_iuYgSXycQvb, PARZERO_queue);
    PARZERO_f83T(str_JKF8d7BdQ41, PARZERO_queue);
    PARZERO_f83T(str_WYhljbj6Ut1, PARZERO_queue);
    PARZERO_f83T(str_85vrrNH3mR7, PARZERO_queue);
    PARZERO_f83T(str_eIA2tHcNZt9, PARZERO_queue);
    PARZERO_f83T(str_FVcxBzdMF99, PARZERO_queue);
    PARZERO_f83T(str_4wF8hgGOC3l, PARZERO_queue);
    PARZERO_f83T(str_baOp0SqqxZa, PARZERO_queue);
    PARZERO_f83T(str_yEn7bIzFO17, PARZERO_queue);
    PARZERO_f83T(str_jRbiwb9QoO4, PARZERO_queue);
    PARZERO_f83T(str_MnuQLPY1gie, PARZERO_queue);
    PARZERO_f83T(str_iqIw1B7fIJ7, PARZERO_queue);
    PARZERO_f83T(str_5j8tXarLnng, PARZERO_queue);
    PARZERO_f83T(str_ZxLoGcfp2Of, PARZERO_queue);
    PARZERO_f83T(str_4eCz5turkM1, PARZERO_queue);
    PARZERO_f83T(str_BfNe5UI4fe2, PARZERO_queue);
    PARZERO_f83T(str_eD4mWFBbZQ6, PARZERO_queue);
    PARZERO_f83T(str_AJyfp9wq1Ml, PARZERO_queue);
    PARZERO_f83T(str_rSiYuQgPDUi, PARZERO_queue);
    PARZERO_f83T(str_VqaY5S6Ltbg, PARZERO_queue);
    PARZERO_f83T(str_yMbq6hEIGxk, PARZERO_queue);
    PARZERO_f83T(str_OokcKR28ew6, PARZERO_queue);
    PARZERO_f83T(str_KxmAtvVIW1i, PARZERO_queue);
    PARZERO_f83T(str_Bc6P7zVUdW6, PARZERO_queue);
    PARZERO_f83T(str_X0xc4w1TAZ9, PARZERO_queue);
    PARZERO_f83T(str_QEJ7S5ntxrk, PARZERO_queue);
    PARZERO_f83T(str_vp5GoKzKuMb, PARZERO_queue);
    PARZERO_f83T(str_z7OFVfq8IMi, PARZERO_queue);
    PARZERO_f83T(str_VLMFPCNHoL6, PARZERO_queue);
    PARZERO_f83T(str_BoqTaGpQg5b, PARZERO_queue);
    PARZERO_f83T(str_NsxAC7cy3Ga, PARZERO_queue);
    PARZERO_f83T(str_n6MFqRk4oUg, PARZERO_queue);
    TODO_5TaN(str_a9aEBbp7Fql, str_7NNX97mGs5d, testdiffs);
    PARZERO_f83T(str_v4ApVJmczQd, PARZERO_queue);
    PARZERO_f83T(str_bMAU5po8B79, PARZERO_queue);
    PARZERO_f83T(str_viBmYapl7lc, PARZERO_queue);
    PARZERO_f83T(str_zGAzsw9ebSk, PARZERO_queue);
    PARZERO_f83T(str_JdPiVJQzzy1, PARZERO_queue);
    PARZERO_f83T(str_KKyn4OMNEy9, PARZERO_queue);
    PARZERO_f83T(str_0dEy3ESolD8, PARZERO_queue);
    PARZERO_f83T(str_EyeMcqi2l3f, PARZERO_queue);
    PARZERO_f83T(str_WREJuc3XFM0, PARZERO_queue);
    PARZERO_f83T(str_Cu5DeJi2TA3, PARZERO_queue);
    PARZERO_f83T(str_JCUSm1T3LOk, PARZERO_queue);
    PARZERO_f83T(str_UIe7W7zuYS8, PARZERO_queue);
    PARZERO_f83T(str_Z8ZQl2yDiSc, PARZERO_queue);
    PARZERO_f83T(str_Jw5BfohAh1f, PARZERO_queue);
    PARZERO_f83T(str_iRADgJPXgtd, PARZERO_queue);
    PARZERO_f83T(str_eG4dLDyp0w1, PARZERO_queue);
    PARZERO_f83T(str_VutVmAnXV27, PARZERO_queue);
    PARZERO_f83T(str_TRDCnpau7D5, PARZERO_queue);
    PARZERO_f83T(str_DG4wErg4TSg, PARZERO_queue);
    PARZERO_f83T(str_h2hvYOQoBP7, PARZERO_queue);
    PARZERO_f83T(str_s8WPZWSGk8i, PARZERO_queue);
    PARZERO_f83T(str_GRpmnOY7IW1, PARZERO_queue);
    PARZERO_f83T(str_uo6A5uHOT4f, PARZERO_queue);
    PARZERO_f83T(str_W5k6F1MNPia, PARZERO_queue);
    PARZERO_f83T(str_VblMKguew61, PARZERO_queue);
    PARZERO_f83T(str_K5xjRbmbU1j, PARZERO_queue);
    PARZERO_f83T(str_VFLffpO9f5f, PARZERO_queue);
    PARZERO_f83T(str_hFs0YQbEca8, PARZERO_queue);
    PARZERO_f83T(str_lJ0K3HNfcwg, PARZERO_queue);
    PARZERO_f83T(str_WgKNte3Bvje, PARZERO_queue);
    PARZERO_f83T(str_8YHEnlGDnZ1, PARZERO_queue);
    PARZERO_f83T(str_gQYmWfpvem3, PARZERO_queue);
    PARZERO_f83T(str_YeNgZLRkCGe, PARZERO_queue);
    PARZERO_f83T(str_GijosH1Qr09, PARZERO_queue);
    PARZERO_f83T(str_XdqjUEnAll8, PARZERO_queue);
    PARZERO_f83T(str_wrN6ToXoPq9, PARZERO_queue);
    PARZERO_f83T(str_LVC6Z5orJl6, PARZERO_queue);
    PARZERO_f83T(str_1SBlfyGKY8i, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_08eiRZhgpY1), fu::str(str_JPwg92b5bo1) }}, PARZERO_queue);
    PARZERO_f83T(str_naQ9xOK24jj, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_wBOXD0ar7Y7), fu::str(str_KfJftDgDlMk) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_tsLsXXR9134), fu::str(str_NUUEHFzwTk4), fu::str(str_vptizWpEwy8) }}, PARZERO_queue);
    PARZERO_f83T(str_j5aAPhN1dff, PARZERO_queue);
    PARZERO_f83T(str_pzqtoRyuiK9, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_zKwO2PVV2Kk), fu::str(str_xiait1K9cc7) }}, PARZERO_queue);
    PARZERO_f83T(str_AyC8Sz3Xvd5, PARZERO_queue);
    PARZERO_f83T(str_0NMc6LDFli1, PARZERO_queue);
    PARZERO_f83T(str_8FCe6Cr7bpg, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_Vshfku53tH3), fu::str(str_g6wj0B6vCWb) }}, PARZERO_queue);
    TODO_3QGL(fu::vec<fu::str> {{ fu::str(str_Vshfku53tH3), fu::str(str_n2ShRbEE8zl) }}, str_v6Phd4Ckcie, testdiffs);
    PARZERO_f83T(str_ydjNEPGqK3i, PARZERO_queue);
    PARZERO_f83T(str_Z9onYAdaf8b, PARZERO_queue);
    PARZERO_f83T(str_SDwWRJD8Pmi, PARZERO_queue);
    PARZERO_f83T(str_7YbJLsKzgz2, PARZERO_queue);
    PARZERO_f83T(str_FkrTCufLaG2, PARZERO_queue);
    PARZERO_f83T(str_lQ4dWcPcTra, PARZERO_queue);
    PARZERO_f83T(str_bkCPdEoJ9sg, PARZERO_queue);
    PARZERO_f83T(str_GN5eDjFQws9, PARZERO_queue);
    PARZERO_f83T(str_KtvqHt4uayd, PARZERO_queue);
    PARZERO_f83T(str_3A2ZevlxLZ0, PARZERO_queue);
    PARZERO_f83T(str_wlaj4IuxHW7, PARZERO_queue);
    PARZERO_f83T(str_S8mgDIez1q8, PARZERO_queue);
    PARZERO_f83T(str_0qc14Icppyb, PARZERO_queue);
    PARZERO_f83T(str_2Hs0suA9w99, PARZERO_queue);
    PARZERO_f83T(str_Oxl2YB7CEd0, PARZERO_queue);
    PARZERO_f83T(str_pLLQDlSu3wg, PARZERO_queue);
    PARZERO_f83T(str_XenVcGtTEs8, PARZERO_queue);
    PARZERO_f83T(str_OyGPB0V2Uce, PARZERO_queue);
    PARZERO_f83T(str_Ono5iR8ywPc, PARZERO_queue);
    PARZERO_f83T(str_zbfjbPhgYa3, PARZERO_queue);
    PARZERO_f83T(str_R6We47NDRU6, PARZERO_queue);
    PARZERO_f83T(str_8hBDrtZxABi, PARZERO_queue);
    PARZERO_f83T(str_9cTaL8Bn22d, PARZERO_queue);
    PARZERO_f83T(str_2fxgtZzyikg, PARZERO_queue);
    PARZERO_f83T(str_o6FtGkqSxt9, PARZERO_queue);
    PARZERO_f83T(str_GOqIycjLRk2, PARZERO_queue);
    PARZERO_f83T(str_oDld2SGUSug, PARZERO_queue);
    PARZERO_f83T(str_n1ljknw4L2e, PARZERO_queue);
    PARZERO_f83T(str_rqwmqJz6OGc, PARZERO_queue);
    PARZERO_f83T(str_Wwczx5EojCk, PARZERO_queue);
    PARZERO_f83T(str_jrgwtv5LVpb, PARZERO_queue);
    PARZERO_f83T(str_PPEedE913Ld, PARZERO_queue);
    PARZERO_f83T(str_5fT0Cc1YF4f, PARZERO_queue);
    PARZERO_f83T(str_8ppmBpyFhf3, PARZERO_queue);
    PARZERO_f83T(str_E30xh9U7DFk, PARZERO_queue);
    PARZERO_f83T(str_N49RPGMMSV4, PARZERO_queue);
    PARZERO_f83T(str_UPfr3r6MbQ7, PARZERO_queue);
    PARZERO_f83T(str_cJ4h8q2IXGj, PARZERO_queue);
    TODO_5TaN(str_fmGBJChDlxk, str_7NNX97mGs5d, testdiffs);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_vEzE0zRYlI8), fu::str(str_d815FcSpjIc) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_ssNyToqAB68), fu::str(str_syjmioCu5Yd) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_wIqfwOKjNIl), fu::str(str_7rkmFWY8wZ2), fu::str(str_M0e9i3cottg), fu::str(str_TrEVbJrguI2) }}, PARZERO_queue);
    PARZERO_f83T(str_pGLPMH8el78, PARZERO_queue);
    PARZERO_f83T(str_UJazhkxbL75, PARZERO_queue);
    PARZERO_f83T(str_XLxi39Y9lFe, PARZERO_queue);
    PARZERO_f83T(str_B315WHl5jX1, PARZERO_queue);
    PARZERO_f83T(str_IhlKCAiBPsk, PARZERO_queue);
    PARZERO_f83T(str_14bQcicZnI0, PARZERO_queue);
    PARZERO_f83T(str_oBXMDJiMYB0, PARZERO_queue);
    PARZERO_f83T(str_vq49F8eE801, PARZERO_queue);
    TODO_5TaN(str_p3yFAfmfOBi, str_8RiKcCfOlBd, testdiffs);
    TODO_5TaN(str_8Vn2BAJ6hq0, str_N7ugWleN8je, testdiffs);
    PARZERO_f83T(str_4ZyGU93Ppna, PARZERO_queue);
    PARZERO_f83T(str_kxIjny6th6f, PARZERO_queue);
    PARZERO_f83T(str_cD3iyVgVhV8, PARZERO_queue);
    PARZERO_f83T(str_IJ7RE102xMc, PARZERO_queue);
    PARZERO_f83T(str_5jbiuj6pri9, PARZERO_queue);
    PARZERO_f83T(str_0qJ8q13JQ1l, PARZERO_queue);
    PARZERO_f83T(str_2AFi0dCest4, PARZERO_queue);
    PARZERO_f83T(str_lOODLuOF1qc, PARZERO_queue);
    PARZERO_f83T(str_G1JOw8Cr9X9, PARZERO_queue);
    PARZERO_f83T(str_turhjXtbP8k, PARZERO_queue);
    PARZERO_f83T(str_poSi2gSU3B1, PARZERO_queue);
    PARZERO_f83T(str_27H1lbWorm2, PARZERO_queue);
    PARZERO_f83T(str_Ehh6dlsKgSb, PARZERO_queue);
    PARZERO_f83T(str_3Ehc80pm5W5, PARZERO_queue);
    PARZERO_f83T(str_n3IjUB06OJ9, PARZERO_queue);
    PARZERO_f83T(str_VaZ89M0Uxs1, PARZERO_queue);
    PARZERO_f83T(str_sEAbqorG5q6, PARZERO_queue);
    PARZERO_f83T(str_99DHs63HK10, PARZERO_queue);
    PARZERO_f83T(str_lGxsig7rGx9, PARZERO_queue);
    PARZERO_f83T(str_jB0pWti6mZ3, PARZERO_queue);
    PARZERO_f83T(str_uGz5YpwRa95, PARZERO_queue);
    PARZERO_f83T(str_dPYLI6XGCAf, PARZERO_queue);
    PARZERO_f83T(str_MJ4fG4x3eqc, PARZERO_queue);
    PARZERO_f83T(str_a1q3gbMUjC7, PARZERO_queue);
    PARZERO_f83T(str_YlebwiTEBmj, PARZERO_queue);
    PARZERO_f83T(str_SVqKWc5Cn30, PARZERO_queue);
    PARZERO_f83T(str_f0clcpmxQ0c, PARZERO_queue);
    PARZERO_f83T(str_iZQ6l8bpHAe, PARZERO_queue);
    PARZERO_f83T(str_UxMJXmZeCm3, PARZERO_queue);
    PARZERO_f83T(str_Is0SuuA6Mu9, PARZERO_queue);
    PARZERO_f83T(str_PYUVsGYkPoj, PARZERO_queue);
    PARZERO_f83T(str_NeFV0bpxV0h, PARZERO_queue);
    PARZERO_f83T(str_0LlLhdYgbZj, PARZERO_queue);
    PARZERO_f83T(str_4vg60020IRc, PARZERO_queue);
    PARZERO_f83T(str_qanPrWRnZwd, PARZERO_queue);
    PARZERO_f83T(str_dFuNduznSXg, PARZERO_queue);
    PARZERO_f83T(str_j9apFJH3FY5, PARZERO_queue);
    PARZERO_f83T(str_lzIeca1Suig, PARZERO_queue);
    TODO_5TaN(str_EsiYTpW3Dbh, str_82fLRafJ41d, testdiffs);
    PARZERO_f83T(str_3sTHvlOeAW7, PARZERO_queue);
    PARZERO_f83T(str_X4SsAWJ1a0e, PARZERO_queue);
    PARZERO_f83T(str_qCkAW5kkekd, PARZERO_queue);
    PARZERO_f83T(str_0Wa6BLs9fCd, PARZERO_queue);
    PARZERO_f83T(str_q5M3vCa7Khi, PARZERO_queue);
    PARZERO_f83T(str_nPG8HiIx3ec, PARZERO_queue);
    ARROPS_FnZ2("0,1,2,3,4"_view, "push(5)"_view, fu::str(str_90ptpPCGvya), PARZERO_queue);
    ARROPS_FnZ2("0,1,2,3,4"_view, "insert(5, 5)"_view, fu::str(str_90ptpPCGvya), PARZERO_queue);
    ARROPS_FnZ2("0,1,2,3,4"_view, "pop()"_view, fu::str(str_OFMn1vaNmF3), PARZERO_queue);
    ARROPS_FnZ2("0,1,2,3,4"_view, "splice(4, 1)"_view, fu::str(str_OFMn1vaNmF3), PARZERO_queue);
    ARROPS_FnZ2("0,1,2,3,4"_view, "unshift(5)"_view, fu::str(str_wXoLNlkfwzj), PARZERO_queue);
    ARROPS_FnZ2("0,1,2,3,4"_view, "insert(0, 5)"_view, fu::str(str_wXoLNlkfwzj), PARZERO_queue);
    ARROPS_FnZ2("0,1,2,3,4"_view, "shift()"_view, fu::str(str_WH8u7MfeHB0), PARZERO_queue);
    ARROPS_FnZ2("0,1,2,3,4"_view, "insert(1, 5)"_view, fu::str(str_gBXOUnICkN0), PARZERO_queue);
    ARROPS_FnZ2("0,1,2,3,100"_view, "splice(1, 3)"_view, fu::str(str_V1KYEmaMpmc), PARZERO_queue);
    PARZERO_f83T(str_tXttLJYNzq7, PARZERO_queue);
    PARZERO_f83T(str_PwUQYxB5dVf, PARZERO_queue);
    PARZERO_f83T(str_bT0JEalwgK5, PARZERO_queue);
    PARZERO_f83T(str_ddAIkpytU2k, PARZERO_queue);
    PARZERO_f83T(str_hbNpLUmow49, PARZERO_queue);
    PARZERO_f83T(str_Qn4oMSeXLS0, PARZERO_queue);
    PARZERO_f83T(str_ucNSkRs4qDj, PARZERO_queue);
    PARZERO_f83T(str_Y40VRJQdrc1, PARZERO_queue);
    PARZERO_f83T(str_iFxUHcBAfKd, PARZERO_queue);
    PARZERO_f83T(str_ojMkbeJEJoe, PARZERO_queue);
    PARZERO_f83T(str_vdUI3y5bSHf, PARZERO_queue);
    PARZERO_f83T(str_7ys8sIXls83, PARZERO_queue);
    PARZERO_f83T(str_P0zSFqzApMi, PARZERO_queue);
    PARZERO_f83T(str_umJRsttiPqe, PARZERO_queue);
    PARZERO_f83T(str_lihkIoeFYSg, PARZERO_queue);
    PARZERO_f83T(str_9oFL12Kkfl6, PARZERO_queue);
    PARZERO_f83T(str_Vnaxj62T9M6, PARZERO_queue);
    PARZERO_f83T(str_AeFAohzOMk2, PARZERO_queue);
    PARZERO_f83T(str_1LNlS1C2Bmj, PARZERO_queue);
    PARZERO_f83T(str_twBsqF7IAQ9, PARZERO_queue);
    PARZERO_f83T(str_zE5BBJXzIe9, PARZERO_queue);
    PARZERO_f83T(str_JC7vGTy2Y96, PARZERO_queue);
    PARZERO_f83T(str_goc6tLsUuXd, PARZERO_queue);
    PARZERO_f83T(str_Jh5IjP2w3F1, PARZERO_queue);
    PARZERO_f83T(str_j0Z0cYzBc9f, PARZERO_queue);
    PARZERO_f83T(str_SEIrynv0s06, PARZERO_queue);
    PARZERO_f83T(str_nZmj0FVdyCb, PARZERO_queue);
    PARZERO_f83T(str_kW4aBnNXGk6, PARZERO_queue);
    PARZERO_f83T(str_b7YX0P13Kz1, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_7jBjqn7nlkf), fu::str(str_aBCi48oqauk) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_PV5EQW0GOJa), fu::str(str_bdZD81b26p7) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_6j4WP2cfXkd), fu::str(str_cm5Ztlk8NEa) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_LvQcpDtTeG1), fu::str(str_h1bgkXAZC5a) }}, PARZERO_queue);
    PARZERO_f83T(str_pJErjlBJBze, PARZERO_queue);
    PARZERO_f83T(str_wCaqfnNtuKg, PARZERO_queue);
    PARZERO_f83T(str_MY3H22i9HSf, PARZERO_queue);
    PARZERO_f83T(str_G60lwX13usg, PARZERO_queue);
    PARZERO_f83T(str_LFMuGP7zkwe, PARZERO_queue);
    PARZERO_f83T(str_qkNYGyxMEsj, PARZERO_queue);
    TODO_5TaN(str_U5OqM8Lbbn0, str_d2EK5g3cKOh, testdiffs);
    TODO_5TaN(str_G0kA3okWkyk, str_d2EK5g3cKOh, testdiffs);
    PARZERO_f83T(str_0iTgITfVfb5, PARZERO_queue);
    PARZERO_f83T(str_W3JZkC0h6aj, PARZERO_queue);
    PARZERO_f83T(str_02kaJcTwNwf, PARZERO_queue);
    PARZERO_f83T(str_cKyol8AMMq6, PARZERO_queue);
    PARZERO_f83T(str_PVgwWl6S6v7, PARZERO_queue);
    PARZERO_f83T(str_0pVxBuEzeKc, PARZERO_queue);
    PARZERO_f83T(str_tECsgmQFKG3, PARZERO_queue);
    PARZERO_f83T(str_WrcRN68Mxah, PARZERO_queue);
    PARZERO_f83T(str_KZ9ysYdoyKa, PARZERO_queue);
    PARZERO_f83T(str_1ojPKRf7Utf, PARZERO_queue);
    PARZERO_f83T(str_ZTkZZ88ngTa, PARZERO_queue);
    PARZERO_f83T(str_4M4TRkKm0y5, PARZERO_queue);
    PARZERO_f83T(str_EraeyyqTNTj, PARZERO_queue);
    PARZERO_f83T(str_jpaJCCAutgf, PARZERO_queue);
    PARZERO_f83T(str_aQXZCd48W3f, PARZERO_queue);
    PARZERO_f83T(str_uW64YBGUVfe, PARZERO_queue);
    PARZERO_f83T(str_QSAeWDug9Rh, PARZERO_queue);
    PARZERO_f83T(str_PUvI6e7LUJi, PARZERO_queue);
    PARZERO_f83T(str_c9OPYAg3Bwi, PARZERO_queue);
    PARZERO_f83T(str_Ko7K1mMYe83, PARZERO_queue);
    PARZERO_f83T(str_LcMduGygZN0, PARZERO_queue);
    PARZERO_f83T(str_L73JyuUJ7Ej, PARZERO_queue);
    TODO_5TaN(str_wwG8lk7Habe, str_1Ttx9EsoFp6, testdiffs);
    TODO_5TaN(str_ZzIHvRi2MZc, str_eEfU4xm8eid, testdiffs);
    PARZERO_f83T(str_LaHR0qoD3Xk, PARZERO_queue);
    PARZERO_f83T(str_dzJjfKCnwS7, PARZERO_queue);
    PARZERO_f83T(str_0P7j8d7E7ca, PARZERO_queue);
    PARZERO_f83T(str_gWDY3TD1Kg5, PARZERO_queue);
    TODO_5TaN(str_z1R24yn8Nl3, str_BiRtOLbIsI9, testdiffs);
    PARZERO_f83T(str_ywYrKcAdUnf, PARZERO_queue);
    PARZERO_f83T(str_zpvbMVfBBQ3, PARZERO_queue);
    PARZERO_f83T(str_XUtUfEkHOu3, PARZERO_queue);
    PARZERO_f83T(str_P791Hu3rUrh, PARZERO_queue);
    PARZERO_f83T(str_SuwjQW5Kr68, PARZERO_queue);
    PARZERO_f83T(str_1bHJQDC15ua, PARZERO_queue);
    PARZERO_f83T(str_rAljFnDSThl, PARZERO_queue);
    PARZERO_f83T(str_szgVyETT578, PARZERO_queue);
    PARZERO_f83T(str_GGdFk8M2Fld, PARZERO_queue);
    PARZERO_f83T(str_MAG8L6bSGz0, PARZERO_queue);
    PARZERO_f83T(str_6u237Ikarvg, PARZERO_queue);
    PARZERO_f83T(str_5bs9m6ujLV6, PARZERO_queue);
    PARZERO_f83T(str_sc6XvZ5Gej6, PARZERO_queue);
    PARZERO_f83T(str_2YcHzbNsMfe, PARZERO_queue);
    PARZERO_f83T(str_Rz7woBLtT75, PARZERO_queue);
    PARZERO_f83T(str_6pM9yj51Tel, PARZERO_queue);
    PARZERO_f83T(str_n2DYVZF2199, PARZERO_queue);
    PARZERO_f83T(str_6n2LeTogpY2, PARZERO_queue);
    PARZERO_f83T(str_QnYmFTJZ1h8, PARZERO_queue);
    PARZERO_f83T(str_t4Fd3HAwhdi, PARZERO_queue);
    PARZERO_f83T(str_srtqeGvhyE3, PARZERO_queue);
    PARZERO_f83T(str_TcBrCVupfag, PARZERO_queue);
    PARZERO_f83T(str_TELWImXuCx5, PARZERO_queue);
    PARZERO_f83T(str_giZL1d581j6, PARZERO_queue);
    PARZERO_f83T(str_YhCXrPMlHhk, PARZERO_queue);
    PARZERO_f83T(str_vZhpRufJ9Gg, PARZERO_queue);
    PARZERO_f83T(str_Vt9jmHW7RJ4, PARZERO_queue);
    PARZERO_f83T(str_409E0Pbj6Tc, PARZERO_queue);
    PARZERO_f83T(str_OURuRS7GKjj, PARZERO_queue);
    PARZERO_f83T(str_mn5GD0Tnlm0, PARZERO_queue);
    PARZERO_f83T(str_sseec7v7rjk, PARZERO_queue);
    PARZERO_f83T(str_lv2KzaPx7Mb, PARZERO_queue);
    PARZERO_f83T(str_W2wJsPI7Orc, PARZERO_queue);
    PARZERO_f83T(str_8UfyX8E022e, PARZERO_queue);
    PARZERO_f83T(str_tDvPFy2YCP0, PARZERO_queue);
    PARZERO_f83T(str_MOjORdaaAnl, PARZERO_queue);
    PARZERO_f83T(str_EqbJPTaEFn0, PARZERO_queue);
    PARZERO_f83T(str_YshiuNEQ9Y0, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_7O0waSDwiDc), fu::str(str_DTlmAaSG8Zc) }}, PARZERO_queue);
    PARZERO_f83T(str_YfFHDPDtSE8, PARZERO_queue);
    PARZERO_f83T(str_WTIvJmFmE80, PARZERO_queue);
    PARZERO_f83T(str_XIIK1e1qIe4, PARZERO_queue);
    PARZERO_f83T(str_ur1bbemEqwd, PARZERO_queue);
    TODO_5TaN(str_xwqTz633eVl, str_d2EK5g3cKOh, testdiffs);
    TODO_5TaN(str_dO8E494jT9l, str_d2EK5g3cKOh, testdiffs);
    PARZERO_f83T(str_7iXyrWEHuqi, PARZERO_queue);
    PARZERO_f83T(str_fdtSYNgZ7ri, PARZERO_queue);
    PARZERO_f83T(str_DRwbmXUWkHl, PARZERO_queue);
    PARZERO_f83T(str_BFKa8WMJDob, PARZERO_queue);
    PARZERO_f83T(str_eiUwpjkJfl4, PARZERO_queue);
    PARZERO_f83T(str_SnScbuuo7e7, PARZERO_queue);
    PARZERO_f83T(str_klRBwTVqJz2, PARZERO_queue);
    PARZERO_f83T(str_Um3bUHKTMbe, PARZERO_queue);
    PARZERO_f83T(str_djULcnFW6Gh, PARZERO_queue);
    PARZERO_f83T(str_HVYN9NaXKZa, PARZERO_queue);
    PARZERO_f83T(str_AIFkvGpL8c6, PARZERO_queue);
    PARZERO_f83T(str_g8AmOijSlef, PARZERO_queue);
    PARZERO_f83T(str_tF9BfWR3fr8, PARZERO_queue);
    PARZERO_f83T(str_ecT9BI9Znt6, PARZERO_queue);
    PARZERO_f83T(str_Hscug6rbDla, PARZERO_queue);
    PARZERO_f83T(str_eydOPEBfKj1, PARZERO_queue);
    PARZERO_f83T(str_qb1yHn5kQZ2, PARZERO_queue);
    PARZERO_f83T(str_82KJ9geMHkg, PARZERO_queue);
    PARZERO_f83T(str_1eTW176MsZf, PARZERO_queue);
    PARZERO_f83T(str_J66srUeRWz3, PARZERO_queue);
    PARZERO_f83T(str_RX6IaFnghBk, PARZERO_queue);
    PARZERO_f83T(str_6bYwXoF3Vje, PARZERO_queue);
    PARZERO_f83T(str_Fi1DHU0qL3e, PARZERO_queue);
    PARZERO_f83T(str_g2xJfeY7Bc2, PARZERO_queue);
    PARZERO_f83T(str_crlS0Mew724, PARZERO_queue);
    TODO_5TaN(str_z8uLIH7OiGd, str_7NNX97mGs5d, testdiffs);
    PARZERO_f83T(str_eksbrMjHXQj, PARZERO_queue);
    PARZERO_f83T(str_bVqcDaJNIq7, PARZERO_queue);
    PARZERO_f83T(str_0E9DX5mh2g5, PARZERO_queue);
    PARZERO_f83T(str_dJ2hCXHqoH9, PARZERO_queue);
    PARZERO_f83T(str_TYEtinCvsN6, PARZERO_queue);
    PARZERO_f83T(str_wh4Og3s07ib, PARZERO_queue);
    PARZERO_f83T(str_sUh5jygOo64, PARZERO_queue);
    PARZERO_f83T(str_8RQQYUiveF9, PARZERO_queue);
    PARZERO_f83T(str_lqbsvROjIpe, PARZERO_queue);
    PARZERO_f83T(str_bLZdNb0horl, PARZERO_queue);
    PARZERO_f83T(str_l8AEL6TqHy1, PARZERO_queue);
    PARZERO_f83T(str_Q0KJQbm3kw3, PARZERO_queue);
    PARZERO_f83T(str_Jr57XGWeqH9, PARZERO_queue);
    PARZERO_f83T(str_3ckcyNDBZb9, PARZERO_queue);
    PARZERO_f83T(str_aZa4IHN6Qna, PARZERO_queue);
    PARZERO_f83T(str_Ks9lRjj1ey2, PARZERO_queue);
    PARZERO_f83T(str_QGl2kvLVc4j, PARZERO_queue);
    PARZERO_f83T(str_WbvoADcs9pd, PARZERO_queue);
    PARZERO_f83T(str_HyLZx5lUgyj, PARZERO_queue);
    PARZERO_f83T(str_JglcmOHnQH2, PARZERO_queue);
    PARZERO_f83T(str_GIF3ajUTKqb, PARZERO_queue);
    PARZERO_f83T(str_11HBVV9lLOf, PARZERO_queue);
    PARZERO_f83T(str_M99gVht5uy7, PARZERO_queue);
    PARZERO_f83T(str_iVRwMHSEtGl, PARZERO_queue);
    PARZERO_f83T(str_cuTxap0V8xk, PARZERO_queue);
    PARZERO_f83T(str_GLatQIzftql, PARZERO_queue);
    TODO_5TaN(str_LIyMZPSX0Z4, str_DD9tKgbERtj, testdiffs);
    PARZERO_f83T(str_VZYkDdTYrwa, PARZERO_queue);
    PARZERO_f83T(str_U892qezW07a, PARZERO_queue);
    PARZERO_f83T(str_W0HDjpcW0o8, PARZERO_queue);
    PARZERO_f83T(str_R9mQlLnjNri, PARZERO_queue);
    PARZERO_f83T(str_i9gqlzlD4c7, PARZERO_queue);
    PARZERO_f83T(str_fV1buoCgdzk, PARZERO_queue);
    PARZERO_f83T(str_7tOpRfOR61e, PARZERO_queue);
    PARZERO_f83T(str_TWCZ1aJKESk, PARZERO_queue);
    PARZERO_f83T(str_QHdcOBxDM8a, PARZERO_queue);
    PARZERO_f83T(str_XHrxKqaMW81, PARZERO_queue);
    PARZERO_f83T(str_Bmzik1QY5R4, PARZERO_queue);
    PARZERO_f83T(str_N02QFubGyme, PARZERO_queue);
    PARZERO_f83T(str_L6XBo5dkQc7, PARZERO_queue);
    PARZERO_f83T(str_S6mDo19N32d, PARZERO_queue);
    PARZERO_f83T(str_vIinEHLDIc1, PARZERO_queue);
    PARZERO_f83T(str_ojAnNtyGmca, PARZERO_queue);
    PARZERO_f83T(str_hJQdvfVJ8Zh, PARZERO_queue);
    PARZERO_f83T(str_RHmvnrW5N7g, PARZERO_queue);
    PARZERO_f83T(str_D1FndQTVgpg, PARZERO_queue);
    PARZERO_f83T(str_6XDblbrQ37k, PARZERO_queue);
    PARZERO_f83T(str_rExTxD9KWle, PARZERO_queue);
    PARZERO_f83T(str_6prroUJvfqi, PARZERO_queue);
    PARZERO_f83T(str_JejnyFwGJQd, PARZERO_queue);
    PARZERO_f83T(str_Fh7f6lXl4Ok, PARZERO_queue);
    PARZERO_f83T(str_hH51Cpbtf58, PARZERO_queue);
    TODO_5TaN(str_uq16CtSTcbe, str_JOmkFEpnqVk, testdiffs);
    PARZERO_f83T(str_fWEwtmoZ4p4, PARZERO_queue);
    PARZERO_f83T(str_5YLWjJsVHJg, PARZERO_queue);
    PARZERO_f83T(str_YiTd2hxhIP6, PARZERO_queue);
    PARZERO_f83T(str_oiAmt23sPz8, PARZERO_queue);
    PARZERO_f83T(str_eTJr1ebVqJ9, PARZERO_queue);
    PARZERO_f83T(str_lP4FFxnma2k, PARZERO_queue);
    PARZERO_f83T(str_0SAYqnOVvR8, PARZERO_queue);
    PARZERO_f83T(str_SL3fl0R9uI4, PARZERO_queue);
    PARZERO_f83T(str_5yOgoSyfAEh, PARZERO_queue);
    PARZERO_f83T(str_CMNEVaFpkhk, PARZERO_queue);
    TODO_5TaN(str_zBbGuuCsVtj, str_XO9hHrgUcre, testdiffs);
    PARZERO_f83T(str_cGYJWXP0GY2, PARZERO_queue);
    PARZERO_f83T(str_y4XNKMoPxB9, PARZERO_queue);
    PARZERO_f83T(str_kWgil0IZ8hh, PARZERO_queue);
    PARZERO_f83T(str_ny2UNPvcWNa, PARZERO_queue);
    PARZERO_f83T(str_FbPjSz6slI0, PARZERO_queue);
    PARZERO_f83T(str_17zw1FjBgtg, PARZERO_queue);
    PARZERO_f83T(str_MgnEzgw4zR6, PARZERO_queue);
    PARZERO_f83T(str_5pGje5BjZpf, PARZERO_queue);
    PARZERO_f83T(str_sdMnewT3hc5, PARZERO_queue);
    PARZERO_f83T(str_mFFg7nJEXhi, PARZERO_queue);
    PARZERO_f83T(str_XedCLuKmHKl, PARZERO_queue);
    PARZERO_f83T(str_bVqyeUPNNs0, PARZERO_queue);
    PARZERO_f83T(str_NzzOKOBtuxa, PARZERO_queue);
    PARZERO_f83T(str_XpHE3cnJwwh, PARZERO_queue);
    PARZERO_f83T(str_L0KvwRIemNg, PARZERO_queue);
    PARZERO_f83T(str_8O8sw0xqA79, PARZERO_queue);
    PARZERO_f83T(str_KFvMtS49Hs3, PARZERO_queue);
    PARZERO_f83T(str_gP6VlFGkdDl, PARZERO_queue);
    PARZERO_f83T(str_tv8l2904UOk, PARZERO_queue);
    PARZERO_f83T(str_plFsAGo0xo1, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_BnOYCh0VHje), fu::str(str_foZwTdEsr0g) }}, PARZERO_queue);
    PARZERO_f83T(str_3rEfgWuLkFh, PARZERO_queue);
    PARZERO_f83T(str_hiwfv3zXKDk, PARZERO_queue);
    PARZERO_f83T(str_VWfM6qTtBqa, PARZERO_queue);
    PARZERO_f83T(str_iXIxqeQot3g, PARZERO_queue);
    PARZERO_f83T(str_H7kMh8p7Ns6, PARZERO_queue);
    PARZERO_f83T(str_Lxam3a7czm3, PARZERO_queue);
    PARZERO_f83T(str_G9xtOZowzjk, PARZERO_queue);
    PARZERO_f83T(str_ImXZnV6wOZe, PARZERO_queue);
    PARZERO_f83T(str_Q4CMKzY4mke, PARZERO_queue);
    PARZERO_f83T(str_WzfveXxsIHh, PARZERO_queue);
    PARZERO_f83T(str_zV2QBWp4vr6, PARZERO_queue);
    PARZERO_f83T(str_hLJPgMfTQbi, PARZERO_queue);
    PARZERO_f83T(str_zm97G0DZxg3, PARZERO_queue);
    PARZERO_f83T(str_R6XOifmRMec, PARZERO_queue);
    PARZERO_f83T(str_NRBFKKNrYf8, PARZERO_queue);
    PARZERO_f83T(str_t2nHn9h7boa, PARZERO_queue);
    PARZERO_f83T(str_R4vLFPcN651, PARZERO_queue);
    TODO_5TaN(str_Oi4pkq80wSd, str_vAJvMVcmBid, testdiffs);
    PARZERO_f83T(str_foZUrZXSP7i, PARZERO_queue);
    PARZERO_f83T(str_vUTRGRAwDqe, PARZERO_queue);
    PARZERO_f83T(str_BHENw2Sl5F2, PARZERO_queue);
    PARZERO_f83T(str_PUvBFFkwSCc, PARZERO_queue);
    PARZERO_f83T(str_Ax1cuLTlcrd, PARZERO_queue);
    PARZERO_f83T(str_Opn6EtAfLEa, PARZERO_queue);
    PARZERO_f83T(str_AOmOYBUv8d8, PARZERO_queue);
    PARZERO_f83T(str_PKgFEDbZS74, PARZERO_queue);
    PARZERO_f83T(str_nbN5PDOmP5a, PARZERO_queue);
    PARZERO_f83T(str_pKtGSuMWjE8, PARZERO_queue);
    PARZERO_f83T(str_M2KtAtxahm4, PARZERO_queue);
    PARZERO_f83T(str_umNewjR2R63, PARZERO_queue);
    PARZERO_f83T(str_hDZQ3DkoIoe, PARZERO_queue);
    PARZERO_f83T(str_qpb1j19imC7, PARZERO_queue);
    PARZERO_f83T(str_JAKl4QAgDLh, PARZERO_queue);
    PARZERO_f83T(str_ZxdCm8kgzvj, PARZERO_queue);
    PARZERO_f83T(str_W4ssiwgNQLb, PARZERO_queue);
    TODO_5TaN(str_Ncrg9Qd4OV0, str_nymB0yMEwFi, testdiffs);
    PARZERO_f83T(str_5dc6nxGHwC2, PARZERO_queue);
    PARZERO_f83T(str_Y9s0dAohcZk, PARZERO_queue);
    PARZERO_f83T(str_sajh9U8V839, PARZERO_queue);
    PARZERO_f83T(str_InyKrlsJrp4, PARZERO_queue);
    PARZERO_f83T(str_g8p58qVSzIc, PARZERO_queue);
    PARZERO_f83T(str_v2Ob5tAa8Lc, PARZERO_queue);
    TODO_5TaN(str_svVY0gA6fu5, str_7NNX97mGs5d, testdiffs);
    PARZERO_f83T(str_XSAPer3T5fl, PARZERO_queue);
    TODO_5TaN(str_GNZDg2ofY9l, str_xiA4fkkpz2a, testdiffs);
    PARZERO_f83T(str_Uxd6RwIJ5K4, PARZERO_queue);
    TODO_5TaN(str_MhZJG7dx5x6, str_1cxfkW9df2j, testdiffs);
    PARZERO_f83T(str_sJhZOKz92T7, PARZERO_queue);
    PARZERO_f83T(str_L67XPFk7rS9, PARZERO_queue);
    PARZERO_f83T(str_lbVGS9KSFgc, PARZERO_queue);
    PARZERO_f83T(str_hNJgAGwCBn3, PARZERO_queue);
    PARZERO_f83T(str_FKqrN6Hm17b, PARZERO_queue);
    TODO_5TaN(str_oAhHoHEU56g, str_sB9bzAwwUdc, testdiffs);
    PARZERO_f83T(str_p1TRI1HZycj, PARZERO_queue);
    TODO_5TaN(str_ERkLCYTa8N5, str_SNYVOshXQJ2, testdiffs);
    PARZERO_f83T(str_0fBGgGkT5fi, PARZERO_queue);
    PARZERO_f83T(str_UtWTYNNeeV4, PARZERO_queue);
    PARZERO_f83T(str_CcCHgTPau7h, PARZERO_queue);
    PARZERO_f83T(str_sIoceH3ZiTa, PARZERO_queue);
    TODO_5TaN(str_b5SHhsoZdCc, str_1cLasDUM6h7, testdiffs);
    PARZERO_f83T(str_m9B302EJS32, PARZERO_queue);
    PARZERO_f83T(str_0tG5TYZbLY1, PARZERO_queue);
    PARZERO_f83T(str_lPGwgVhKOKl, PARZERO_queue);
    PARZERO_f83T(str_jbOHBlEMYi7, PARZERO_queue);
    PARZERO_f83T(str_nHH3vGaxek9, PARZERO_queue);
    TODO_5TaN(str_C9pp6hmkode, str_UdVSZ8zMVk2, testdiffs);
    PARZERO_f83T(str_e07NkpWpAP6, PARZERO_queue);
    PARZERO_f83T(str_K4CGxXvZ5P0, PARZERO_queue);
    PARZERO_f83T(str_8ReSaeZX6V7, PARZERO_queue);
    PARZERO_f83T(str_ZXGTHhqKwF9, PARZERO_queue);
    PARZERO_f83T(str_MfFWscBTsVd, PARZERO_queue);
    PARZERO_f83T(str_Er28gnY0mj3, PARZERO_queue);
    PARZERO_f83T(str_N5EyWI2Biyh, PARZERO_queue);
    PARZERO_f83T(str_lOjRy2S54C7, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_ZKeYzfmbqR2), fu::str(str_RjAh6PW3xu1) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_eq1W8BeKfu5), fu::str(str_Y5RmIFOFVt8) }}, PARZERO_queue);
    PARZERO_f83T(str_ty91wj3Sla8, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_6uMGyExTuKh), fu::str(str_0AYAm403K2j) }}, PARZERO_queue);
    TODO_5TaN(str_X9aWJCzFH87, str_d2EK5g3cKOh, testdiffs);
    PARZERO_f83T(str_vyKKp6AnhJa, PARZERO_queue);
    PARZERO_f83T(str_LaX2eFJlOpk, PARZERO_queue);
    PARZERO_f83T(str_XOofzIkzwXl, PARZERO_queue);
    PARZERO_f83T(str_n2qDSukJtXb, PARZERO_queue);
    PARZERO_f83T(str_yuIUno1H8j3, PARZERO_queue);
    PARZERO_f83T(str_mNK2Vf31P2k, PARZERO_queue);
    PARZERO_f83T(str_3DA9WPFB5i9, PARZERO_queue);
    PARZERO_f83T(str_EuOZOWWnzai, PARZERO_queue);
    PARZERO_f83T(str_nu3MwoZEQR8, PARZERO_queue);
    PARZERO_f83T(str_2J19eVEnGuh, PARZERO_queue);
    PARZERO_f83T(str_Slt2amkSfyg, PARZERO_queue);
    PARZERO_f83T(str_jjYdDvf5mp9, PARZERO_queue);
    PARZERO_f83T(str_LywBYH3xxzj, PARZERO_queue);
    PARZERO_f83T(str_9asArZHWPj4, PARZERO_queue);
    PARZERO_f83T(str_v9T2ZiteUuf, PARZERO_queue);
    PARZERO_f83T(str_KmftRAv7li1, PARZERO_queue);
    PARZERO_f83T(str_8WN9I0ePNTh, PARZERO_queue);
    PARZERO_f83T(str_MBSJv6qgMVl, PARZERO_queue);
    PARZERO_f83T(str_YLC0Y5M0zQ5, PARZERO_queue);
    PARZERO_f83T(str_JTKSIzNITn3, PARZERO_queue);
    PARZERO_f83T(str_eCJplqU8Hpe, PARZERO_queue);
    PARZERO_f83T(str_U7f8Xk2iFF9, PARZERO_queue);
    PARZERO_f83T(str_I6Q0tBLEzu2, PARZERO_queue);
    PARZERO_f83T(str_NYr3DKkgNJf, PARZERO_queue);
    PARZERO_f83T(str_bEx282N2IOg, PARZERO_queue);
    PARZERO_f83T(str_qRHUeJQze50, PARZERO_queue);
    TODO_5TaN(str_Blft4cK8ZLk, str_d2EK5g3cKOh, testdiffs);
    PARZERO_f83T(str_1PTEV8Q36t9, PARZERO_queue);
    TODO_5TaN(str_I3G1yBinSj0, str_d2EK5g3cKOh, testdiffs);
    PARZERO_f83T(str_rOjQb9fxWab, PARZERO_queue);
    PARZERO_f83T(str_Lk8NMQEMyv4, PARZERO_queue);
    PARZERO_f83T(str_c3zqNj2eSHa, PARZERO_queue);
    PARZERO_f83T(str_lROtY1IbeH0, PARZERO_queue);
    PARZERO_f83T(str_Zbv96DdNHNf, PARZERO_queue);
    PARZERO_f83T(str_gleWCRHfXnj, PARZERO_queue);
    PARZERO_f83T(str_EyC9LKicYJ5, PARZERO_queue);
    PARZERO_f83T(str_DEGSojuzqOk, PARZERO_queue);
    TODO_5TaN(str_hjNW5v60Ch0, str_d2EK5g3cKOh, testdiffs);
    PARZERO_f83T(str_hPsjR0vRtDk, PARZERO_queue);
    PARZERO_f83T(str_qzQlo69mI6i, PARZERO_queue);
    PARZERO_f83T(str_lmnTq0pYQ25, PARZERO_queue);
    PARZERO_f83T(str_P8okKIaxyed, PARZERO_queue);
    PARZERO_f83T(str_mv2oOuIMnDj, PARZERO_queue);
    PARZERO_f83T(str_GYg4RLYQMAj, PARZERO_queue);
    PARZERO_f83T(str_Ba2HIPbQOic, PARZERO_queue);
    PARZERO_f83T(str_antU2vtMPt3, PARZERO_queue);
    PARZERO_f83T(str_drETF6n0tH8, PARZERO_queue);
    PARZERO_f83T(str_EXodQPgiNCd, PARZERO_queue);
    PARZERO_f83T(str_pbPXqZxiTv3, PARZERO_queue);
    PARZERO_f83T(str_1Fw5b3LHYse, PARZERO_queue);
    PARZERO_f83T(str_QtGDBwaVqkh, PARZERO_queue);
    PARZERO_f83T(str_GdfPdNDmfR2, PARZERO_queue);
    PARZERO_f83T(str_7LA43D3UPHa, PARZERO_queue);
    PARZERO_f83T(str_31misFGSQg0, PARZERO_queue);
    PARZERO_f83T(str_8vnvzTPC19i, PARZERO_queue);
    PARZERO_f83T(str_5Gpkh68a3q0, PARZERO_queue);
    PARZERO_f83T(str_NUi5GlAGGbl, PARZERO_queue);
    PARZERO_f83T(str_xm6xHd9JU10, PARZERO_queue);
    PARZERO_f83T(str_3QU1IyFMHyd, PARZERO_queue);
    PARZERO_f83T(str_JEPVcxr9bj8, PARZERO_queue);
    PARZERO_f83T(str_UL3mDG0WLtg, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_YQZvhWU6aG6), fu::str(str_GcF9x4MzLwi) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_V2oo3Ctmmyb), fu::str(str_HGJwbnKNj1c), fu::str(str_de7qbmiyKI0) }}, PARZERO_queue);
    PARZERO_f83T(str_oVLpCj7iXH0, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_RT053X7XUSc), fu::str(str_X9A88hvZ5yi), fu::str(str_alJ5CkJI5D1) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_HI5gbBCp0M8) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_3ZwYaCj9IG3) }}, PARZERO_queue);
    PARZERO_f83T(str_c28272KFHKj, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_PfB1ja8Why0), fu::str(str_BhMDRFxgM48), fu::str(str_9CQoT2BjKtc) }}, PARZERO_queue);
    PARZERO_f83T(str_HaE3P6rCOP1, PARZERO_queue);
    PARZERO_f83T(str_LYjyBX46jLc, PARZERO_queue);
    PARZERO_f83T(str_YNXO209j2o3, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_BxekpC0UBsk), fu::str(str_N4jTXSfl7Rc) }}, PARZERO_queue);
    TODO_5TaN(str_1JOMjfBoU7d, str_Wis5H3E3g56, testdiffs);
    PARZERO_f83T(str_U3Fq7CgnPZ3, PARZERO_queue);
    PARZERO_f83T(str_xIge1tUIAva, PARZERO_queue);
    PARZERO_f83T(str_iW50pX4u2lj, PARZERO_queue);
    PARZERO_f83T(str_P6hDUXr6CSe, PARZERO_queue);
    PARZERO_f83T(str_YjFDAs6qR3c, PARZERO_queue);
    PARZERO_f83T(str_zCi9LCJWHT0, PARZERO_queue);
    PARZERO_f83T(str_jqhwrRfd8H1, PARZERO_queue);
    PARZERO_f83T(str_g2qktFUCfV6, PARZERO_queue);
    PARZERO_f83T(str_JQE4nZlIV7j, PARZERO_queue);
    PARZERO_f83T(str_Epo07hZ3Ht4, PARZERO_queue);
    PARZERO_f83T(str_FWkyqWnmdc5, PARZERO_queue);
    PARZERO_f83T(str_0x77MPjkNse, PARZERO_queue);
    PARZERO_f83T(str_f37z66mgEJg, PARZERO_queue);
    PARZERO_f83T(str_ZkxOd0GDND8, PARZERO_queue);
    PARZERO_f83T(str_Ai0XLpTxgJ3, PARZERO_queue);
    PARZERO_f83T(str_RSrR1PnvQbg, PARZERO_queue);
    PARZERO_f83T(str_yaXhjElFK6e, PARZERO_queue);
    PARZERO_f83T(str_AW5GLkCm1rg, PARZERO_queue);
    PARZERO_f83T(str_yKbGo8YCzZe, PARZERO_queue);
    PARZERO_f83T(str_RZCPT3fZfz3, PARZERO_queue);
    PARZERO_f83T(str_lfuxNE9f2Y5, PARZERO_queue);
    PARZERO_f83T(str_9IYK1g4d6ia, PARZERO_queue);
    PARZERO_f83T(str_FMnRr5Dr6gi, PARZERO_queue);
    PARZERO_f83T(str_96ZDJIk4Tb7, PARZERO_queue);
    PARZERO_f83T(str_LBEkNBfWyH6, PARZERO_queue);
    PARZERO_f83T(str_2VO9qrsYgaa, PARZERO_queue);
    PARZERO_f83T(str_qzcBzXAkyL1, PARZERO_queue);
    PARZERO_f83T(str_CTge4gbA3I2, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_ixb2sG8mIHk), fu::str(str_6n6cSZlfwlb) }}, PARZERO_queue);
    TODO_5TaN(str_ubdWzpMsvlk, str_hd353XtBVk3, testdiffs);
    PARZERO_f83T(str_LFloVZbZU7a, PARZERO_queue);
    PARZERO_f83T(str_U8brJ7vFTWh, PARZERO_queue);
    PARZERO_f83T(str_8NAZgBhQrBb, PARZERO_queue);
    PARZERO_f83T(str_E2BdEjaqodi, PARZERO_queue);
    PARZERO_f83T(str_IjvKDfkycm0, PARZERO_queue);
    PARZERO_f83T(str_aiAv7Gll9p0, PARZERO_queue);
    PARZERO_f83T(str_AADRVY4JCP5, PARZERO_queue);
    PARZERO_f83T(str_mx7D8BYaRAd, PARZERO_queue);
    PARZERO_f83T(str_IO0uNMPZc69, PARZERO_queue);
    PARZERO_f83T(str_mK1xbU4NnVh, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_jml9OOAxvN0), fu::str(str_J5k72AQT8vh) }}, PARZERO_queue);
    PARZERO_f83T(str_JthWo7jvICd, PARZERO_queue);
    PARZERO_f83T(str_q5K6cSDBIs7, PARZERO_queue);
    PARZERO_f83T(str_Rpo89VSoDph, PARZERO_queue);
    PARZERO_f83T(str_G78onPwzfJ9, PARZERO_queue);
    TODO_5TaN(str_JKcVp1yK6T5, str_pIOO3VBh8s4, testdiffs);
    PARZERO_f83T(str_hKwc9fKGRZf, PARZERO_queue);
    PARZERO_f83T(str_x5G9gnMvee2, PARZERO_queue);
    PARZERO_f83T(str_ugDZ60Z0vKc, PARZERO_queue);
    PARZERO_f83T(str_xK9bm3Xa4zi, PARZERO_queue);
    PARZERO_f83T(str_vcPSIkvp8ob, PARZERO_queue);
    PARZERO_f83T(str_WQOmA1IVh1e, PARZERO_queue);
    PARZERO_f83T(str_nb54bLkYkRk, PARZERO_queue);
    PARZERO_f83T(str_kOWe0eXsI5g, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_9zkccdn7AQ8), fu::str(str_1XtA3r4zIHg) }}, PARZERO_queue);
    TODO_5TaN(str_yHJW0nOJvE1, str_d2EK5g3cKOh, testdiffs);
    PARZERO_f83T(str_CTsvbD2mvKh, PARZERO_queue);
    PARZERO_f83T(str_N6tUBF0E9cd, PARZERO_queue);
    PARZERO_f83T(str_WBLgVmIOy2d, PARZERO_queue);
    PARZERO_f83T(str_EDaCgeUrtEl, PARZERO_queue);
    PARZERO_f83T(str_S6gcyKuglei, PARZERO_queue);
    PARZERO_f83T(str_j5brj1fMTD6, PARZERO_queue);
    PARZERO_f83T(str_YKRLxJfVOua, PARZERO_queue);
    PARZERO_f83T(str_VyhBOAWWWbf, PARZERO_queue);
    PARZERO_f83T(str_A6bqOp9jkQf, PARZERO_queue);
    TODO_5TaN(str_Vnpz84BUw70, str_obYFqukJtP7, testdiffs);
    TODO_5TaN(str_0zyzS2HLe78, str_93NC1NGKYFa, testdiffs);
    PARZERO_f83T(str_WJZwFyazgz6, PARZERO_queue);
    PARZERO_f83T(str_mv4hceYbq9a, PARZERO_queue);
    PARZERO_f83T(str_F8dG5TXPNhb, PARZERO_queue);
    PARZERO_f83T(str_w8xka4WNc33, PARZERO_queue);
    PARZERO_f83T(str_OtPU6RZhcth, PARZERO_queue);
    PARZERO_f83T(str_M2D85C9Gjie, PARZERO_queue);
    PARZERO_f83T(str_HngqjVSOr8d, PARZERO_queue);
    PARZERO_f83T(str_EMW0GmzsNQ1, PARZERO_queue);
    PARZERO_f83T(str_hSwpopTaNsf, PARZERO_queue);
    PARZERO_f83T(str_FV5pePYQVli, PARZERO_queue);
    PARZERO_f83T(str_EY6j8Qm8IJc, PARZERO_queue);
    PARZERO_f83T(str_s2Jgjlmq8Jj, PARZERO_queue);
    PARZERO_f83T(str_PPtWuM5nPX7, PARZERO_queue);
    PARZERO_f83T(str_6F6YVtf8zu7, PARZERO_queue);
    PARZERO_f83T(str_yTocFvWRCJ9, PARZERO_queue);
    PARZERO_f83T(str_YhffEIeyP4b, PARZERO_queue);
    PARZERO_f83T(str_QUFM3RNo1d8, PARZERO_queue);
    PARZERO_f83T(str_MXjCQVRLmH9, PARZERO_queue);
    PARZERO_f83T(str_V1hZIdnZ8Yh, PARZERO_queue);
    PARZERO_f83T(str_2oUu7X6Eq89, PARZERO_queue);
    PARZERO_f83T(str_l0iz2Emuj8a, PARZERO_queue);
    PARZERO_f83T(str_D33OW2ODtI5, PARZERO_queue);
    PARZERO_f83T(str_gYsPBgNLeT6, PARZERO_queue);
    PARZERO_f83T(str_MGhsN5uLWa9, PARZERO_queue);
    PARZERO_f83T(str_UqrsF36HzOe, PARZERO_queue);
    PARZERO_f83T(str_yRqhnevYXM0, PARZERO_queue);
    PARZERO_f83T(str_rP2BlWRsuz8, PARZERO_queue);
    PARZERO_f83T(str_nVamv0ewwI9, PARZERO_queue);
    PARZERO_f83T(str_6xyuOM0Fu98, PARZERO_queue);
    PARZERO_f83T(str_5nUL3Fy5Itb, PARZERO_queue);
    PARZERO_f83T(str_yKCIbEULfK0, PARZERO_queue);
    PARZERO_f83T(str_S7Mq0JpxQra, PARZERO_queue);
    PARZERO_f83T(str_dHzApFYUEd5, PARZERO_queue);
    PARZERO_f83T(str_QvpAKAXMExk, PARZERO_queue);
    PARZERO_f83T(str_16N6tyAWDud, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_DPuxQu2SWz9), fu::str(str_KuOqMUXRqD5) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_Bmjzqh9P9dl), fu::str(str_Y5RgpZYXwMg) }}, PARZERO_queue);
    PARZERO_f83T(str_mxYBvLRUoG9, PARZERO_queue);
    PARZERO_f83T(str_sV06SBepb70, PARZERO_queue);
    PARZERO_f83T(str_jqtrZXhgPJ6, PARZERO_queue);
    PARZERO_f83T(str_glAOqonimS1, PARZERO_queue);
    PARZERO_f83T(str_B5NSp6CLaY9, PARZERO_queue);
    PARZERO_f83T(str_rS3Gcju2tq7, PARZERO_queue);
    PARZERO_f83T(str_vc56ANfj1Yk, PARZERO_queue);
    PARZERO_f83T(str_CwUw4SUX7i3, PARZERO_queue);
    PARZERO_f83T(str_eDCxCBP6pyk, PARZERO_queue);
    PARZERO_f83T(str_lE1s8tFYyu0, PARZERO_queue);
    PARZERO_f83T(str_zVvSB0MeD83, PARZERO_queue);
    PARZERO_f83T(str_v6ny8YL303b, PARZERO_queue);
    PARZERO_f83T(str_BcfaWWJLNZ4, PARZERO_queue);
    PARZERO_f83T(str_X3JQlWGFpCe, PARZERO_queue);
    PARZERO_f83T(str_kKX9u85OLb5, PARZERO_queue);
    PARZERO_f83T(str_EG0xVT4HEEc, PARZERO_queue);
    PARZERO_f83T(str_CYT7wm50l69, PARZERO_queue);
    PARZERO_f83T(str_QQl5MGTlBLf, PARZERO_queue);
    PARZERO_f83T(str_JvxDhW61Qfc, PARZERO_queue);
    PARZERO_f83T(str_Sn061lUEA30, PARZERO_queue);
    PARZERO_f83T(str_0DdOamm5A2d, PARZERO_queue);
    PARZERO_f83T(str_yds2uBcZhQf, PARZERO_queue);
    PARZERO_f83T(str_qC4SnnrbCuj, PARZERO_queue);
    PARZERO_f83T(str_w9WiIRgP4f9, PARZERO_queue);
    PARZERO_f83T(str_d7UySL4cDz9, PARZERO_queue);
    PARZERO_f83T(str_1l93oEQ75H5, PARZERO_queue);
    PARZERO_f83T(str_bolt5VaaTX5, PARZERO_queue);
    PARZERO_f83T(str_ZwyqVqNclR6, PARZERO_queue);
    PARZERO_f83T(str_5FhXSus1Lk4, PARZERO_queue);
    PARZERO_f83T(str_JFMhNmTqxt2, PARZERO_queue);
    PARZERO_f83T(str_VE1NLogSte9, PARZERO_queue);
    PARZERO_f83T(str_iivKpq1utyj, PARZERO_queue);
    PARZERO_f83T(str_4NB2wLvVJWj, PARZERO_queue);
    PARZERO_f83T(str_NjZ7HJk9wYi, PARZERO_queue);
    PARZERO_f83T(str_8TTGQXtcrQl, PARZERO_queue);
    PARZERO_f83T(str_caZ5HZc0am3, PARZERO_queue);
    PARZERO_f83T(str_dPdIDTU5aXg, PARZERO_queue);
    PARZERO_f83T(str_ESBEtPPDYB7, PARZERO_queue);
    PARZERO_f83T(str_kf7l5Ym0Z2f, PARZERO_queue);
    PARZERO_f83T(str_9IsPx78WwG5, PARZERO_queue);
    PARZERO_f83T(str_jpjiV6OT9Yf, PARZERO_queue);
    PARZERO_f83T(str_dwrQjpYGLu7, PARZERO_queue);
    PARZERO_f83T(str_Dg49jMXBJ1k, PARZERO_queue);
    PARZERO_f83T(str_x6z7DPIwiD6, PARZERO_queue);
    PARZERO_f83T(str_Od3xKjDXmch, PARZERO_queue);
    PARZERO_f83T(str_LbArdTMBUc8, PARZERO_queue);
    PARZERO_f83T(str_VLDYFSMzC9d, PARZERO_queue);
    PARZERO_f83T(str_cmcEu9vf947, PARZERO_queue);
    PARZERO_f83T(str_cOXsHKSCUi4, PARZERO_queue);
    PARZERO_f83T(str_U5TapvWeKX9, PARZERO_queue);
    PARZERO_f83T(str_CyT4RwLkrt4, PARZERO_queue);
    PARZERO_f83T(str_PZt2fczB6T8, PARZERO_queue);
    PARZERO_f83T(str_TXGkrnq8mli, PARZERO_queue);
    PARZERO_f83T(str_lxMcwA2Xt77, PARZERO_queue);
    PARZERO_f83T(str_JCAVxpTxXvf, PARZERO_queue);
    PARZERO_f83T(str_tOlvohgMcvj, PARZERO_queue);
    PARZERO_f83T(str_NPpvtFMxxq8, PARZERO_queue);
    PARZERO_f83T(str_9oHn7b5azCb, PARZERO_queue);
    PARZERO_f83T(str_7sWciLLgRdb, PARZERO_queue);
    PARZERO_f83T(str_clnQL6Eb6Hi, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_lWGOkuzI9cd), fu::str(str_s8GQ05yfFAa) }}, PARZERO_queue);
    PARZERO_f83T(str_KjBlWW53nZ9, PARZERO_queue);
    PARZERO_f83T(str_ix3infy8a9b, PARZERO_queue);
    PARZERO_f83T(str_oXaKTtLnYwe, PARZERO_queue);
    PARZERO_f83T(str_WkQrb4jDVm9, PARZERO_queue);
    PARZERO_f83T(str_ylWnmDDgQpk, PARZERO_queue);
    PARZERO_f83T(str_g0FIedSACr8, PARZERO_queue);
    PARZERO_f83T(str_7jPgvr3TSQc, PARZERO_queue);
    TODO_5TaN(str_S65lFLF1Mv4, str_VvQW5a7D8G1, testdiffs);
    PARZERO_f83T(str_eiND4hgtvS9, PARZERO_queue);
    PARZERO_f83T(str_sT9YKO5zUtc, PARZERO_queue);
    TODO_5TaN(str_4pWVwSyYGUe, str_HTpttwyWlv5, testdiffs);
    TODO_5TaN(str_kNQxHs1UMl8, str_HTpttwyWlv5, testdiffs);
    PARZERO_f83T(str_rDj67BjlPM3, PARZERO_queue);
    PARZERO_f83T(str_vtFtiZPuEjk, PARZERO_queue);
    PARZERO_f83T(str_xuaAaFtg6Nj, PARZERO_queue);
    PARZERO_f83T(str_QfslEuUPZGf, PARZERO_queue);
    PARZERO_f83T(str_ncoS6AtYCm8, PARZERO_queue);
    PARZERO_f83T(str_37Xu8pXqkHh, PARZERO_queue);
    PARZERO_f83T(str_PhnRon16jm0, PARZERO_queue);
    PARZERO_f83T(str_o2eG5BmopOk, PARZERO_queue);
    PARZERO_f83T(str_lAIQ2G9zVof, PARZERO_queue);
    PARZERO_f83T(str_7rSNjUwclRi, PARZERO_queue);
    PARZERO_f83T(str_xJc1UIVwVQ6, PARZERO_queue);
    PARZERO_f83T(str_SccMw8BEj2b, PARZERO_queue);
    PARZERO_f83T(str_Aog51GgZHcl, PARZERO_queue);
    PARZERO_f83T(str_nNSkafvEjOd, PARZERO_queue);
    PARZERO_f83T(str_ZAiEYcZNVr6, PARZERO_queue);
    PARZERO_f83T(str_Y3uptv5OJJ0, PARZERO_queue);
    PARZERO_f83T(str_XJy3qp0ohg3, PARZERO_queue);
    PARZERO_f83T(str_OdmZ5grYJZf, PARZERO_queue);
    PARZERO_f83T(str_MsaQe4N4Izd, PARZERO_queue);
    PARZERO_f83T(str_NgaY8OOH6a3, PARZERO_queue);
    PARZERO_f83T(str_o2Sdu5DfgCe, PARZERO_queue);
    PARZERO_f83T(str_F8siDzXia2l, PARZERO_queue);
    PARZERO_f83T(str_u3pTf61Rlog, PARZERO_queue);
    PARZERO_f83T(str_xDcCfHalr0j, PARZERO_queue);
    PARZERO_f83T(str_IZHyaIOmasj, PARZERO_queue);
    PARZERO_f83T(str_Az2yy9aj2k2, PARZERO_queue);
    PARZERO_f83T(str_StrTNIIl3we, PARZERO_queue);
    PARZERO_f83T(str_PiXPI8lGafd, PARZERO_queue);
    PARZERO_f83T(str_nLyiAoD8Z6b, PARZERO_queue);
    PARZERO_f83T(str_AFAKQSWWtzb, PARZERO_queue);
    PARZERO_f83T(str_RQfRt0XHw26, PARZERO_queue);
    PARZERO_f83T(str_74QSBcmE1hb, PARZERO_queue);
    PARZERO_f83T(str_lQwMWHVPrP1, PARZERO_queue);
    PARZERO_f83T(str_ZQ4md1AWmSl, PARZERO_queue);
    PARZERO_f83T(str_4xljR6e3n61, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_wiu6KPMm1v7), fu::str(str_HxVIx1cxKqj) }}, PARZERO_queue);
    PARZERO_f83T(str_bYdqvkF3Nnk, PARZERO_queue);
    PARZERO_f83T(str_htLginyCH09, PARZERO_queue);
    PARZERO_f83T(str_tEoiYblGnZ7, PARZERO_queue);
    PARZERO_f83T(str_DvYSfLZpzJj, PARZERO_queue);
    PARZERO_f83T(str_kio3cHsMoAc, PARZERO_queue);
    PARZERO_f83T(str_bDYUtsWBN9k, PARZERO_queue);
    PARZERO_f83T(str_aJHe5OJMhDc, PARZERO_queue);
    PARZERO_f83T(str_QKt3CT26HX0, PARZERO_queue);
    TODO_5TaN(str_GsoamMK21h6, str_gBZB5o8yN1c, testdiffs);
    PARZERO_f83T(str_JUDGNCyQ13i, PARZERO_queue);
    PARZERO_f83T(str_VvaqP9MAaXl, PARZERO_queue);
    PARZERO_f83T(str_sP4ALCscbmc, PARZERO_queue);
    PARZERO_f83T(str_HUUA4HTYrIk, PARZERO_queue);
    PARZERO_f83T(str_QE81Ir4AFBl, PARZERO_queue);
    PARZERO_f83T(str_yCPfS5dd1Zi, PARZERO_queue);
    PARZERO_f83T(str_GaUyfz8VQWa, PARZERO_queue);
    PARZERO_f83T(str_jdCdJrMviyf, PARZERO_queue);
    PARZERO_f83T(str_30wuhCTFta7, PARZERO_queue);
    PARZERO_f83T(str_uZjq3kidXob, PARZERO_queue);
    PARZERO_f83T(str_GEHjzInm7Zg, PARZERO_queue);
    PARZERO_f83T(str_RDOUB2vsOeg, PARZERO_queue);
    PARZERO_f83T(str_8uxVys2Ru1l, PARZERO_queue);
    PARZERO_f83T(str_NPkxhs8H2v9, PARZERO_queue);
    PARZERO_f83T(str_kquArAoBrld, PARZERO_queue);
    PARZERO_f83T(str_ETZpXdWqHVh, PARZERO_queue);
    ZERO_SAME_5TaN(fu::view<fu::str> {{ fu::str(str_irKqdRGeiLh), fu::str(str_jy3EDTzRJdf), fu::str(str_KJkEfSAPDdd) }}, testdiffs);
    PARZERO_f83T(str_qSX16EtbwId, PARZERO_queue);
    PARZERO_f83T(str_oS3VXW5w4Jh, PARZERO_queue);
    PARZERO_f83T(str_MJOk5pv6rqc, PARZERO_queue);
    PARZERO_f83T(str_mDXIjAM2H7c, PARZERO_queue);
    PARZERO_f83T(str_Uy0gNzg9gD8, PARZERO_queue);
    TODO_5TaN(str_IXKm30Q2kYb, str_HGbFUc8Tvs6, testdiffs);
    PARZERO_f83T(str_YdoB2Bqkls0, PARZERO_queue);
    PARZERO_f83T(str_Kw5cFVZQnH8, PARZERO_queue);
    PARZERO_f83T(str_5C7pItJEAL2, PARZERO_queue);
    PARZERO_f83T(str_C3mMFVEhYMd, PARZERO_queue);
    PARZERO_f83T(str_suFsZHAF0Ci, PARZERO_queue);
    PARZERO_f83T(str_QzPHV96Ss5e, PARZERO_queue);
    PARZERO_f83T(str_bPv7EcnvEze, PARZERO_queue);
    PARZERO_f83T(str_r07zzFEWZji, PARZERO_queue);
    PARZERO_f83T(str_SsUMPANCEXc, PARZERO_queue);
    PARZERO_f83T(str_AtDAHKifEt4, PARZERO_queue);
    PARZERO_f83T(str_rHJq9GelhP2, PARZERO_queue);
    PARZERO_f83T(str_XkyPrhR2W93, PARZERO_queue);
    PARZERO_f83T(str_M5QJcXTnuc9, PARZERO_queue);
    PARZERO_f83T(str_6S7EjVKUIda, PARZERO_queue);
    PARZERO_f83T(str_sYLQo93eUzh, PARZERO_queue);
    PARZERO_f83T(str_JtO3SNjaEVf, PARZERO_queue);
    PARZERO_f83T(str_Iqo9mznxu78, PARZERO_queue);
    PARZERO_f83T(str_L9ob3cXaEx3, PARZERO_queue);
    PARZERO_f83T(str_mxd0QSPcyLa, PARZERO_queue);
    PARZERO_f83T(str_15isfz81rGe, PARZERO_queue);
    PARZERO_f83T(str_du7fyzKiYZ8, PARZERO_queue);
    PARZERO_f83T(str_6OCoGZxQCFi, PARZERO_queue);
    PARZERO_f83T(str_XgBOG66B0ub, PARZERO_queue);
    PARZERO_f83T(str_fpkEWqq8Kg6, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_NCDDYdNotGa), fu::str(str_bDKxvI6K5we) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_k35PMrzH9ya), fu::str(str_CG0xDNYh6n1) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_k35PMrzH9ya), fu::str(str_Dopo8R9DDNf), fu::str(str_47JovCWR8qd) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_k35PMrzH9ya), fu::str(str_5TtobiIiVCl), fu::str(str_47JovCWR8qd) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_k35PMrzH9ya), fu::str(str_5TtobiIiVCl), fu::str(str_KlAaBQjRqd4) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_kKa9CP7GU62), fu::str(str_jn4Zwjk56Lh), fu::str(str_fcyvbEwYWc7), fu::str(str_GqPRG1QJoj4) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_LXOEJE0w5Wb), fu::str(str_yWN6vXeiDI6), fu::str(str_IxOcTPRGNil), fu::str(str_YGguMkCbI0k) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_LSTam6ibS72), fu::str(str_C74NcrTvF0g) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_kNCr1t0n6Mk), fu::str(str_laDF3oSGVSi) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_j8AKNds8bb4), fu::str(str_rrfXAsM0nzd) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_uzmtSFwwtvg), fu::str(str_rP1IUyzDPIi) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_HtYfmqhayZ7), fu::str(str_Gc7BcAL4x60) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_PrkBHpkj5T6), fu::str(str_uaTCnpZ4At0) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_dwwkyKqyuN0), fu::str(str_9AX1ZTniVb5) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_McVhNeOqqI7), fu::str(str_V3VaBSYlxTg) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_6zLJlVY63a2) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_2s3qzorYYT1), fu::str(str_YE1dlqShbO0) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_8KnCKfUVQI3), fu::str(str_D5BgtB9atkc) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_WsrP1RubjL3), fu::str(str_aBzbuqatg98) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_X59k84irB65), fu::str(str_Ng15uG1a245) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_pfiQr2EQLD8), fu::str(str_lDV2yrsa83i) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_LTU8rQ2Cun8), fu::str(str_P0wc9EiKQh7), fu::str(str_WqNfxGIAnIe), fu::str(str_FhDbff6AUw3) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_GZc3qjFNYD6), fu::str(str_fCINv3VVv42), fu::str(str_BzzzJQKuP50) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_0N0KGMJ9Rt7), fu::str(str_nPLwfXgApZh) }}, PARZERO_queue);
    PARZERO_f83T(str_zA2C53D7QFb, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_52ePUZZHGKh), fu::str(str_8NRkIhBtwrh), fu::str(str_jvhZD8ySNpc), fu::str(str_WscpQeEYbD4) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_FWSsifKePf5), fu::str(str_lPcg1EFC8A8) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_rnlJRY1cKB8), fu::str(str_oW9tjyA2m17), fu::str(str_xX4G8D7HBO6) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_RsdBBPzPGE1), fu::str(str_1M3VYfdJaBl) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_JeMkjaogCzf), fu::str(str_Ej6IuxKGVp8) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_kGn8pi1n0I3), fu::str(str_DTwmwWnUfWj), fu::str(str_m946sXHGlgh) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_jd68xUK1eE7), fu::str(str_Gupk7SVzVxa), fu::str(str_PrbrWNHV2A9) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_IrF0SyC7erj), fu::str(str_2fT2n4ENPte) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_WhhVxfJq9L6), fu::str(str_pY55c27MPXl) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_9EjaCjlFse6), fu::str(str_m3hvBHEwNh5) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_yHH7hwIrBr7), fu::str(str_9kRCAYXn2X7) }}, PARZERO_queue);
    PARZERO_f83T(str_BQIscLichHf, PARZERO_queue);
    TODO_3QGL(fu::vec<fu::str> {{ fu::str(str_NEwm7SyHQc2), fu::str(str_1zJQMKRdeOj), fu::str(str_NxN8rdNPZVf) }}, str_aUyJC6QlRV0, testdiffs);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_orGAHn2iVe7), fu::str(str_utlV5PYCIh9) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_ry5n7dmgD78), fu::str(str_ssMHfG1JwYe) }}, PARZERO_queue);
    PARZERO_f83T(str_TiUjQBn72C9, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_6cQGu65vWT8), fu::str(str_qOzsKukbJ81) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_Po0tEhVEwac), fu::str(str_xrxY9LuW8gi) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_nJn4P6sZVJc), fu::str(str_g5EjgNlm809) }}, PARZERO_queue);
    TODO_3QGL(fu::vec<fu::str> {{ fu::str(str_iw1o0gTr0Ec), fu::str(str_qUxrdhFEqF9), fu::str(str_qeyoTT0Q744) }}, str_7NNX97mGs5d, testdiffs);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_tcIWyRRBH5k), fu::str(str_Rhq9oSD2JP5), fu::str(str_Gz4pyGnEVah) }}, PARZERO_queue);
    PARZERO_f83T(str_NYKq3KTyI31, PARZERO_queue);
    PARZERO_f83T(str_MxkaOnPFMJ9, PARZERO_queue);
    PARZERO_f83T(str_51pRuFwLg23, PARZERO_queue);
    PARZERO_f83T(str_rdTjuqBCcIk, PARZERO_queue);
    PARZERO_f83T(str_7H5lmgRZG68, PARZERO_queue);
    TODO_5TaN(str_59LsNTlTOmd, str_DsRh5yawTT0, testdiffs);
    TODO_5TaN(str_xOzAypluxK1, str_0IANEn52Qjj, testdiffs);
    PARZERO_f83T(str_8TdSZ3fFMX5, PARZERO_queue);
    PARZERO_f83T(str_aEVb6C1NyT6, PARZERO_queue);
    PARZERO_f83T(str_r6QEXSFdC1b, PARZERO_queue);
    PARZERO_f83T(str_LpPry8a1bCi, PARZERO_queue);
    PARZERO_f83T(str_UGJbvoA1DMb, PARZERO_queue);
    PARZERO_f83T(str_6bcH6aDI6Qb, PARZERO_queue);
    PARZERO_f83T(str_KZnKlHz7uNa, PARZERO_queue);
    PARZERO_f83T(str_J1e7WB3z7S2, PARZERO_queue);
    PARZERO_f83T(str_OqTRFg5CCu1, PARZERO_queue);
    PARZERO_f83T(str_wjcjLstruQ6, PARZERO_queue);
    PARZERO_f83T(str_965Djp2jmze, PARZERO_queue);
    PARZERO_f83T(str_kAvUwpx3VZ3, PARZERO_queue);
    PARZERO_f83T(str_7zBz5AuSUD1, PARZERO_queue);
    PARZERO_f83T(str_N9NiLXXujp2, PARZERO_queue);
    PARZERO_f83T(str_hgepVrB6JQ7, PARZERO_queue);
    PARZERO_f83T(str_Bbtsr3VOFce, PARZERO_queue);
    PARZERO_f83T(str_zGI50AXK3m1, PARZERO_queue);
    PARZERO_f83T(str_0Lg3nCAFG53, PARZERO_queue);
    PARZERO_f83T(str_kXSKYvoo7o9, PARZERO_queue);
    PARZERO_f83T(str_LeHODRpX4ik, PARZERO_queue);
    PARZERO_f83T(str_YD0dq3TXXfe, PARZERO_queue);
    PARZERO_f83T(str_2LETc9YWv3e, PARZERO_queue);
    PARZERO_f83T(str_KqnyGOzrvi5, PARZERO_queue);
    PARZERO_f83T(str_lOOoVF4iBFa, PARZERO_queue);
    PARZERO_f83T(str_HxpoQbU6JVf, PARZERO_queue);
    PARZERO_f83T(str_HpBDbktYVC7, PARZERO_queue);
    PARZERO_f83T(str_fIdYTyYre6l, PARZERO_queue);
    PARZERO_f83T(str_eQZohJM4zYh, PARZERO_queue);
    PARZERO_f83T(str_PxneohOK78c, PARZERO_queue);
    PARZERO_f83T(str_glrSoAjAQTh, PARZERO_queue);
    PARZERO_f83T(str_Uj6PtU4Lr9f, PARZERO_queue);
    PARZERO_f83T(str_SCvgbUC1dj4, PARZERO_queue);
    PARZERO_f83T(str_rZ4VFfeFKz9, PARZERO_queue);
    PARZERO_f83T(str_bRzLoN1XF33, PARZERO_queue);
    PARZERO_f83T(str_5z2hl7J3wo4, PARZERO_queue);
    PARZERO_f83T(str_wF6g1ZBJw63, PARZERO_queue);
    PARZERO_f83T(str_6yPJFahwrK8, PARZERO_queue);
    PARZERO_f83T(str_ui5zqCRSoFd, PARZERO_queue);
    PARZERO_f83T(str_YUTmqvzQpQl, PARZERO_queue);
    PARZERO_f83T(str_BvvXIxYUvAe, PARZERO_queue);
    PARZERO_f83T(str_8qqoyU6hP7l, PARZERO_queue);
    PARZERO_f83T(str_9xKp5y8oyr0, PARZERO_queue);
    PARZERO_f83T(str_pXROE67H9lj, PARZERO_queue);
    PARZERO_f83T(str_cBHRC4wQWka, PARZERO_queue);
    PARZERO_f83T(str_3fRZV7hf9Qh, PARZERO_queue);
    PARZERO_f83T(str_Q5DJe6XL7zc, PARZERO_queue);
    PARZERO_f83T(str_PLEGjIwX4Vl, PARZERO_queue);
    PARZERO_f83T(str_OVU2LMEFkhh, PARZERO_queue);
    PARZERO_f83T(str_s2j1ZcjYdfd, PARZERO_queue);
    PARZERO_f83T(str_ZwlsW2TCjSb, PARZERO_queue);
    PARZERO_f83T(str_p7vT6CwmEW8, PARZERO_queue);
    PARZERO_f83T(str_D3xbc9TnSMi, PARZERO_queue);
    PARZERO_f83T(str_6JDUtpJdBI3, PARZERO_queue);
    PARZERO_f83T(str_fvo0sJVjkcj, PARZERO_queue);
    PARZERO_f83T(str_V9j5JgBRWIc, PARZERO_queue);
    PARZERO_f83T(str_rDVkdXBRPu5, PARZERO_queue);
    PARZERO_f83T(str_Fx7h8uUWPN5, PARZERO_queue);
    TODO_5TaN(str_p3M1TLekYH5, str_Q3MBtJ5DKPh, testdiffs);
    TODO_5TaN(str_RZEt4Dc6DGj, str_BKaTNV2iPb1, testdiffs);
    PARZERO_f83T(str_OH7dtXLbyo1, PARZERO_queue);
    PARZERO_f83T(str_rusVXp1cWGk, PARZERO_queue);
    PARZERO_f83T(str_JraZ5CRliw1, PARZERO_queue);
    PARZERO_f83T(str_4Nkn2qZDXS4, PARZERO_queue);
    PARZERO_f83T(str_RpX2M3QLoo9, PARZERO_queue);
    PARZERO_f83T(str_PxQV4htUajj, PARZERO_queue);
    PARZERO_f83T(str_bkCaQjDgfNc, PARZERO_queue);
    PARZERO_f83T(str_6USD34CDPT8, PARZERO_queue);
    PARZERO_f83T(str_veoPuhVvnF2, PARZERO_queue);
    PARZERO_f83T(str_9cU5mqsF1w7, PARZERO_queue);
    PARZERO_f83T(str_46Qs1uMN960, PARZERO_queue);
    PARZERO_f83T(str_VruuYP1yqQd, PARZERO_queue);
    PARZERO_f83T(str_ZCm7zwSWUUk, PARZERO_queue);
    PARZERO_f83T(str_CtxlJzDzcU1, PARZERO_queue);
    PARZERO_f83T(str_4LgHe883CBi, PARZERO_queue);
    PARZERO_f83T(str_6oFINV2DHY3, PARZERO_queue);
    TODO_5TaN(str_Bi7j5a2PHZ9, str_vYzCQpQvfGl, testdiffs);
    TODO_5TaN(str_GspYM69Ovsa, str_m6dz1Bjxkia, testdiffs);
    PARZERO_f83T(str_FvzpTwttKef, PARZERO_queue);
    PARZERO_f83T(str_CtISJ19EsIf, PARZERO_queue);
    PARZERO_f83T(str_jLiP2ZGDm6l, PARZERO_queue);
    TODO_5TaN(str_CftzlWzfnl5, str_j5m0YmSwph8, testdiffs);
    TODO_5TaN(str_cFtmvRUGNjl, str_rMLsaE8lD1i, testdiffs);
    TODO_5TaN(str_eEoBDapraPj, str_TSWhkUkEf4d, testdiffs);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_6nVxW3v0AUd), fu::str(str_NGT82x8ekfl), fu::str(str_SQIp3UY2Ydf) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_uPUQPEqUdAa), fu::str(str_NGT82x8ekfl), fu::str(str_SQIp3UY2Ydf) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_Mc0n6yWdit0), fu::str(str_VTvjSDJy1E9) }}, PARZERO_queue);
    PARZERO_f83T(str_wX6j4Mx8Blg, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_VjRGHnOJqe0), fu::str(str_JvVJwt6EcW9), fu::str(str_eM5E5Hcy0Oa) }}, PARZERO_queue);
    PARZERO_f83T(str_umbLUEsnAF5, PARZERO_queue);
    PARZERO_f83T(str_IDykhjq4Tpj, PARZERO_queue);
    PARZERO_f83T(str_f25p7v1DgP9, PARZERO_queue);
    PARZERO_f83T(str_02CGk6meQS6, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_zDF46rHaov5), fu::str(str_yb0ft1pca48) }}, PARZERO_queue);
    PARZERO_f83T(str_umRd7qZVp52, PARZERO_queue);
    PARZERO_f83T(str_cfHO2eU0Gl8, PARZERO_queue);
    PARZERO_f83T(str_3dlmMXWun0e, PARZERO_queue);
    PARZERO_f83T(str_feLuEjPcbGl, PARZERO_queue);
    PARZERO_f83T(str_WPdFjqYDGQ8, PARZERO_queue);
    TODO_5TaN(str_cOLbOLhi6U5, str_ujmEX47lP27, testdiffs);
    TODO_5TaN(str_UTpHhxZPP9k, str_D165vHqY9mc, testdiffs);
    PARZERO_f83T(str_xIwQfIXYUR0, PARZERO_queue);
    PARZERO_f83T(str_8bwbkqoO426, PARZERO_queue);
    PARZERO_f83T(str_455SDML51xk, PARZERO_queue);
    PARZERO_f83T(str_pZqYc6emId0, PARZERO_queue);
    PARZERO_f83T(str_QsKkCBM3X90, PARZERO_queue);
    PARZERO_f83T(str_Sv2N8r9evO9, PARZERO_queue);
    PARZERO_f83T(str_1LZrc3S45Kb, PARZERO_queue);
    PARZERO_f83T(str_paXAREW61Te, PARZERO_queue);
    PARZERO_f83T(str_hmzfMLvHUy2, PARZERO_queue);
    PARZERO_f83T(str_j5DhuV12M25, PARZERO_queue);
    PARZERO_f83T(str_TK5MMVWFk2l, PARZERO_queue);
    PARZERO_f83T(str_X3hO7kdDKai, PARZERO_queue);
    PARZERO_f83T(str_oEXTexNjPU2, PARZERO_queue);
    PARZERO_f83T(str_Yfc6HoSAQXa, PARZERO_queue);
    TODO_5TaN(str_CzkBvOQW0e1, str_4UKyyw3dWM1, testdiffs);
    PARZERO_f83T(str_TXa97AP04yf, PARZERO_queue);
    PARZERO_f83T(str_PbyaJDIM27e, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_3xsNUg8LFod), fu::str(str_PQlTFCtv5Qk), fu::str(str_I2x6OzYltAf) }}, PARZERO_queue);
    PARZERO_f83T(str_2hj4R7Qde66, PARZERO_queue);
    PARZERO_f83T(str_sRf1NjrYJw3, PARZERO_queue);
    PARZERO_f83T(str_CPk75RdQt8i, PARZERO_queue);
    PARZERO_f83T(str_X9dvS4NfKil, PARZERO_queue);
    PARZERO_f83T(str_n3LHxHnLmGi, PARZERO_queue);
    PARZERO_f83T(str_gyRCVMTxbz4, PARZERO_queue);
    PARZERO_f83T(str_bNJsPndhUC5, PARZERO_queue);
    PARZERO_f83T(str_KRst2x4rU82, PARZERO_queue);
    PARZERO_f83T(str_C0tPiZpvzJ5, PARZERO_queue);
    TODO_5TaN(str_F1SYSKtXa4h, str_H9Ej1K3v8xc, testdiffs);
    PARZERO_f83T(str_gMoCsPy5gYf, PARZERO_queue);
    PARZERO_f83T(str_KKalcDl25ri, PARZERO_queue);
    PARZERO_f83T(str_LCl7QVCmrxl, PARZERO_queue);
    PARZERO_f83T(str_NpS9n79rVog, PARZERO_queue);
    PARZERO_f83T(str_KpiqFI4OUp4, PARZERO_queue);
    PARZERO_f83T(str_B2muxAIeNCa, PARZERO_queue);
    PARZERO_f83T(str_WHC3oHq5Mf2, PARZERO_queue);
    PARZERO_f83T(str_yY9XgygFmdj, PARZERO_queue);
    PARZERO_f83T(str_CVgFWE9Jtj0, PARZERO_queue);
    PARZERO_f83T(str_V6ekLRJvGDi, PARZERO_queue);
    PARZERO_f83T(str_8SDD2V9Ii4l, PARZERO_queue);
    TODO_5TaN(str_BABAZ1KQkse, str_klfQNVlvksd, testdiffs);
    PARZERO_f83T(str_z7l1sNrBGf7, PARZERO_queue);
    PARZERO_f83T(str_uRem5Bd2aBh, PARZERO_queue);
    PARZERO_f83T(str_QAPUsKIWW8g, PARZERO_queue);
    PARZERO_f83T(str_jFzZNxoLfJ4, PARZERO_queue);
    PARZERO_f83T(str_njVzGXd7jhe, PARZERO_queue);
    PARZERO_f83T(str_MGF6lI4iMWh, PARZERO_queue);
    PARZERO_f83T(str_Wwp9jmgCiN4, PARZERO_queue);
    PARZERO_f83T(str_WENk3Xxqsm7, PARZERO_queue);
    PARZERO_f83T(str_H5nImr7Wxsi, PARZERO_queue);
    PARZERO_f83T(str_l7z989jS39c, PARZERO_queue);
    PARZERO_f83T(str_YpPNUYLFQr7, PARZERO_queue);
    PARZERO_f83T(str_ZzYxTZGCLJ0, PARZERO_queue);
    PARZERO_f83T(str_zbL9jkccOaf, PARZERO_queue);
    PARZERO_f83T(str_upaoR4AKh07, PARZERO_queue);
    PARZERO_f83T(str_WhI1dfS53Jk, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_Y01Swsdnopf), fu::str(str_1kyksorLMu8) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_O4MlfWNmNUg), fu::str(str_qavnxcj2Sh3) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_nCYEnU0rgM6), fu::str(str_WEyM5y8zG87), fu::str(str_IbGrSLMPJph), fu::str(str_usDEG4ebjd0) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_crCciuTsJB9), fu::str(str_39HKALOxQj3), fu::str(str_GQ9I53Gj8Ng), fu::str(str_0wNrsWbvFgk) }}, PARZERO_queue);
    PARZERO_f83T(str_Onxhzl01ASb, PARZERO_queue);
    PARZERO_f83T(str_AHJUfbLvUrh, PARZERO_queue);
    PARZERO_f83T(str_2kr5mKkGXgg, PARZERO_queue);
    PARZERO_f83T(str_p061OjMME72, PARZERO_queue);
    PARZERO_f83T(str_sZHT5tWLvie, PARZERO_queue);
    PARZERO_f83T(str_DMs69K9lwB6, PARZERO_queue);
    PARZERO_f83T(str_8sVW4PtPpLg, PARZERO_queue);
    PARZERO_f83T(str_GnM25CXn0h6, PARZERO_queue);
    PARZERO_f83T(str_tzNe27nPuTg, PARZERO_queue);
    PARZERO_f83T(str_6ZkixeVeFZ5, PARZERO_queue);
    PARZERO_f83T(str_NYPfCtJ5tz9, PARZERO_queue);
    PARZERO_f83T(str_3p1wMhemCA0, PARZERO_queue);
    PARZERO_f83T(str_zIbrQJ45pa6, PARZERO_queue);
    PARZERO_f83T(str_wjqa1nQUglh, PARZERO_queue);
    PARZERO_f83T(str_cBxT6Bxdr5g, PARZERO_queue);
    PARZERO_f83T(str_pX5zbPjirgl, PARZERO_queue);
    PARZERO_f83T(str_qkXou8bcCbb, PARZERO_queue);
    PARZERO_f83T(str_yMqtjv7yE87, PARZERO_queue);
    PARZERO_f83T(str_z9vfpAgDiO0, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_AS8Ul9ljZLg), fu::str(str_CHyUsYS8m5f) }}, PARZERO_queue);
    PARZERO_f83T(str_fG762V2Zjkc, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_Tt0PZvVZrM6), fu::str(str_iq9rebitw38) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_QVwlv7K2xe6), fu::str(str_IwrSF5i4ILd), fu::str(str_Vwmi4MBZNQi) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_oLE84j43Ec2), fu::str(str_DJsNMRKLJT5), fu::str(str_97U6ng39drg), fu::str(str_rq2beZaL6J4) }}, PARZERO_queue);
    PARZERO_f83T(str_ulfuzkUO3y4, PARZERO_queue);
    PARZERO_f83T(str_X3723xJC1pc, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_YMumZy69Bl3), fu::str(str_kxAhvMgu0gf) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_cCUEkbSSCRl), fu::str(str_zghXR5FT6C9) }}, PARZERO_queue);
    TODO_5TaN(str_r2dOk01XFK2, str_riqFeS7SRy2, testdiffs);
    TODO_5TaN(str_buGjTxntDx9, str_VcJiiFjlogj, testdiffs);
    PARZERO_f83T(str_QJdbu43L1kb, PARZERO_queue);
    PARZERO_f83T(str_fyjAutaCroh, PARZERO_queue);
    PARZERO_f83T(str_LXDfBhH4mBb, PARZERO_queue);
    PARZERO_f83T(str_B5NSNz1UKjj, PARZERO_queue);
    PARZERO_f83T(str_AMjv7GnB8u8, PARZERO_queue);
    PARZERO_f83T(str_xgsNFF9kPQj, PARZERO_queue);
    PARZERO_f83T(str_rzXVwAoZ3Ia, PARZERO_queue);
    PARZERO_f83T(str_1BUKALBd2e3, PARZERO_queue);
    PARZERO_f83T(str_PKkx26mHOde, PARZERO_queue);
    PARZERO_f83T(str_tWZ2s8dX0Kb, PARZERO_queue);
    PARZERO_f83T(str_1CR17tSKo7g, PARZERO_queue);
    PARZERO_f83T(str_Nch3v8fr1xi, PARZERO_queue);
    PARZERO_f83T(str_KOHayIWDEyg, PARZERO_queue);
    PARZERO_f83T(str_y3aRWLXT7t7, PARZERO_queue);
    PARZERO_f83T(str_6hz98eM1Tch, PARZERO_queue);
    PARZERO_f83T(str_71VeIhloiC2, PARZERO_queue);
    PARZERO_f83T(str_8TpQX1bw9ei, PARZERO_queue);
    PARZERO_f83T(str_g7Q13veCZHa, PARZERO_queue);
    PARZERO_f83T(str_GZlwPSwgfz9, PARZERO_queue);
    PARZERO_f83T(str_zd5nxhng9fc, PARZERO_queue);
    PARZERO_f83T(str_Rq4VXGrQw12, PARZERO_queue);
    PARZERO_f83T(str_NsINuz9EYCh, PARZERO_queue);
    PARZERO_f83T(str_pUFG7VmvKI4, PARZERO_queue);
    PARZERO_f83T(str_tKIKW0dRjn0, PARZERO_queue);
    ZERO_SAME_5TaN(fu::view<fu::str> {{ fu::str(str_hVEKQMU7uP2), fu::str(str_1wBW4oBl8N5) }}, testdiffs);
    PARZERO_f83T(str_hE1rd7gfVRi, PARZERO_queue);
    PARZERO_f83T(str_Q2EZ5iWaPS2, PARZERO_queue);
    PARZERO_f83T(str_yeHGUlPAbV7, PARZERO_queue);
    PARZERO_f83T(str_72kqrO937Sa, PARZERO_queue);
    PARZERO_f83T(str_o7FUT2yV1tc, PARZERO_queue);
    PARZERO_f83T(str_ahP49fH49S3, PARZERO_queue);
    PARZERO_f83T(str_tEchOBEkvBk, PARZERO_queue);
    PARZERO_f83T(str_vbRvXts1fuc, PARZERO_queue);
    PARZERO_f83T(str_afhS3zDV5m1, PARZERO_queue);
    PARZERO_f83T(str_bwKWWQ00mjj, PARZERO_queue);
    PARZERO_f83T(str_jtCluGQLEWh, PARZERO_queue);
    PARZERO_f83T(str_vBf6Mspu4Nc, PARZERO_queue);
    PARZERO_f83T(str_Ck8EPKw8be5, PARZERO_queue);
    PARZERO_f83T(str_ffCwTiyHpue, PARZERO_queue);
    PARZERO_f83T(str_9P335zaTRd4, PARZERO_queue);
    PARZERO_f83T(str_6rKK4AqCQH8, PARZERO_queue);
    TODO_5TaN(str_92Qn6CnB6f0, str_vL8HEb1sPLj, testdiffs);
    PARZERO_f83T(str_vvCgpKaEFBa, PARZERO_queue);
    PARZERO_f83T(str_ARlgBKtA413, PARZERO_queue);
    PARZERO_f83T(str_qYgaVkrLR7j, PARZERO_queue);
    PARZERO_f83T(str_OJfoSC7duY6, PARZERO_queue);
    PARZERO_f83T(str_KNfmjI7Oy5d, PARZERO_queue);
    PARZERO_f83T(str_r0IImUoY8th, PARZERO_queue);
    PARZERO_f83T(str_uKl51cREbK9, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_tlfBarDXTJc), fu::str(str_fKxR1nSBWzi), fu::str(str_vWzUeiHEVFc) }}, PARZERO_queue);
    PARZERO_f83T(str_BYKzGroabBj, PARZERO_queue);
    PARZERO_f83T(str_Qo08aBJiZi8, PARZERO_queue);
    PARZERO_f83T(str_r4emsqkokEa, PARZERO_queue);
    PARZERO_f83T(str_IQxtphh6EJk, PARZERO_queue);
    PARZERO_f83T(str_SBSqlDR5yxg, PARZERO_queue);
    PARZERO_f83T(str_0f9ZKNXuYcc, PARZERO_queue);
    PARZERO_f83T(str_4z6JwwnbgGe, PARZERO_queue);
    TODO_5TaN(str_6Zwznygyhu3, str_KvHJLAxGyqb, testdiffs);
    PARZERO_f83T(str_7aM0X46QwB9, PARZERO_queue);
    PARZERO_f83T(str_1HI0EYiwYVj, PARZERO_queue);
    PARZERO_f83T(str_7JSrnkGxH87, PARZERO_queue);
    PARZERO_f83T(str_u8G9tDUZ8ql, PARZERO_queue);
    PARZERO_f83T(str_yQbsd8SCrg9, PARZERO_queue);
    TODO_5TaN(str_ZxTVDKLSuzf, str_IjxpyOqnzta, testdiffs);
    TODO_5TaN(str_kd0Z0HVe6V0, str_h2TO1AAmzcf, testdiffs);
    PARZERO_f83T(str_kHhhgx2cFol, PARZERO_queue);
    PARZERO_f83T(str_fEd1j1u4VY4, PARZERO_queue);
    PARZERO_f83T(str_pQrEbItTlAg, PARZERO_queue);
    PARZERO_f83T(str_mRyIvB0tOoc, PARZERO_queue);
    PARZERO_f83T(str_lEiEin3TTae, PARZERO_queue);
    PARZERO_f83T(str_E4QLKyAkugj, PARZERO_queue);
    PARZERO_f83T(str_6yBoL8VOMd1, PARZERO_queue);
    PARZERO_f83T(str_lm1ndvHwrO0, PARZERO_queue);
    PARZERO_f83T(str_fLJhLzaH49a, PARZERO_queue);
    PARZERO_f83T(str_a0QjQQ65v1c, PARZERO_queue);
    PARZERO_f83T(str_wdUzEEKF3Bl, PARZERO_queue);
    PARZERO_f83T(str_eIx4DST6EQi, PARZERO_queue);
    PARZERO_f83T(str_4rh8LdLmbne, PARZERO_queue);
    TODO_5TaN(str_aodirEasCmj, str_GAdGEvCiLVd, testdiffs);
    PARZERO_f83T(str_MwxJd6Y0wGh, PARZERO_queue);
    PARZERO_f83T(str_fGfJCzCisxi, PARZERO_queue);
    PARZERO_f83T(str_NZsZKnKFcEb, PARZERO_queue);
    PARZERO_f83T(str_rFnJkVE5l84, PARZERO_queue);
    PARZERO_f83T(str_XIUg3aIBkP4, PARZERO_queue);
    PARZERO_f83T(str_1ilaqwMePjh, PARZERO_queue);
    TODO_5TaN(str_boCxSefF295, str_iic78EGpxAb, testdiffs);
    PARZERO_f83T(str_ErGgRIaBMw9, PARZERO_queue);
    PARZERO_f83T(str_2XnPUzzis01, PARZERO_queue);
    PARZERO_f83T(str_gP83QiNxEP9, PARZERO_queue);
    TODO_5TaN(str_s5To0Jewevh, str_NLide8oHp42, testdiffs);
    PARZERO_f83T(str_vxllbTQfC2i, PARZERO_queue);
    PARZERO_f83T(str_g1eL60Zvh4i, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_KY93l4iJQEg), fu::str(str_KY93l4iJQEg), fu::str(str_HNMLY6Vnqwg) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_AGr2q1Piub4), fu::str(str_AGr2q1Piub4), fu::str(str_UX3HpCNPB46) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_KY93l4iJQEg), fu::str(str_AGr2q1Piub4), fu::str(str_HNMLY6Vnqwg) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_QfKbKJREPx9), fu::str(str_SorTR4aXN4e), fu::str(str_QSVLBrqODx7) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_ICiheY0Ami4), fu::str(str_oYzIVJbj7Sk), fu::str(str_9cwexZI9T1j) }}, PARZERO_queue);
    PARZERO_f83T(str_hYgX5gHQ5r8, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_tTSX8KnSmGa), fu::str(str_k2eQ2PJueV4) }}, PARZERO_queue);
    TODO_3QGL(fu::vec<fu::str> {{ fu::str(str_Db37nsTFWMc), fu::str(str_pwjEGqbB95j) }}, str_7NNX97mGs5d, testdiffs);
    PARZERO_f83T(str_2sHnIvnH4Yc, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_ARbVH7j5eUk), fu::str(str_kcROpYwSf68) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_HV0X1MEq5b1), fu::str(str_KoAhlTjsyo7) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_ELitno4wlw5), fu::str(str_1e3a4VG4OM7), fu::str(str_ltWPaZGiJXe), fu::str(str_XD8NLOYIbT4) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_Fq4ogPA9pc2), fu::str(str_6PRTAxiBaOl), fu::str(str_AJsADX9c9Y1) }}, PARZERO_queue);
    PARZERO_f83T(str_pvTxycb2KF0, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_qY3mizywEBe), fu::str(str_YF4S7RdfVvg), fu::str(str_750jaIhoMzf) }}, PARZERO_queue);
    PARZERO_f83T(str_nzEDLcvaHPk, PARZERO_queue);
    PARZERO_f83T(str_xtBLPESrVai, PARZERO_queue);
    PARZERO_f83T(str_Acu77WIZEre, PARZERO_queue);
    PARZERO_f83T(str_eQeZkl1J0K1, PARZERO_queue);
    PARZERO_f83T(str_pUalFXizeeg, PARZERO_queue);
    TODO_5TaN(str_Y2Q52pisvCk, str_U7BlLIMQO8i, testdiffs);
    PARZERO_f83T(str_3xVeAd7xPS1, PARZERO_queue);
    PARZERO_f83T(str_ZxywGOfYBcg, PARZERO_queue);
    PARZERO_f83T(str_TKereznYXb4, PARZERO_queue);
    PARZERO_f83T(str_0uqKdCPVVo2, PARZERO_queue);
    PARZERO_f83T(str_4HV1ElLoVS9, PARZERO_queue);
    PARZERO_f83T(str_Q9dZtLEVsB7, PARZERO_queue);
    PARZERO_f83T(str_Lf3JMmMbil7, PARZERO_queue);
    PARZERO_f83T(str_ENftHR8bqH0, PARZERO_queue);
    PARZERO_f83T(str_jzHRoXhPvu7, PARZERO_queue);
    PARZERO_f83T(str_SzjjlrtvTeh, PARZERO_queue);
    PARZERO_f83T(str_mNKQFe92yT2, PARZERO_queue);
    PARZERO_f83T(str_fF6DgpL8p0f, PARZERO_queue);
    PARZERO_f83T(str_GNVUcbPTqvb, PARZERO_queue);
    PARZERO_f83T(str_2ooe0u2YVQj, PARZERO_queue);
    PARZERO_f83T(str_xDh7khfJPig, PARZERO_queue);
    PARZERO_f83T(str_bMASOltDVVl, PARZERO_queue);
    PARZERO_f83T(str_XuinLIhnv2k, PARZERO_queue);
    PARZERO_f83T(str_x853FIwFRH1, PARZERO_queue);
    PARZERO_f83T(str_FX1WbvOQsP9, PARZERO_queue);
    PARZERO_f83T(str_mgxNCoXenSl, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_1PU1HAOK0P4), fu::str(str_BLkvlzN2nRk) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_UhZPzvlyXid), fu::str(str_8krJ9vKI0Ci) }}, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_5n1lru9tNYe), fu::str(str_nh4koosfWz3) }}, PARZERO_queue);
    PARZERO_f83T(str_HukZVc94OZ2, PARZERO_queue);
    TODO_5TaN(str_MYdZDZPRl4j, str_BHZehN7PC0h, testdiffs);
    PARZERO_f83T(str_p4VpH2ZxlQ4, PARZERO_queue);
    PARZERO_f83T(str_mYvSnmAq9W4, PARZERO_queue);
    PARZERO_f83T(str_OK02hUaDTo6, PARZERO_queue);
    PARZERO_f83T(str_bc305rUCcd6, PARZERO_queue);
    PARZERO_f83T(str_O2OokfNZuKa, PARZERO_queue);
    PARZERO_f83T(str_KwcYIIvaRE5, PARZERO_queue);
    PARZERO_f83T(str_7E053aQjj6b, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_xdgD8N5OY03), fu::str(str_zbqLAlJTv81) }}, PARZERO_queue);
    PARZERO_f83T(str_lhdS6fISOJ4, PARZERO_queue);
    PARZERO_f83T(str_GoCO9rldWa5, PARZERO_queue);
    PARZERO_f83T(str_JzAwBv3xALh, PARZERO_queue);
    PARZERO_f83T(str_8Cvo1IMWO3k, PARZERO_queue);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_WlqTtHNNhM8), fu::str(str_MvfsSVRQB05), fu::str(str_NWCmQD4aCbl) }}, PARZERO_queue);
    PARZERO_f83T(str_PniEgXTrCXb, PARZERO_queue);
    PARZERO_f83T(str_KmETJqDp3t9, PARZERO_queue);
    TODO_3QGL(fu::vec<fu::str> {{ fu::str(str_XO40EdCgGZ8), fu::str(str_lA3gn4LRZFk) }}, str_JZKkHEHMrPj, testdiffs);
    TODO_5TaN(str_mhIp5eCmxC1, str_cstDX5OBfka, testdiffs);
    PARZERO_f83T(str_dfA6MAtIeTh, PARZERO_queue);
    PARZERO_f83T(str_dtCVR0EWJF2, PARZERO_queue);
    PARZERO_f83T(str_mK8cHmIIEf1, PARZERO_queue);
    PARZERO_f83T(str_LZTU8zhmhBa, PARZERO_queue);
    PARZERO_f83T(str_zWW85IiRHG8, PARZERO_queue);
    PARZERO_f83T(str_g65ZuNHPj04, PARZERO_queue);
    PARZERO_f83T(str_4O0eDuFPMl5, PARZERO_queue);
    PARZERO_f83T(str_RmgGZeNM6ch, PARZERO_queue);
    PARZERO_f83T(str_bYLORUJwv20, PARZERO_queue);
    PARZERO_f83T(str_tRWdBElJGRj, PARZERO_queue);
    PARZERO_f83T(str_xvucwGYzNOk, PARZERO_queue);
    PARZERO_f83T(str_J3W0m9R6dVh, PARZERO_queue);
    PARZERO_f83T(str_1dOcin5BCy2, PARZERO_queue);
    PARZERO_f83T(str_Vd6jAj1drW8, PARZERO_queue);
    PARZERO_f83T(str_Pi6xvQdFLeg, PARZERO_queue);
    PARZERO_f83T(str_3fwinQ4O1qa, PARZERO_queue);
    PARZERO_f83T(str_Ep8x7vZi8pk, PARZERO_queue);
    PARZERO_f83T(str_90YEa9KO3Kb, PARZERO_queue);
    PARZERO_f83T(str_7aGG30WswR9, PARZERO_queue);
    PARZERO_f83T(str_ykKKvopL5S6, PARZERO_queue);
    PARZERO_f83T(str_KUNkWgFt0ea, PARZERO_queue);
    PARZERO_f83T(str_UrDz18ae8G1, PARZERO_queue);
    PARZERO_f83T(str_2qU8mGLlvvk, PARZERO_queue);
    PARZERO_f83T(str_xQ97CujNlY3, PARZERO_queue);
    PARZERO_f83T(str_QAAMBdIPAJf, PARZERO_queue);
    PARZERO_f83T(str_AVyGElvuqNf, PARZERO_queue);
    PARZERO_f83T(str_anoIKxiIozh, PARZERO_queue);
    PARZERO_f83T(str_6h06MsfKt3h, PARZERO_queue);
    PARZERO_f83T(str_1dfayCbIQee, PARZERO_queue);
    PARZERO_f83T(str_ZCWyxiDX2n7, PARZERO_queue);
    PARZERO_f83T(str_zdGfbfw0jRa, PARZERO_queue);
    PARZERO_f83T(str_JA3vdb8NkI4, PARZERO_queue);
    PARZERO_f83T(str_1mU848R2pR9, PARZERO_queue);
    PARZERO_f83T(str_WVCvJUWA9F9, PARZERO_queue);
    TODO_5TaN(str_RXoB0pjZPGj, str_TPVzubCI8O2, testdiffs);
    TODO_5TaN(str_vWGnPrHQXjg, str_TPVzubCI8O2, testdiffs);
    TODO_5TaN(str_ICJgNQd5AO6, str_UiUqtBd2rC0, testdiffs);
    PARZERO_f83T(str_ShFXgoCGHyg, PARZERO_queue);
    PARZERO_f83T(str_qe1KOpsV4ve, PARZERO_queue);
    PARZERO_f83T(str_v3dBqKDge08, PARZERO_queue);
    PARZERO_f83T(str_jyAI36yjM8j, PARZERO_queue);
    PARZERO_f83T(str_VGNCOU8hZx6, PARZERO_queue);
    PARZERO_f83T(str_azGiwegXxmd, PARZERO_queue);
    PARZERO_f83T(str_O4MFxnV8cMe, PARZERO_queue);
    PARZERO_f83T(str_NKUT9ZpjO9i, PARZERO_queue);
    PARZERO_f83T(str_SV5PZT2QEib, PARZERO_queue);
    PARZERO_f83T(str_Qtdh48HQsAh, PARZERO_queue);
    PARZERO_f83T(str_D6f2hnR5ey9, PARZERO_queue);
    PARZERO_f83T(str_X3GeE6wyzve, PARZERO_queue);
    PARZERO_f83T(str_RTojzkPql6d, PARZERO_queue);
    TODO_5TaN(str_FlefEpx4l0l, str_7NNX97mGs5d, testdiffs);
    PARZERO_WvpD(fu::vec<fu::str> {{ fu::str(str_1I9IXsIp5s6), fu::str(str_xcC0x12Tp41) }}, PARZERO_queue);
}

#endif
