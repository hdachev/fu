
pragma emit(
`
    extern char **environ;
`);

pub fn spawn(
    mut argv: string[],

    // ref stdout: string,
    // ref stderr: string,
    ref status!: i32): i32
{
    // Command must contain at least one argument, the path to the binary.
    if (!argv)
        return -1;

    pragma include(
        "<alloca.h>",
        "<errno.h>",
        "<fcntl.h>",
        "<unistd.h>",
        "<spawn.h>",
        "<sys/wait.h>");

    mut err = -1;

    //
    pragma emit(
    `
        const size_t argv_len   = (size_t) `argv`.size();
        char** argv_cstr        = (char**) alloca(sizeof(void*) * (1 + argv_len));
        argv_cstr[argv_len]     = 0;

        for (size_t i = 0; i < argv_len; i++)
        {
            auto& arg = `argv`.mutref(fu::i(i));
                  arg.push(0);

            argv_cstr[i]        = (char*) arg.data();
        }

        //
        int pid {};
        {
            posix_spawn_file_actions_t file_actions;
            posix_spawn_file_actions_init(&file_actions);
            posix_spawn_file_actions_addopen(&file_actions, STDOUT_FILENO, "/dev/null", O_WRONLY|O_APPEND, 0);
            posix_spawn_file_actions_addopen(&file_actions, STDERR_FILENO, "/dev/null", O_WRONLY|O_APPEND, 0);

            `err` =
                posix_spawnp(&pid,
                    argv_cstr[0],
                    &file_actions,
                    nullptr,        // posix_spawnattr_t*          attrp
                    argv_cstr,
                    environ);

            posix_spawn_file_actions_destroy(&file_actions);
        }

        //
        if (`err`)
            return `err`;

        for (;;)
        {
            int wstatus {};
            int options {};
            int wait_ret = waitpid(pid, &wstatus, options);

            // if WNOHANG was specified and one or more child(ren)
            //  specified by pid exist, but have not yet changed state,
            //   then 0 is returned.
            //
            if (wait_ret == 0)
                goto YIELD_AND_CONTINUE;

            // On failure, -1 is returned.
            if (wait_ret == -1)
            {
                // On failure, each of these calls sets errno to indicate the error.
                //
                //   EAGAIN The PID file descriptor specified in id is nonblocking and
                //          the process that it refers to has not terminated.
                //
                if ((`err` = errno) == EAGAIN)
                    goto YIELD_AND_CONTINUE;

                return `err`;
            }

            // waitpid(): on success, returns the process ID
            //  of the child whose state has changed.
            //
            if (wait_ret != pid)
                return -1;

            // We care about the exit status here.
            {
                `status` = WEXITSTATUS(wstatus);
                return 0;
            }

            // Let's not do this for starters,
            //  but we could do a non-blocking wait and then TryWork() here.
            //
            YIELD_AND_CONTINUE:
            {
                // TODO yield(); continue;
                return -1;
            }
        }
    `);

    return status;
}
