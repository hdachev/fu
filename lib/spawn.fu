
pragma include(
    "<alloca.h>",
    "<errno.h>",
    "<fcntl.h>",
    "<unistd.h>",
    "<spawn.h>",
    "<poll.h>",
    "<sys/wait.h>");


//

pub primitive PID:      i32;
pub primitive ReadEnd:  i32;
pub primitive WriteEnd: i32;

pub struct PosixPipe {
    r: ReadEnd;
    w: WriteEnd;
};

fn pipe(ref p: PosixPipe) {
    pragma include(
        "<unistd.h>",           // pipe
        "<errno.h>");

    assert(p.r == 0 && p.w == 0);

    mut err = 0;
    pragma emit(`
        if (pipe((int*) &`p.r`))
        {
            `err` = errno;
            `p.r` = -1;
            `p.w` = -1;
        }
    `);

    return err;
}


//

pragma emit(`
    extern char **environ;
`);

pub fn spawn(
    ref pid:    PID,
    mut argv:   string[],
    stdout?:    PosixPipe,
    stderr?:    PosixPipe,
    stdin?:     PosixPipe)
{
    pragma include(
        "<alloca.h>",
        "<errno.h>",
        "<spawn.h>");

    mut err = 0;
    pid     = 0;

    if (!argv) {
        pragma emit(`
            `err` = EINVAL;
        `);

        return err;
    }

    pragma emit(
    `
        const size_t argv_len   = (size_t) `argv`.size();
        char** argv_cstr        = (char**) alloca(sizeof(void*) * (1 + argv_len));
        argv_cstr[argv_len]     = 0;

        for (size_t i = 0; i < argv_len; i++)
        {
            auto& arg = argv.mutref(fu::i(i));
                  arg.push(0);

            argv_cstr[i]        = (char*) arg.data();
        }

        //
        posix_spawn_file_actions_t file_actions;
        posix_spawn_file_actions_init(&file_actions);

        const auto& Pipe =
            [&](const auto& pipe, int which)
        {
            if (pipe) {
                if (which == STDIN_FILENO) {
                    posix_spawn_file_actions_addclose(&file_actions, pipe.w);
                    posix_spawn_file_actions_adddup2 (&file_actions, pipe.r, STDIN_FILENO);
                    posix_spawn_file_actions_addclose(&file_actions, pipe.r);
                }
                else {
                    posix_spawn_file_actions_addclose(&file_actions, pipe.r);
                    posix_spawn_file_actions_adddup2 (&file_actions, pipe.w, which);
                    posix_spawn_file_actions_addclose(&file_actions, pipe.w);
                }
            }
            else {
                posix_spawn_file_actions_addopen(&file_actions, which,
                    "/dev/null", which == STDIN_FILENO
                        ? O_RDONLY                  | O_CLOEXEC
                        : O_WRONLY | O_APPEND       | O_CLOEXEC,
                    0);
            }
        };

        Pipe(`stdin`,  STDIN_FILENO);
        Pipe(`stdout`, STDOUT_FILENO);
        Pipe(`stderr`, STDERR_FILENO);

        //
        `err` = posix_spawnp(&pid,
            argv_cstr[0],
            &file_actions,
            nullptr,        // posix_spawnattr_t*          attrp
            argv_cstr,
            environ);

        posix_spawn_file_actions_destroy(&file_actions);
    `);

    //
    return err;
}


//

pragma emit(
`
typedef int PosixPipe[2];
typedef int Errno;

static Errno fu_waitpid(
    int pid, int& wstatus)
{
    wstatus     = -1;
    Errno err   = -1;

    for (;;)
    {
        int options {};
        int wait_ret = waitpid(pid, &wstatus, options);

        // if WNOHANG was specified and one or more child(ren)
        //  specified by pid exist, but have not yet changed state,
        //   then 0 is returned.
        //
        if (wait_ret == 0)
            goto YIELD_AND_CONTINUE;

        // On failure, -1 is returned.
        if (wait_ret == -1)
        {
            // On failure, each of these calls sets errno to indicate the error.
            //
            //   EAGAIN The PID file descriptor specified in id is nonblocking and
            //          the process that it refers to has not terminated.
            //
            if ((err = errno) == EAGAIN)
                goto YIELD_AND_CONTINUE;

            return err;
        }

        // waitpid(): on success, returns the process ID
        //  of the child whose state has changed.
        //
        if (wait_ret != pid)
            return -1;

        // The exit code, term sig, etc are all packed in wstatus,
        //  wstatus = 0 means exit-ok, code = 0.
        //
        return 0;

        // Let's not do this for starters,
        //  but we could do a non-blocking wait and then TryWork() here.
        //
        YIELD_AND_CONTINUE:
        {
            // TODO yield(); continue;
            return -1;
        }
    }
}

`);


//

pub fn spawn(
    mut argv: string[],
    ref status!: i32): i32
{
    mut pid: PID;
    mut err = spawn(argv, :pid);
    if (err)
        return err;

    pragma emit(`
        `err` = fu_waitpid(`pid`, `status`);
    `);

    return err;
}


//

pub struct Child {
    pid:        PID;
    stdout:     ReadEnd;
    stderr:     ReadEnd;
    stdin:      WriteEnd;
};

fn close_one(fd: ReadEnd or WriteEnd, ref err!: i32)
{
    assert(fd != 0);
    pragma output(`
        if (close(`fd`) && !`err`)
            `err` = errno;
    `);
}

pub fn close(child!: Child, ref status: i32) {
    mut err = 0;

    pragma emit(`
        auto e = fu_waitpid(`child.pid`, `status`);
        if (!`err`)
            `err` = e;
    `);

    if (child.stdout) close_one(child.stdout, :err);
    if (child.stderr) close_one(child.stderr, :err);
    if (child.stdin)  close_one(child.stdin,  :err);

    return err;
}


//

pub enum ChildStream {
    Ignore = 0
    Parent
    Pipe
};

fn STDOUT_FILENO(): WriteEnd = __native("<stdio.h>", "STDOUT_FILENO");
fn STDERR_FILENO(): WriteEnd = __native("<stdio.h>", "STDERR_FILENO");
fn  STDIN_FILENO(): ReadEnd  = __native("<stdio.h>", "STDIN_FILENO");

fn close_both(pipe: PosixPipe, ref err!: i32)
{
    close_one(pipe.r, :err);
    close_one(pipe.w, :err);
}

fn close_one_lax(fd: ReadEnd or WriteEnd)
{
    assert(fd != 0);
    pragma output(`
        if (close(`fd`))
            perror("spawn::close_one_lax");
    `);
}

pub fn spawn(
    mut argv:   string[],
    ref child:  Child,

    stdout  !out_m?: ChildStream,
    stderr  !err_m?: ChildStream,
    stdin   !in_m?:  ChildStream)
{
    child = [];
    mut err = 0;

    mut stdout: PosixPipe;
    if (out_m == "Pipe" && (err = pipe(stdout)))
        return err;

    mut stderr: PosixPipe;
    if (err_m == "Pipe" && (err = pipe(stderr)))
    {
        if (out_m == "Pipe") close_both(stdout, :err);
        return err;
    }

    mut stdin: PosixPipe;
    if (in_m == "Pipe" && (err = pipe(stdin)))
    {
        if (out_m == "Pipe") close_both(stdout, :err);
        if (err_m == "Pipe") close_both(stderr, :err);
        return err;
    }

    if (out_m == "Parent") stdout.w = STDOUT_FILENO;
    if (err_m == "Parent") stderr.w = STDERR_FILENO;
    if (in_m == "Parent")  stdin.r  = STDIN_FILENO;

    mut pid: PID;
    if ((err = spawn(:pid, :argv, :stdout, :stderr, :stdin)))
    {
        if (out_m == "Pipe") close_both(stdout, :err);
        if (err_m == "Pipe") close_both(stderr, :err);
        if (in_m == "Pipe")  close_both(stdin, :err);
        return err;
    }

    if (out_m == "Pipe") close_one_lax(stdout.w);
    if (err_m == "Pipe") close_one_lax(stderr.w);
    if (in_m == "Pipe")  close_one_lax(stdin.r);

    child = Child(
        :pid,
        stdout: stdout.r,
        stderr: stderr.r,
        stdin:  stdin.w,
    );

    return 0;
}


// TODO get rid of this

pub fn spawn(
    mut argv: string[],

    ref stdout!stdout_buf: string,
    ref stderr!stderr_buf: string,

    ref status!: i32): i32
{
    mut err = 0;
    mut child: Child;
    if ((err = spawn(:child, :argv, stdout: "Pipe", stderr: "Pipe")))
        return err;

    defer close(:child, :status);

    // Collect output.
    pragma input(
    `
        const size_t BUF_SIZE = 64 * 1024;
        fu::byte BUF[BUF_SIZE];

        const auto& ReadFD = [&](int fd, auto&& out)
        {
            void*  data = BUF;
            size_t capa = BUF_SIZE;

            // Write directly into the string
            //  if it has more capa than the buffer here.
            //
            auto size   = out.size();
            auto avail  = out.capa() - size;

            if (avail > 0 && size_t(avail) > BUF_SIZE)
            {
                data = out.data_mut() + size;
                capa = size_t(avail);
            }

            //
            auto bytes  = read(fd, data, size_t(capa));

            if (bytes < 0 && !`err`)
            {
                `err` = errno;
            }
            else if (bytes > 0)
            {
                auto count  = (decltype(size)) bytes;
                size += count;

                // Copy if using the local buffer.
                if (data == BUF)
                    out.append_copy(fu_ZERO(), BUF, count);
                else
                    out.UNSAFE__WriteSize(size);

                return true;
            }

            //
            return false;
        };

        const auto& ReadPollFD = [&](pollfd& pfd, auto&& out)
        {
            return pfd.revents & POLLIN
                && ReadFD(pfd.fd, out);
        };

        const size_t N = 2;
        pollfd poll_fds[N] =
        {
            { `child.stdout`, POLLIN, {/* revents */} },
            { `child.stderr`, POLLIN, {/* revents */} },
        };

        int poll_ret;
        while (!`err` && (poll_ret = poll(&poll_fds[0], N, /*timeout*/-1)))
        {
            if (poll_ret < 0)
            {
                auto e = errno;
                if (e == EINTR || e == EAGAIN)
                    continue;

                `err` = e;
                break;
            }

            // Don't short circuit here.
            if (  int(!ReadPollFD(poll_fds[0], `stdout_buf`))
                & int(!ReadPollFD(poll_fds[1], `stderr_buf`)))
            {
                break;
            }
        }
    `);

    return err;
}
