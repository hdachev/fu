
pragma include(
    "<alloca.h>",
    "<errno.h>",
    "<fcntl.h>",
    "<unistd.h>",
    "<spawn.h>",
    "<sys/wait.h>");

pragma emit(
`

extern char **environ;

typedef int PosixPipe[2];

typedef int Errno;

static Errno fu_spawn(
    fu_VEC<fu_STR>&  argv, int& pid,
    const PosixPipe* stdout,
    const PosixPipe* stderr)
{
    Errno err               = -1;
    pid                     =  0;

    //
    const size_t argv_len   = (size_t) argv.size();
    char** argv_cstr        = (char**) alloca(sizeof(void*) * (1 + argv_len));
    argv_cstr[argv_len]     = 0;

    for (size_t i = 0; i < argv_len; i++)
    {
        auto& arg = argv.mutref(fu::i(i));
              arg.push(0);

        argv_cstr[i]        = (char*) arg.data();
    }

    //
    posix_spawn_file_actions_t file_actions;
    posix_spawn_file_actions_init(&file_actions);

    //
    const auto& Pipe        = [&](const PosixPipe* pipe, int STDOUT_or_STDERR)
    {
        if (pipe)
        {
            const int R     = 0;
            const int W     = 1;

            posix_spawn_file_actions_addclose(&file_actions, (*pipe)[R]);
            posix_spawn_file_actions_adddup2 (&file_actions, (*pipe)[W], STDOUT_or_STDERR);
            posix_spawn_file_actions_addclose(&file_actions, (*pipe)[W]);
        }
        else
        {
            posix_spawn_file_actions_addopen (&file_actions, STDOUT_or_STDERR,
                "/dev/null", O_WRONLY|O_APPEND, 0);
        }
    };

    Pipe(stdout, STDOUT_FILENO);
    Pipe(stderr, STDERR_FILENO);

    //
    err =
        posix_spawnp(&pid,
            argv_cstr[0],
            &file_actions,
            nullptr,        // posix_spawnattr_t*          attrp
            argv_cstr,
            environ);

    posix_spawn_file_actions_destroy(&file_actions);

    //
    return err;
}

static Errno fu_waitpid(
    int pid, int& status)
{
    Errno err = -1;

    for (;;)
    {
        int wstatus {};
        int options {};
        int wait_ret = waitpid(pid, &wstatus, options);

        // if WNOHANG was specified and one or more child(ren)
        //  specified by pid exist, but have not yet changed state,
        //   then 0 is returned.
        //
        if (wait_ret == 0)
            goto YIELD_AND_CONTINUE;

        // On failure, -1 is returned.
        if (wait_ret == -1)
        {
            // On failure, each of these calls sets errno to indicate the error.
            //
            //   EAGAIN The PID file descriptor specified in id is nonblocking and
            //          the process that it refers to has not terminated.
            //
            if ((err = errno) == EAGAIN)
                goto YIELD_AND_CONTINUE;

            return err;
        }

        // waitpid(): on success, returns the process ID
        //  of the child whose state has changed.
        //
        if (wait_ret != pid)
            return -1;

        // We care about the exit status here.
        {
            status = WEXITSTATUS(wstatus);
            return 0;
        }

        // Let's not do this for starters,
        //  but we could do a non-blocking wait and then TryWork() here.
        //
        YIELD_AND_CONTINUE:
        {
            // TODO yield(); continue;
            return -1;
        }
    }
}

`);


//

pub fn spawn(
    mut argv: string[],

    // ref stdout: string,
    // ref stderr: string,
    ref status!: i32): i32
{
    // Command must contain at least one argument,
    //  the path to the binary.
    if (!argv)
        return -1;

    mut err = -1;
    mut pid: i32;

    pragma emit(
    `
        `err` =
            fu_spawn(
                `argv`, `pid`,
                /*stdout*/ nullptr,
                /*stderr*/ nullptr)
    `);

    if (err)
        return err;

    pragma emit(
    `
        `err` =
            fu_waitpid(
                `pid`, `status`);
    `);

    return err;
}
