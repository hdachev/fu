import gl;

pragma include(
    "<stdio.h>",
    "<glad/glad.h>");


// In-language, ported stuff.

pub struct Loop
{
    hm_framebuffers:    hash::Map(u64, ::FBO);
    hm_textures:        hash::Map(u64, ::Tex);
    hm_shaders:         hash::Map(u64, ::Shader);

    hm_geometries:      hash::Map(u64, Mesh::Geometry);
    hm_instances:       hash::Map(u64, Mesh::Instances);

    ubo_Frame:          ::Buffer;
    ubo_Pass:           ::Buffer;
    ubo_ROP:            ::Buffer;
};


//

struct FrameState {
    bp_ubo_Frame: UBO::BindingPoint;
    bp_ubo_Pass: UBO::BindingPoint;
    bp_ubo_ROP: UBO::BindingPoint;

    blend_state: BlendState::BlendState;
    rop_state: ROPState::ROPState;

    device_rect: u64;
}


//

fn Frame_begin(ref caches: Loop,
    frame: Frame, framebuffer: ivec2)
{
    // TODO FIX hotswap workaround
    glfw::window::gladLoadIfNeeded();

    // uncomment this call to draw in wireframe polygons.
    pragma output(
    `
        // glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
    `);

    using mut frame_state = FrameState(
        bp_ubo_Frame    : UBO::BindingPoint(0),
        bp_ubo_Pass     : UBO::BindingPoint(1),
        bp_ubo_ROP      : UBO::BindingPoint(2),

        blend_state     : BlendState::init(),
        rop_state       : ROPState::init(),

        device_rect     : u64(framebuffer.x) << 32
                        | u64(framebuffer.y) << 48,
    );

    // Per-frame UBOs and texture data.
    {
        bp_ubo_Frame.updateAndBind(
            caches.ubo_Frame,
            frame.ubo_Frame);

        TexUnits::updateAndBind(
            caches.hm_textures,
            0, frame.texunit_00);
    }

    return frame_state;
}

fn Frame_end()
{
    // Loop exit cleanup + error pump.
    pragma output(
    `
        glBindVertexArray(0);

        glBindTexture(GL_TEXTURE_2D, 0);
        glBindBuffer(GL_ARRAY_BUFFER, 0);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

        #ifndef NDEBUG
        {
            GLenum error;
            while ((error = glGetError()))
                printf("  \e[0;31mERROR\e[0m glGetError != 0: x(%X)\\n", error);
        }
        #endif //
    `);
}


//

fn Pass_begin(ref caches: Loop, using ref _: FrameState,
    pass: Pass)
{
    // Per-pass UBOs and texture data.
    {
        bp_ubo_Pass.updateAndBind(
            caches.ubo_Pass,
            pass.ubo_Pass);

        TexUnits::updateAndBind(
            caches.hm_textures,
            10, pass.texunit_10);
    }

    let outputs = FBO::Outputs(
        pass.fbo.outputs.len,
        get_output: |shadow i|
        {
            let spec        = pass.fbo.outputs[i];
            let tex_handle  = caches.hm_textures.ref(spec.id).updateAndBind(spec, for_sampling: false).handle;

            FBO::Output(
                :tex_handle,
                :spec.format,
                :spec.flags,
                :spec.layer,
                :spec.level)
        });

    caches
        .hm_framebuffers.ref(pass.fbo.id)
        .updateAndBindOutputs(outputs);

    // Viewport:
    rop_state.update(:pass, :device_rect, :outputs.has_depth_buffer);
    rop_state.clear(pass.clear);

    return outputs;
}


//

pub fn renderFrame(
    ref loop:       Loop,
    frame:          Frame,
    framebuffer:    ivec2,

    draw)
{
    implicit ref caches = loop;
    shadow implicit ref frame = frame;
    implicit mut frame_state = Frame_begin(caches, frame, framebuffer);

    ///////
    draw();
    ///////

    Frame_end();
}

pub fn renderPass(
    pass: Pass,

    draw,

    implicit ref caches: Loop,
    implicit frame: Frame,
    implicit ref frame_state: FrameState)
{
    shadow implicit ref pass = pass;

    implicit outputs = Pass_begin(caches, frame_state, pass);

    ///////
    draw();
    ///////
}

pub fn renderBlit(
    cmd: BlitCommand,

    implicit ref caches: Loop)
{
    if (cmd.type == "GenerateMipmaps")
    {
        let tex = caches.hm_textures.get(cmd.id);
        if (tex.handle)
        {
            pragma output(
            `
                glBindTexture(GL_TEXTURE_2D, `tex.handle`);
                glGenerateMipmap(GL_TEXTURE_2D);
            `);
        }
    }
}

pub fn render(
    rop: ROP,

    implicit ref caches: Loop,
    implicit frame: Frame,
    implicit pass: Pass,

    using implicit ref frame_state: FrameState,
    implicit outputs: FBO::Outputs,

    geometry: Geometry,
    draws: Draw[..],
    instances?: Instances)
{
    shadow implicit ref rop = rop;

    // MRT blending, all things separate.
    blend_state.update(
        rop.blend.equations,
        outputs.num_color_buffers.int);

    // Per-ROP UBOs & textures.
    {
        bp_ubo_ROP.updateAndBind(
            caches.ubo_ROP,
            rop.ubo_ROP);

        TexUnits::updateAndBind(
            caches.hm_textures,
            20, rop.texunit_20);
    }

    // Switch to shader.
    {
        ref shader = caches.hm_shaders.ref(rop.shader.id);

        shader.update(
            rop.shader.vert,
            rop.shader.frag);

        shader.use();

        if (process::DEBUG)
        {
            assert(frame.texunit_00.len >= shader.DEBUG_texunit_expect.if(exists: 0).int);
            assert( pass.texunit_10.len >= shader.DEBUG_texunit_expect.if(exists: 1).int);
            assert(  rop.texunit_20.len >= shader.DEBUG_texunit_expect.if(exists: 2).int);
        }

        // Per-shader UBOs & textures.
        // {
        //     UBOs.updateLevel(
        //         GL_UBO::ubo_Shader,
        //         shader.ubo_Shader, batch.ubo_Shader);

        //     TexUnits::updateAndBind(
        //         Textures,
        //         30, batch.texunit_30);
        // }
    }

    // NOTE
    //
    // There used to be a loop over multiple ROP batches,
    //  but we've gotten rid of that now,
    //   one ROP == one batch.

    // Per-material-instance UBOs & textures.
    // {
    //     UBOs.updateLevel(
    //         GL_UBO::ubo_Batch,
    //         ubo_Batch, material.ubo_Batch);
    //
    //     TexUnits::updateAndBind(
    //         Textures,
    //         40, material.texunit_40);
    // }

    // NOTE
    //
    // Previously there were multiple meshes per batch,
    //  but now that too has gone away,
    //   expectation is we'd be batching multiple models
    //    within the same geometry if we care for speed,
    //     otherwise one ROP == one mesh.

    // TODO FIX after most of the hierarchy was flattenened
    //  we've now ended up with redundant ROP/Batch/geometry IDs,
    //   and this mesh.id here is the rop.batch.id
    //    which is otherwise not useful.
    //
    let INSTANCED   = !!instances.inst_data.len;

    ref m_geom      = caches.hm_geometries.ref(geometry.id);

    mut m_NOOP      = Mesh::Instances;
    ref m_inst      = INSTANCED
        ? caches.hm_instances.ref(instances.id)
        : m_NOOP;

    ref vao         = INSTANCED
        ? m_inst.vao_w_instancing
        : m_geom.vao_WO_instancing;

    // VAO bind first to protect whatever
    //  VAO was bound up to this point.
    vao.bind();

    // Geom update after VAO bind,
    //  we dont want to overwrite someone else's
    //   GL_ELEMENT_ARRAY_BUFFER.
    m_geom.update(
        vertices:   geometry.vert_bytes,
        indices:    geometry.index_bytes);

    if (INSTANCED)
        m_inst.update(instances.inst_data);

    assert(geometry.vert_bytes || !geometry.vert_attribs);
    assert(instances.inst_data || !instances.inst_attribs);

    // Update & draw.
    vao.updateAndDraw(

        // Vertex data.
        :m_geom.vertices,
        :m_geom.indices,
        :geometry.vert_attribs,

        // Instance data.
        m_inst.data,
        :instances.inst_attribs,

        // Draw data.
        draws);
}

pub inline fn render(rop: ROP, geometry: Geometry)
    render(:rop, :geometry,
        draws: [
            Draw(
                index_count: geometry.total_index_count,
                instance_count: 1),
        ]);

pub inline fn render(rop: ROP, geometry: Geometry, mesh: Mesh)
    render(:rop, :geometry,
        draws: [
            Draw(
                :mesh,
                instance_count: 1),
        ]);
