
pub struct TEA
{
    v0: u32;
    v1: u32;
}

pub inline fn r4(using ref _: TEA, ref sum: u32)
{
    mut delta: u32 = 0x9e3779b9;

    for (mut i = 0; i < 4; i++) {
        sum += delta;

        v0 += ((v1<<4) + 0xA341316C) ^ (v1 + sum) ^ ((v1>>5) + 0xC8013EA4);
        v1 += ((v0<<4) + 0xAD90777D) ^ (v0 + sum) ^ ((v0>>5) + 0x7E95761E);
    }
}

pub inline fn r8(using ref _: TEA, ref sum: u32)
{
    mut delta: u32 = 0x9e3779b9;

    for (mut i = 0; i < 8; i++) {
        sum += delta;

        v0 += ((v1<<4) + 0xA341316C) ^ (v1 + sum) ^ ((v1>>5) + 0xC8013EA4);
        v1 += ((v0<<4) + 0xAD90777D) ^ (v0 + sum) ^ ((v0>>5) + 0x7E95761E);
    }
}

pub inline fn r16(using ref _: TEA, ref sum: u32)
{
    mut delta: u32 = 0x9e3779b9;

    for (mut i = 0; i < 16; i++) {
        sum += delta;

        v0 += ((v1<<4) + 0xA341316C) ^ (v1 + sum) ^ ((v1>>5) + 0xC8013EA4);
        v1 += ((v0<<4) + 0xAD90777D) ^ (v0 + sum) ^ ((v0>>5) + 0x7E95761E);
    }
}


// Shorthands.

pub inline fn r4(ref tea: TEA) {
    mut sum: u32; tea.r4(sum);
}

pub inline fn r8(ref tea: TEA) {
    mut sum: u32; tea.r8(sum);
}

pub inline fn r16(ref tea: TEA) {
    mut sum: u32; tea.r16(sum);
}


//

pub inline fn u64(tea: TEA)
    tea.v0.u64 | (tea.v1.u64 << 32);


// Don't return 1F.
//  This doesn't use the head byte
//   which allows you to pick bools without correlation.

pub inline fn uniform_f01(u: u32)
    (u & 0xffffff).f32 * (1 / 0x1000000 .f32);

pub inline fn uniform_f11(u: u32)
{
    let f01 = u.uniform_f01;
    return u & 0x1000000 ? -f01 : +f01;
}


// Let's put our cooler features to use.

pub fn hash(mut res: TEA, u8view: [byte])
{
    // First off, a view over most of the array as u32s.
    let u32len  = u8view.len & ~3;
    let u32view = u8view[0, u32len].view(u32);

    // First, tuples.
    for (mut i = 1; i < u32view.len; i += 2)
    {
        res.v0 ^= u32view[i - 1];
        res.v1 ^= u32view[i];
        res.r16();
    }

    if (u8view.len & 7)
    {
        // A lone trailer.
        if (u32view.len & 1)
            res.v0 ^= u32view[u32view.len - 1];

        // The trailing bytes.
        {
            mut last: u32;
            for (mut i = u32len; i < u8view.len; i++)
            {
                last <<= 8;
                last |= u8view[i].u32;
            }

            res.v1 ^= last;
        }

        // Finally, let's go for a good final shuffle.
        res.r16();
    }

    return res;
}

pub fn hash(u8view: [byte])
{
    mut res: TEA;
    res = res.hash(u8view);
    return res;
}

pub fn hash62(str: [byte], chars = 11): string
{
    mut res: string;
    mut v = str.hash.u64;
    for (mut i = 0; i < chars; i++)
    {
        let c = v % 62;
        v = v / 62;

        if (c < 10)
            res ~= byte(c -  0 + '0'.u64);
        else if (c < 36)
            res ~= byte(c - 10 + 'a'.u64);
        else
            res ~= byte(c - 36 + 'A'.u64);
    }

    return res;
}

pub fn hash16(str: [byte], chars = 16): string
{
    mut res: string;
    mut v = str.hash.u64;
    for (mut i = 0; i < chars; i++)
    {
        let c = v % 16;
        v = v / 16;

        if (c < 10)
            res ~= byte(c -  0 + '0'.u64);
        else
            res ~= byte(c - 10 + 'a'.u64);
    }

    return res;
}
