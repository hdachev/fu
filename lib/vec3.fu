
pub struct vec3
{
    x?: f32;
    y?: f32;
    z?: f32;
};

pub inline fn -(a: vec3) vec3(-a.x, -a.y, -a.z);

pub inline fn +(a: vec3, b: vec3) vec3(a.x + b.x, a.y + b.y, a.z + b.z);
pub inline fn -(a: vec3, b: vec3) vec3(a.x - b.x, a.y - b.y, a.z - b.z);
pub inline fn *(a: vec3, b: vec3) vec3(a.x * b.x, a.y * b.y, a.z * b.z);
pub inline fn /(a: vec3, b: vec3) vec3(a.x / b.x, a.y / b.y, a.z / b.z);

pub inline fn +(a: vec3, b: f32) vec3(a.x + b, a.y + b, a.z + b);
pub inline fn -(a: vec3, b: f32) vec3(a.x - b, a.y - b, a.z - b);
pub inline fn *(a: vec3, b: f32) vec3(a.x * b, a.y * b, a.z * b);
pub inline fn /(a: vec3, b: f32) vec3(a.x / b, a.y / b, a.z / b);

pub inline fn +(a: f32, b: vec3) vec3(a + b.x, a + b.y, a + b.z);
pub inline fn -(a: f32, b: vec3) vec3(a - b.x, a - b.y, a - b.z);
pub inline fn *(a: f32, b: vec3) vec3(a * b.x, a * b.y, a * b.z);
pub inline fn /(a: f32, b: vec3) vec3(a / b.x, a / b.y, a / b.z);

pub inline fn +=(a: &mut vec3, b: vec3): &mut vec3 { a.x += b.x; a.y += b.y; a.z += b.z; return a; }
pub inline fn -=(a: &mut vec3, b: vec3): &mut vec3 { a.x -= b.x; a.y -= b.y; a.z -= b.z; return a; }
pub inline fn *=(a: &mut vec3, b: vec3): &mut vec3 { a.x *= b.x; a.y *= b.y; a.z *= b.z; return a; }
pub inline fn /=(a: &mut vec3, b: vec3): &mut vec3 { a.x /= b.x; a.y /= b.y; a.z /= b.z; return a; }

pub inline fn +=(a: &mut vec3, b: f32): &mut vec3 { a.x += b; a.y += b; a.z += b; return a; }
pub inline fn -=(a: &mut vec3, b: f32): &mut vec3 { a.x -= b; a.y -= b; a.z -= b; return a; }
pub inline fn *=(a: &mut vec3, b: f32): &mut vec3 { a.x *= b; a.y *= b; a.z *= b; return a; }
pub inline fn /=(a: &mut vec3, b: f32): &mut vec3 { a.x /= b; a.y /= b; a.z /= b; return a; }

pub inline fn dot  (a: vec3, b: vec3) a.x * b.x + a.y * b.y + a.z * b.z;
pub inline fn lensq(a: vec3)          a.x * a.x + a.y * a.y + a.z * a.z;

pub inline fn len  (a: vec3) a.lensq.sqrt;

pub inline fn norm(a: vec3)
{
    mut n = 1 / a.len;
        n = n.finite ? n : 0;

    return a * n;
}

pub inline fn normalize(a: &mut vec3)
{
    let l = a.len;

    mut n = 1 / l;
        n = n.finite ? n : 0;

    a *= n;
    return l;
}

pub inline fn cross(a: vec3, b: vec3)
    vec3(
        a.y * b.z - a.z * b.y,
        a.z * b.x - a.x * b.z,
        a.x * b.y - a.y * b.x);

pub inline fn lerp(a: vec3, b: vec3, w1: f32)
{
    let w0 = 1 - w1;
    return vec3(
        a.x * w0 + b.x * w1,
        a.y * w0 + b.y * w1,
        a.z * w0 + b.z * w1);
}

pub inline fn perp(v: vec3)
    abs(v.x) > abs(v.y)
        ? vec3(-v.z, 0, v.x)
        : vec3(0, v.z, -v.y);

pub inline fn min(a: vec3, b: vec3)
    vec3(a.x.min(b.x),
         a.y.min(b.y),
         a.z.min(b.z));

pub inline fn max(a: vec3, b: vec3)
    vec3(a.x.max(b.x),
         a.y.max(b.y),
         a.z.max(b.z));

pub inline fn minc(using _: vec3)
    z < x && z < y ? z : y < x ? y : x;

pub inline fn maxc(using _: vec3)
    z > x && z > y ? z : y > x ? y : x;


////////////////////////////////////////
////////////////////////////////////////

pub inline fn quadratic(
    a: f32, b: f32, c: f32,
    x0: &mut f32,
    x1: &mut f32)
{
    let discr = b * b - 4 * a * c;
    if (discr < 0) {
        x0 = x1 = 0/0.f32;
        return;
    }

    mut discr_sqrt = sqrt(discr);
        discr_sqrt = b > 0  ? +discr_sqrt
                            : -discr_sqrt;

    let q  = -0.5 * (b + discr_sqrt);
        x0 = q / a;
        x1 = c / q;
}

pub inline fn ray_sphere(
    ro: vec3, rd: vec3,
    so: vec3, sr: f32)
{
    let L = ro - so;
    let a = rd.lensq;
    let b = 2 * rd.dot(L);
    let c = L.lensq - sr*sr;

    mut t0: f32;
    mut t1: f32;
    quadratic(a, b, c, t0, t1);

    t0 = t1 < t0 && t1 >= 0 ? t1 : t0;

    return t0;
}


////////////////////////////////////////
////////////////////////////////////////

pub inline fn ray_plane(
    ro: vec3, rd: vec3,
    pp: vec3, pn: vec3)
{
    let denom = rd.dot(pn);
    let delta = pp - ro;
    let t = delta.dot(pn) / denom;

    return t;
}

// TODO plane as [normal + mul]

/*
// TODO https://gist.github.com/Kinwailo/d9a07f98d8511206182e50acda4fbc9b
//
// Returns: INTERSECT : 0
//          INSIDE : 1
//          OUTSIDE : 2
int FrustumAABBIntersect(Plane *planes, Vector &mins, Vector &maxs) {
   int    ret = INSIDE;
   Vector vmin, vmax;

   for(int i = 0; i < 6; ++i) {
      // X axis
      if(planes.normal.x > 0) {
         vmin.x = mins.x;
         vmax.x = maxs.x;
      } else {
         vmin.x = maxs.x;
         vmax.x = mins.x;
      }
      // Y axis
      if(planes.normal.y > 0) {
         vmin.y = mins.y;
         vmax.y = maxs.y;
      } else {
         vmin.y = maxs.y;
         vmax.y = mins.y;
      }
      // Z axis
      if(planes.normal.z > 0) {
         vmin.z = mins.z;
         vmax.z = maxs.z;
      } else {
         vmin.z = maxs.z;
         vmax.z = mins.z;
      }
      if(Vector::DotProduct(planes.normal, vmin) + planes.d > 0)
         return OUTSIDE;
      if(Vector::DotProduct(planes.normal, vmax) + planes.d >= 0)
         ret = INTERSECT;
   }
   return ret;
}
*/


////////////////////////////////////////
////////////////////////////////////////

pub inline fn ray_aabb(
    ro: vec3, rd_recp: vec3,
    min: vec3, max: vec3)
{
    let t1 = (min - ro) * rd_recp;
    let t2 = (max - ro) * rd_recp;

    let tmin = min(t1, t2).minc;
    let tmax = max(t1, t2).maxc;

    return tmax >= tmin;
}
